# Comparing `tmp/nautilus_trader-1.174.0.tar.gz` & `tmp/nautilus_trader-1.175.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "nautilus_trader-1.174.0.tar", max compression
+gzip compressed data, was "nautilus_trader-1.175.0.tar", max compression
```

## Comparing `nautilus_trader-1.174.0.tar` & `nautilus_trader-1.175.0.tar`

### file list

```diff
@@ -1,711 +1,735 @@
--rw-r--r--   0        0        0     7652 2023-05-20 00:56:32.860015 nautilus_trader-1.174.0/LICENSE
--rw-r--r--   0        0        0    23501 2023-05-20 00:56:32.860015 nautilus_trader-1.174.0/README.md
--rw-r--r--   0        0        0    12291 2023-05-20 00:56:32.860015 nautilus_trader-1.174.0/build.py
--rw-r--r--   0        0        0      663 2023-05-20 00:56:32.872015 nautilus_trader-1.174.0/nautilus_core/.cargo/config.toml
--rw-r--r--   0        0        0       65 2023-05-20 00:56:32.872015 nautilus_trader-1.174.0/nautilus_core/.clippy.toml
--rw-r--r--   0        0        0       37 2023-05-20 00:56:32.872015 nautilus_trader-1.174.0/nautilus_core/.rustfmt.toml
--rw-r--r--   0        0        0    84260 2023-05-20 00:56:32.872015 nautilus_trader-1.174.0/nautilus_core/Cargo.lock
--rw-r--r--   0        0        0     1612 2023-05-20 00:56:32.872015 nautilus_trader-1.174.0/nautilus_core/Cargo.toml
--rw-r--r--   0        0        0     7652 2023-05-20 00:56:32.872015 nautilus_trader-1.174.0/nautilus_core/LICENSE
--rw-r--r--   0        0        0     1248 2023-05-20 00:56:32.872015 nautilus_trader-1.174.0/nautilus_core/README.md
--rw-r--r--   0        0        0      702 2023-05-20 00:56:32.872015 nautilus_trader-1.174.0/nautilus_core/backtest/Cargo.toml
--rw-r--r--   0        0        0     1889 2023-05-20 00:56:32.872015 nautilus_trader-1.174.0/nautilus_core/backtest/build.rs
--rw-r--r--   0        0        0      484 2023-05-20 00:56:32.872015 nautilus_trader-1.174.0/nautilus_core/backtest/cbindgen.toml
--rw-r--r--   0        0        0      810 2023-05-20 00:56:32.872015 nautilus_trader-1.174.0/nautilus_core/backtest/cbindgen_cython.toml
--rw-r--r--   0        0        0     5773 2023-05-20 00:56:32.872015 nautilus_trader-1.174.0/nautilus_core/backtest/src/engine.rs
--rw-r--r--   0        0        0      900 2023-05-20 00:56:32.872015 nautilus_trader-1.174.0/nautilus_core/backtest/src/lib.rs
--rw-r--r--   0        0        0      715 2023-05-20 00:56:32.872015 nautilus_trader-1.174.0/nautilus_core/common/Cargo.toml
--rw-r--r--   0        0        0     2542 2023-05-20 00:56:32.872015 nautilus_trader-1.174.0/nautilus_core/common/build.rs
--rw-r--r--   0        0        0      531 2023-05-20 00:56:32.872015 nautilus_trader-1.174.0/nautilus_core/common/cbindgen.toml
--rw-r--r--   0        0        0      724 2023-05-20 00:56:32.872015 nautilus_trader-1.174.0/nautilus_core/common/cbindgen_cython.toml
--rw-r--r--   0        0        0    25390 2023-05-20 00:56:32.872015 nautilus_trader-1.174.0/nautilus_core/common/src/clock.rs
--rw-r--r--   0        0        0     6296 2023-05-20 00:56:32.872015 nautilus_trader-1.174.0/nautilus_core/common/src/enums.rs
--rw-r--r--   0        0        0      979 2023-05-20 00:56:32.872015 nautilus_trader-1.174.0/nautilus_core/common/src/lib.rs
--rw-r--r--   0        0        0    25121 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/common/src/logging.rs
--rw-r--r--   0        0        0     7311 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/common/src/msgbus.rs
--rw-r--r--   0        0        0     1299 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/common/src/testing.rs
--rw-r--r--   0        0        0     8996 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/common/src/timer.rs
--rw-r--r--   0        0        0     3091 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/common/tests/test_clock.rs
--rw-r--r--   0        0        0      616 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/core/Cargo.toml
--rw-r--r--   0        0        0     1234 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/core/benches/criterion_time_benchmark.rs
--rw-r--r--   0        0        0     2538 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/core/build.rs
--rw-r--r--   0        0        0      681 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/core/cbindgen.toml
--rw-r--r--   0        0        0      791 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/core/cbindgen_cython.toml
--rw-r--r--   0        0        0     7634 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/core/src/correctness.rs
--rw-r--r--   0        0        0     5544 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/core/src/cvec.rs
--rw-r--r--   0        0        0     5256 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/core/src/datetime.rs
--rw-r--r--   0        0        0      998 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/core/src/lib.rs
--rw-r--r--   0        0        0     4973 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/core/src/parsing.rs
--rw-r--r--   0        0        0     5119 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/core/src/string.rs
--rw-r--r--   0        0        0     5105 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/core/src/time.rs
--rw-r--r--   0        0        0     7354 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/core/src/uuid.rs
--rw-r--r--   0        0        0      497 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/indicators/Cargo.toml
--rw-r--r--   0        0        0     4123 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/indicators/src/ema.rs
--rw-r--r--   0        0        0     1289 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/indicators/src/lib.rs
--rw-r--r--   0        0        0      765 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/Cargo.toml
--rw-r--r--   0        0        0      399 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/benches/criterion_fixed_precision_benchmark.rs
--rw-r--r--   0        0        0      225 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/benches/iai_fixed_precision_benchmark.rs
--rw-r--r--   0        0        0     2540 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/build.rs
--rw-r--r--   0        0        0     1084 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/cbindgen.toml
--rw-r--r--   0        0        0     1304 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/cbindgen_cython.toml
--rw-r--r--   0        0        0    21360 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/currencies.rs
--rw-r--r--   0        0        0    19066 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/data/bar.rs
--rw-r--r--   0        0        0    12419 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/data/book.rs
--rw-r--r--   0        0        0     2119 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/data/mod.rs
--rw-r--r--   0        0        0     9260 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/data/tick.rs
--rw-r--r--   0        0        0    22849 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/enums.rs
--rw-r--r--   0        0        0      917 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/events/mod.rs
--rw-r--r--   0        0        0    10645 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/events/order.rs
--rw-r--r--   0        0        0     3681 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/events/position.rs
--rw-r--r--   0        0        0     7336 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/identifiers/account_id.rs
--rw-r--r--   0        0        0     4804 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/identifiers/client_id.rs
--rw-r--r--   0        0        0     4027 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/identifiers/client_order_id.rs
--rw-r--r--   0        0        0     3834 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/identifiers/component_id.rs
--rw-r--r--   0        0        0     3972 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/identifiers/exec_algorithm_id.rs
--rw-r--r--   0        0        0     6257 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/identifiers/instrument_id.rs
--rw-r--r--   0        0        0     1177 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/identifiers/mod.rs
--rw-r--r--   0        0        0     3808 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/identifiers/order_list_id.rs
--rw-r--r--   0        0        0     3800 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/identifiers/position_id.rs
--rw-r--r--   0        0        0     3549 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/identifiers/strategy_id.rs
--rw-r--r--   0        0        0     3642 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/identifiers/symbol.rs
--rw-r--r--   0        0        0     3726 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/identifiers/trade_id.rs
--rw-r--r--   0        0        0     3493 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/identifiers/trader_id.rs
--rw-r--r--   0        0        0     3603 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/identifiers/venue.rs
--rw-r--r--   0        0        0     3980 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/identifiers/venue_order_id.rs
--rw-r--r--   0        0        0     1831 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/instruments/mod.rs
--rw-r--r--   0        0        0     1357 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/lib.rs
--rw-r--r--   0        0        0     3480 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/orderbook/book.rs
--rw-r--r--   0        0        0    12899 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/orderbook/ladder.rs
--rw-r--r--   0        0        0     7569 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/orderbook/level.rs
--rw-r--r--   0        0        0      929 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/orderbook/mod.rs
--rw-r--r--   0        0        0     4637 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/orders/limit.rs
--rw-r--r--   0        0        0    27273 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/orders/mod.rs
--rw-r--r--   0        0        0     7685 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/position.rs
--rw-r--r--   0        0        0     1358 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/types/balance.rs
--rw-r--r--   0        0        0     5219 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/types/currency.rs
--rw-r--r--   0        0        0     6164 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/types/fixed.rs
--rw-r--r--   0        0        0      982 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/types/mod.rs
--rw-r--r--   0        0        0     7444 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/types/money.rs
--rw-r--r--   0        0        0    10073 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/types/price.rs
--rw-r--r--   0        0        0    10189 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/model/src/types/quantity.rs
--rw-r--r--   0        0        0      624 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/network/Cargo.toml
--rw-r--r--   0        0        0     1539 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/network/benches/bench_client.rs
--rw-r--r--   0        0        0    14287 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/network/src/lib.rs
--rw-r--r--   0        0        0      509 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/network/tests/test_http.py
--rw-r--r--   0        0        0     1052 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/persistence/Cargo.toml
--rw-r--r--   0        0        0     3291 2023-05-20 00:56:32.876015 nautilus_trader-1.174.0/nautilus_core/persistence/benches/persistence_benchmark.rs
--rw-r--r--   0        0        0     6101 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_core/persistence/src/kmerge_batch.rs
--rw-r--r--   0        0        0     1285 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_core/persistence/src/lib.rs
--rw-r--r--   0        0        0     6931 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_core/persistence/src/parquet/implementations/bar.rs
--rw-r--r--   0        0        0     8338 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_core/persistence/src/parquet/implementations/book_delta.rs
--rw-r--r--   0        0        0     6895 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_core/persistence/src/parquet/implementations/book_snapshot.rs
--rw-r--r--   0        0        0      950 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_core/persistence/src/parquet/implementations/mod.rs
--rw-r--r--   0        0        0     6601 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_core/persistence/src/parquet/implementations/quote.rs
--rw-r--r--   0        0        0     6988 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_core/persistence/src/parquet/implementations/trade.rs
--rw-r--r--   0        0        0     1680 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_core/persistence/src/parquet/mod.rs
--rw-r--r--   0        0        0    11980 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_core/persistence/src/session.rs
--rw-r--r--   0        0        0     3549 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_core/persistence/tests/test_catalog.rs
--rw-r--r--   0        0        0     2906 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_core/persistence/tests/test_persistence_module.py
--rw-r--r--   0        0        0     2179 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_core/persistence/tests/test_util.rs
--rw-r--r--   0        0        0      647 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_core/pyo3/Cargo.toml
--rw-r--r--   0        0        0     2275 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_core/pyo3/src/lib.rs
--rw-r--r--   0        0        0       50 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_core/rust-toolchain.toml
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/__init__.pxd
--rw-r--r--   0        0        0     1268 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/__init__.py
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/accounting/__init__.pxd
--rw-r--r--   0        0        0     1414 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/accounting/__init__.py
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/accounting/accounts/__init__.pxd
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/accounting/accounts/__init__.py
--rw-r--r--   0        0        0     3970 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/accounting/accounts/base.pxd
--rw-r--r--   0        0        0    14287 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/accounting/accounts/base.pyx
--rw-r--r--   0        0        0     1442 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/accounting/accounts/betting.pxd
--rw-r--r--   0        0        0     2758 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/accounting/accounts/betting.pyx
--rw-r--r--   0        0        0     1881 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/accounting/accounts/cash.pxd
--rw-r--r--   0        0        0    11292 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/accounting/accounts/cash.pyx
--rw-r--r--   0        0        0     3168 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/accounting/accounts/margin.pxd
--rw-r--r--   0        0        0    20650 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/accounting/accounts/margin.pyx
--rw-r--r--   0        0        0     1488 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/accounting/calculators.pxd
--rw-r--r--   0        0        0    10743 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/accounting/calculators.pyx
--rw-r--r--   0        0        0     2111 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/accounting/error.py
--rw-r--r--   0        0        0     1089 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/accounting/factory.pxd
--rw-r--r--   0        0        0     4063 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/accounting/factory.pyx
--rw-r--r--   0        0        0     2659 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/accounting/manager.pxd
--rw-r--r--   0        0        0    22701 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/accounting/manager.pyx
--rw-r--r--   0        0        0     1153 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/adapters/__init__.py
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/adapters/_template/__init__.py
--rw-r--r--   0        0        0     1013 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/adapters/_template/core.py
--rw-r--r--   0        0        0    13300 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/adapters/_template/data.py
--rw-r--r--   0        0        0     6617 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/adapters/_template/execution.py
--rw-r--r--   0        0        0     2461 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/adapters/_template/providers.py
--rw-r--r--   0        0        0      946 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/__init__.py
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/client/__init__.py
--rw-r--r--   0        0        0    11390 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/client/core.py
--rw-r--r--   0        0        0     2278 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/client/enums.py
--rw-r--r--   0        0        0     3484 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/client/exceptions.py
--rw-r--r--   0        0        0     2395 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/client/spec.py
--rw-r--r--   0        0        0     2725 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/client/util.py
--rw-r--r--   0        0        0     2856 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/common.py
--rw-r--r--   0        0        0     2342 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/config.py
--rw-r--r--   0        0        0     2056 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/constants.py
--rw-r--r--   0        0        0    12896 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/data.py
--rw-r--r--   0        0        0     7912 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/data_types.py
--rw-r--r--   0        0        0    41691 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/execution.py
--rw-r--r--   0        0        0     8697 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/factories.py
--rw-r--r--   0        0        0     2919 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/historic.py
--rw-r--r--   0        0        0     1271 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/orderbook.pxd
--rw-r--r--   0        0        0     2017 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/orderbook.pyx
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/parsing/__init__.py
--rw-r--r--   0        0        0     2557 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/parsing/common.py
--rw-r--r--   0        0        0     2151 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/parsing/core.py
--rw-r--r--   0        0        0    12500 2023-05-20 00:56:32.880015 nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/parsing/requests.py
--rw-r--r--   0        0        0    24123 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/parsing/streaming.py
--rw-r--r--   0        0        0    13206 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/providers.py
--rw-r--r--   0        0        0     7303 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/sockets.py
--rw-r--r--   0        0        0      939 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/__init__.py
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/common/__init__.py
--rw-r--r--   0        0        0      957 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/common/constants.py
--rw-r--r--   0        0        0    27093 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/common/data.py
--rw-r--r--   0        0        0    11975 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/common/enums.py
--rw-r--r--   0        0        0    35889 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/common/execution.py
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/common/schemas/__init__.py
--rw-r--r--   0        0        0    10209 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/common/schemas/account.py
--rw-r--r--   0        0        0    21194 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/common/schemas/market.py
--rw-r--r--   0        0        0     2434 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/common/schemas/symbol.py
--rw-r--r--   0        0        0     1199 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/common/schemas/user.py
--rw-r--r--   0        0        0    14983 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/common/types.py
--rw-r--r--   0        0        0     4013 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/config.py
--rw-r--r--   0        0        0    17023 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/factories.py
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/__init__.py
--rw-r--r--   0        0        0     8782 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/data.py
--rw-r--r--   0        0        0     6746 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/enums.py
--rw-r--r--   0        0        0    12284 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/execution.py
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/http/__init__.py
--rw-r--r--   0        0        0    13354 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/http/account.py
--rw-r--r--   0        0        0     3646 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/http/market.py
--rw-r--r--   0        0        0     1964 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/http/user.py
--rw-r--r--   0        0        0     4884 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/http/wallet.py
--rw-r--r--   0        0        0    16539 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/providers.py
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/schemas/__init__.py
--rw-r--r--   0        0        0     6885 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/schemas/account.py
--rw-r--r--   0        0        0     7594 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/schemas/market.py
--rw-r--r--   0        0        0    13834 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/schemas/user.py
--rw-r--r--   0        0        0     1271 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/schemas/wallet.py
--rw-r--r--   0        0        0     4630 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/types.py
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/http/__init__.py
--rw-r--r--   0        0        0    24541 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/http/account.py
--rw-r--r--   0        0        0     6438 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/http/client.py
--rw-r--r--   0        0        0     3226 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/http/endpoint.py
--rw-r--r--   0        0        0     1558 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/http/error.py
--rw-r--r--   0        0        0    31639 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/http/market.py
--rw-r--r--   0        0        0     7778 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/http/user.py
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/spot/__init__.py
--rw-r--r--   0        0        0     5852 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/spot/data.py
--rw-r--r--   0        0        0     4799 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/spot/enums.py
--rw-r--r--   0        0        0     9847 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/spot/execution.py
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/spot/http/__init__.py
--rw-r--r--   0        0        0    26424 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/spot/http/account.py
--rw-r--r--   0        0        0     6709 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/spot/http/market.py
--rw-r--r--   0        0        0     1973 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/spot/http/user.py
--rw-r--r--   0        0        0     4669 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/spot/http/wallet.py
--rw-r--r--   0        0        0    13617 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/spot/providers.py
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/spot/schemas/__init__.py
--rw-r--r--   0        0        0     3299 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/spot/schemas/account.py
--rw-r--r--   0        0        0     6189 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/spot/schemas/market.py
--rw-r--r--   0        0        0    11677 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/spot/schemas/user.py
--rw-r--r--   0        0        0     1252 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/spot/schemas/wallet.py
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/websocket/__init__.py
--rw-r--r--   0        0        0     7670 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/binance/websocket/client.py
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.884015 nautilus_trader-1.174.0/nautilus_trader/adapters/deribit/__init__.py
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/adapters/deribit/http/__init__.py
--rw-r--r--   0        0        0     5601 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/adapters/deribit/http/client.py
--rw-r--r--   0        0        0     1554 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/adapters/deribit/http/error.py
--rw-r--r--   0        0        0      931 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/adapters/interactive_brokers/__init__.py
--rw-r--r--   0        0        0     1299 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/adapters/interactive_brokers/common.py
--rw-r--r--   0        0        0     4009 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/adapters/interactive_brokers/config.py
--rw-r--r--   0        0        0    21104 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/adapters/interactive_brokers/data.py
--rw-r--r--   0        0        0    16801 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/adapters/interactive_brokers/execution.py
--rw-r--r--   0        0        0     9905 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/adapters/interactive_brokers/factories.py
--rw-r--r--   0        0        0     6745 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/adapters/interactive_brokers/gateway.py
--rw-r--r--   0        0        0    14016 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/adapters/interactive_brokers/historic.py
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/adapters/interactive_brokers/parsing/__init__.py
--rw-r--r--   0        0        0     3911 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/adapters/interactive_brokers/parsing/data.py
--rw-r--r--   0        0        0     4905 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/adapters/interactive_brokers/parsing/execution.py
--rw-r--r--   0        0        0     8268 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/adapters/interactive_brokers/parsing/instruments.py
--rw-r--r--   0        0        0     9210 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/adapters/interactive_brokers/providers.py
--rw-r--r--   0        0        0     4646 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/adapters/interactive_brokers/web.py
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/adapters/sandbox/__init__.py
--rw-r--r--   0        0        0     1393 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/adapters/sandbox/config.py
--rw-r--r--   0        0        0     7814 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/adapters/sandbox/execution.py
--rw-r--r--   0        0        0     2693 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/adapters/sandbox/factory.py
--rw-r--r--   0        0        0      979 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/analysis/__init__.py
--rw-r--r--   0        0        0    15157 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/analysis/analyzer.py
--rw-r--r--   0        0        0     4714 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/analysis/reporter.py
--rw-r--r--   0        0        0     3968 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/analysis/statistic.py
--rw-r--r--   0        0        0     2255 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/__init__.py
--rw-r--r--   0        0        0     2016 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/expectancy.py
--rw-r--r--   0        0        0     1717 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/long_ratio.py
--rw-r--r--   0        0        0     1481 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/loser_avg.py
--rw-r--r--   0        0        0     1527 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/loser_max.py
--rw-r--r--   0        0        0     1525 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/loser_min.py
--rw-r--r--   0        0        0     1576 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/profit_factor.py
--rw-r--r--   0        0        0     1412 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/returns_avg.py
--rw-r--r--   0        0        0     1427 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/returns_avg_loss.py
--rw-r--r--   0        0        0     1426 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/returns_avg_win.py
--rw-r--r--   0        0        0     1728 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/returns_volatility.py
--rw-r--r--   0        0        0     1336 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/risk_return_ratio.py
--rw-r--r--   0        0        0     1788 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/sharpe_ratio.py
--rw-r--r--   0        0        0     1895 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/sortino_ratio.py
--rw-r--r--   0        0        0     1511 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/win_rate.py
--rw-r--r--   0        0        0     1502 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/winner_avg.py
--rw-r--r--   0        0        0     1360 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/winner_max.py
--rw-r--r--   0        0        0     1507 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/winner_min.py
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/backtest/__init__.pxd
--rw-r--r--   0        0        0      945 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/backtest/__init__.py
--rw-r--r--   0        0        0     1710 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/backtest/__main__.py
--rw-r--r--   0        0        0     3874 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/backtest/auction.py
--rw-r--r--   0        0        0     1100 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/backtest/data_client.pxd
--rw-r--r--   0        0        0    12847 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/backtest/data_client.pyx
--rw-r--r--   0        0        0     2164 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/backtest/engine.pxd
--rw-r--r--   0        0        0    46027 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/backtest/engine.pyx
--rw-r--r--   0        0        0     6839 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/backtest/exchange.pxd
--rw-r--r--   0        0        0    28471 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/backtest/exchange.pyx
--rw-r--r--   0        0        0     1084 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/backtest/execution_client.pxd
--rw-r--r--   0        0        0     5182 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/backtest/execution_client.pyx
--rw-r--r--   0        0        0    11198 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/backtest/matching_engine.pxd
--rw-r--r--   0        0        0    85772 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/backtest/matching_engine.pyx
--rw-r--r--   0        0        0     2075 2023-05-20 00:56:32.888015 nautilus_trader-1.174.0/nautilus_trader/backtest/models.pxd
--rw-r--r--   0        0        0     5344 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/backtest/models.pyx
--rw-r--r--   0        0        0     1814 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/backtest/modules.pxd
--rw-r--r--   0        0        0     8294 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/backtest/modules.pyx
--rw-r--r--   0        0        0    11400 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/backtest/node.py
--rw-r--r--   0        0        0     3110 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/backtest/results.py
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/cache/__init__.pxd
--rw-r--r--   0        0        0     1052 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/cache/__init__.py
--rw-r--r--   0        0        0     9896 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/cache/base.pxd
--rw-r--r--   0        0        0    23040 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/cache/base.pyx
--rw-r--r--   0        0        0     7346 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/cache/cache.pxd
--rw-r--r--   0        0        0   122388 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/cache/cache.pyx
--rw-r--r--   0        0        0     3663 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/cache/database.pxd
--rw-r--r--   0        0        0     9114 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/cache/database.pyx
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/common/__init__.pxd
--rw-r--r--   0        0        0     1571 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/common/__init__.py
--rw-r--r--   0        0        0     9919 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/common/actor.pxd
--rw-r--r--   0        0        0    73833 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/common/actor.pyx
--rw-r--r--   0        0        0     3551 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/common/clock.pxd
--rw-r--r--   0        0        0    27216 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/common/clock.pyx
--rw-r--r--   0        0        0     2916 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/common/component.pxd
--rw-r--r--   0        0        0    19989 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/common/component.pyx
--rw-r--r--   0        0        0     1836 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/common/enums.pyx
--rw-r--r--   0        0        0     1518 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/common/enums_c.pxd
--rw-r--r--   0        0        0     2638 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/common/enums_c.pyx
--rw-r--r--   0        0        0     8599 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/common/factories.pxd
--rw-r--r--   0        0        0    51638 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/common/factories.pyx
--rw-r--r--   0        0        0     1320 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/common/functions.py
--rw-r--r--   0        0        0     2139 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/common/generators.pxd
--rw-r--r--   0        0        0     7837 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/common/generators.pyx
--rw-r--r--   0        0        0     2460 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/common/logging.pxd
--rw-r--r--   0        0        0    18699 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/common/logging.pyx
--rw-r--r--   0        0        0     2421 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/common/messages.pxd
--rw-r--r--   0        0        0    10632 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/common/messages.pyx
--rw-r--r--   0        0        0    10746 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/common/providers.py
--rw-r--r--   0        0        0     1566 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/common/queue.pxd
--rw-r--r--   0        0        0     5704 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/common/queue.pyx
--rw-r--r--   0        0        0     2440 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/common/throttler.pxd
--rw-r--r--   0        0        0     7418 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/common/throttler.pyx
--rw-r--r--   0        0        0     2482 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/common/timer.pxd
--rw-r--r--   0        0        0    11992 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/common/timer.pyx
--rw-r--r--   0        0        0     3793 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/config/__init__.py
--rw-r--r--   0        0        0     9917 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/config/backtest.py
--rw-r--r--   0        0        0    19918 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/config/common.py
--rw-r--r--   0        0        0     1015 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/config/error.py
--rw-r--r--   0        0        0     7535 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/config/live.py
--rw-r--r--   0        0        0     1264 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/config/validation.py
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/core/__init__.pxd
--rw-r--r--   0        0        0     1339 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/core/__init__.py
--rw-r--r--   0        0        0     1230 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/core/asynchronous.py
--rw-r--r--   0        0        0     3628 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/core/correctness.pxd
--rw-r--r--   0        0        0    37204 2023-05-20 00:56:32.892015 nautilus_trader-1.174.0/nautilus_trader/core/correctness.pyx
--rw-r--r--   0        0        0     1191 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/core/data.pxd
--rw-r--r--   0        0        0     2665 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/core/data.pyx
--rw-r--r--   0        0        0     1680 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/core/datetime.pxd
--rw-r--r--   0        0        0     9470 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/core/datetime.pyx
--rw-r--r--   0        0        0     1230 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/core/fsm.pxd
--rw-r--r--   0        0        0     4364 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/core/fsm.pyx
--rw-r--r--   0        0        0      907 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/core/includes/backtest.h
--rw-r--r--   0        0        0     7908 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/core/includes/common.h
--rw-r--r--   0        0        0     2997 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/core/includes/core.h
--rw-r--r--   0        0        0    32646 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/core/includes/model.h
--rw-r--r--   0        0        0     2325 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/core/inspect.py
--rw-r--r--   0        0        0     2471 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/core/message.pxd
--rw-r--r--   0        0        0     6720 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/core/message.pyx
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/core/rust/__init__.pxd
--rw-r--r--   0        0        0     1050 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/core/rust/backtest.pxd
--rw-r--r--   0        0        0     7939 2023-05-20 01:01:55.873037 nautilus_trader-1.174.0/nautilus_trader/core/rust/common.pxd
--rw-r--r--   0        0        0     1222 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/core/rust/common.pyx
--rw-r--r--   0        0        0     2942 2023-05-20 01:01:32.217266 nautilus_trader-1.174.0/nautilus_trader/core/rust/core.pxd
--rw-r--r--   0        0        0    31055 2023-05-20 01:01:40.041191 nautilus_trader-1.174.0/nautilus_trader/core/rust/model.pxd
--rw-r--r--   0        0        0     2689 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/core/rust/model.pyx
--rw-r--r--   0        0        0     1359 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/core/stats.pxd
--rw-r--r--   0        0        0     5710 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/core/stats.pyx
--rw-r--r--   0        0        0     3197 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/core/string.pxd
--rw-r--r--   0        0        0     1049 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/core/uuid.pxd
--rw-r--r--   0        0        0     3157 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/core/uuid.pyx
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/data/__init__.pxd
--rw-r--r--   0        0        0     1360 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/data/__init__.py
--rw-r--r--   0        0        0     4156 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/data/aggregation.pxd
--rw-r--r--   0        0        0    24142 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/data/aggregation.pyx
--rw-r--r--   0        0        0     8386 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/data/client.pxd
--rw-r--r--   0        0        0    41143 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/data/client.pyx
--rw-r--r--   0        0        0     9022 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/data/engine.pxd
--rw-r--r--   0        0        0    55431 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/data/engine.pyx
--rw-r--r--   0        0        0     2396 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/data/messages.pxd
--rw-r--r--   0        0        0     8389 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/data/messages.pyx
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/examples/__init__.py
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/examples/algorithms/__init__.py
--rw-r--r--   0        0        0     4133 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/examples/algorithms/blank.py
--rw-r--r--   0        0        0    11508 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/examples/algorithms/twap.py
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/examples/strategies/__init__.pxd
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/examples/strategies/__init__.py
--rw-r--r--   0        0        0     5581 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/examples/strategies/blank.py
--rw-r--r--   0        0        0    12340 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/examples/strategies/ema_cross.py
--rw-r--r--   0        0        0    12010 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/examples/strategies/ema_cross_bracket.py
--rw-r--r--   0        0        0    14927 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/examples/strategies/ema_cross_bracket_algo.py
--rw-r--r--   0        0        0    10735 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/examples/strategies/ema_cross_cython.pyx
--rw-r--r--   0        0        0    16017 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/examples/strategies/ema_cross_stop_entry.py
--rw-r--r--   0        0        0    14424 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/examples/strategies/ema_cross_trailing_stop.py
--rw-r--r--   0        0        0    12963 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/examples/strategies/ema_cross_twap.py
--rw-r--r--   0        0        0     5512 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/examples/strategies/market_maker.py
--rw-r--r--   0        0        0     8241 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/examples/strategies/orderbook_imbalance.py
--rw-r--r--   0        0        0     2730 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/examples/strategies/signal_strategy.py
--rw-r--r--   0        0        0     4629 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/examples/strategies/subscribe.py
--rw-r--r--   0        0        0    13464 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/examples/strategies/volatility_market_maker.py
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/execution/__init__.pxd
--rw-r--r--   0        0        0     1353 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/execution/__init__.py
--rw-r--r--   0        0        0     5954 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/execution/algorithm.pxd
--rw-r--r--   0        0        0    38095 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/execution/algorithm.pyx
--rw-r--r--   0        0        0     7458 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/execution/client.pxd
--rw-r--r--   0        0        0    28604 2023-05-20 00:56:32.896015 nautilus_trader-1.174.0/nautilus_trader/execution/client.pyx
--rw-r--r--   0        0        0     4418 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/execution/emulator.pxd
--rw-r--r--   0        0        0    39253 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/execution/emulator.pyx
--rw-r--r--   0        0        0     6030 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/execution/engine.pxd
--rw-r--r--   0        0        0    33464 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/execution/engine.pyx
--rw-r--r--   0        0        0     3485 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/execution/matching_core.pxd
--rw-r--r--   0        0        0    14476 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/execution/matching_core.pyx
--rw-r--r--   0        0        0     5380 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/execution/messages.pxd
--rw-r--r--   0        0        0    30396 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/execution/messages.pyx
--rw-r--r--   0        0        0     8370 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/execution/reports.pxd
--rw-r--r--   0        0        0    22070 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/execution/reports.pyx
--rw-r--r--   0        0        0     1785 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/execution/trailing.pxd
--rw-r--r--   0        0        0    16636 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/execution/trailing.pyx
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/__init__.pxd
--rw-r--r--   0        0        0     1188 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/__init__.py
--rw-r--r--   0        0        0     1722 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/amat.pxd
--rw-r--r--   0        0        0     4836 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/amat.pyx
--rw-r--r--   0        0        0     1482 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/aroon.pxd
--rw-r--r--   0        0        0     3474 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/aroon.pyx
--rw-r--r--   0        0        0     1474 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/atr.pxd
--rw-r--r--   0        0        0     4324 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/atr.pyx
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/average/__init__.pxd
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/average/__init__.py
--rw-r--r--   0        0        0     1770 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/average/ama.pxd
--rw-r--r--   0        0        0     5197 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/average/ama.pyx
--rw-r--r--   0        0        0     1063 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/average/dema.pxd
--rw-r--r--   0        0        0     3852 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/average/dema.pyx
--rw-r--r--   0        0        0     1096 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/average/ema.pxd
--rw-r--r--   0        0        0     3466 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/average/ema.pyx
--rw-r--r--   0        0        0     1247 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/average/hma.pxd
--rw-r--r--   0        0        0     4335 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/average/hma.pyx
--rw-r--r--   0        0        0     3114 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/average/ma_factory.pyx
--rw-r--r--   0        0        0     1566 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/average/moving_average.pxd
--rw-r--r--   0        0        0     2945 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/average/moving_average.pyx
--rw-r--r--   0        0        0     1080 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/average/rma.pxd
--rw-r--r--   0        0        0     3478 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/average/rma.pyx
--rw-r--r--   0        0        0     1020 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/average/sma.pxd
--rw-r--r--   0        0        0     3542 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/average/sma.pyx
--rw-r--r--   0        0        0     1283 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/average/vidya.pxd
--rw-r--r--   0        0        0     4604 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/average/vidya.pyx
--rw-r--r--   0        0        0     1174 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/average/wma.pxd
--rw-r--r--   0        0        0     4712 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/average/wma.pyx
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/base/__init__.pxd
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/base/__init__.py
--rw-r--r--   0        0        0     1715 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/base/indicator.pxd
--rw-r--r--   0        0        0     2981 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/base/indicator.pyx
--rw-r--r--   0        0        0     1315 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/bias.pxd
--rw-r--r--   0        0        0     2872 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/bias.pyx
--rw-r--r--   0        0        0     1579 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/bollinger_bands.pxd
--rw-r--r--   0        0        0     5221 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/bollinger_bands.pyx
--rw-r--r--   0        0        0     1639 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/cci.pxd
--rw-r--r--   0        0        0     4060 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/cci.pyx
--rw-r--r--   0        0        0     1375 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/cmo.pxd
--rw-r--r--   0        0        0     3664 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/cmo.pyx
--rw-r--r--   0        0        0     1662 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/dm.pxd
--rw-r--r--   0        0        0     3736 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/dm.pyx
--rw-r--r--   0        0        0     1490 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/donchian_channel.pxd
--rw-r--r--   0        0        0     4376 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/donchian_channel.pyx
--rw-r--r--   0        0        0     1231 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/efficiency_ratio.pxd
--rw-r--r--   0        0        0     3123 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/efficiency_ratio.pyx
--rw-r--r--   0        0        0     3172 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/fuzzy_candlesticks.pxd
--rw-r--r--   0        0        0    12544 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/fuzzy_candlesticks.pyx
--rw-r--r--   0        0        0     1347 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/fuzzy_enum.pyx
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/fuzzy_enums/__init__.pxd
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/fuzzy_enums/__init__.py
--rw-r--r--   0        0        0      976 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/fuzzy_enums/candle_body.pxd
--rw-r--r--   0        0        0      980 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/fuzzy_enums/candle_body.pyx
--rw-r--r--   0        0        0      947 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/fuzzy_enums/candle_direction.pxd
--rw-r--r--   0        0        0      987 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/fuzzy_enums/candle_direction.pyx
--rw-r--r--   0        0        0     1020 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/fuzzy_enums/candle_size.pxd
--rw-r--r--   0        0        0      972 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/fuzzy_enums/candle_size.pyx
--rw-r--r--   0        0        0      972 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/fuzzy_enums/candle_wick.pxd
--rw-r--r--   0        0        0      980 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/fuzzy_enums/candle_wick.pyx
--rw-r--r--   0        0        0     1809 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/keltner_channel.pxd
--rw-r--r--   0        0        0     4675 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/keltner_channel.pyx
--rw-r--r--   0        0        0     1395 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/keltner_position.pxd
--rw-r--r--   0        0        0     4284 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/keltner_position.pyx
--rw-r--r--   0        0        0     1713 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/kvo.pxd
--rw-r--r--   0        0        0     4731 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/kvo.pyx
--rw-r--r--   0        0        0     1636 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/linear_regression.pxd
--rw-r--r--   0        0        0     3843 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/linear_regression.pyx
--rw-r--r--   0        0        0     1662 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/macd.pxd
--rw-r--r--   0        0        0     4821 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/macd.pyx
--rw-r--r--   0        0        0     1232 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/obv.pxd
--rw-r--r--   0        0        0     2962 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/obv.pyx
--rw-r--r--   0        0        0     1514 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/pressure.pxd
--rw-r--r--   0        0        0     4387 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/pressure.pyx
--rw-r--r--   0        0        0     1476 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/psl.pxd
--rw-r--r--   0        0        0     3315 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/psl.pyx
--rw-r--r--   0        0        0     1227 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/roc.pxd
--rw-r--r--   0        0        0     2730 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/roc.pyx
--rw-r--r--   0        0        0     1393 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/rsi.pxd
--rw-r--r--   0        0        0     3771 2023-05-20 00:56:32.900015 nautilus_trader-1.174.0/nautilus_trader/indicators/rsi.pyx
--rw-r--r--   0        0        0     1767 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/indicators/rvi.pxd
--rw-r--r--   0        0        0     4543 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/indicators/rvi.pyx
--rw-r--r--   0        0        0     1444 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/indicators/spread_analyzer.pxd
--rw-r--r--   0        0        0     3384 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/indicators/spread_analyzer.pyx
--rw-r--r--   0        0        0     1485 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/indicators/stochastics.pxd
--rw-r--r--   0        0        0     3888 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/indicators/stochastics.pyx
--rw-r--r--   0        0        0     2275 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/indicators/swings.pxd
--rw-r--r--   0        0        0     4682 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/indicators/swings.pyx
--rw-r--r--   0        0        0     1458 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/indicators/vhf.pxd
--rw-r--r--   0        0        0     3517 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/indicators/vhf.pyx
--rw-r--r--   0        0        0     1485 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/indicators/volatility_ratio.pxd
--rw-r--r--   0        0        0     4486 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/indicators/volatility_ratio.pyx
--rw-r--r--   0        0        0     1270 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/indicators/vwap.pxd
--rw-r--r--   0        0        0     2942 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/indicators/vwap.pyx
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/infrastructure/__init__.pxd
--rw-r--r--   0        0        0     1047 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/infrastructure/__init__.py
--rw-r--r--   0        0        0     1362 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/infrastructure/cache.pxd
--rw-r--r--   0        0        0    30746 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/infrastructure/cache.pyx
--rw-r--r--   0        0        0     1155 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/live/__init__.py
--rw-r--r--   0        0        0     1849 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/live/__main__.py
--rw-r--r--   0        0        0    30848 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/live/data_client.py
--rw-r--r--   0        0        0    15072 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/live/data_engine.py
--rw-r--r--   0        0        0    16682 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/live/execution_client.py
--rw-r--r--   0        0        0    37117 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/live/execution_engine.py
--rw-r--r--   0        0        0     3535 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/live/factories.py
--rw-r--r--   0        0        0    20190 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/live/node.py
--rw-r--r--   0        0        0     8452 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/live/node_builder.py
--rw-r--r--   0        0        0     9203 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/live/risk_engine.py
--rw-r--r--   0        0        0     5560 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/__init__.pxd
--rw-r--r--   0        0        0     1141 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/__init__.py
--rw-r--r--   0        0        0      894 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/currencies.pxd
--rw-r--r--   0        0        0     9220 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/currencies.pyx
--rw-r--r--   0        0        0     1308 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/currency.pxd
--rw-r--r--   0        0        0     8403 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/currency.pyx
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/data/__init__.pxd
--rw-r--r--   0        0        0      950 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/data/__init__.py
--rw-r--r--   0        0        0     2541 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/data/bar.pxd
--rw-r--r--   0        0        0    26622 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/data/bar.pyx
--rw-r--r--   0        0        0     1178 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/data/bar_aggregation.pxd
--rw-r--r--   0        0        0      958 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/data/bar_aggregation.pyx
--rw-r--r--   0        0        0     1467 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/data/base.pxd
--rw-r--r--   0        0        0     3443 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/data/base.pyx
--rw-r--r--   0        0        0     1373 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/data/bet.pxd
--rw-r--r--   0        0        0     4166 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/data/bet.pyx
--rw-r--r--   0        0        0     3757 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/data/book.pxd
--rw-r--r--   0        0        0    14710 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/data/book.pyx
--rw-r--r--   0        0        0     3259 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/data/tick.pxd
--rw-r--r--   0        0        0    24747 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/data/tick.pyx
--rw-r--r--   0        0        0     1225 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/data/ticker.pxd
--rw-r--r--   0        0        0     3293 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/data/ticker.pyx
--rw-r--r--   0        0        0     2492 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/data/venue.pxd
--rw-r--r--   0        0        0    10197 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/data/venue.pyx
--rw-r--r--   0        0        0     7484 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/enums.pyx
--rw-r--r--   0        0        0     4918 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/enums_c.pxd
--rw-r--r--   0        0        0    11387 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/enums_c.pyx
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/events/__init__.pxd
--rw-r--r--   0        0        0      951 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/events/__init__.py
--rw-r--r--   0        0        0     2058 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/events/account.pxd
--rw-r--r--   0        0        0     5965 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/events/account.pyx
--rw-r--r--   0        0        0     9076 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/events/order.pxd
--rw-r--r--   0        0        0    85735 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/events/order.pyx
--rw-r--r--   0        0        0     5544 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/events/position.pxd
--rw-r--r--   0        0        0    34546 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/events/position.pyx
--rw-r--r--   0        0        0     2983 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/identifiers.pxd
--rw-r--r--   0        0        0    22672 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/identifiers.pyx
--rw-r--r--   0        0        0        0 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/instruments/__init__.pxd
--rw-r--r--   0        0        0     1752 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/instruments/__init__.py
--rw-r--r--   0        0        0     4880 2023-05-20 00:56:32.904015 nautilus_trader-1.174.0/nautilus_trader/model/instruments/base.pxd
--rw-r--r--   0        0        0    19261 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/instruments/base.pyx
--rw-r--r--   0        0        0     1745 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/instruments/betting.pxd
--rw-r--r--   0        0        0     7712 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/instruments/betting.pyx
--rw-r--r--   0        0        0     1521 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/instruments/crypto_future.pxd
--rw-r--r--   0        0        0    11042 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/instruments/crypto_future.pyx
--rw-r--r--   0        0        0     1491 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/instruments/crypto_perpetual.pxd
--rw-r--r--   0        0        0    11211 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/instruments/crypto_perpetual.pyx
--rw-r--r--   0        0        0     1265 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/instruments/currency_pair.pxd
--rw-r--r--   0        0        0    11354 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/instruments/currency_pair.pyx
--rw-r--r--   0        0        0     1108 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/instruments/equity.pxd
--rw-r--r--   0        0        0     7319 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/instruments/equity.pyx
--rw-r--r--   0        0        0     1344 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/instruments/futures_contract.pxd
--rw-r--r--   0        0        0     6806 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/instruments/futures_contract.pyx
--rw-r--r--   0        0        0     1386 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/instruments/options_contract.pxd
--rw-r--r--   0        0        0     7459 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/instruments/options_contract.pyx
--rw-r--r--   0        0        0     5280 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/objects.pxd
--rw-r--r--   0        0        0    40812 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/objects.pyx
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orderbook/__init__.pxd
--rw-r--r--   0        0        0     1597 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orderbook/__init__.py
--rw-r--r--   0        0        0     5048 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orderbook/book.pxd
--rw-r--r--   0        0        0    30652 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orderbook/book.pyx
--rw-r--r--   0        0        0     1005 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orderbook/error.py
--rw-r--r--   0        0        0     2752 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orderbook/ladder.pxd
--rw-r--r--   0        0        0     8368 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orderbook/ladder.pyx
--rw-r--r--   0        0        0     1357 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orderbook/level.pxd
--rw-r--r--   0        0        0     4097 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orderbook/level.pyx
--rw-r--r--   0        0        0     1336 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orderbook/simulated.pxd
--rw-r--r--   0        0        0     6245 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orderbook/simulated.pyx
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orders/__init__.pxd
--rw-r--r--   0        0        0     2093 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orders/__init__.py
--rw-r--r--   0        0        0     8827 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orders/base.pxd
--rw-r--r--   0        0        0    33961 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orders/base.pyx
--rw-r--r--   0        0        0     1705 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orders/limit.pxd
--rw-r--r--   0        0        0    17316 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orders/limit.pyx
--rw-r--r--   0        0        0     2171 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orders/limit_if_touched.pxd
--rw-r--r--   0        0        0    16477 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orders/limit_if_touched.pyx
--rw-r--r--   0        0        0     1849 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orders/list.pxd
--rw-r--r--   0        0        0     2367 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orders/list.pyx
--rw-r--r--   0        0        0     1206 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orders/market.pxd
--rw-r--r--   0        0        0    12902 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orders/market.pyx
--rw-r--r--   0        0        0     1608 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orders/market_if_touched.pxd
--rw-r--r--   0        0        0    14755 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orders/market_if_touched.pyx
--rw-r--r--   0        0        0     1644 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orders/market_to_limit.pxd
--rw-r--r--   0        0        0    13592 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orders/market_to_limit.pyx
--rw-r--r--   0        0        0     2161 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orders/stop_limit.pxd
--rw-r--r--   0        0        0    16617 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orders/stop_limit.pyx
--rw-r--r--   0        0        0     1598 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orders/stop_market.pxd
--rw-r--r--   0        0        0    15030 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orders/stop_market.pyx
--rw-r--r--   0        0        0     2641 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orders/trailing_stop_limit.pxd
--rw-r--r--   0        0        0    18630 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orders/trailing_stop_limit.pyx
--rw-r--r--   0        0        0     1947 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orders/trailing_stop_market.pxd
--rw-r--r--   0        0        0    16279 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orders/trailing_stop_market.pyx
--rw-r--r--   0        0        0     1141 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orders/unpacker.pxd
--rw-r--r--   0        0        0     3906 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/orders/unpacker.pyx
--rw-r--r--   0        0        0     6860 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/position.pxd
--rw-r--r--   0        0        0    23025 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/position.pyx
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/tick_scheme/__init__.pxd
--rw-r--r--   0        0        0     1311 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/tick_scheme/__init__.py
--rw-r--r--   0        0        0     1581 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/tick_scheme/base.pxd
--rw-r--r--   0        0        0     3709 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/tick_scheme/base.pyx
--rw-r--r--   0        0        0     1147 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/tick_scheme/implementations/__init__.py
--rw-r--r--   0        0        0     1371 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/tick_scheme/implementations/fixed.pxd
--rw-r--r--   0        0        0     4052 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/tick_scheme/implementations/fixed.pyx
--rw-r--r--   0        0        0     1359 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/tick_scheme/implementations/tiered.pxd
--rw-r--r--   0        0        0     5632 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/model/tick_scheme/implementations/tiered.pyx
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/msgbus/__init__.pxd
--rw-r--r--   0        0        0      994 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/msgbus/__init__.py
--rw-r--r--   0        0        0     2718 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/msgbus/bus.pxd
--rw-r--r--   0        0        0    16946 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/msgbus/bus.pyx
--rw-r--r--   0        0        0     1181 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/msgbus/subscription.pxd
--rw-r--r--   0        0        0     3066 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/msgbus/subscription.pyx
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/network/__init__.pxd
--rw-r--r--   0        0        0     1125 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/network/__init__.py
--rw-r--r--   0        0        0     1020 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/network/error.py
--rw-r--r--   0        0        0     1520 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/network/http.pxd
--rw-r--r--   0        0        0     9912 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/network/http.pyx
--rw-r--r--   0        0        0     1868 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/network/socket.pxd
--rw-r--r--   0        0        0     6595 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/network/socket.pyx
--rw-r--r--   0        0        0     1832 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/network/websocket.pxd
--rw-r--r--   0        0        0    10808 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/network/websocket.pyx
--rw-r--r--   0        0        0      972 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/persistence/__init__.py
--rw-r--r--   0        0        0     1079 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/persistence/catalog/__init__.py
--rw-r--r--   0        0        0     6131 2023-05-20 00:56:32.908015 nautilus_trader-1.174.0/nautilus_trader/persistence/catalog/base.py
--rw-r--r--   0        0        0    18579 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/persistence/catalog/parquet.py
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/persistence/external/__init__.py
--rw-r--r--   0        0        0    14916 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/persistence/external/core.py
--rw-r--r--   0        0        0     1555 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/persistence/external/metadata.py
--rw-r--r--   0        0        0    13281 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/persistence/external/readers.py
--rw-r--r--   0        0        0     3157 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/persistence/external/util.py
--rw-r--r--   0        0        0     2152 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/persistence/funcs.py
--rw-r--r--   0        0        0     5280 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/persistence/loaders.py
--rw-r--r--   0        0        0     1530 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/persistence/migrate.py
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/persistence/streaming/__init__.py
--rw-r--r--   0        0        0     5330 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/persistence/streaming/batching.py
--rw-r--r--   0        0        0     8232 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/persistence/streaming/engine.py
--rw-r--r--   0        0        0     7476 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/persistence/streaming/writer.py
--rw-r--r--   0        0        0     2564 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/persistence/wranglers.pxd
--rw-r--r--   0        0        0    17866 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/persistence/wranglers.pyx
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/portfolio/__init__.pxd
--rw-r--r--   0        0        0      948 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/portfolio/__init__.py
--rw-r--r--   0        0        0     2132 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/portfolio/base.pxd
--rw-r--r--   0        0        0     4033 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/portfolio/base.pyx
--rw-r--r--   0        0        0     3015 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/portfolio/portfolio.pxd
--rw-r--r--   0        0        0    37488 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/portfolio/portfolio.pyx
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/risk/__init__.pxd
--rw-r--r--   0        0        0     1084 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/risk/__init__.py
--rw-r--r--   0        0        0     5613 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/risk/engine.pxd
--rw-r--r--   0        0        0    36965 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/risk/engine.pyx
--rw-r--r--   0        0        0     1747 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/risk/sizing.pxd
--rw-r--r--   0        0        0     7081 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/risk/sizing.pyx
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/serialization/__init__.pxd
--rw-r--r--   0        0        0     1106 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/serialization/__init__.py
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/serialization/arrow/__init__.pxd
--rw-r--r--   0        0        0      948 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/serialization/arrow/__init__.py
--rw-r--r--   0        0        0     1408 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/serialization/arrow/implementations/__init__.py
--rw-r--r--   0        0        0     4222 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/serialization/arrow/implementations/account_state.py
--rw-r--r--   0        0        0     1373 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/serialization/arrow/implementations/bar.py
--rw-r--r--   0        0        0     1090 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/serialization/arrow/implementations/instruments.py
--rw-r--r--   0        0        0     5194 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/serialization/arrow/implementations/order_book.py
--rw-r--r--   0        0        0     2947 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/serialization/arrow/implementations/order_events.py
--rw-r--r--   0        0        0     5420 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/serialization/arrow/implementations/orderbook_v2.py
--rw-r--r--   0        0        0     2873 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/serialization/arrow/implementations/position_events.py
--rw-r--r--   0        0        0    29149 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/serialization/arrow/schema.py
--rw-r--r--   0        0        0     3023 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/serialization/arrow/schema_v2.py
--rw-r--r--   0        0        0      910 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/serialization/arrow/serializer.pxd
--rw-r--r--   0        0        0     6290 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/serialization/arrow/serializer.pyx
--rw-r--r--   0        0        0     4625 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/serialization/arrow/util.py
--rw-r--r--   0        0        0     1053 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/serialization/base.pxd
--rw-r--r--   0        0        0    10114 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/serialization/base.pyx
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/serialization/msgpack/__init__.pxd
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/serialization/msgpack/__init__.py
--rw-r--r--   0        0        0     1097 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/serialization/msgpack/serializer.pxd
--rw-r--r--   0        0        0     3649 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/serialization/msgpack/serializer.pyx
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/system/__init__.py
--rw-r--r--   0        0        0    23192 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/system/kernel.py
--rw-r--r--   0        0        0     1035 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/test_kit/__init__.py
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/test_kit/mocks/__init__.py
--rw-r--r--   0        0        0     6160 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/test_kit/mocks/actors.py
--rw-r--r--   0        0        0     5825 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/test_kit/mocks/cache_database.py
--rw-r--r--   0        0        0     3967 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/test_kit/mocks/data.py
--rw-r--r--   0        0        0     3077 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/test_kit/mocks/engines.py
--rw-r--r--   0        0        0    12905 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/test_kit/mocks/exec_clients.py
--rw-r--r--   0        0        0     6073 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/test_kit/mocks/strategies.py
--rw-r--r--   0        0        0     3076 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/test_kit/performance.py
--rw-r--r--   0        0        0    20761 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/test_kit/providers.py
--rw-r--r--   0        0        0     1276 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/test_kit/stubs/__init__.py
--rw-r--r--   0        0        0     4385 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/test_kit/stubs/commands.py
--rw-r--r--   0        0        0     6613 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/test_kit/stubs/component.py
--rw-r--r--   0        0        0     6251 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/test_kit/stubs/config.py
--rw-r--r--   0        0        0    17802 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/test_kit/stubs/data.py
--rw-r--r--   0        0        0    13185 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/test_kit/stubs/events.py
--rw-r--r--   0        0        0     6704 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/test_kit/stubs/execution.py
--rw-r--r--   0        0        0     3425 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/test_kit/stubs/identifiers.py
--rw-r--r--   0        0        0     2970 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/test_kit/stubs/persistence.py
--rw-r--r--   0        0        0      869 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/trading/__init__.pxd
--rw-r--r--   0        0        0     1145 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/trading/__init__.py
--rw-r--r--   0        0        0     2103 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/trading/filters.pxd
--rw-r--r--   0        0        0    16813 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/trading/filters.pyx
--rw-r--r--   0        0        0     6774 2023-05-20 00:56:32.912015 nautilus_trader-1.174.0/nautilus_trader/trading/strategy.pxd
--rw-r--r--   0        0        0    53611 2023-05-20 00:56:32.916015 nautilus_trader-1.174.0/nautilus_trader/trading/strategy.pyx
--rw-r--r--   0        0        0     3055 2023-05-20 00:56:32.916015 nautilus_trader-1.174.0/nautilus_trader/trading/trader.pxd
--rw-r--r--   0        0        0    20063 2023-05-20 00:56:32.916015 nautilus_trader-1.174.0/nautilus_trader/trading/trader.pyx
--rw-r--r--   0        0        0     7477 2023-05-20 00:56:32.916015 nautilus_trader-1.174.0/pyproject.toml
--rw-r--r--   0        0        0    25793 1970-01-01 00:00:00.000000 nautilus_trader-1.174.0/PKG-INFO
+-rw-r--r--   0        0        0     7652 2023-06-17 12:45:50.819001 nautilus_trader-1.175.0/LICENSE
+-rw-r--r--   0        0        0    24139 2023-06-17 12:45:50.819001 nautilus_trader-1.175.0/README.md
+-rw-r--r--   0        0        0    12563 2023-06-17 12:45:50.819001 nautilus_trader-1.175.0/build.py
+-rw-r--r--   0        0        0      663 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/.cargo/config.toml
+-rw-r--r--   0        0        0    94369 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/Cargo.lock
+-rw-r--r--   0        0        0     1691 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/Cargo.toml
+-rw-r--r--   0        0        0     7652 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/LICENSE
+-rw-r--r--   0        0        0     1248 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/README.md
+-rw-r--r--   0        0        0      702 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/backtest/Cargo.toml
+-rw-r--r--   0        0        0     1882 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/backtest/build.rs
+-rw-r--r--   0        0        0      484 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/backtest/cbindgen.toml
+-rw-r--r--   0        0        0      810 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/backtest/cbindgen_cython.toml
+-rw-r--r--   0        0        0     5732 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/backtest/src/engine.rs
+-rw-r--r--   0        0        0      900 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/backtest/src/lib.rs
+-rw-r--r--   0        0        0       65 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/clippy.toml
+-rw-r--r--   0        0        0      715 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/common/Cargo.toml
+-rw-r--r--   0        0        0     2536 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/common/build.rs
+-rw-r--r--   0        0        0      531 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/common/cbindgen.toml
+-rw-r--r--   0        0        0      724 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/common/cbindgen_cython.toml
+-rw-r--r--   0        0        0    18875 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/common/src/clock.rs
+-rw-r--r--   0        0        0     8305 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/common/src/clock_api.rs
+-rw-r--r--   0        0        0     9689 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/common/src/enums.rs
+-rw-r--r--   0        0        0     1038 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/common/src/lib.rs
+-rw-r--r--   0        0        0    22774 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/common/src/logging.rs
+-rw-r--r--   0        0        0     4372 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/common/src/logging_api.rs
+-rw-r--r--   0        0        0     7311 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/common/src/msgbus.rs
+-rw-r--r--   0        0        0     2463 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/common/src/testing.rs
+-rw-r--r--   0        0        0     7894 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/common/src/timer.rs
+-rw-r--r--   0        0        0     1857 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/common/src/timer_api.rs
+-rw-r--r--   0        0        0      639 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/core/Cargo.toml
+-rw-r--r--   0        0        0     1234 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/core/benches/criterion_time_benchmark.rs
+-rw-r--r--   0        0        0     2532 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/core/build.rs
+-rw-r--r--   0        0        0      681 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/core/cbindgen.toml
+-rw-r--r--   0        0        0      791 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/core/cbindgen_cython.toml
+-rw-r--r--   0        0        0     7666 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/core/src/correctness.rs
+-rw-r--r--   0        0        0     5544 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/core/src/cvec.rs
+-rw-r--r--   0        0        0     5257 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/core/src/datetime.rs
+-rw-r--r--   0        0        0      998 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/core/src/lib.rs
+-rw-r--r--   0        0        0     7462 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/core/src/parsing.rs
+-rw-r--r--   0        0        0     5143 2023-06-17 12:45:50.835001 nautilus_trader-1.175.0/nautilus_core/core/src/string.rs
+-rw-r--r--   0        0        0     5106 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/core/src/time.rs
+-rw-r--r--   0        0        0     7991 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/core/src/uuid.rs
+-rw-r--r--   0        0        0      497 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/indicators/Cargo.toml
+-rw-r--r--   0        0        0     5107 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/indicators/src/ema.rs
+-rw-r--r--   0        0        0     1512 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/indicators/src/lib.rs
+-rw-r--r--   0        0        0      881 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/Cargo.toml
+-rw-r--r--   0        0        0      399 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/benches/criterion_fixed_precision_benchmark.rs
+-rw-r--r--   0        0        0      225 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/benches/iai_fixed_precision_benchmark.rs
+-rw-r--r--   0        0        0     2534 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/build.rs
+-rw-r--r--   0        0        0     1201 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/cbindgen.toml
+-rw-r--r--   0        0        0     1410 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/cbindgen_cython.toml
+-rw-r--r--   0        0        0    22050 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/currencies.rs
+-rw-r--r--   0        0        0    14495 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/data/bar.rs
+-rw-r--r--   0        0        0     5702 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/data/bar_api.rs
+-rw-r--r--   0        0        0    11452 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/data/book.rs
+-rw-r--r--   0        0        0     3433 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/data/book_api.rs
+-rw-r--r--   0        0        0     1947 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/data/mod.rs
+-rw-r--r--   0        0        0     6502 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/data/tick.rs
+-rw-r--r--   0        0        0     3272 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/data/tick_api.rs
+-rw-r--r--   0        0        0    34427 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/enums.rs
+-rw-r--r--   0        0        0      936 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/events/mod.rs
+-rw-r--r--   0        0        0    11566 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/events/order.rs
+-rw-r--r--   0        0        0     4127 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/events/order_api.rs
+-rw-r--r--   0        0        0     3530 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/events/position.rs
+-rw-r--r--   0        0        0     7357 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/account_id.rs
+-rw-r--r--   0        0        0     4823 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/client_id.rs
+-rw-r--r--   0        0        0     4213 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/client_order_id.rs
+-rw-r--r--   0        0        0     3856 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/component_id.rs
+-rw-r--r--   0        0        0     3998 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/exec_algorithm_id.rs
+-rw-r--r--   0        0        0     6978 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/instrument_id.rs
+-rw-r--r--   0        0        0     1901 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/macros.rs
+-rw-r--r--   0        0        0     2798 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/mod.rs
+-rw-r--r--   0        0        0     3830 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/order_list_id.rs
+-rw-r--r--   0        0        0     3820 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/position_id.rs
+-rw-r--r--   0        0        0     3733 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/strategy_id.rs
+-rw-r--r--   0        0        0     3810 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/symbol.rs
+-rw-r--r--   0        0        0     3744 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/trade_id.rs
+-rw-r--r--   0        0        0     3678 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/trader_id.rs
+-rw-r--r--   0        0        0     3765 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/venue.rs
+-rw-r--r--   0        0        0     4004 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/venue_order_id.rs
+-rw-r--r--   0        0        0     1866 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/instruments/mod.rs
+-rw-r--r--   0        0        0     6754 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/instruments/synthetic.rs
+-rw-r--r--   0        0        0     4886 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/instruments/synthetic_api.rs
+-rw-r--r--   0        0        0     2485 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/lib.rs
+-rw-r--r--   0        0        0    23202 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/orderbook/book.rs
+-rw-r--r--   0        0        0     6676 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/orderbook/book_api.rs
+-rw-r--r--   0        0        0    20289 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/orderbook/ladder.rs
+-rw-r--r--   0        0        0     9955 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/orderbook/level.rs
+-rw-r--r--   0        0        0      947 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/orderbook/mod.rs
+-rw-r--r--   0        0        0     4581 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/orders/limit.rs
+-rw-r--r--   0        0        0    27066 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/orders/mod.rs
+-rw-r--r--   0        0        0     7661 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/position.rs
+-rw-r--r--   0        0        0     1342 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/types/balance.rs
+-rw-r--r--   0        0        0     7370 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/types/currency.rs
+-rw-r--r--   0        0        0     6164 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/types/fixed.rs
+-rw-r--r--   0        0        0      982 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/types/mod.rs
+-rw-r--r--   0        0        0     8544 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/types/money.rs
+-rw-r--r--   0        0        0    11276 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/types/price.rs
+-rw-r--r--   0        0        0    11648 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/model/src/types/quantity.rs
+-rw-r--r--   0        0        0      835 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/network/Cargo.toml
+-rw-r--r--   0        0        0     1649 2023-06-17 12:45:50.839002 nautilus_trader-1.175.0/nautilus_core/network/benches/test_client.rs
+-rw-r--r--   0        0        0     1652 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/benches/test_server.rs
+-rw-r--r--   0        0        0    13452 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/src/http.rs
+-rw-r--r--   0        0        0     1321 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/src/lib.rs
+-rw-r--r--   0        0        0    10031 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/src/socket.rs
+-rw-r--r--   0        0        0    21477 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/src/websocket.rs
+-rw-r--r--   0        0        0       18 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/.gitignore
+-rw-r--r--   0        0        0     2862 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/CHANGELOG.md
+-rw-r--r--   0        0        0     2408 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/Cargo.toml
+-rw-r--r--   0        0        0     1093 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/LICENSE
+-rw-r--r--   0        0        0     2861 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/README.md
+-rw-r--r--   0        0        0      268 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/rustfmt.toml
+-rw-r--r--   0        0        0     6903 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/src/compat.rs
+-rw-r--r--   0        0        0     2747 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/src/connect.rs
+-rw-r--r--   0        0        0     5486 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/src/handshake.rs
+-rw-r--r--   0        0        0    14222 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/src/lib.rs
+-rw-r--r--   0        0        0     2974 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/src/stream.rs
+-rw-r--r--   0        0        0     9381 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/src/tls.rs
+-rw-r--r--   0        0        0     3623 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/tests/communication.rs
+-rw-r--r--   0        0        0      883 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/network/tokio-tungstenite/tests/handshakes.rs
+-rw-r--r--   0        0        0     1065 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/persistence/Cargo.toml
+-rw-r--r--   0        0        0     4179 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/persistence/benches/bench_persistence.rs
+-rw-r--r--   0        0        0     6102 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/persistence/src/kmerge_batch.rs
+-rw-r--r--   0        0        0     1285 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/persistence/src/lib.rs
+-rw-r--r--   0        0        0     6861 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/persistence/src/parquet/implementations/bar.rs
+-rw-r--r--   0        0        0     8163 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/persistence/src/parquet/implementations/delta.rs
+-rw-r--r--   0        0        0      926 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/persistence/src/parquet/implementations/mod.rs
+-rw-r--r--   0        0        0     6551 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/persistence/src/parquet/implementations/quote.rs
+-rw-r--r--   0        0        0     6894 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/persistence/src/parquet/implementations/trade.rs
+-rw-r--r--   0        0        0     1632 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/persistence/src/parquet/mod.rs
+-rw-r--r--   0        0        0    11170 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/persistence/src/session.rs
+-rw-r--r--   0        0        0     3536 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/persistence/tests/test_catalog.rs
+-rw-r--r--   0        0        0     2906 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/persistence/tests/test_persistence_module.py
+-rw-r--r--   0        0        0     2159 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/persistence/tests/test_util.rs
+-rw-r--r--   0        0        0      647 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/pyo3/Cargo.toml
+-rw-r--r--   0        0        0     2591 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/pyo3/src/lib.rs
+-rw-r--r--   0        0        0       50 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/rust-toolchain.toml
+-rw-r--r--   0        0        0      225 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_core/rustfmt.toml
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/__init__.pxd
+-rw-r--r--   0        0        0     1268 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/__init__.py
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/__init__.pxd
+-rw-r--r--   0        0        0     1414 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/__init__.py
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/__init__.pxd
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/__init__.py
+-rw-r--r--   0        0        0     3975 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/base.pxd
+-rw-r--r--   0        0        0    14292 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/base.pyx
+-rw-r--r--   0        0        0     1738 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/betting.pxd
+-rw-r--r--   0        0        0     3421 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/betting.pyx
+-rw-r--r--   0        0        0     1886 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/cash.pxd
+-rw-r--r--   0        0        0    11342 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/cash.pyx
+-rw-r--r--   0        0        0     3178 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/margin.pxd
+-rw-r--r--   0        0        0    20725 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/margin.pyx
+-rw-r--r--   0        0        0     1488 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/calculators.pxd
+-rw-r--r--   0        0        0    10737 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/calculators.pyx
+-rw-r--r--   0        0        0     2111 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/error.py
+-rw-r--r--   0        0        0     1089 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/factory.pxd
+-rw-r--r--   0        0        0     4063 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/factory.pyx
+-rw-r--r--   0        0        0     2659 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/manager.pxd
+-rw-r--r--   0        0        0    22701 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/accounting/manager.pyx
+-rw-r--r--   0        0        0     1153 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/adapters/__init__.py
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/adapters/_template/__init__.py
+-rw-r--r--   0        0        0     1013 2023-06-17 12:45:50.843002 nautilus_trader-1.175.0/nautilus_trader/adapters/_template/core.py
+-rw-r--r--   0        0        0    13291 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/_template/data.py
+-rw-r--r--   0        0        0     6617 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/_template/execution.py
+-rw-r--r--   0        0        0     2461 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/_template/providers.py
+-rw-r--r--   0        0        0      946 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/__init__.py
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/client/__init__.py
+-rw-r--r--   0        0        0    11386 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/client/core.py
+-rw-r--r--   0        0        0     2278 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/client/enums.py
+-rw-r--r--   0        0        0     3484 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/client/exceptions.py
+-rw-r--r--   0        0        0     2395 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/client/spec.py
+-rw-r--r--   0        0        0     2725 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/client/util.py
+-rw-r--r--   0        0        0     2856 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/common.py
+-rw-r--r--   0        0        0     2342 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/config.py
+-rw-r--r--   0        0        0     2056 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/constants.py
+-rw-r--r--   0        0        0    12886 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/data.py
+-rw-r--r--   0        0        0     7890 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/data_types.py
+-rw-r--r--   0        0        0    41677 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/execution.py
+-rw-r--r--   0        0        0     8697 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/factories.py
+-rw-r--r--   0        0        0     2919 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/historic.py
+-rw-r--r--   0        0        0     1267 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/orderbook.pxd
+-rw-r--r--   0        0        0     1994 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/orderbook.pyx
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/parsing/__init__.py
+-rw-r--r--   0        0        0     2557 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/parsing/common.py
+-rw-r--r--   0        0        0     2153 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/parsing/core.py
+-rw-r--r--   0        0        0    12492 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/parsing/requests.py
+-rw-r--r--   0        0        0    24233 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/parsing/streaming.py
+-rw-r--r--   0        0        0    13453 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/providers.py
+-rw-r--r--   0        0        0     7303 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/sockets.py
+-rw-r--r--   0        0        0      939 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/__init__.py
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/__init__.py
+-rw-r--r--   0        0        0      957 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/constants.py
+-rw-r--r--   0        0        0    26457 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/data.py
+-rw-r--r--   0        0        0    11941 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/enums.py
+-rw-r--r--   0        0        0    33817 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/execution.py
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/schemas/__init__.py
+-rw-r--r--   0        0        0    10209 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/schemas/account.py
+-rw-r--r--   0        0        0    21891 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/schemas/market.py
+-rw-r--r--   0        0        0     2434 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/schemas/symbol.py
+-rw-r--r--   0        0        0     1199 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/schemas/user.py
+-rw-r--r--   0        0        0    14968 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/types.py
+-rw-r--r--   0        0        0     4013 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/config.py
+-rw-r--r--   0        0        0    16833 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/factories.py
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/__init__.py
+-rw-r--r--   0        0        0     8645 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/data.py
+-rw-r--r--   0        0        0     6746 2023-06-17 12:45:50.847002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/enums.py
+-rw-r--r--   0        0        0    12254 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/execution.py
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/http/__init__.py
+-rw-r--r--   0        0        0    13350 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/http/account.py
+-rw-r--r--   0        0        0     3643 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/http/market.py
+-rw-r--r--   0        0        0     1961 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/http/user.py
+-rw-r--r--   0        0        0     4879 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/http/wallet.py
+-rw-r--r--   0        0        0    16510 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/providers.py
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/schemas/__init__.py
+-rw-r--r--   0        0        0     6885 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/schemas/account.py
+-rw-r--r--   0        0        0     7589 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/schemas/market.py
+-rw-r--r--   0        0        0    13834 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/schemas/user.py
+-rw-r--r--   0        0        0     1271 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/schemas/wallet.py
+-rw-r--r--   0        0        0     5069 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/types.py
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/http/__init__.py
+-rw-r--r--   0        0        0    24539 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/http/account.py
+-rw-r--r--   0        0        0     4838 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/http/client.py
+-rw-r--r--   0        0        0     3226 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/http/endpoint.py
+-rw-r--r--   0        0        0     1558 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/http/error.py
+-rw-r--r--   0        0        0    32295 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/http/market.py
+-rw-r--r--   0        0        0     7770 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/http/user.py
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/__init__.py
+-rw-r--r--   0        0        0     5722 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/data.py
+-rw-r--r--   0        0        0     4799 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/enums.py
+-rw-r--r--   0        0        0     9841 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/execution.py
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/http/__init__.py
+-rw-r--r--   0        0        0    26418 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/http/account.py
+-rw-r--r--   0        0        0     6703 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/http/market.py
+-rw-r--r--   0        0        0     1967 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/http/user.py
+-rw-r--r--   0        0        0     4663 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/http/wallet.py
+-rw-r--r--   0        0        0    13621 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/providers.py
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/schemas/__init__.py
+-rw-r--r--   0        0        0     3299 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/schemas/account.py
+-rw-r--r--   0        0        0     6803 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/schemas/market.py
+-rw-r--r--   0        0        0    11677 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/schemas/user.py
+-rw-r--r--   0        0        0     1252 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/schemas/wallet.py
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/websocket/__init__.py
+-rw-r--r--   0        0        0     9396 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/binance/websocket/client.py
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/deribit/__init__.py
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/deribit/http/__init__.py
+-rw-r--r--   0        0        0     5601 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/deribit/http/client.py
+-rw-r--r--   0        0        0     1554 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/deribit/http/error.py
+-rw-r--r--   0        0        0      931 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/__init__.py
+-rw-r--r--   0        0        0      957 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/client/__init__.py
+-rw-r--r--   0        0        0    61657 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/client/client.py
+-rw-r--r--   0        0        0     6375 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/client/common.py
+-rw-r--r--   0        0        0     6816 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/common.py
+-rw-r--r--   0        0        0     7192 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/config.py
+-rw-r--r--   0        0        0    17666 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/data.py
+-rw-r--r--   0        0        0    36373 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/execution.py
+-rw-r--r--   0        0        0     9483 2023-06-17 12:45:50.851002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/factories.py
+-rw-r--r--   0        0        0     7055 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/gateway.py
+-rw-r--r--   0        0        0    13994 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/historic.py
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/parsing/__init__.py
+-rw-r--r--   0        0        0     3248 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/parsing/data.py
+-rw-r--r--   0        0        0     3843 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/parsing/execution.py
+-rw-r--r--   0        0        0    15711 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/parsing/instruments.py
+-rw-r--r--   0        0        0    11931 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/providers.py
+-rw-r--r--   0        0        0     4646 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/web.py
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/adapters/sandbox/__init__.py
+-rw-r--r--   0        0        0     1393 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/adapters/sandbox/config.py
+-rw-r--r--   0        0        0     7838 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/adapters/sandbox/execution.py
+-rw-r--r--   0        0        0     2693 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/adapters/sandbox/factory.py
+-rw-r--r--   0        0        0      979 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/__init__.py
+-rw-r--r--   0        0        0    15157 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/analyzer.py
+-rw-r--r--   0        0        0     4706 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/reporter.py
+-rw-r--r--   0        0        0     3968 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistic.py
+-rw-r--r--   0        0        0     2255 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/__init__.py
+-rw-r--r--   0        0        0     2016 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/expectancy.py
+-rw-r--r--   0        0        0     1717 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/long_ratio.py
+-rw-r--r--   0        0        0     1481 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/loser_avg.py
+-rw-r--r--   0        0        0     1527 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/loser_max.py
+-rw-r--r--   0        0        0     1525 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/loser_min.py
+-rw-r--r--   0        0        0     1576 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/profit_factor.py
+-rw-r--r--   0        0        0     1412 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/returns_avg.py
+-rw-r--r--   0        0        0     1427 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/returns_avg_loss.py
+-rw-r--r--   0        0        0     1426 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/returns_avg_win.py
+-rw-r--r--   0        0        0     1728 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/returns_volatility.py
+-rw-r--r--   0        0        0     1336 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/risk_return_ratio.py
+-rw-r--r--   0        0        0     1788 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/sharpe_ratio.py
+-rw-r--r--   0        0        0     1895 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/sortino_ratio.py
+-rw-r--r--   0        0        0     1511 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/win_rate.py
+-rw-r--r--   0        0        0     1502 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/winner_avg.py
+-rw-r--r--   0        0        0     1360 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/winner_max.py
+-rw-r--r--   0        0        0     1507 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/winner_min.py
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/backtest/__init__.pxd
+-rw-r--r--   0        0        0      945 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/backtest/__init__.py
+-rw-r--r--   0        0        0     1710 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/backtest/__main__.py
+-rw-r--r--   0        0        0     3840 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/backtest/auction.py
+-rw-r--r--   0        0        0     1100 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/backtest/data_client.pxd
+-rw-r--r--   0        0        0    12847 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/backtest/data_client.pyx
+-rw-r--r--   0        0        0     2164 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/backtest/engine.pxd
+-rw-r--r--   0        0        0    47964 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/backtest/engine.pyx
+-rw-r--r--   0        0        0     7183 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/backtest/exchange.pxd
+-rw-r--r--   0        0        0    29202 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/backtest/exchange.pyx
+-rw-r--r--   0        0        0     1084 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/backtest/execution_client.pxd
+-rw-r--r--   0        0        0     5182 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/backtest/execution_client.pyx
+-rw-r--r--   0        0        0    11478 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/backtest/matching_engine.pxd
+-rw-r--r--   0        0        0    86190 2023-06-17 12:45:50.855002 nautilus_trader-1.175.0/nautilus_trader/backtest/matching_engine.pyx
+-rw-r--r--   0        0        0     2075 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/backtest/models.pxd
+-rw-r--r--   0        0        0     5344 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/backtest/models.pyx
+-rw-r--r--   0        0        0     1814 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/backtest/modules.pxd
+-rw-r--r--   0        0        0     8294 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/backtest/modules.pyx
+-rw-r--r--   0        0        0    11390 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/backtest/node.py
+-rw-r--r--   0        0        0     3110 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/backtest/results.py
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/cache/__init__.pxd
+-rw-r--r--   0        0        0     1052 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/cache/__init__.py
+-rw-r--r--   0        0        0     9896 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/cache/base.pxd
+-rw-r--r--   0        0        0    23040 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/cache/base.pyx
+-rw-r--r--   0        0        0     7346 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/cache/cache.pxd
+-rw-r--r--   0        0        0   123311 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/cache/cache.pyx
+-rw-r--r--   0        0        0     3663 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/cache/database.pxd
+-rw-r--r--   0        0        0     9114 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/cache/database.pyx
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/__init__.pxd
+-rw-r--r--   0        0        0     1571 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/__init__.py
+-rw-r--r--   0        0        0    10008 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/actor.pxd
+-rw-r--r--   0        0        0    73784 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/actor.pyx
+-rw-r--r--   0        0        0     3551 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/clock.pxd
+-rw-r--r--   0        0        0    27231 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/clock.pyx
+-rw-r--r--   0        0        0     2916 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/component.pxd
+-rw-r--r--   0        0        0    20109 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/component.pyx
+-rw-r--r--   0        0        0     1836 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/enums.pyx
+-rw-r--r--   0        0        0     1518 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/enums_c.pxd
+-rw-r--r--   0        0        0     2638 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/enums_c.pyx
+-rw-r--r--   0        0        0     9277 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/factories.pxd
+-rw-r--r--   0        0        0    56125 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/factories.pyx
+-rw-r--r--   0        0        0     1320 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/functions.py
+-rw-r--r--   0        0        0     2139 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/generators.pxd
+-rw-r--r--   0        0        0     7837 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/generators.pyx
+-rw-r--r--   0        0        0     2492 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/logging.pxd
+-rw-r--r--   0        0        0    18806 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/logging.pyx
+-rw-r--r--   0        0        0     2421 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/messages.pxd
+-rw-r--r--   0        0        0    10632 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/messages.pyx
+-rw-r--r--   0        0        0    10746 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/providers.py
+-rw-r--r--   0        0        0     1566 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/queue.pxd
+-rw-r--r--   0        0        0     5704 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/queue.pyx
+-rw-r--r--   0        0        0     2440 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/throttler.pxd
+-rw-r--r--   0        0        0     7418 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/throttler.pyx
+-rw-r--r--   0        0        0     2482 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/timer.pxd
+-rw-r--r--   0        0        0    11992 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/common/timer.pyx
+-rw-r--r--   0        0        0     3793 2023-06-17 12:45:50.859003 nautilus_trader-1.175.0/nautilus_trader/config/__init__.py
+-rw-r--r--   0        0        0     9913 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/config/backtest.py
+-rw-r--r--   0        0        0    21003 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/config/common.py
+-rw-r--r--   0        0        0     1015 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/config/error.py
+-rw-r--r--   0        0        0     6651 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/config/live.py
+-rw-r--r--   0        0        0     1264 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/config/validation.py
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/__init__.pxd
+-rw-r--r--   0        0        0     1339 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/__init__.py
+-rw-r--r--   0        0        0     1230 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/asynchronous.py
+-rw-r--r--   0        0        0     3628 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/correctness.pxd
+-rw-r--r--   0        0        0    37204 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/correctness.pyx
+-rw-r--r--   0        0        0      897 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/data.pxd
+-rw-r--r--   0        0        0     1954 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/data.pyx
+-rw-r--r--   0        0        0     1680 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/datetime.pxd
+-rw-r--r--   0        0        0     9479 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/datetime.pyx
+-rw-r--r--   0        0        0     1230 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/fsm.pxd
+-rw-r--r--   0        0        0     4364 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/fsm.pyx
+-rw-r--r--   0        0        0     2511 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/includes/algorithms.h
+-rw-r--r--   0        0        0      907 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/includes/backtest.h
+-rw-r--r--   0        0        0    12998 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/includes/common.h
+-rw-r--r--   0        0        0     3027 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/includes/core.h
+-rw-r--r--   0        0        0    50013 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/includes/model.h
+-rw-r--r--   0        0        0     2325 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/inspect.py
+-rw-r--r--   0        0        0     2471 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/message.pxd
+-rw-r--r--   0        0        0     6720 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/message.pyx
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/rust/__init__.pxd
+-rw-r--r--   0        0        0     2635 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/rust/algorithms.pxd
+-rw-r--r--   0        0        0     1050 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/rust/backtest.pxd
+-rw-r--r--   0        0        0    12551 2023-06-17 12:53:55.864524 nautilus_trader-1.175.0/nautilus_trader/core/rust/common.pxd
+-rw-r--r--   0        0        0     1222 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/rust/common.pyx
+-rw-r--r--   0        0        0     2998 2023-06-17 12:52:52.095179 nautilus_trader-1.175.0/nautilus_trader/core/rust/core.pxd
+-rw-r--r--   0        0        0    46788 2023-06-17 12:53:12.008904 nautilus_trader-1.175.0/nautilus_trader/core/rust/model.pxd
+-rw-r--r--   0        0        0     2618 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/rust/model.pyx
+-rw-r--r--   0        0        0     1359 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/stats.pxd
+-rw-r--r--   0        0        0     5710 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/stats.pyx
+-rw-r--r--   0        0        0     3698 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/string.pxd
+-rw-r--r--   0        0        0     1049 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/uuid.pxd
+-rw-r--r--   0        0        0     3157 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/core/uuid.pyx
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/data/__init__.pxd
+-rw-r--r--   0        0        0     1360 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/data/__init__.py
+-rw-r--r--   0        0        0     4156 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/data/aggregation.pxd
+-rw-r--r--   0        0        0    24142 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/data/aggregation.pyx
+-rw-r--r--   0        0        0     8386 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/data/client.pxd
+-rw-r--r--   0        0        0    41150 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/data/client.pyx
+-rw-r--r--   0        0        0     9166 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/data/engine.pxd
+-rw-r--r--   0        0        0    56337 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/data/engine.pyx
+-rw-r--r--   0        0        0     2396 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/data/messages.pxd
+-rw-r--r--   0        0        0     8389 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/data/messages.pyx
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/examples/__init__.py
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/examples/algorithms/__init__.py
+-rw-r--r--   0        0        0     4133 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/examples/algorithms/blank.py
+-rw-r--r--   0        0        0    11508 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/examples/algorithms/twap.py
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/examples/strategies/__init__.pxd
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/examples/strategies/__init__.py
+-rw-r--r--   0        0        0     5567 2023-06-17 12:45:50.863003 nautilus_trader-1.175.0/nautilus_trader/examples/strategies/blank.py
+-rw-r--r--   0        0        0    12080 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/examples/strategies/ema_cross.py
+-rw-r--r--   0        0        0    11997 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/examples/strategies/ema_cross_bracket.py
+-rw-r--r--   0        0        0    14914 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/examples/strategies/ema_cross_bracket_algo.py
+-rw-r--r--   0        0        0    10735 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/examples/strategies/ema_cross_cython.pyx
+-rw-r--r--   0        0        0    15993 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/examples/strategies/ema_cross_stop_entry.py
+-rw-r--r--   0        0        0    14375 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/examples/strategies/ema_cross_trailing_stop.py
+-rw-r--r--   0        0        0    12721 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/examples/strategies/ema_cross_twap.py
+-rw-r--r--   0        0        0     5331 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/examples/strategies/market_maker.py
+-rw-r--r--   0        0        0     8092 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/examples/strategies/orderbook_imbalance.py
+-rw-r--r--   0        0        0     2720 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/examples/strategies/signal_strategy.py
+-rw-r--r--   0        0        0     4641 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/examples/strategies/subscribe.py
+-rw-r--r--   0        0        0    13449 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/examples/strategies/volatility_market_maker.py
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/__init__.pxd
+-rw-r--r--   0        0        0     1353 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/__init__.py
+-rw-r--r--   0        0        0     5954 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/algorithm.pxd
+-rw-r--r--   0        0        0    38095 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/algorithm.pyx
+-rw-r--r--   0        0        0     7458 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/client.pxd
+-rw-r--r--   0        0        0    28604 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/client.pyx
+-rw-r--r--   0        0        0     4418 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/emulator.pxd
+-rw-r--r--   0        0        0    40391 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/emulator.pyx
+-rw-r--r--   0        0        0     6579 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/engine.pxd
+-rw-r--r--   0        0        0    41895 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/engine.pyx
+-rw-r--r--   0        0        0     3485 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/matching_core.pxd
+-rw-r--r--   0        0        0    14476 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/matching_core.pyx
+-rw-r--r--   0        0        0     5380 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/messages.pxd
+-rw-r--r--   0        0        0    30390 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/messages.pyx
+-rw-r--r--   0        0        0     8370 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/reports.pxd
+-rw-r--r--   0        0        0    22070 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/reports.pyx
+-rw-r--r--   0        0        0     1785 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/trailing.pxd
+-rw-r--r--   0        0        0    16636 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/execution/trailing.pyx
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/__init__.pxd
+-rw-r--r--   0        0        0     1188 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/__init__.py
+-rw-r--r--   0        0        0     1722 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/amat.pxd
+-rw-r--r--   0        0        0     4836 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/amat.pyx
+-rw-r--r--   0        0        0     1482 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/aroon.pxd
+-rw-r--r--   0        0        0     3474 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/aroon.pyx
+-rw-r--r--   0        0        0     1474 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/atr.pxd
+-rw-r--r--   0        0        0     4324 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/atr.pyx
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/__init__.pxd
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/__init__.py
+-rw-r--r--   0        0        0     1770 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/ama.pxd
+-rw-r--r--   0        0        0     5197 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/ama.pyx
+-rw-r--r--   0        0        0     1063 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/dema.pxd
+-rw-r--r--   0        0        0     3852 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/dema.pyx
+-rw-r--r--   0        0        0     1096 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/ema.pxd
+-rw-r--r--   0        0        0     3466 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/ema.pyx
+-rw-r--r--   0        0        0     1247 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/hma.pxd
+-rw-r--r--   0        0        0     4335 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/hma.pyx
+-rw-r--r--   0        0        0     3114 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/ma_factory.pyx
+-rw-r--r--   0        0        0     1566 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/moving_average.pxd
+-rw-r--r--   0        0        0     2945 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/moving_average.pyx
+-rw-r--r--   0        0        0     1080 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/rma.pxd
+-rw-r--r--   0        0        0     3478 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/rma.pyx
+-rw-r--r--   0        0        0     1020 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/sma.pxd
+-rw-r--r--   0        0        0     3542 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/sma.pyx
+-rw-r--r--   0        0        0     1283 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/vidya.pxd
+-rw-r--r--   0        0        0     4604 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/vidya.pyx
+-rw-r--r--   0        0        0     1174 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/wma.pxd
+-rw-r--r--   0        0        0     4712 2023-06-17 12:45:50.867003 nautilus_trader-1.175.0/nautilus_trader/indicators/average/wma.pyx
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/base/__init__.pxd
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/base/__init__.py
+-rw-r--r--   0        0        0     1715 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/base/indicator.pxd
+-rw-r--r--   0        0        0     2981 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/base/indicator.pyx
+-rw-r--r--   0        0        0     1315 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/bias.pxd
+-rw-r--r--   0        0        0     2872 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/bias.pyx
+-rw-r--r--   0        0        0     1579 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/bollinger_bands.pxd
+-rw-r--r--   0        0        0     5221 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/bollinger_bands.pyx
+-rw-r--r--   0        0        0     1639 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/cci.pxd
+-rw-r--r--   0        0        0     4060 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/cci.pyx
+-rw-r--r--   0        0        0     1375 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/cmo.pxd
+-rw-r--r--   0        0        0     3664 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/cmo.pyx
+-rw-r--r--   0        0        0     1662 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/dm.pxd
+-rw-r--r--   0        0        0     3736 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/dm.pyx
+-rw-r--r--   0        0        0     1490 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/donchian_channel.pxd
+-rw-r--r--   0        0        0     4376 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/donchian_channel.pyx
+-rw-r--r--   0        0        0     1231 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/efficiency_ratio.pxd
+-rw-r--r--   0        0        0     3123 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/efficiency_ratio.pyx
+-rw-r--r--   0        0        0     3172 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_candlesticks.pxd
+-rw-r--r--   0        0        0    12544 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_candlesticks.pyx
+-rw-r--r--   0        0        0     1347 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enum.pyx
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/__init__.pxd
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/__init__.py
+-rw-r--r--   0        0        0      976 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_body.pxd
+-rw-r--r--   0        0        0      980 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_body.pyx
+-rw-r--r--   0        0        0      947 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_direction.pxd
+-rw-r--r--   0        0        0      987 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_direction.pyx
+-rw-r--r--   0        0        0     1020 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_size.pxd
+-rw-r--r--   0        0        0      972 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_size.pyx
+-rw-r--r--   0        0        0      972 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_wick.pxd
+-rw-r--r--   0        0        0      980 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_wick.pyx
+-rw-r--r--   0        0        0     1809 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/keltner_channel.pxd
+-rw-r--r--   0        0        0     4675 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/keltner_channel.pyx
+-rw-r--r--   0        0        0     1395 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/keltner_position.pxd
+-rw-r--r--   0        0        0     4284 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/keltner_position.pyx
+-rw-r--r--   0        0        0     1713 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/kvo.pxd
+-rw-r--r--   0        0        0     4731 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/kvo.pyx
+-rw-r--r--   0        0        0     1636 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/linear_regression.pxd
+-rw-r--r--   0        0        0     3843 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/linear_regression.pyx
+-rw-r--r--   0        0        0     1662 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/macd.pxd
+-rw-r--r--   0        0        0     4821 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/macd.pyx
+-rw-r--r--   0        0        0     1232 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/obv.pxd
+-rw-r--r--   0        0        0     2962 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/obv.pyx
+-rw-r--r--   0        0        0     1514 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/pressure.pxd
+-rw-r--r--   0        0        0     4387 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/pressure.pyx
+-rw-r--r--   0        0        0     1476 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/psl.pxd
+-rw-r--r--   0        0        0     3315 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/psl.pyx
+-rw-r--r--   0        0        0     1227 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/roc.pxd
+-rw-r--r--   0        0        0     2730 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/roc.pyx
+-rw-r--r--   0        0        0     1393 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/rsi.pxd
+-rw-r--r--   0        0        0     3771 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/rsi.pyx
+-rw-r--r--   0        0        0     1767 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/rvi.pxd
+-rw-r--r--   0        0        0     4543 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/rvi.pyx
+-rw-r--r--   0        0        0     1444 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/spread_analyzer.pxd
+-rw-r--r--   0        0        0     3384 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/spread_analyzer.pyx
+-rw-r--r--   0        0        0     1485 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/stochastics.pxd
+-rw-r--r--   0        0        0     3888 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/stochastics.pyx
+-rw-r--r--   0        0        0     2275 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/swings.pxd
+-rw-r--r--   0        0        0     4682 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/swings.pyx
+-rw-r--r--   0        0        0     1458 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/vhf.pxd
+-rw-r--r--   0        0        0     3517 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/vhf.pyx
+-rw-r--r--   0        0        0     1485 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/volatility_ratio.pxd
+-rw-r--r--   0        0        0     4486 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/volatility_ratio.pyx
+-rw-r--r--   0        0        0     1270 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/vwap.pxd
+-rw-r--r--   0        0        0     2942 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/indicators/vwap.pyx
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/infrastructure/__init__.pxd
+-rw-r--r--   0        0        0     1047 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/infrastructure/__init__.py
+-rw-r--r--   0        0        0     1362 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/infrastructure/cache.pxd
+-rw-r--r--   0        0        0    30746 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/infrastructure/cache.pyx
+-rw-r--r--   0        0        0     1155 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/live/__init__.py
+-rw-r--r--   0        0        0     1849 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/live/__main__.py
+-rw-r--r--   0        0        0    30839 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/live/data_client.py
+-rw-r--r--   0        0        0    15072 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/live/data_engine.py
+-rw-r--r--   0        0        0    16682 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/live/execution_client.py
+-rw-r--r--   0        0        0    37905 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/live/execution_engine.py
+-rw-r--r--   0        0        0     3535 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/live/factories.py
+-rw-r--r--   0        0        0    16026 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/live/node.py
+-rw-r--r--   0        0        0     9050 2023-06-17 12:45:50.871003 nautilus_trader-1.175.0/nautilus_trader/live/node_builder.py
+-rw-r--r--   0        0        0     9203 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/live/risk_engine.py
+-rw-r--r--   0        0        0     5505 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/__init__.pxd
+-rw-r--r--   0        0        0     1141 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/__init__.py
+-rw-r--r--   0        0        0     3751 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/currencies.py
+-rw-r--r--   0        0        0     1375 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/currency.pxd
+-rw-r--r--   0        0        0     9509 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/currency.pyx
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/__init__.pxd
+-rw-r--r--   0        0        0     2125 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/__init__.py
+-rw-r--r--   0        0        0     2541 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/bar.pxd
+-rw-r--r--   0        0        0    26954 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/bar.pyx
+-rw-r--r--   0        0        0     1178 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/bar_aggregation.pxd
+-rw-r--r--   0        0        0      958 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/bar_aggregation.pyx
+-rw-r--r--   0        0        0     1467 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/base.pxd
+-rw-r--r--   0        0        0     3832 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/base.pyx
+-rw-r--r--   0        0        0     3103 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/book.pxd
+-rw-r--r--   0        0        0    16647 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/book.pyx
+-rw-r--r--   0        0        0     3740 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/tick.pxd
+-rw-r--r--   0        0        0    24661 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/tick.pyx
+-rw-r--r--   0        0        0     1529 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/ticker.pxd
+-rw-r--r--   0        0        0     3312 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/ticker.pyx
+-rw-r--r--   0        0        0     3331 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/venue.pxd
+-rw-r--r--   0        0        0     9886 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/data/venue.pyx
+-rw-r--r--   0        0        0     7239 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/enums.pyx
+-rw-r--r--   0        0        0     4770 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/enums_c.pxd
+-rw-r--r--   0        0        0    10998 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/enums_c.pyx
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/events/__init__.pxd
+-rw-r--r--   0        0        0     2664 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/events/__init__.py
+-rw-r--r--   0        0        0     2058 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/events/account.pxd
+-rw-r--r--   0        0        0     5965 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/events/account.pyx
+-rw-r--r--   0        0        0     9385 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/events/order.pxd
+-rw-r--r--   0        0        0    88334 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/events/order.pyx
+-rw-r--r--   0        0        0     5544 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/events/position.pxd
+-rw-r--r--   0        0        0    34546 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/events/position.pyx
+-rw-r--r--   0        0        0     2975 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/identifiers.pxd
+-rw-r--r--   0        0        0    24599 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/identifiers.pyx
+-rw-r--r--   0        0        0        0 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/__init__.pxd
+-rw-r--r--   0        0        0     1752 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/__init__.py
+-rw-r--r--   0        0        0     5271 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/base.pxd
+-rw-r--r--   0        0        0    19927 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/base.pyx
+-rw-r--r--   0        0        0     1745 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/betting.pxd
+-rw-r--r--   0        0        0     7717 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/betting.pyx
+-rw-r--r--   0        0        0     1521 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/crypto_future.pxd
+-rw-r--r--   0        0        0    11042 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/crypto_future.pyx
+-rw-r--r--   0        0        0     1491 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/crypto_perpetual.pxd
+-rw-r--r--   0        0        0    11211 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/crypto_perpetual.pyx
+-rw-r--r--   0        0        0     1265 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/currency_pair.pxd
+-rw-r--r--   0        0        0    11354 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/currency_pair.pyx
+-rw-r--r--   0        0        0     1108 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/equity.pxd
+-rw-r--r--   0        0        0     7433 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/equity.pyx
+-rw-r--r--   0        0        0     1344 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/futures_contract.pxd
+-rw-r--r--   0        0        0     6920 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/futures_contract.pyx
+-rw-r--r--   0        0        0     1386 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/options_contract.pxd
+-rw-r--r--   0        0        0     7573 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/options_contract.pyx
+-rw-r--r--   0        0        0     1212 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/synthetic.pxd
+-rw-r--r--   0        0        0     6590 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/instruments/synthetic.pyx
+-rw-r--r--   0        0        0     5402 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/objects.pxd
+-rw-r--r--   0        0        0    41153 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/objects.pyx
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/orderbook/__init__.pxd
+-rw-r--r--   0        0        0     1270 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/orderbook/__init__.py
+-rw-r--r--   0        0        0     2644 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/orderbook/book.pxd
+-rw-r--r--   0        0        0    15327 2023-06-17 12:45:50.875003 nautilus_trader-1.175.0/nautilus_trader/model/orderbook/book.pyx
+-rw-r--r--   0        0        0     1005 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orderbook/error.py
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/__init__.pxd
+-rw-r--r--   0        0        0     2093 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/__init__.py
+-rw-r--r--   0        0        0     9208 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/base.pxd
+-rw-r--r--   0        0        0    34743 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/base.pyx
+-rw-r--r--   0        0        0     1705 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/limit.pxd
+-rw-r--r--   0        0        0    18225 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/limit.pyx
+-rw-r--r--   0        0        0     2171 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/limit_if_touched.pxd
+-rw-r--r--   0        0        0    17334 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/limit_if_touched.pyx
+-rw-r--r--   0        0        0     1849 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/list.pxd
+-rw-r--r--   0        0        0     2367 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/list.pyx
+-rw-r--r--   0        0        0     1206 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/market.pxd
+-rw-r--r--   0        0        0    13291 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/market.pyx
+-rw-r--r--   0        0        0     1608 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/market_if_touched.pxd
+-rw-r--r--   0        0        0    15612 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/market_if_touched.pyx
+-rw-r--r--   0        0        0     1644 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/market_to_limit.pxd
+-rw-r--r--   0        0        0    13929 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/market_to_limit.pyx
+-rw-r--r--   0        0        0     2161 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/stop_limit.pxd
+-rw-r--r--   0        0        0    17474 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/stop_limit.pyx
+-rw-r--r--   0        0        0     1598 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/stop_market.pxd
+-rw-r--r--   0        0        0    15777 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/stop_market.pyx
+-rw-r--r--   0        0        0     2641 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/trailing_stop_limit.pxd
+-rw-r--r--   0        0        0    19377 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/trailing_stop_limit.pyx
+-rw-r--r--   0        0        0     1947 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/trailing_stop_market.pxd
+-rw-r--r--   0        0        0    17026 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/trailing_stop_market.pyx
+-rw-r--r--   0        0        0     1141 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/unpacker.pxd
+-rw-r--r--   0        0        0     3906 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/orders/unpacker.pyx
+-rw-r--r--   0        0        0     6860 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/position.pxd
+-rw-r--r--   0        0        0    23025 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/position.pyx
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/__init__.pxd
+-rw-r--r--   0        0        0     1311 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/__init__.py
+-rw-r--r--   0        0        0     1581 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/base.pxd
+-rw-r--r--   0        0        0     3709 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/base.pyx
+-rw-r--r--   0        0        0     1147 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/implementations/__init__.py
+-rw-r--r--   0        0        0     1371 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/implementations/fixed.pxd
+-rw-r--r--   0        0        0     4052 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/implementations/fixed.pyx
+-rw-r--r--   0        0        0     1359 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/implementations/tiered.pxd
+-rw-r--r--   0        0        0     5632 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/implementations/tiered.pyx
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/msgbus/__init__.pxd
+-rw-r--r--   0        0        0      994 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/msgbus/__init__.py
+-rw-r--r--   0        0        0     2718 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/msgbus/bus.pxd
+-rw-r--r--   0        0        0    16946 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/msgbus/bus.pyx
+-rw-r--r--   0        0        0     1181 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/msgbus/subscription.pxd
+-rw-r--r--   0        0        0     3066 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/msgbus/subscription.pyx
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/network/__init__.pxd
+-rw-r--r--   0        0        0     1125 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/network/__init__.py
+-rw-r--r--   0        0        0     1020 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/network/error.py
+-rw-r--r--   0        0        0     1520 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/network/http.pxd
+-rw-r--r--   0        0        0     9912 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/network/http.pyx
+-rw-r--r--   0        0        0     1868 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/network/socket.pxd
+-rw-r--r--   0        0        0     6595 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/network/socket.pyx
+-rw-r--r--   0        0        0     7780 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/network/socket_pyo3.py
+-rw-r--r--   0        0        0      972 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/persistence/__init__.py
+-rw-r--r--   0        0        0     1079 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/persistence/catalog/__init__.py
+-rw-r--r--   0        0        0     6083 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/persistence/catalog/base.py
+-rw-r--r--   0        0        0    18551 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/persistence/catalog/parquet.py
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/persistence/external/__init__.py
+-rw-r--r--   0        0        0    15158 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/persistence/external/core.py
+-rw-r--r--   0        0        0     1555 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/persistence/external/metadata.py
+-rw-r--r--   0        0        0    13281 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/persistence/external/readers.py
+-rw-r--r--   0        0        0     4017 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/persistence/external/util.py
+-rw-r--r--   0        0        0     2152 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/persistence/funcs.py
+-rw-r--r--   0        0        0     5432 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/persistence/loaders.py
+-rw-r--r--   0        0        0     1530 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/persistence/migrate.py
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.879004 nautilus_trader-1.175.0/nautilus_trader/persistence/streaming/__init__.py
+-rw-r--r--   0        0        0     5187 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/persistence/streaming/batching.py
+-rw-r--r--   0        0        0     8224 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/persistence/streaming/engine.py
+-rw-r--r--   0        0        0     8933 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/persistence/streaming/writer.py
+-rw-r--r--   0        0        0     2564 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/persistence/wranglers.pxd
+-rw-r--r--   0        0        0    17852 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/persistence/wranglers.pyx
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/portfolio/__init__.pxd
+-rw-r--r--   0        0        0      948 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/portfolio/__init__.py
+-rw-r--r--   0        0        0     2132 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/portfolio/base.pxd
+-rw-r--r--   0        0        0     4033 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/portfolio/base.pyx
+-rw-r--r--   0        0        0     3143 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/portfolio/portfolio.pxd
+-rw-r--r--   0        0        0    37984 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/portfolio/portfolio.pyx
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/risk/__init__.pxd
+-rw-r--r--   0        0        0     1084 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/risk/__init__.py
+-rw-r--r--   0        0        0     5613 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/risk/engine.pxd
+-rw-r--r--   0        0        0    36965 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/risk/engine.pyx
+-rw-r--r--   0        0        0     1747 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/risk/sizing.pxd
+-rw-r--r--   0        0        0     7081 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/risk/sizing.pyx
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/__init__.pxd
+-rw-r--r--   0        0        0     1106 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/__init__.py
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/__init__.pxd
+-rw-r--r--   0        0        0      948 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/__init__.py
+-rw-r--r--   0        0        0     1408 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/__init__.py
+-rw-r--r--   0        0        0     4214 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/account_state.py
+-rw-r--r--   0        0        0     1369 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/bar.py
+-rw-r--r--   0        0        0     1090 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/instruments.py
+-rw-r--r--   0        0        0     3798 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/order_book.py
+-rw-r--r--   0        0        0     2923 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/order_events.py
+-rw-r--r--   0        0        0     3845 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/orderbook_v2.py
+-rw-r--r--   0        0        0     2837 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/position_events.py
+-rw-r--r--   0        0        0    28986 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/schema.py
+-rw-r--r--   0        0        0     3004 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/schema_v2.py
+-rw-r--r--   0        0        0      910 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/serializer.pxd
+-rw-r--r--   0        0        0     6178 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/serializer.pyx
+-rw-r--r--   0        0        0     4625 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/util.py
+-rw-r--r--   0        0        0     1053 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/base.pxd
+-rw-r--r--   0        0        0    10114 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/base.pyx
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/msgpack/__init__.pxd
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/msgpack/__init__.py
+-rw-r--r--   0        0        0     1097 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/msgpack/serializer.pxd
+-rw-r--r--   0        0        0     3649 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/serialization/msgpack/serializer.pyx
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/system/__init__.py
+-rw-r--r--   0        0        0    27789 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/system/kernel.py
+-rw-r--r--   0        0        0     1035 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/test_kit/__init__.py
+-rw-r--r--   0        0        0     1746 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/test_kit/functions.py
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/test_kit/mocks/__init__.py
+-rw-r--r--   0        0        0     6160 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/test_kit/mocks/actors.py
+-rw-r--r--   0        0        0     5825 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/test_kit/mocks/cache_database.py
+-rw-r--r--   0        0        0     3992 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/test_kit/mocks/data.py
+-rw-r--r--   0        0        0     3077 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/test_kit/mocks/engines.py
+-rw-r--r--   0        0        0    12905 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/test_kit/mocks/exec_clients.py
+-rw-r--r--   0        0        0     6069 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/test_kit/mocks/strategies.py
+-rw-r--r--   0        0        0     3173 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/test_kit/performance.py
+-rw-r--r--   0        0        0    20761 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/test_kit/providers.py
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/__init__.py
+-rw-r--r--   0        0        0     4887 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/commands.py
+-rw-r--r--   0        0        0     6602 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/component.py
+-rw-r--r--   0        0        0     6386 2023-06-17 12:45:50.883004 nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/config.py
+-rw-r--r--   0        0        0    18470 2023-06-17 12:45:50.887004 nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/data.py
+-rw-r--r--   0        0        0    13987 2023-06-17 12:45:50.887004 nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/events.py
+-rw-r--r--   0        0        0     9540 2023-06-17 12:45:50.887004 nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/execution.py
+-rw-r--r--   0        0        0     3651 2023-06-17 12:45:50.887004 nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/identifiers.py
+-rw-r--r--   0        0        0     2970 2023-06-17 12:45:50.887004 nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/persistence.py
+-rw-r--r--   0        0        0      869 2023-06-17 12:45:50.887004 nautilus_trader-1.175.0/nautilus_trader/trading/__init__.pxd
+-rw-r--r--   0        0        0     1145 2023-06-17 12:45:50.887004 nautilus_trader-1.175.0/nautilus_trader/trading/__init__.py
+-rw-r--r--   0        0        0     2193 2023-06-17 12:45:50.887004 nautilus_trader-1.175.0/nautilus_trader/trading/filters.pxd
+-rw-r--r--   0        0        0    16984 2023-06-17 12:45:50.887004 nautilus_trader-1.175.0/nautilus_trader/trading/filters.pyx
+-rw-r--r--   0        0        0     6774 2023-06-17 12:45:50.887004 nautilus_trader-1.175.0/nautilus_trader/trading/strategy.pxd
+-rw-r--r--   0        0        0    53645 2023-06-17 12:45:50.887004 nautilus_trader-1.175.0/nautilus_trader/trading/strategy.pyx
+-rw-r--r--   0        0        0     3055 2023-06-17 12:45:50.887004 nautilus_trader-1.175.0/nautilus_trader/trading/trader.pxd
+-rw-r--r--   0        0        0    20230 2023-06-17 12:45:50.887004 nautilus_trader-1.175.0/nautilus_trader/trading/trader.pyx
+-rw-r--r--   0        0        0     7502 2023-06-17 12:45:50.887004 nautilus_trader-1.175.0/pyproject.toml
+-rw-r--r--   0        0        0    26388 1970-01-01 00:00:00.000000 nautilus_trader-1.175.0/PKG-INFO
```

### Comparing `nautilus_trader-1.174.0/LICENSE` & `nautilus_trader-1.175.0/LICENSE`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/README.md` & `nautilus_trader-1.175.0/README.md`

 * *Files 2% similar despite different names*

```diff
@@ -4,38 +4,38 @@
 [![codecov](https://codecov.io/gh/nautechsystems/nautilus_trader/branch/master/graph/badge.svg?token=DXO9QQI40H)](https://codecov.io/gh/nautechsystems/nautilus_trader)
 ![pythons](https://img.shields.io/pypi/pyversions/nautilus_trader)
 ![pypi-version](https://img.shields.io/pypi/v/nautilus_trader)
 ![pypi-format](https://img.shields.io/pypi/format/nautilus_trader?color=blue)
 [![Downloads](https://pepy.tech/badge/nautilus-trader)](https://pepy.tech/project/nautilus-trader)
 [![discord](https://img.shields.io/discord/924497682343550976?color=768AD4&label=discord)](https://discord.gg/AUWVs3XaCS)
 
-| Branch    | Version | Status |
-|:----------|:--------|:-------|
-| `master`  | ![version](https://img.shields.io/endpoint?url=https%3A%2F%2Fraw.githubusercontent.com%2Fnautechsystems%2Fnautilus_trader%2Fmaster%2Fversion.json) | [![build](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml/badge.svg?branch=master)](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml) |
+| Branch    | Version                                                                                                                                             | Status                                                                                                                                                                                            |
+| :-------- | :-------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
+| `master`  | ![version](https://img.shields.io/endpoint?url=https%3A%2F%2Fraw.githubusercontent.com%2Fnautechsystems%2Fnautilus_trader%2Fmaster%2Fversion.json)  | [![build](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml/badge.svg?branch=master)](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml)  |
 | `develop` | ![version](https://img.shields.io/endpoint?url=https%3A%2F%2Fraw.githubusercontent.com%2Fnautechsystems%2Fnautilus_trader%2Fdevelop%2Fversion.json) | [![build](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml/badge.svg?branch=develop)](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml) |
 
 | Platform           | Rust    | Python |
-|:-------------------|:--------|:-------|
-| `Linux (x86_64)`   | 1.69.0+ | 3.9+   |
-| `macOS (x86_64)`   | 1.69.0+ | 3.9+   |
-| `macOS (arm64)`    | 1.69.0+ | 3.9+   |
-| `Windows (x86_64)` | 1.69.0+ | 3.9+   |
+| :----------------- | :------ | :----- |
+| `Linux (x86_64)`   | 1.70.0+ | 3.9+   |
+| `macOS (x86_64)`   | 1.70.0+ | 3.9+   |
+| `macOS (arm64)`    | 1.70.0+ | 3.9+   |
+| `Windows (x86_64)` | 1.70.0+ | 3.9+   |
 
 - **Website:** https://nautilustrader.io
 - **Docs:** https://docs.nautilustrader.io
 - **Support:** [support@nautilustrader.io](mailto:support@nautilustrader.io)
 
 ## Introduction
 
 NautilusTrader is an open-source, high-performance, production-grade algorithmic trading platform,
 providing quantitative traders with the ability to backtest portfolios of automated trading strategies
 on historical data with an event-driven engine, and also deploy those same strategies live, with no code changes.
 
-The platform is 'AI-first', designed to develop and deploy algorithmic trading strategies within a highly performant 
-and robust Python native environment. This helps to address the parity challenge of keeping the Python research/backtest 
+The platform is 'AI-first', designed to develop and deploy algorithmic trading strategies within a highly performant
+and robust Python native environment. This helps to address the parity challenge of keeping the Python research/backtest
 environment, consistent with the production live trading environment.
 
 NautilusTraders design, architecture and implementation philosophy holds software correctness and safety at the
 highest level, with the aim of supporting Python native, mission-critical, trading system backtesting
 and live deployment workloads.
 
 The platform is also universal and asset class agnostic - with any REST, WebSocket or FIX API able to be integrated via modular
@@ -52,18 +52,19 @@
 - **Customizable** - Add user defined custom components, or assemble entire systems from scratch leveraging the cache and message bus
 - **Backtesting** - Run with multiple venues, instruments and strategies simultaneously using historical quote tick, trade tick, bar, order book and custom data with nanosecond resolution
 - **Live** - Use identical strategy implementations between backtesting and live deployments
 - **Multi-venue** - Multiple venue capabilities facilitate market making and statistical arbitrage strategies
 - **AI Agent Training** - Backtest engine fast enough to be used to train AI trading agents (RL/ES)
 
 ![Alt text](https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/_images/nautilus-art.png?raw=true "nautilus")
-> *nautilus - from ancient Greek 'sailor' and naus 'ship'.*
+
+> _nautilus - from ancient Greek 'sailor' and naus 'ship'._
 >
-> *The nautilus shell consists of modular chambers with a growth factor which approximates a logarithmic spiral.
-> The idea is that this can be translated to the aesthetics of design and architecture.*
+> _The nautilus shell consists of modular chambers with a growth factor which approximates a logarithmic spiral.
+> The idea is that this can be translated to the aesthetics of design and architecture._
 
 ## Why NautilusTrader?
 
 - **Highly performant event-driven Python** - native binary core components
 - **Parity between backtesting and live trading** - identical strategy code
 - **Reduced operational risk** - risk management functionality, logical correctness and type safety
 - **Highly extendable** - message bus, custom components and actors, custom data, custom adapters
@@ -71,15 +72,15 @@
 Traditionally, trading strategy research and backtesting might be conducted in Python (or other suitable language)
 using vectorized methods, with the strategy then needing to be reimplemented in a more event-drive way
 using C++, C#, Java or other statically typed language(s). The reasoning here is that vectorized backtesting code cannot
 express the granular time and event dependent complexity of real-time trading, where compiled languages have
 proven to be more suitable due to their inherently higher performance, and type safety.
 
 One of the key advantages of NautilusTrader here, is that this reimplementation step is now circumvented - as the critical core components of the platform
-have all been written entirely in Rust or Cython. This means we're using the right tools for the job, where systems programming languages compile performant binaries, 
+have all been written entirely in Rust or Cython. This means we're using the right tools for the job, where systems programming languages compile performant binaries,
 with CPython C extension modules then able to offer a Python native environment, suitable for professional quantitative traders and trading firms.
 
 ## Why Python?
 
 Python was originally created decades ago as a simple scripting language with a clean straight
 forward syntax. It has since evolved into a fully fledged general purpose object-oriented
 programming language. Based on the TIOBE index, Python is currently the most popular programming language in the world.
@@ -112,15 +113,16 @@
 
 The project increasingly utilizes Rust for core performance-critical components. Python language binding is handled through
 Cython, with static libraries linked at compile-time before the wheel binaries are packaged, so a user
 does not need to have Rust installed to run NautilusTrader. In the future as more Rust code is introduced,
 [PyO3](https://pyo3.rs/latest) will be leveraged for easier Python bindings.
 
 This project makes the [Soundness Pledge](https://raphlinus.github.io/rust/2020/01/18/soundness-pledge.html):
-> The intent of this project is to be free of soundness bugs. 
+
+> The intent of this project is to be free of soundness bugs.
 > The developers will do their best to avoid them, and welcome help in analyzing and fixing them.
 
 ## Architecture (data flow)
 
 ![Architecture](https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/_images/architecture-overview.png?raw=true "architecture")
 
 ## Quality Attributes
@@ -134,93 +136,98 @@
 
 ## Integrations
 
 NautilusTrader is designed in a modular way to work with 'adapters' which provide
 connectivity to data publishers and/or trading venues - converting their raw API
 into a unified interface. The following integrations are currently supported:
 
-| Name                                                    | ID        | Type                    | Status                                              | Docs                                                              |
-|:--------------------------------------------------------|:----------|:------------------------|:----------------------------------------------------|:------------------------------------------------------------------|
-[Betfair](https://betfair.com)                            | `BETFAIR` | Sports Betting Exchange | ![status](https://img.shields.io/badge/beta-yellow) | [Guide](https://docs.nautilustrader.io/integrations/betfair.html) |
-[Binance](https://binance.com)                            | `BINANCE` | Crypto Exchange (CEX)   | ![status](https://img.shields.io/badge/beta-yellow) | [Guide](https://docs.nautilustrader.io/integrations/binance.html) |
-[Binance US](https://binance.us)                          | `BINANCE` | Crypto Exchange (CEX)   | ![status](https://img.shields.io/badge/beta-yellow) | [Guide](https://docs.nautilustrader.io/integrations/binance.html) |
-[Binance Futures](https://www.binance.com/en/futures)     | `BINANCE` | Crypto Exchange (CEX)   | ![status](https://img.shields.io/badge/beta-yellow) | [Guide](https://docs.nautilustrader.io/integrations/binance.html) |
-[Interactive Brokers](https://www.interactivebrokers.com) | `IB`      | Brokerage (multi-venue) | ![status](https://img.shields.io/badge/beta-yellow) | [Guide](https://docs.nautilustrader.io/integrations/ib.html)      |
+| Name                                                      | ID        | Type                    | Status                                              | Docs                                                              |
+| :-------------------------------------------------------- | :-------- | :---------------------- | :-------------------------------------------------- | :---------------------------------------------------------------- |
+| [Betfair](https://betfair.com)                            | `BETFAIR` | Sports Betting Exchange | ![status](https://img.shields.io/badge/beta-yellow) | [Guide](https://docs.nautilustrader.io/integrations/betfair.html) |
+| [Binance](https://binance.com)                            | `BINANCE` | Crypto Exchange (CEX)   | ![status](https://img.shields.io/badge/beta-yellow) | [Guide](https://docs.nautilustrader.io/integrations/binance.html) |
+| [Binance US](https://binance.us)                          | `BINANCE` | Crypto Exchange (CEX)   | ![status](https://img.shields.io/badge/beta-yellow) | [Guide](https://docs.nautilustrader.io/integrations/binance.html) |
+| [Binance Futures](https://www.binance.com/en/futures)     | `BINANCE` | Crypto Exchange (CEX)   | ![status](https://img.shields.io/badge/beta-yellow) | [Guide](https://docs.nautilustrader.io/integrations/binance.html) |
+| [Interactive Brokers](https://www.interactivebrokers.com) | `IB`      | Brokerage (multi-venue) | ![status](https://img.shields.io/badge/beta-yellow) | [Guide](https://docs.nautilustrader.io/integrations/ib.html)      |
 
 Refer to the [Integrations](https://docs.nautilustrader.io/integrations/index.html) documentation for further details.
 
 ## Installation
 
 ### From PyPI
 
 We recommend running the platform with the latest stable version of Python, and in a virtual environment to isolate the dependencies.
 
 To install the latest binary wheel from PyPI:
 
     pip install -U nautilus_trader
 
 ### From Source
+
 Installation from source requires the `Python.h` header file, which is included in development releases such as `python-dev`.
 You'll also need the latest stable `rustc` and `cargo` to compile the Rust libraries.
 
 For MacBook Pro M1/M2, make sure your Python installed using pyenv is configured with `--enable-shared`:
 
     PYTHON_CONFIGURE_OPTS="--enable-shared" pyenv install <python_version>
 
 See https://pyo3.rs/latest/getting_started#virtualenvs.
 
 It's possible to install from source using `pip` if you first install the build dependencies
 as specified in the `pyproject.toml`. However, we highly recommend installing using [poetry](https://python-poetry.org/) as below.
 
 1. Install [rustup](https://rustup.rs/) (the Rust toolchain installer):
+
    - Linux and macOS:
-       ```
-       curl https://sh.rustup.rs -sSf | sh
-       ```
+     ```
+     curl https://sh.rustup.rs -sSf | sh
+     ```
    - Windows:
-       - Download and install [`rustup-init.exe`](https://win.rustup.rs/x86_64)
-       - Install "Desktop development with C++" with [Build Tools for Visual Studio 2019](https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?sku=BuildTools&rel=16)
+     - Download and install [`rustup-init.exe`](https://win.rustup.rs/x86_64)
+     - Install "Desktop development with C++" with [Build Tools for Visual Studio 2019](https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?sku=BuildTools&rel=16)
 
 2. Enable `cargo` in the current shell:
+
    - Linux and macOS:
-       ```
-       source $HOME/.cargo/env
-       ```
+     ```
+     source $HOME/.cargo/env
+     ```
    - Windows:
      - Start a new PowerShell
 
 3. Install poetry (or follow the installation guide on their site):
 
-       curl -sSL https://install.python-poetry.org | python3 -
+   curl -sSL https://install.python-poetry.org | python3 -
 
 4. Clone the source with `git`, and install from the projects root directory:
 
-       git clone https://github.com/nautechsystems/nautilus_trader
-       cd nautilus_trader
-       poetry install --only main --all-extras
+   git clone https://github.com/nautechsystems/nautilus_trader
+   cd nautilus_trader
+   poetry install --only main --all-extras
 
 Refer to the [Installation Guide](https://docs.nautilustrader.io/getting_started/installation.html) for other options and further details.
 
 ## Versioning and releases
 
 NautilusTrader is currently following a bi-weekly beta release schedule.
 The API is becoming more stable, however breaking changes are still possible between releases.
 Documentation of these changes in the release notes are made on a best-effort basis.
 
 ### Branches
+
 - `master` branch will always reflect the source code for the latest released version
-- `develop` branch is normally very active with frequent commits and may contain experimental features. We aim to maintain a stable 
-passing build on this branch
+- `develop` branch is normally very active with frequent commits and may contain experimental features. We aim to maintain a stable
+  passing build on this branch
 
 The current roadmap has a goal of achieving a stable API for a `2.x` version. From this
 point we will follow a formal process for releases, with deprecation periods for any API changes.
 
 ## Makefile
 
 A `Makefile` is provided to automate most installation and build tasks for development. It provides the following targets:
+
 - `make install` -- Installs in `release` build mode with `main`, `dev` and `test` dependencies then installs the package using poetry (default)
 - `make install-debug` -- Same as `make install` but with `debug` build mode
 - `make install-just-deps` -- Installs just the `main`, `dev` and `test` dependencies (does not install package)
 - `make install-just-deps-all` -- Same as `make install-just-deps` and additionally installs `docs` dependencies
 - `make build` -- Runs the Cython build script in `release` build mode (default)
 - `make build-debug` -- Runs the Cython build script in `debug` build mode
 - `make clean` -- **CAUTION** Cleans all non-source artifacts from the repository
@@ -230,38 +237,44 @@
 - `make pytest` -- Runs all tests with `pytest` (except performance tests)
 - `make pytest-coverage` -- Same as `make pytest` and additionally runs with test coverage and produces a report
 
 ## Examples
 
 Indicators and strategies can be developed in both Python and Cython (although if performance and latency sensitivity are import we recommend Cython).
 The below are some examples of this:
+
 - [indicator](/examples/indicators/ema_python.py) example written in Python
 - [indicator](/nautilus_trader/indicators/) examples written in Cython
 - [strategy](/nautilus_trader/examples/strategies/) examples written in both Python and Cython
 - [backtest](/examples/backtest/) examples using a `BacktestEngine` directly
 
 ## Docker
 
 Docker containers are built using a base `python:3.10-slim` with the following image variant tags:
+
 - `nautilus_trader:latest` has the latest release version installed
 - `nautilus_trader:develop` has the head of the `develop` branch installed
 - `jupyterlab:develop` has the head of the `develop` branch installed along with `jupyterlab` and an
-example backtest notebook with accompanying data
+  example backtest notebook with accompanying data
 
 The container images can be pulled as follows:
 
-    docker pull ghcr.io/nautechsystems/<image_variant_tag>
+    docker pull ghcr.io/nautechsystems/<image_variant_tag> --platform linux/amd64
 
 You can launch the backtest example container by running:
 
-    docker pull ghcr.io/nautechsystems/jupyterlab:develop
+    docker pull ghcr.io/nautechsystems/jupyterlab:develop --platform linux/amd64
     docker run -p 8888:8888 ghcr.io/nautechsystems/jupyterlab:develop
 
-| :warning: WARNING                                                               |
-|:--------------------------------------------------------------------------------|
+Then open your browser at the following address:
+
+    http://127.0.0.1:8888/lab
+
+| :warning: WARNING |
+| :---------------- |
 
 **NautilusTrader currently exceeds the rate limit for Jupyter notebook logging (stdout output),
 this is why `log_level` in the examples is set to "ERROR". If you lower this level to see more
 logging then the notebook will hang during cell execution. A fix is currently
 being investigated which involves either raising the configured rate limits for
 Jupyter, or throttling the log flushing from Nautilus.**
 https://github.com/jupyterlab/jupyterlab/issues/12845
@@ -371,44 +384,45 @@
 ## Development
 
 We aim to provide the most pleasant developer experience possible for this hybrid codebase of Python, Cython and Rust.
 Refer to the [Developer Guide](https://docs.nautilustrader.io/developer_guide/index.html) for helpful information.
 
 ## Contributing
 
-Thank you for considering contributing to Nautilus Trader! We welcome any and all help to improve 
-the project. If you have an idea for an enhancement or a bug fix, the first step is to open an [issue](https://github.com/nautechsystems/nautilus_trader/issues) 
-on GitHub to discuss it with the team. This helps to ensure that your contribution will be 
+Thank you for considering contributing to Nautilus Trader! We welcome any and all help to improve
+the project. If you have an idea for an enhancement or a bug fix, the first step is to open an [issue](https://github.com/nautechsystems/nautilus_trader/issues)
+on GitHub to discuss it with the team. This helps to ensure that your contribution will be
 well-aligned with the goals of the project and avoids duplication of effort.
 
-Once you're ready to start working on your contribution, make sure to follow the guidelines 
-outlined in the [CONTRIBUTING.md](https://github.com/nautechsystems/nautilus_trader/blob/develop/CONTRIBUTING.md) file. This includes signing a Contributor License Agreement (CLA) 
+Once you're ready to start working on your contribution, make sure to follow the guidelines
+outlined in the [CONTRIBUTING.md](https://github.com/nautechsystems/nautilus_trader/blob/develop/CONTRIBUTING.md) file. This includes signing a Contributor License Agreement (CLA)
 to ensure that your contributions can be included in the project.
 
-Note that all pull requests should be made to the `develop` branch. This is where new features 
+Note that all pull requests should be made to the `develop` branch. This is where new features
 and improvements are integrated before being released to the public.
 
 Thank you again for your interest in Nautilus Trader! We look forward to reviewing your contributions and working with you to improve the project.
 
 ## Community
-Join our community of users and contributors on [Discord](https://discord.gg/AUWVs3XaCS) to chat 
-and stay up-to-date with the latest announcements and features of NautilusTrader. Whether you're a 
+
+Join our community of users and contributors on [Discord](https://discord.gg/AUWVs3XaCS) to chat
+and stay up-to-date with the latest announcements and features of NautilusTrader. Whether you're a
 developer looking to contribute or just want to learn more about the platform, all are welcome on our server.
 
 ## License
 
 The source code for NautilusTrader is available on GitHub under the [GNU Lesser General Public License v3.0](https://www.gnu.org/licenses/lgpl-3.0.en.html).
 Contributions to the project are welcome and require the completion of a standard Contributor License Agreement (CLA).
 
 ---
 
-NautilusTrader is developed and maintained by Nautech Systems, a technology 
-company specializing in the development of high-performance trading systems. 
-Although the project utilizes the Rust programming language and benefits from its ecosystem, 
-Nautech Systems is not affiliated with the Rust Foundation, and this project is not an official 
+NautilusTrader is developed and maintained by Nautech Systems, a technology
+company specializing in the development of high-performance trading systems.
+Although the project utilizes the Rust programming language and benefits from its ecosystem,
+Nautech Systems is not affiliated with the Rust Foundation, and this project is not an official
 work of the Rust Foundation.
 For more information, visit https://nautilustrader.io.
 
 Copyright (C) 2015-2023 Nautech Systems Pty Ltd. All rights reserved.
 
 ![nautechsystems](https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/_images/ns-logo.png?raw=true "nautechsystems")
 <img src="https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/_images/ferris.png" width="128">
```

### Comparing `nautilus_trader-1.174.0/build.py` & `nautilus_trader-1.175.0/build.py`

 * *Files 3% similar despite different names*

```diff
@@ -154,18 +154,21 @@
         extra_compile_args.append("-Wno-parentheses-equality")
         if BUILD_MODE == "release":
             extra_compile_args.append("-O2")
             extra_compile_args.append("-pipe")
 
     if platform.system() == "Windows":
         extra_link_args += [
-            "WS2_32.Lib",
             "AdvAPI32.Lib",
-            "UserEnv.Lib",
             "bcrypt.lib",
+            "Kernel32.lib",
+            "ntdll.lib",
+            "User32.Lib",
+            "UserEnv.Lib",
+            "WS2_32.Lib",
         ]
 
     print("Creating C extension modules...")
     print(f"define_macros={define_macros}")
     print(f"extra_compile_args={extra_compile_args}")
 
     return [
@@ -241,35 +244,37 @@
             result.stdout.decode()
             .splitlines()[0]
             .lstrip("Apple ")
             .lstrip("Ubuntu ")
             .lstrip("clang version ")
         )
         return output
-    except subprocess.CalledProcessError as e:
+    except (subprocess.CalledProcessError, FileNotFoundError) as e:
+        err_msg = str(e) if isinstance(e, FileNotFoundError) else e.stderr.decode()
         raise RuntimeError(
             "You are installing from source which requires the Clang compiler to be installed.\n"
-            f"Error running clang: {e.stderr.decode()}",
+            f"Error running clang: {err_msg}",
         ) from e
 
 
 def _get_rustc_version() -> str:
     try:
         result = subprocess.run(
             ["rustc", "--version"],  # noqa
             check=True,
             capture_output=True,
         )
-        output = result.stdout.decode().lstrip("rustc ")[:-1]
+        output = result.stdout.decode().lstrip("rustc ").strip()
         return output
-    except subprocess.CalledProcessError as e:
+    except (subprocess.CalledProcessError, FileNotFoundError) as e:
+        err_msg = str(e) if isinstance(e, FileNotFoundError) else e.stderr.decode()
         raise RuntimeError(
             "You are installing from source which requires the Rust compiler to be installed.\n"
             "Find more information at https://www.rust-lang.org/tools/install\n"
-            f"Error running rustc: {e.stderr.decode()}",
+            f"Error running rustc: {err_msg}",
         ) from e
 
 
 def _strip_unneeded_symbols() -> None:
     try:
         print("Stripping unneeded symbols from binaries...")
         for so in itertools.chain(Path("nautilus_trader").rglob("*.so")):
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/.cargo/config.toml` & `nautilus_trader-1.175.0/nautilus_core/.cargo/config.toml`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_core/Cargo.lock` & `nautilus_trader-1.175.0/nautilus_core/Cargo.lock`

 * *Files 2% similar despite different names*

```diff
@@ -30,17 +30,17 @@
  "getrandom",
  "once_cell",
  "version_check",
 ]
 
 [[package]]
 name = "aho-corasick"
-version = "1.0.1"
+version = "1.0.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "67fc08ce920c31afb70f013dcce1bfc3a3195de6a228474e45e1f145b36f8d04"
+checksum = "43f6cb1bf222025340178f382c426f13757b2960e89779dfcb319c32542a5a41"
 dependencies = [
  "memchr",
 ]
 
 [[package]]
 name = "alloc-no-stdlib"
 version = "2.0.4"
@@ -53,14 +53,20 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "94fb8275041c72129eb51b7d0322c29b8387a0386127718b096429201a5d6ece"
 dependencies = [
  "alloc-no-stdlib",
 ]
 
 [[package]]
+name = "android-tzdata"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e999941b234f3131b00bc13c22d06e8c5ff726d1b6318ac7eb276997bbb4fef0"
+
+[[package]]
 name = "android_system_properties"
 version = "0.1.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
 dependencies = [
  "libc",
 ]
@@ -69,23 +75,23 @@
 name = "anes"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "4b46cbb362ab8752921c97e041f5e366ee6297bd428a31275b9fcf1e380f7299"
 
 [[package]]
 name = "arrayvec"
-version = "0.7.2"
+version = "0.7.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8da52d66c7071e2e3fa2a1e5c6d088fec47b593032b254f5e980de8ea54454d6"
+checksum = "8868f09ff8cea88b079da74ae569d9b8c62a23c68c746240b704ee6f7525c89c"
 
 [[package]]
 name = "arrow"
-version = "38.0.0"
+version = "40.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c107a57b5913d852da9d5a40e280e4695f2258b5b87733c13b770c63a7117287"
+checksum = "6619cab21a0cdd8c9b9f1d9e09bfaa9b1974e5ef809a6566aef0b998caf38ace"
 dependencies = [
  "ahash 0.8.3",
  "arrow-arith",
  "arrow-array",
  "arrow-buffer",
  "arrow-cast",
  "arrow-csv",
@@ -97,76 +103,76 @@
  "arrow-schema",
  "arrow-select",
  "arrow-string",
 ]
 
 [[package]]
 name = "arrow-arith"
-version = "38.0.0"
+version = "40.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ace6aa3d5617c5d03041a05e01c6819428a8ddf49dd0b055df9b40fef9d96094"
+checksum = "e0dc95485623a76e00929bda8caa40c1f838190952365c4f43a7b9ae86d03e94"
 dependencies = [
  "arrow-array",
  "arrow-buffer",
  "arrow-data",
  "arrow-schema",
  "chrono",
  "half 2.2.1",
  "num",
 ]
 
 [[package]]
 name = "arrow-array"
-version = "38.0.0"
+version = "40.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "104a04520692cc674e6afd7682f213ca41f9b13ff1873f63a5a2857a590b87b3"
+checksum = "3267847f53d3042473cfd2c769afd8d74a6d7d201fc3a34f5cb84c0282ef47a7"
 dependencies = [
  "ahash 0.8.3",
  "arrow-buffer",
  "arrow-data",
  "arrow-schema",
  "chrono",
  "chrono-tz",
  "half 2.2.1",
  "hashbrown 0.13.2",
  "num",
 ]
 
 [[package]]
 name = "arrow-buffer"
-version = "38.0.0"
+version = "40.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "72c875bcb9530ec403998fb0b2dc6d180a7c64563ca4bc22b90eafb84b113143"
+checksum = "c5f66553e66e120ac4b21570368ee9ebf35ff3f5399f872b0667699e145678f5"
 dependencies = [
  "half 2.2.1",
  "num",
 ]
 
 [[package]]
 name = "arrow-cast"
-version = "38.0.0"
+version = "40.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d6d6e18281636c8fc0b93be59834da6bf9a72bb70fd0c98ddfdaf124da466c28"
+checksum = "65e6f3579dbf0d97c683d451b2550062b0f0e62a3169bf74238b5f59f44ad6d8"
 dependencies = [
  "arrow-array",
  "arrow-buffer",
  "arrow-data",
  "arrow-schema",
  "arrow-select",
  "chrono",
  "comfy-table",
  "lexical-core",
  "num",
 ]
 
 [[package]]
 name = "arrow-csv"
-version = "38.0.0"
+version = "40.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3197dab0963a236ff8e7c82e2272535745955ac1321eb740c29f2f88b353f54e"
+checksum = "373579c4c1a8f5307d3125b7a89c700fcf8caf85821c77eb4baab3855ae0aba5"
 dependencies = [
  "arrow-array",
  "arrow-buffer",
  "arrow-cast",
  "arrow-data",
  "arrow-schema",
  "chrono",
@@ -175,43 +181,43 @@
  "lazy_static",
  "lexical-core",
  "regex",
 ]
 
 [[package]]
 name = "arrow-data"
-version = "38.0.0"
+version = "40.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "eb68113d6ecdbe8bba48b2c4042c151bf9e1c61244e45072a50250a6fc59bafe"
+checksum = "61bc8df9912cca6642665fdf989d6fa0de2570f18a7f709bcf59d29de96d2097"
 dependencies = [
  "arrow-buffer",
  "arrow-schema",
  "half 2.2.1",
  "num",
 ]
 
 [[package]]
 name = "arrow-ipc"
-version = "38.0.0"
+version = "40.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "eab4bbf2dd3078facb5ce0a9641316a64f42bfd8cf357e6775c8a5e6708e3a8d"
+checksum = "0105dcf5f91daa7182d87b713ee0b32b3bfc88e0c48e7dc3e9d6f1277a07d1ae"
 dependencies = [
  "arrow-array",
  "arrow-buffer",
  "arrow-cast",
  "arrow-data",
  "arrow-schema",
  "flatbuffers",
 ]
 
 [[package]]
 name = "arrow-json"
-version = "38.0.0"
+version = "40.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "48c5b650d23746a494665d914a7fa3d21d939153cff9d53bdebe39bffa88f263"
+checksum = "e73134fb5b5ec8770f8cbb214c2c487b2d350081e403ca4eeeb6f8f5e19846ac"
 dependencies = [
  "arrow-array",
  "arrow-buffer",
  "arrow-cast",
  "arrow-data",
  "arrow-schema",
  "chrono",
@@ -221,103 +227,103 @@
  "num",
  "serde",
  "serde_json",
 ]
 
 [[package]]
 name = "arrow-ord"
-version = "38.0.0"
+version = "40.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "68c6fce28e5011e30acc7466b5efcb8ed0197c396240bd2b10e167f275a3c208"
+checksum = "89f25bc66e18d4c2aa1fe2f9bb03e2269da60e636213210385ae41a107f9965a"
 dependencies = [
  "arrow-array",
  "arrow-buffer",
  "arrow-data",
  "arrow-schema",
  "arrow-select",
  "half 2.2.1",
  "num",
 ]
 
 [[package]]
 name = "arrow-row"
-version = "38.0.0"
+version = "40.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f20a421f19799d8b93eb8edde5217e910fa1e2d6ceb3c529f000e57b6db144c0"
+checksum = "1095ff85ea4f5ff02d17b30b089de31b51a50be01c6b674f0a0509ab771232f1"
 dependencies = [
  "ahash 0.8.3",
  "arrow-array",
  "arrow-buffer",
  "arrow-data",
  "arrow-schema",
  "half 2.2.1",
  "hashbrown 0.13.2",
 ]
 
 [[package]]
 name = "arrow-schema"
-version = "38.0.0"
+version = "40.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bc85923d8d6662cc66ac6602c7d1876872e671002d60993dfdf492a6badeae92"
+checksum = "25187bbef474151a2e4ddec67b9e34bda5cbfba292dc571392fa3a1f71ff5a82"
 
 [[package]]
 name = "arrow-select"
-version = "38.0.0"
+version = "40.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f6ab6613ce65b61d85a3410241744e84e48fbab0fe06e1251b4429d21b3470fd"
+checksum = "fd0d4ee884aec3aa05e41478e3cd312bf609de9babb5d187a43fb45931da4da4"
 dependencies = [
  "arrow-array",
  "arrow-buffer",
  "arrow-data",
  "arrow-schema",
  "num",
 ]
 
 [[package]]
 name = "arrow-string"
-version = "38.0.0"
+version = "40.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f3008641239e884aefba66d8b8532da6af40d14296349fcc85935de4ba67b89e"
+checksum = "d6d71c3ffe4c07e66ce8fdc6aed5b00e0e60c5144911879b10546f5b72d8fa1c"
 dependencies = [
  "arrow-array",
  "arrow-buffer",
  "arrow-data",
  "arrow-schema",
  "arrow-select",
  "regex",
- "regex-syntax 0.6.29",
+ "regex-syntax 0.7.2",
 ]
 
 [[package]]
 name = "async-compression"
-version = "0.3.15"
+version = "0.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "942c7cd7ae39e91bde4820d74132e9862e62c2f386c3aa90ccf55949f5bad63a"
+checksum = "5b0122885821398cc923ece939e24d1056a2384ee719432397fa9db87230ff11"
 dependencies = [
  "bzip2",
  "flate2",
  "futures-core",
  "futures-io",
  "memchr",
  "pin-project-lite",
  "tokio",
  "xz2",
- "zstd 0.11.2+zstd.1.5.2",
- "zstd-safe 5.0.2+zstd.1.5.2",
+ "zstd",
+ "zstd-safe",
 ]
 
 [[package]]
 name = "async-trait"
 version = "0.1.68"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "b9ccdd8f2a161be9bd5c023df56f1b2a0bd1d83872ae53b71a84a12c9bf6e842"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.16",
+ "syn 2.0.18",
 ]
 
 [[package]]
 name = "atty"
 version = "0.2.14"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "d9b39be18770d11421cdb1b9947a45dd3f37e93092cbf377614828a319d5fee8"
@@ -331,17 +337,17 @@
 name = "autocfg"
 version = "1.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa"
 
 [[package]]
 name = "base64"
-version = "0.21.0"
+version = "0.21.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a4a4ddaa51a5bc52a6948f74c06d20aaaddb71924eab79b8c97a8c556e942d6a"
+checksum = "604178f6c5c21f02dc555784810edfb88d34ac2c73b2eae109655649ee73ce3d"
 
 [[package]]
 name = "binary-heap-plus"
 version = "0.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e4551d8382e911ecc0d0f0ffb602777988669be09447d536ff4388d1def11296"
 dependencies = [
@@ -363,14 +369,23 @@
  "funty",
  "radium",
  "tap",
  "wyz",
 ]
 
 [[package]]
+name = "block-buffer"
+version = "0.10.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
+dependencies = [
+ "generic-array",
+]
+
+[[package]]
 name = "borsh"
 version = "0.10.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "4114279215a005bc675e386011e594e1d9b800918cea18fcadadcce864a2046b"
 dependencies = [
  "borsh-derive",
  "hashbrown 0.13.2",
@@ -430,17 +445,17 @@
 dependencies = [
  "alloc-no-stdlib",
  "alloc-stdlib",
 ]
 
 [[package]]
 name = "bumpalo"
-version = "3.12.2"
+version = "3.13.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3c6ed94e98ecff0c12dd1b04c15ec0d7d9458ca8fe806cea6f12954efe74c63b"
+checksum = "a3e2c3daef883ecc1b5d58c15adae93470a91d425f3532ba1695849656af3fc1"
 
 [[package]]
 name = "bytecheck"
 version = "0.6.11"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "8b6372023ac861f6e6dc89c8344a8f398fb42aaba2b5dbc649ca0c0e9dbcb627"
 dependencies = [
@@ -457,14 +472,20 @@
 dependencies = [
  "proc-macro2",
  "quote",
  "syn 1.0.109",
 ]
 
 [[package]]
+name = "bytecount"
+version = "0.6.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2c676a478f63e9fa2dd5368a42f28bba0d6c560b775f38583c8bbaa7fcd67c9c"
+
+[[package]]
 name = "byteorder"
 version = "1.4.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "14c189c53d098945499cdfa7ecc63567cf3886b3332b312a5b4585d8d3a6a610"
 
 [[package]]
 name = "bytes"
@@ -497,17 +518,17 @@
 name = "cast"
 version = "0.3.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "37b2a672a2cb129a2e41c10b1224bb368f9f37a2b16b612598138befd7b37eb5"
 
 [[package]]
 name = "cbindgen"
-version = "0.24.3"
+version = "0.24.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a6358dedf60f4d9b8db43ad187391afe959746101346fe51bb978126bec61dfb"
+checksum = "4b922faaf31122819ec80c4047cc684c6979a087366c069611e33649bf98e18d"
 dependencies = [
  "clap",
  "heck",
  "indexmap",
  "log",
  "proc-macro2",
  "quote",
@@ -531,21 +552,21 @@
 name = "cfg-if"
 version = "1.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
 name = "chrono"
-version = "0.4.24"
+version = "0.4.26"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4e3c5919066adf22df73762e50cffcde3a758f2a848b113b586d1f86728b673b"
+checksum = "ec837a71355b28f6556dbd569b37b3f363091c0bd4b2e735674521b4c5fd9bc5"
 dependencies = [
+ "android-tzdata",
  "iana-time-zone",
  "js-sys",
- "num-integer",
  "num-traits",
  "time",
  "wasm-bindgen",
  "winapi",
 ]
 
 [[package]]
@@ -619,17 +640,17 @@
 checksum = "2850f2f5a82cbf437dd5af4d49848fbdfc27c157c3d010345776f952765261c5"
 dependencies = [
  "os_str_bytes",
 ]
 
 [[package]]
 name = "comfy-table"
-version = "6.1.4"
+version = "6.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6e7b787b0dc42e8111badfdbe4c3059158ccb2db8780352fa1b01e8ccf45cc4d"
+checksum = "7e959d788268e3bf9d35ace83e81b124190378e4c91c9067524675e33394b8ba"
 dependencies = [
  "strum",
  "strum_macros",
  "unicode-width",
 ]
 
 [[package]]
@@ -673,14 +694,23 @@
 [[package]]
 name = "core-foundation-sys"
 version = "0.8.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e496a50fda8aacccc86d7529e2c1e0892dbd0f898a6b5645b5561b89c3210efa"
 
 [[package]]
+name = "cpufeatures"
+version = "0.2.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "03e69e28e9f7f77debdedbaafa2866e1de9ba56df55a8bd7cfc724c25a09987c"
+dependencies = [
+ "libc",
+]
+
+[[package]]
 name = "crc32fast"
 version = "1.3.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "b540bd8bc810d3885c6ea91e2018302f68baba2129ab3e88f32389ee9370880d"
 dependencies = [
  "cfg-if",
 ]
@@ -740,45 +770,55 @@
  "cfg-if",
  "crossbeam-epoch",
  "crossbeam-utils",
 ]
 
 [[package]]
 name = "crossbeam-epoch"
-version = "0.9.14"
+version = "0.9.15"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "46bd5f3f85273295a9d14aedfb86f6aadbff6d8f5295c4a9edb08e819dcf5695"
+checksum = "ae211234986c545741a7dc064309f67ee1e5ad243d0e48335adc0484d960bcc7"
 dependencies = [
  "autocfg",
  "cfg-if",
  "crossbeam-utils",
- "memoffset",
+ "memoffset 0.9.0",
  "scopeguard",
 ]
 
 [[package]]
 name = "crossbeam-utils"
-version = "0.8.15"
+version = "0.8.16"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3c063cd8cc95f5c377ed0d4b49a4b21f632396ff690e8470c29b3359b346984b"
+checksum = "5a22b2d63d4d1dc0b7f1b6b2747dd0088008a9be28b6ddf0b1e7d335e3037294"
 dependencies = [
  "cfg-if",
 ]
 
 [[package]]
 name = "crunchy"
 version = "0.2.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "7a81dae078cea95a014a339291cec439d2f232ebe854a9d672b796c6afafa9b7"
 
 [[package]]
+name = "crypto-common"
+version = "0.1.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3"
+dependencies = [
+ "generic-array",
+ "typenum",
+]
+
+[[package]]
 name = "csv"
-version = "1.2.1"
+version = "1.2.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0b015497079b9a9d69c02ad25de6c0a6edef051ea6360a327d0bd05802ef64ad"
+checksum = "626ae34994d3d8d668f4269922248239db4ae42d538b14c398b74a52208e8086"
 dependencies = [
  "csv-core",
  "itoa",
  "ryu",
  "serde",
 ]
 
@@ -836,18 +876,24 @@
  "hashbrown 0.12.3",
  "lock_api",
  "once_cell",
  "parking_lot_core",
 ]
 
 [[package]]
+name = "data-encoding"
+version = "2.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c2e66c9d817f1720209181c316d28635c050fa304f9c79e47a520882661b7308"
+
+[[package]]
 name = "datafusion"
-version = "24.0.0"
+version = "26.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0404a559d5a6d8320369bb0a290b43bbc4f8622d0ef6f04bd095ace9a663f439"
+checksum = "9992c267436551d40b52d65289b144712e7b0ebdc62c8c859fd1574e5f73efbb"
 dependencies = [
  "ahash 0.8.3",
  "arrow",
  "arrow-array",
  "arrow-schema",
  "async-compression",
  "async-trait",
@@ -882,37 +928,37 @@
  "tempfile",
  "tokio",
  "tokio-stream",
  "tokio-util",
  "url",
  "uuid",
  "xz2",
- "zstd 0.12.3+zstd.1.5.2",
+ "zstd",
 ]
 
 [[package]]
 name = "datafusion-common"
-version = "24.0.0"
+version = "26.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4653b79a55161852973760db69ea6dcd05c9966a1b588fd83028f625536a1d7f"
+checksum = "c3be97f7a7c720cdbb71e9eeabf814fa6ad8102b9022390f6cac74d3b4af6392"
 dependencies = [
  "arrow",
  "arrow-array",
  "chrono",
  "num_cpus",
  "object_store",
  "parquet",
  "sqlparser",
 ]
 
 [[package]]
 name = "datafusion-execution"
-version = "24.0.0"
+version = "26.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "53481c334b73c6759697919d1d05690392381145fa1890849a65b5a71a24a1ec"
+checksum = "c77c4b14b809b0e4c5bb101b6834504f06cdbb0d3c643400c61d0d844b33264e"
 dependencies = [
  "dashmap",
  "datafusion-common",
  "datafusion-expr",
  "hashbrown 0.13.2",
  "log",
  "object_store",
@@ -920,47 +966,50 @@
  "rand",
  "tempfile",
  "url",
 ]
 
 [[package]]
 name = "datafusion-expr"
-version = "24.0.0"
+version = "26.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a8ecd7c6605d0b4269346d03289e2ced1715a303e75e6d313dba0bafb1f823f2"
+checksum = "e6ec7409bd45cf4fae6395d7d1024c8a97e543cadc88363e405d2aad5330e5e7"
 dependencies = [
  "ahash 0.8.3",
  "arrow",
  "datafusion-common",
+ "lazy_static",
  "sqlparser",
+ "strum",
+ "strum_macros",
 ]
 
 [[package]]
 name = "datafusion-optimizer"
-version = "24.0.0"
+version = "26.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "70a7c04e94cb4aa9c323993856e18b91f690dda0358a34ab07a3fe0f14bc6600"
+checksum = "64b537c93f87989c212db92a448a0f5eb4f0995e27199bb7687ae94f8b64a7a8"
 dependencies = [
  "arrow",
  "async-trait",
  "chrono",
  "datafusion-common",
  "datafusion-expr",
  "datafusion-physical-expr",
  "hashbrown 0.13.2",
  "itertools",
  "log",
- "regex-syntax 0.7.1",
+ "regex-syntax 0.7.2",
 ]
 
 [[package]]
 name = "datafusion-physical-expr"
-version = "24.0.0"
+version = "26.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9e34eb8668fee1443965fff41ba73b2956d50a07ed8dd929cfa2e839ab91da5a"
+checksum = "f60ee3f53340fdef36ee54d9e12d446ae2718b1d0196ac581f791d34808ec876"
 dependencies = [
  "ahash 0.8.3",
  "arrow",
  "arrow-array",
  "arrow-buffer",
  "arrow-schema",
  "chrono",
@@ -979,29 +1028,29 @@
  "regex",
  "unicode-segmentation",
  "uuid",
 ]
 
 [[package]]
 name = "datafusion-row"
-version = "24.0.0"
+version = "26.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "efa800ae88dfd62ea6c58c24a1154d92937c755672f522b84e8ea6539fad369b"
+checksum = "d58fc64058aa3bcb00077a0d19474a0d584d31dec8c7ac3406868f485f659af9"
 dependencies = [
  "arrow",
  "datafusion-common",
  "paste",
  "rand",
 ]
 
 [[package]]
 name = "datafusion-sql"
-version = "24.0.0"
+version = "26.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "556642ef90073e39af721362353ccce4e1f418da7a8e31c23510ed9de6eb71f2"
+checksum = "1531f0314151a34bf6c0a83c7261525688b7c729876f53e7896b8f4ca8f57d07"
 dependencies = [
  "arrow",
  "arrow-schema",
  "datafusion-common",
  "datafusion-expr",
  "log",
  "sqlparser",
@@ -1035,26 +1084,49 @@
 checksum = "ebcda35c7a396850a55ffeac740804b40ffec779b98fffbb1738f4033f0ee79e"
 dependencies = [
  "derive_builder_core",
  "syn 1.0.109",
 ]
 
 [[package]]
+name = "digest"
+version = "0.10.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
+dependencies = [
+ "block-buffer",
+ "crypto-common",
+]
+
+[[package]]
 name = "doc-comment"
 version = "0.3.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "fea41bba32d969b513997752735605054bc0dfa92b4c56bf1189f2e174be7a10"
 
 [[package]]
 name = "either"
 version = "1.8.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "7fcaabb2fef8c910e7f4c7ce9f67a1283a1715879a7c230ca9d6d1ae31f16d91"
 
 [[package]]
+name = "env_logger"
+version = "0.10.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "85cdab6a89accf66733ad5a1693a4dcced6aeff64602b634530dd73c1f3ee9f0"
+dependencies = [
+ "humantime",
+ "is-terminal",
+ "log",
+ "regex",
+ "termcolor",
+]
+
+[[package]]
 name = "errno"
 version = "0.3.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "4bcfec3a70f97c962c307b2d2c56e358cf1d00b558d74262b5f929ee8cc7e73a"
 dependencies = [
  "errno-dragonfly",
  "libc",
@@ -1068,14 +1140,20 @@
 checksum = "aa68f1b12764fab894d2755d2518754e71b4fd80ecfb822714a1206c2aab39bf"
 dependencies = [
  "cc",
  "libc",
 ]
 
 [[package]]
+name = "evalexpr"
+version = "11.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ec3b4e80fd8edee77d6fc35d59862d5765dae7512a95f49fd7bf03847c85b26a"
+
+[[package]]
 name = "fastrand"
 version = "1.9.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e51093e27b0797c359783294ca4f0a911c270184cb10f85783b118614a1501be"
 dependencies = [
  "instant",
 ]
@@ -1084,17 +1162,17 @@
 name = "fixedbitset"
 version = "0.4.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "0ce7134b9999ecaf8bcd65542e436736ef32ddca1b3e06094cb6ec5755203b80"
 
 [[package]]
 name = "flatbuffers"
-version = "23.1.21"
+version = "23.5.26"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "77f5399c2c9c50ae9418e522842ad362f61ee48b346ac106807bd355a8a7c619"
+checksum = "4dac53e22462d78c16d64a1cd22371b54cc3fe94aa15e7886a2fa6e5d1ab8640"
 dependencies = [
  "bitflags",
  "rustc_version",
 ]
 
 [[package]]
 name = "flate2"
@@ -1125,17 +1203,17 @@
 name = "foreign-types-shared"
 version = "0.1.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "00b0228411908ca8685dba7fc2cdd70ec9990a6e753e89b6ac91a84c40fbaf4b"
 
 [[package]]
 name = "form_urlencoded"
-version = "1.1.0"
+version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a9c384f161156f5260c24a097c56119f9be8c798586aecc13afbcbe7b7e26bf8"
+checksum = "a62bc1cf6f830c2ec14a513a9fb124d0a213a629668a4186f329db21fe045652"
 dependencies = [
  "percent-encoding",
 ]
 
 [[package]]
 name = "funty"
 version = "2.0.0"
@@ -1194,15 +1272,15 @@
 name = "futures-macro"
 version = "0.3.28"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "89ca545a94061b6365f2c7355b4b32bd20df3ff95f02da9329b34ccc3bd6ee72"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.16",
+ "syn 2.0.18",
 ]
 
 [[package]]
 name = "futures-sink"
 version = "0.3.28"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "f43be4fe21a13b9781a69afa4985b0f6ee0e1afab2c6f454a8cf30e2b2237b6e"
@@ -1234,18 +1312,28 @@
  "memchr",
  "pin-project-lite",
  "pin-utils",
  "slab",
 ]
 
 [[package]]
+name = "generic-array"
+version = "0.14.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
+dependencies = [
+ "typenum",
+ "version_check",
+]
+
+[[package]]
 name = "getrandom"
-version = "0.2.9"
+version = "0.2.10"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c85e1d9ab2eadba7e5040d4e09cbd6d072b76a557ad64e797c2cb9d4da21d7e4"
+checksum = "be4136b2a15dd319360be1c07d9933517ccf0be8f16bf62a3bee4f0d618df427"
 dependencies = [
  "cfg-if",
  "libc",
  "wasi 0.11.0+wasi-snapshot-preview1",
 ]
 
 [[package]]
@@ -1349,14 +1437,20 @@
 [[package]]
 name = "httpdate"
 version = "1.0.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "c4a1e36c821dbe04574f602848a19f742f4fb3c98d40449f11bcad18d6b17421"
 
 [[package]]
+name = "humantime"
+version = "2.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9a3a5bfb195931eeb336b2a7b4d761daec841b97f947d34394601737a7bba5e4"
+
+[[package]]
 name = "hyper"
 version = "0.14.26"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "ab302d72a6f11a3b910431ff93aae7e773078c769f0a3ef15fb9ec692ed147d4"
 dependencies = [
  "bytes",
  "futures-channel",
@@ -1392,17 +1486,17 @@
 name = "iai"
 version = "0.1.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "71a816c97c42258aa5834d07590b718b4c9a598944cd39a52dc25b351185d678"
 
 [[package]]
 name = "iana-time-zone"
-version = "0.1.56"
+version = "0.1.57"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0722cd7114b7de04316e7ea5456a0bbb20e4adb46fd27a3697adb812cff0f37c"
+checksum = "2fad5b825842d2b38bd206f3e81d6957625fd7f0a361e345c30e01a0ae2dd613"
 dependencies = [
  "android_system_properties",
  "core-foundation-sys",
  "iana-time-zone-haiku",
  "js-sys",
  "wasm-bindgen",
  "windows",
@@ -1421,17 +1515,17 @@
 name = "ident_case"
 version = "1.0.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "b9e0384b61958566e926dc50660321d12159025e767c18e043daf26b70104c39"
 
 [[package]]
 name = "idna"
-version = "0.3.0"
+version = "0.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e14ddfc70884202db2244c223200c204c2bda1bc6e0998d11b5e024d657209e6"
+checksum = "7d20d6b07bfbc108882d88ed8e37d39636dcc260e15e30c45e6ba089610b917c"
 dependencies = [
  "unicode-bidi",
  "unicode-normalization",
 ]
 
 [[package]]
 name = "indexmap"
@@ -1462,24 +1556,36 @@
 name = "integer-encoding"
 version = "3.0.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "8bb03732005da905c88227371639bf1ad885cc712789c011c31c5fb3ab3ccf02"
 
 [[package]]
 name = "io-lifetimes"
-version = "1.0.10"
+version = "1.0.11"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9c66c74d2ae7e79a5a8f7ac924adbe38ee42a859c6539ad869eb51f0b52dc220"
+checksum = "eae7b9aee968036d54dce06cebaefd919e4472e753296daccd6d344e3e2df0c2"
 dependencies = [
  "hermit-abi 0.3.1",
  "libc",
  "windows-sys 0.48.0",
 ]
 
 [[package]]
+name = "is-terminal"
+version = "0.4.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "adcf93614601c8129ddf72e2d5633df827ba6551541c6d8c59520a371475be1f"
+dependencies = [
+ "hermit-abi 0.3.1",
+ "io-lifetimes",
+ "rustix",
+ "windows-sys 0.48.0",
+]
+
+[[package]]
 name = "itertools"
 version = "0.10.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "b0fd2260e829bddf4cb6ea802289de2f86d6a7a690192fbe91b3f46e0f2c8473"
 dependencies = [
  "either",
 ]
@@ -1497,17 +1603,17 @@
 checksum = "936cfd212a0155903bcbc060e316fb6cc7cbf2e1907329391ebadc1fe0ce77c2"
 dependencies = [
  "libc",
 ]
 
 [[package]]
 name = "js-sys"
-version = "0.3.63"
+version = "0.3.64"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2f37a4a5928311ac501dee68b3c7613a1037d0edb30c8e5427bd832d55d1b790"
+checksum = "c5f195fe497f702db0f318b07fdd68edb16955aed830df8363d837542f8f935a"
 dependencies = [
  "wasm-bindgen",
 ]
 
 [[package]]
 name = "lazy_static"
 version = "1.4.0"
@@ -1576,48 +1682,45 @@
 dependencies = [
  "lexical-util",
  "static_assertions",
 ]
 
 [[package]]
 name = "libc"
-version = "0.2.144"
+version = "0.2.146"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2b00cc1c228a6782d0f076e7b232802e0c5689d41bb5df366f2a6b6621cfdfe1"
+checksum = "f92be4933c13fd498862a9e02a3055f8a8d9c039ce33db97306fd5a6caa7f29b"
 
 [[package]]
 name = "libm"
 version = "0.2.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "f7012b1bbb0719e1097c47611d3898568c546d597c2e74d66f6087edd5233ff4"
 
 [[package]]
 name = "linux-raw-sys"
-version = "0.3.7"
+version = "0.3.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ece97ea872ece730aed82664c424eb4c8291e1ff2480247ccf7409044bc6479f"
+checksum = "ef53942eb7bf7ff43a617b3e2c1c4a5ecf5944a7c1bc12d7ee39bbb15e5c1519"
 
 [[package]]
 name = "lock_api"
-version = "0.4.9"
+version = "0.4.10"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "435011366fe56583b16cf956f9df0095b405b82d76425bc8981c0e22e60ec4df"
+checksum = "c1cc9717a20b1bb222f333e6a92fd32f7d8a18ddc5a3191a11af45dcbf4dcd16"
 dependencies = [
  "autocfg",
  "scopeguard",
 ]
 
 [[package]]
 name = "log"
-version = "0.4.17"
+version = "0.4.19"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "abb12e687cfb44aa40f41fc3978ef76448f9b6038cad6aef4259d3c095a2382e"
-dependencies = [
- "cfg-if",
-]
+checksum = "b06a4cde4c0f271a446782e3eff8de789548ce57dbc8eca9292c27f4a42004b4"
 
 [[package]]
 name = "lz4"
 version = "1.24.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "7e9e2dd86df36ce760a60f6ff6ad526f7ba1f14ba0356f8254fb6905e6494df1"
 dependencies = [
@@ -1643,14 +1746,23 @@
 dependencies = [
  "cc",
  "libc",
  "pkg-config",
 ]
 
 [[package]]
+name = "matchers"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8263075bb86c5a1b1427b5ae862e8889656f126e9f77c484496e8b47cf5c5558"
+dependencies = [
+ "regex-automata",
+]
+
+[[package]]
 name = "memchr"
 version = "2.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "2dffe52ecf27772e601905b7522cb4ef790d2cc203488bbd0e2fe85fcb74566d"
 
 [[package]]
 name = "memoffset"
@@ -1658,32 +1770,40 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "d61c719bcfbcf5d62b3a09efa6088de8c54bc0bfcd3ea7ae39fcc186108b8de1"
 dependencies = [
  "autocfg",
 ]
 
 [[package]]
+name = "memoffset"
+version = "0.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5a634b1c61a95585bd15607c6ab0c4e5b226e695ff2800ba0cdccddf208c406c"
+dependencies = [
+ "autocfg",
+]
+
+[[package]]
 name = "miniz_oxide"
 version = "0.7.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e7810e0be55b428ada41041c41f32c9f1a42817901b4ccf45fa3d4b6561e74c7"
 dependencies = [
  "adler",
 ]
 
 [[package]]
 name = "mio"
-version = "0.8.6"
+version = "0.8.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5b9d9a46eff5b4ff64b45a9e316a6d1e0bc719ef429cbec4dc630684212bfdf9"
+checksum = "927a765cd3fc26206e66b296465fa9d3e5ab003e651c1b3c060e7956d96b19d2"
 dependencies = [
  "libc",
- "log",
  "wasi 0.11.0+wasi-snapshot-preview1",
- "windows-sys 0.45.0",
+ "windows-sys 0.48.0",
 ]
 
 [[package]]
 name = "native-tls"
 version = "0.2.11"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "07226173c32f2926027b63cce4bcd8076c3552846cbe7925f3aaffeac0a3b92e"
@@ -1697,123 +1817,145 @@
  "schannel",
  "security-framework",
  "security-framework-sys",
  "tempfile",
 ]
 
 [[package]]
-name = "nautilus_backtest"
-version = "0.5.0"
+name = "nautilus-backtest"
+version = "0.6.0"
 dependencies = [
  "cbindgen",
- "nautilus_common",
- "nautilus_core",
- "nautilus_model",
+ "nautilus-common",
+ "nautilus-core",
+ "nautilus-model",
  "pyo3",
  "tempfile",
 ]
 
 [[package]]
-name = "nautilus_common"
-version = "0.5.0"
+name = "nautilus-common"
+version = "0.6.0"
 dependencies = [
  "cbindgen",
  "chrono",
- "nautilus_core",
- "nautilus_model",
+ "nautilus-core",
+ "nautilus-model",
  "pyo3",
  "serde",
  "serde_json",
  "strum",
  "tempfile",
 ]
 
 [[package]]
-name = "nautilus_core"
-version = "0.5.0"
+name = "nautilus-core"
+version = "0.6.0"
 dependencies = [
  "cbindgen",
  "chrono",
  "criterion",
  "iai",
  "pyo3",
  "rstest",
+ "serde",
  "serde_json",
  "uuid",
 ]
 
 [[package]]
-name = "nautilus_indicators"
-version = "0.5.0"
+name = "nautilus-indicators"
+version = "0.6.0"
 dependencies = [
- "nautilus_core",
- "nautilus_model",
+ "nautilus-core",
+ "nautilus-model",
  "pyo3",
 ]
 
 [[package]]
-name = "nautilus_model"
-version = "0.5.0"
+name = "nautilus-model"
+version = "0.6.0"
 dependencies = [
  "cbindgen",
  "criterion",
  "derive_builder",
+ "evalexpr",
  "iai",
  "lazy_static",
- "nautilus_core",
+ "nautilus-core",
  "pyo3",
+ "rmp-serde",
  "rstest",
  "rust_decimal",
+ "serde",
+ "serde_json",
  "strum",
+ "tabled",
  "thiserror",
 ]
 
 [[package]]
-name = "nautilus_network"
-version = "0.5.0"
+name = "nautilus-network"
+version = "0.6.0"
 dependencies = [
+ "criterion",
+ "futures",
+ "futures-util",
  "hyper",
  "hyper-tls",
- "nautilus_core",
+ "nautilus-core",
  "pyo3",
  "pyo3-asyncio",
  "serde_json",
  "tokio",
+ "tokio-tungstenite",
+ "tracing",
+ "tracing-test",
 ]
 
 [[package]]
-name = "nautilus_persistence"
-version = "0.5.0"
+name = "nautilus-persistence"
+version = "0.6.0"
 dependencies = [
  "binary-heap-plus",
  "compare",
  "criterion",
  "datafusion",
  "futures",
- "nautilus_core",
- "nautilus_model",
+ "nautilus-core",
+ "nautilus-model",
  "pin-project-lite",
  "pyo3",
  "pyo3-asyncio",
  "rand",
  "tokio",
 ]
 
 [[package]]
-name = "nautilus_pyo3"
-version = "0.5.0"
+name = "nautilus-pyo3"
+version = "0.6.0"
 dependencies = [
- "nautilus_indicators",
- "nautilus_model",
- "nautilus_network",
- "nautilus_persistence",
+ "nautilus-indicators",
+ "nautilus-model",
+ "nautilus-network",
+ "nautilus-persistence",
  "pyo3",
 ]
 
 [[package]]
+name = "nu-ansi-term"
+version = "0.46.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "77a8165726e8236064dbb45459242600304b42a5ea24ee2948e18e023bf7ba84"
+dependencies = [
+ "overload",
+ "winapi",
+]
+
+[[package]]
 name = "num"
 version = "0.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "43db66d1170d347f9a065114077f7dccb00c1b9478c89384490a3425279a4606"
 dependencies = [
  "num-bigint",
  "num-complex",
@@ -1914,29 +2056,29 @@
  "tracing",
  "url",
  "walkdir",
 ]
 
 [[package]]
 name = "once_cell"
-version = "1.17.1"
+version = "1.18.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b7e5500299e16ebb147ae15a00a942af264cf3688f47923b8fc2cd5858f23ad3"
+checksum = "dd8b5dd2ae5ed71462c540258bedcb51965123ad7e7ccf4b9a8cafaa4a63576d"
 
 [[package]]
 name = "oorandom"
 version = "11.1.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "0ab1bc2a289d34bd04a330323ac98a1b4bc82c9d9fcb1e66b63caa84da26b575"
 
 [[package]]
 name = "openssl"
-version = "0.10.52"
+version = "0.10.54"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "01b8574602df80f7b85fdfc5392fa884a4e3b3f4f35402c070ab34c3d3f78d56"
+checksum = "69b3f656a17a6cbc115b5c7a40c616947d213ba182135b014d6051b73ab6f019"
 dependencies = [
  "bitflags",
  "cfg-if",
  "foreign-types",
  "libc",
  "once_cell",
  "openssl-macros",
@@ -1947,31 +2089,41 @@
 name = "openssl-macros"
 version = "0.1.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a948666b637a0f465e8564c73e89d4dde00d72d4d473cc972f390fc3dcee7d9c"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.16",
+ "syn 2.0.18",
 ]
 
 [[package]]
 name = "openssl-probe"
 version = "0.1.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "ff011a302c396a5197692431fc1948019154afc178baf7d8e37367442a4601cf"
 
 [[package]]
+name = "openssl-src"
+version = "111.26.0+1.1.1u"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "efc62c9f12b22b8f5208c23a7200a442b2e5999f8bdf80233852122b5a4f6f37"
+dependencies = [
+ "cc",
+]
+
+[[package]]
 name = "openssl-sys"
-version = "0.9.87"
+version = "0.9.88"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8e17f59264b2809d77ae94f0e1ebabc434773f370d6ca667bd223ea10e06cc7e"
+checksum = "c2ce0f250f34a308dcfdbb351f511359857d4ed2134ba715a4eadd46e1ffd617"
 dependencies = [
  "cc",
  "libc",
+ "openssl-src",
  "pkg-config",
  "vcpkg",
 ]
 
 [[package]]
 name = "ordered-float"
 version = "2.10.0"
@@ -1979,46 +2131,63 @@
 checksum = "7940cf2ca942593318d07fcf2596cdca60a85c9e7fab408a5e21a4f9dcd40d87"
 dependencies = [
  "num-traits",
 ]
 
 [[package]]
 name = "os_str_bytes"
-version = "6.5.0"
+version = "6.5.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ceedf44fb00f2d1984b0bc98102627ce622e083e49a5bacdb3e514fa4238e267"
+checksum = "4d5d9eb14b174ee9aa2ef96dc2b94637a2d4b6e7cb873c7e171f0c20c6cf3eac"
+
+[[package]]
+name = "overload"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b15813163c1d831bf4a13c3610c05c0d03b39feb07f7e09fa234dac9b15aaf39"
+
+[[package]]
+name = "papergrid"
+version = "0.9.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ae7891b22598926e4398790c8fe6447930c72a67d36d983a49d6ce682ce83290"
+dependencies = [
+ "bytecount",
+ "fnv",
+ "unicode-width",
+]
 
 [[package]]
 name = "parking_lot"
 version = "0.12.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "3742b2c103b9f06bc9fff0a37ff4912935851bee6d36f3c02bcc755bcfec228f"
 dependencies = [
  "lock_api",
  "parking_lot_core",
 ]
 
 [[package]]
 name = "parking_lot_core"
-version = "0.9.7"
+version = "0.9.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9069cbb9f99e3a5083476ccb29ceb1de18b9118cafa53e90c9551235de2b9521"
+checksum = "93f00c865fe7cabf650081affecd3871070f26767e7b2070a3ffae14c654b447"
 dependencies = [
  "cfg-if",
  "libc",
- "redox_syscall 0.2.16",
+ "redox_syscall",
  "smallvec",
- "windows-sys 0.45.0",
+ "windows-targets",
 ]
 
 [[package]]
 name = "parquet"
-version = "38.0.0"
+version = "40.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4cbd51311f8d9ff3d2697b1522b18a588782e097d313a1a278b0faf2ccf2d3f6"
+checksum = "d6a656fcc17e641657c955742c689732684e096f790ff30865d9f8dcc39f7c4a"
 dependencies = [
  "ahash 0.8.3",
  "arrow-array",
  "arrow-buffer",
  "arrow-cast",
  "arrow-data",
  "arrow-ipc",
@@ -2037,15 +2206,15 @@
  "object_store",
  "paste",
  "seq-macro",
  "snap",
  "thrift",
  "tokio",
  "twox-hash",
- "zstd 0.12.3+zstd.1.5.2",
+ "zstd",
 ]
 
 [[package]]
 name = "parse-zoneinfo"
 version = "0.3.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "c705f256449c60da65e11ff6626e0c16a0a0b96aaa348de61376b249bc340f41"
@@ -2057,17 +2226,17 @@
 name = "paste"
 version = "1.0.12"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "9f746c4065a8fa3fe23974dd82f15431cc8d40779821001404d10d2e79ca7d79"
 
 [[package]]
 name = "percent-encoding"
-version = "2.2.0"
+version = "2.3.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "478c572c3d73181ff3c2539045f6eb99e5491218eae919370993b890cdbdd98e"
+checksum = "9b2a4787296e9989611394c33f193f676704af1686e70b8f8033ab5ba9a35a94"
 
 [[package]]
 name = "petgraph"
 version = "0.6.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "4dd7d28ee937e54fe3080c91faa1c3a46c06de6252988a7f4592ba2310ef22a4"
 dependencies = [
@@ -2129,36 +2298,36 @@
 name = "pkg-config"
 version = "0.3.27"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "26072860ba924cbfa98ea39c8c19b4dd6a4a25423dbdf219c1eca91aa0cf6964"
 
 [[package]]
 name = "plotters"
-version = "0.3.4"
+version = "0.3.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2538b639e642295546c50fcd545198c9d64ee2a38620a628724a3b266d5fbf97"
+checksum = "d2c224ba00d7cadd4d5c660deaf2098e5e80e07846537c51f9cfa4be50c1fd45"
 dependencies = [
  "num-traits",
  "plotters-backend",
  "plotters-svg",
  "wasm-bindgen",
  "web-sys",
 ]
 
 [[package]]
 name = "plotters-backend"
-version = "0.3.4"
+version = "0.3.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "193228616381fecdc1224c62e96946dfbc73ff4384fba576e052ff8c1bea8142"
+checksum = "9e76628b4d3a7581389a35d5b6e2139607ad7c75b17aed325f210aa91f4a9609"
 
 [[package]]
 name = "plotters-svg"
-version = "0.3.3"
+version = "0.3.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f9a81d2759aae1dae668f783c308bc5c8ebd191ff4184aaa1b37f65a6ae5a56f"
+checksum = "38f6d39893cca0701371e3c27294f09797214b86f1fb951b89ade8ec04e2abab"
 dependencies = [
  "plotters-backend",
 ]
 
 [[package]]
 name = "ppv-lite86"
 version = "0.2.17"
@@ -2171,24 +2340,48 @@
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1d6ea3c4595b96363c13943497db34af4460fb474a95c43f4446ad341b8c9785"
 dependencies = [
  "toml",
 ]
 
 [[package]]
+name = "proc-macro-error"
+version = "1.0.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "da25490ff9892aab3fcf7c36f08cfb902dd3e71ca0f9f9517bea02a73a5ce38c"
+dependencies = [
+ "proc-macro-error-attr",
+ "proc-macro2",
+ "quote",
+ "syn 1.0.109",
+ "version_check",
+]
+
+[[package]]
+name = "proc-macro-error-attr"
+version = "1.0.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a1be40180e52ecc98ad80b184934baf3d0d29f979574e439af5a55274b35f869"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "version_check",
+]
+
+[[package]]
 name = "proc-macro-hack"
 version = "0.5.20+deprecated"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "dc375e1527247fe1a97d8b7156678dfe7c1af2fc075c9a4db3690ecd2a148068"
 
 [[package]]
 name = "proc-macro2"
-version = "1.0.58"
+version = "1.0.60"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fa1fb82fc0c281dd9671101b66b771ebbe1eaf967b96ac8740dcba4b70005ca8"
+checksum = "dec2b086b7a862cf4de201096214fa870344cf922b2b30c167badb3af3195406"
 dependencies = [
  "unicode-ident",
 ]
 
 [[package]]
 name = "ptr_meta"
 version = "0.1.4"
@@ -2214,15 +2407,15 @@
 version = "0.18.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e3b1ac5b3731ba34fdaa9785f8d74d17448cd18f30cf19e0c7e7b1fdb5272109"
 dependencies = [
  "cfg-if",
  "indoc",
  "libc",
- "memoffset",
+ "memoffset 0.8.0",
  "parking_lot",
  "pyo3-build-config",
  "pyo3-ffi",
  "pyo3-macros",
  "unindent",
 ]
 
@@ -2292,17 +2485,17 @@
  "proc-macro2",
  "quote",
  "syn 1.0.109",
 ]
 
 [[package]]
 name = "quote"
-version = "1.0.27"
+version = "1.0.28"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8f4f29d145265ec1c483c7c654450edde0bfe043d3938d6972630663356d9500"
+checksum = "1b9ab9c7eadfd8df19006f1cf1a4aed13540ed5cbc047010ece5826e10825488"
 dependencies = [
  "proc-macro2",
 ]
 
 [[package]]
 name = "radium"
 version = "0.7.0"
@@ -2359,63 +2552,78 @@
  "crossbeam-deque",
  "crossbeam-utils",
  "num_cpus",
 ]
 
 [[package]]
 name = "redox_syscall"
-version = "0.2.16"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fb5a58c1855b4b6819d59012155603f0b22ad30cad752600aadfcb695265519a"
-dependencies = [
- "bitflags",
-]
-
-[[package]]
-name = "redox_syscall"
 version = "0.3.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "567664f262709473930a4bf9e51bf2ebf3348f2e748ccc50dea20646858f8f29"
 dependencies = [
  "bitflags",
 ]
 
 [[package]]
 name = "regex"
-version = "1.8.1"
+version = "1.8.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "af83e617f331cc6ae2da5443c602dfa5af81e517212d9d611a5b3ba1777b5370"
+checksum = "d0ab3ca65655bb1e41f2a8c8cd662eb4fb035e67c3f78da1d61dffe89d07300f"
 dependencies = [
  "aho-corasick",
  "memchr",
- "regex-syntax 0.7.1",
+ "regex-syntax 0.7.2",
+]
+
+[[package]]
+name = "regex-automata"
+version = "0.1.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6c230d73fb8d8c1b9c0b3135c5142a8acee3a0558fb8db5cf1cb65f8d7862132"
+dependencies = [
+ "regex-syntax 0.6.29",
 ]
 
 [[package]]
 name = "regex-syntax"
 version = "0.6.29"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "f162c6dd7b008981e4d40210aca20b4bd0f9b60ca9271061b07f78537722f2e1"
 
 [[package]]
 name = "regex-syntax"
-version = "0.7.1"
+version = "0.7.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a5996294f19bd3aae0453a862ad728f60e6600695733dd5df01da90c54363a3c"
+checksum = "436b050e76ed2903236f032a59761c1eb99e1b0aead2c257922771dab1fc8c78"
 
 [[package]]
 name = "rend"
 version = "0.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "581008d2099240d37fb08d77ad713bcaec2c4d89d50b5b21a8bb1996bbab68ab"
 dependencies = [
  "bytecheck",
 ]
 
 [[package]]
+name = "ring"
+version = "0.16.20"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3053cf52e236a3ed746dfc745aa9cacf1b791d846bdaf412f60a8d7d6e17c8fc"
+dependencies = [
+ "cc",
+ "libc",
+ "once_cell",
+ "spin",
+ "untrusted",
+ "web-sys",
+ "winapi",
+]
+
+[[package]]
 name = "rkyv"
 version = "0.7.42"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "0200c8230b013893c0b2d6213d6ec64ed2b9be2e0e016682b7224ff82cff5c58"
 dependencies = [
  "bitvec",
  "bytecheck",
@@ -2436,14 +2644,36 @@
 dependencies = [
  "proc-macro2",
  "quote",
  "syn 1.0.109",
 ]
 
 [[package]]
+name = "rmp"
+version = "0.8.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "44519172358fd6d58656c86ab8e7fbc9e1490c3e8f14d35ed78ca0dd07403c9f"
+dependencies = [
+ "byteorder",
+ "num-traits",
+ "paste",
+]
+
+[[package]]
+name = "rmp-serde"
+version = "1.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c5b13be192e0220b8afb7222aa5813cb62cc269ebb5cac346ca6487681d2913e"
+dependencies = [
+ "byteorder",
+ "rmp",
+ "serde",
+]
+
+[[package]]
 name = "rstest"
 version = "0.17.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "de1bb486a691878cd320c2f0d319ba91eeaa2e894066d8b5f8f117c000e9d962"
 dependencies = [
  "futures",
  "futures-timer",
@@ -2463,17 +2693,17 @@
  "rustc_version",
  "syn 1.0.109",
  "unicode-ident",
 ]
 
 [[package]]
 name = "rust_decimal"
-version = "1.29.1"
+version = "1.30.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "26bd36b60561ee1fb5ec2817f198b6fd09fa571c897a5e86d1487cfc2b096dfc"
+checksum = "d0446843641c69436765a35a5a77088e28c2e6a12da93e84aa3ab1cd4aa5a042"
 dependencies = [
  "arrayvec",
  "borsh",
  "bytecheck",
  "byteorder",
  "bytes",
  "num-traits",
@@ -2490,27 +2720,70 @@
 checksum = "bfa0f585226d2e68097d4f95d113b15b83a82e819ab25717ec0590d9584ef366"
 dependencies = [
  "semver",
 ]
 
 [[package]]
 name = "rustix"
-version = "0.37.19"
+version = "0.37.20"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "acf8729d8542766f1b2cf77eb034d52f40d375bb8b615d0b147089946e16613d"
+checksum = "b96e891d04aa506a6d1f318d2771bcb1c7dfda84e126660ace067c9b474bb2c0"
 dependencies = [
  "bitflags",
  "errno",
  "io-lifetimes",
  "libc",
  "linux-raw-sys",
  "windows-sys 0.48.0",
 ]
 
 [[package]]
+name = "rustls"
+version = "0.21.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e32ca28af694bc1bbf399c33a516dbdf1c90090b8ab23c2bc24f834aa2247f5f"
+dependencies = [
+ "log",
+ "ring",
+ "rustls-webpki",
+ "sct",
+]
+
+[[package]]
+name = "rustls-native-certs"
+version = "0.6.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a9aace74cb666635c918e9c12bc0d348266037aa8eb599b5cba565709a8dff00"
+dependencies = [
+ "openssl-probe",
+ "rustls-pemfile",
+ "schannel",
+ "security-framework",
+]
+
+[[package]]
+name = "rustls-pemfile"
+version = "1.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d194b56d58803a43635bdc398cd17e383d6f71f9182b9a192c127ca42494a59b"
+dependencies = [
+ "base64",
+]
+
+[[package]]
+name = "rustls-webpki"
+version = "0.100.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d6207cd5ed3d8dca7816f8f3725513a34609c0c765bf652b8c3cb4cfd87db46b"
+dependencies = [
+ "ring",
+ "untrusted",
+]
+
+[[package]]
 name = "rustversion"
 version = "1.0.12"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "4f3208ce4d8448b3f3e7d168a73f5e0c43a61e32930de3bceeccedb388b6bf06"
 
 [[package]]
 name = "ryu"
@@ -2539,14 +2812,24 @@
 [[package]]
 name = "scopeguard"
 version = "1.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd"
 
 [[package]]
+name = "sct"
+version = "0.7.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d53dcdb7c9f8158937a7981b48accfd39a43af418591a5d008c7b22b5e1b7ca4"
+dependencies = [
+ "ring",
+ "untrusted",
+]
+
+[[package]]
 name = "seahash"
 version = "4.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1c107b6f4780854c8b126e228ea8869f4d7b71260f962fefb57b996b8959ba6b"
 
 [[package]]
 name = "security-framework"
@@ -2581,44 +2864,64 @@
 name = "seq-macro"
 version = "0.3.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e6b44e8fc93a14e66336d230954dda83d18b4605ccace8fe09bc7514a71ad0bc"
 
 [[package]]
 name = "serde"
-version = "1.0.163"
+version = "1.0.164"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2113ab51b87a539ae008b5c6c02dc020ffa39afd2d83cffcb3f4eb2722cebec2"
+checksum = "9e8c8cf938e98f769bc164923b06dce91cea1751522f46f8466461af04c9027d"
 dependencies = [
  "serde_derive",
 ]
 
 [[package]]
 name = "serde_derive"
-version = "1.0.163"
+version = "1.0.164"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8c805777e3930c8883389c602315a24224bcc738b63905ef87cd1420353ea93e"
+checksum = "d9735b638ccc51c28bf6914d90a2e9725b377144fc612c49a611fddd1b631d68"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.16",
+ "syn 2.0.18",
 ]
 
 [[package]]
 name = "serde_json"
-version = "1.0.96"
+version = "1.0.97"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "057d394a50403bcac12672b2b18fb387ab6d289d957dab67dd201875391e52f1"
+checksum = "bdf3bf93142acad5821c99197022e170842cdbc1c30482b98750c688c640842a"
 dependencies = [
  "itoa",
  "ryu",
  "serde",
 ]
 
 [[package]]
+name = "sha1"
+version = "0.10.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f04293dc80c3993519f2d7f6f511707ee7094fe0c6d3406feb330cdb3540eba3"
+dependencies = [
+ "cfg-if",
+ "cpufeatures",
+ "digest",
+]
+
+[[package]]
+name = "sharded-slab"
+version = "0.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "900fba806f70c630b0a382d0d825e17a0f19fcd059a2ade1ff237bcddf446b31"
+dependencies = [
+ "lazy_static",
+]
+
+[[package]]
 name = "signal-hook-registry"
 version = "1.4.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "d8229b473baa5980ac72ef434c4415e70c4b5e71b423043adb4ba059f89c99a1"
 dependencies = [
  "libc",
 ]
@@ -2685,18 +2988,24 @@
 checksum = "64a4a911eed85daf18834cfaa86a79b7d266ff93ff5ba14005426219480ed662"
 dependencies = [
  "libc",
  "winapi",
 ]
 
 [[package]]
+name = "spin"
+version = "0.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6e63cff320ae2c57904679ba7cb63280a3dc4613885beafb148ee7bf9aa9042d"
+
+[[package]]
 name = "sqlparser"
-version = "0.33.0"
+version = "0.34.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "355dc4d4b6207ca8a3434fc587db0a8016130a574dbcdbfb93d7f7b5bc5b211a"
+checksum = "37d3706eefb17039056234df6b566b0014f303f867f2656108334a55b8096f59"
 dependencies = [
  "log",
  "sqlparser_derive",
 ]
 
 [[package]]
 name = "sqlparser_derive"
@@ -2752,46 +3061,71 @@
  "proc-macro2",
  "quote",
  "unicode-ident",
 ]
 
 [[package]]
 name = "syn"
-version = "2.0.16"
+version = "2.0.18"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a6f671d4b5ffdb8eadec19c0ae67fe2639df8684bd7bc4b83d986b8db549cf01"
+checksum = "32d41677bcbe24c20c52e7c70b0d8db04134c5d1066bf98662e2871ad200ea3e"
 dependencies = [
  "proc-macro2",
  "quote",
  "unicode-ident",
 ]
 
 [[package]]
+name = "tabled"
+version = "0.12.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0ce69a5028cd9576063ec1f48edb2c75339fd835e6094ef3e05b3a079bf594a6"
+dependencies = [
+ "papergrid",
+ "tabled_derive",
+ "unicode-width",
+]
+
+[[package]]
+name = "tabled_derive"
+version = "0.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "99f688a08b54f4f02f0a3c382aefdb7884d3d69609f785bd253dc033243e3fe4"
+dependencies = [
+ "heck",
+ "proc-macro-error",
+ "proc-macro2",
+ "quote",
+ "syn 1.0.109",
+]
+
+[[package]]
 name = "tap"
 version = "1.0.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "55937e1799185b12863d447f42597ed69d9928686b8d88a1df17376a097d8369"
 
 [[package]]
 name = "target-lexicon"
 version = "0.12.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "fd1ba337640d60c3e96bc6f0638a939b9c9a7f2c316a1598c279828b3d1dc8c5"
 
 [[package]]
 name = "tempfile"
-version = "3.5.0"
+version = "3.6.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b9fbec84f381d5795b08656e4912bec604d162bff9291d6189a78f4c8ab87998"
+checksum = "31c0432476357e58790aaa47a8efb0c5138f137343f3b5f23bd36a27e3b0a6d6"
 dependencies = [
+ "autocfg",
  "cfg-if",
  "fastrand",
- "redox_syscall 0.3.5",
+ "redox_syscall",
  "rustix",
- "windows-sys 0.45.0",
+ "windows-sys 0.48.0",
 ]
 
 [[package]]
 name = "termcolor"
 version = "1.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "be55cf8942feac5c765c2c993422806843c9a9a45d4d5c407ad6dd2ea95eb9b6"
@@ -2818,15 +3152,25 @@
 name = "thiserror-impl"
 version = "1.0.40"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "f9456a42c5b0d803c8cd86e73dd7cc9edd429499f37a3550d286d5e86720569f"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.16",
+ "syn 2.0.18",
+]
+
+[[package]]
+name = "thread_local"
+version = "1.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3fdd6f064ccff2d6567adcb3873ca630700f00b5ad3f060c25b5dcfd9a4ce152"
+dependencies = [
+ "cfg-if",
+ "once_cell",
 ]
 
 [[package]]
 name = "thrift"
 version = "0.17.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "7e54bc85fc7faa8bc175c4bab5b92ba8d9a3ce893d0e9f42cc455c8ab16a9e09"
@@ -2879,17 +3223,17 @@
 name = "tinyvec_macros"
 version = "0.1.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"
 
 [[package]]
 name = "tokio"
-version = "1.28.1"
+version = "1.28.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0aa32867d44e6f2ce3385e89dceb990188b8bb0fb25b0cf576647a6f98ac5105"
+checksum = "94d7b1cfd2aa4011f2de74c2c4c63665e27a71006b0a192dcd2710272e73dfa2"
 dependencies = [
  "autocfg",
  "bytes",
  "libc",
  "mio",
  "num_cpus",
  "parking_lot",
@@ -2904,39 +3248,69 @@
 name = "tokio-macros"
 version = "2.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "630bdcf245f78637c13ec01ffae6187cca34625e8c63150d424b59e55af2675e"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.16",
+ "syn 2.0.18",
 ]
 
 [[package]]
 name = "tokio-native-tls"
 version = "0.3.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "bbae76ab933c85776efabc971569dd6119c580d8f5d448769dec1764bf796ef2"
 dependencies = [
  "native-tls",
  "tokio",
 ]
 
 [[package]]
+name = "tokio-rustls"
+version = "0.24.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c28327cf380ac148141087fbfb9de9d7bd4e84ab5d2c28fbc911d753de8a7081"
+dependencies = [
+ "rustls",
+ "tokio",
+]
+
+[[package]]
 name = "tokio-stream"
 version = "0.1.14"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "397c988d37662c7dda6d2208364a706264bf3d6138b11d436cbac0ad38832842"
 dependencies = [
  "futures-core",
  "pin-project-lite",
  "tokio",
 ]
 
 [[package]]
+name = "tokio-tungstenite"
+version = "0.19.0"
+dependencies = [
+ "env_logger",
+ "futures-channel",
+ "futures-util",
+ "hyper",
+ "log",
+ "native-tls",
+ "rustls",
+ "rustls-native-certs",
+ "tokio",
+ "tokio-native-tls",
+ "tokio-rustls",
+ "tungstenite",
+ "url",
+ "webpki-roots",
+]
+
+[[package]]
 name = "tokio-util"
 version = "0.7.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "806fe8c2c87eccc8b3267cbae29ed3ab2d0bd37fca70ab622e46aaa9375ddb7d"
 dependencies = [
  "bytes",
  "futures-core",
@@ -2976,53 +3350,132 @@
 name = "tracing-attributes"
 version = "0.1.24"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "0f57e3ca2a01450b1a921183a9c9cbfda207fd822cef4ccb00a65402cbba7a74"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.16",
+ "syn 2.0.18",
 ]
 
 [[package]]
 name = "tracing-core"
 version = "0.1.31"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "0955b8137a1df6f1a2e9a37d8a6656291ff0297c1a97c24e0d8425fe2312f79a"
 dependencies = [
  "once_cell",
+ "valuable",
+]
+
+[[package]]
+name = "tracing-log"
+version = "0.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "78ddad33d2d10b1ed7eb9d1f518a5674713876e97e5bb9b7345a7984fbb4f922"
+dependencies = [
+ "lazy_static",
+ "log",
+ "tracing-core",
+]
+
+[[package]]
+name = "tracing-subscriber"
+version = "0.3.17"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "30a651bc37f915e81f087d86e62a18eec5f79550c7faff886f7090b4ea757c77"
+dependencies = [
+ "matchers",
+ "nu-ansi-term",
+ "once_cell",
+ "regex",
+ "sharded-slab",
+ "smallvec",
+ "thread_local",
+ "tracing",
+ "tracing-core",
+ "tracing-log",
+]
+
+[[package]]
+name = "tracing-test"
+version = "0.2.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3a2c0ff408fe918a94c428a3f2ad04e4afd5c95bbc08fcf868eff750c15728a4"
+dependencies = [
+ "lazy_static",
+ "tracing-core",
+ "tracing-subscriber",
+ "tracing-test-macro",
+]
+
+[[package]]
+name = "tracing-test-macro"
+version = "0.2.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "258bc1c4f8e2e73a977812ab339d503e6feeb92700f6d07a6de4d321522d5c08"
+dependencies = [
+ "lazy_static",
+ "quote",
+ "syn 1.0.109",
 ]
 
 [[package]]
 name = "try-lock"
 version = "0.2.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "3528ecfd12c466c6f163363caf2d02a71161dd5e1cc6ae7b34207ea2d42d81ed"
 
 [[package]]
+name = "tungstenite"
+version = "0.19.0"
+source = "git+https://github.com/snapview/tungstenite-rs#d7b559d724eb156590f9b739245499d6bdce41a3"
+dependencies = [
+ "byteorder",
+ "bytes",
+ "data-encoding",
+ "http",
+ "httparse",
+ "log",
+ "native-tls",
+ "rand",
+ "rustls",
+ "sha1",
+ "thiserror",
+ "url",
+ "utf-8",
+]
+
+[[package]]
 name = "twox-hash"
 version = "1.6.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "97fee6b57c6a41524a810daee9286c02d7752c4253064d0b05472833a438f675"
 dependencies = [
  "cfg-if",
  "static_assertions",
 ]
 
 [[package]]
+name = "typenum"
+version = "1.16.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "497961ef93d974e23eb6f433eb5fe1b7930b659f06d12dec6fc44a8f554c0bba"
+
+[[package]]
 name = "unicode-bidi"
 version = "0.3.13"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "92888ba5573ff080736b3648696b70cafad7d250551175acbaa4e0385b3e1460"
 
 [[package]]
 name = "unicode-ident"
-version = "1.0.8"
+version = "1.0.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e5464a87b239f13a63a501f2701565754bae92d243d4bb7eb12f6d57d2269bf4"
+checksum = "b15811caf2415fb889178633e7724bad2509101cde276048e013b9def5e51fa0"
 
 [[package]]
 name = "unicode-normalization"
 version = "0.1.22"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "5c5713f0fc4b5db668a2ac63cdb7bb4469d8c9fed047b1d0292cc7b0ce2ba921"
 dependencies = [
@@ -3044,34 +3497,52 @@
 [[package]]
 name = "unindent"
 version = "0.1.11"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e1766d682d402817b5ac4490b3c3002d91dfa0d22812f341609f97b08757359c"
 
 [[package]]
+name = "untrusted"
+version = "0.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a156c684c91ea7d62626509bce3cb4e1d9ed5c4d978f7b4352658f96a4c26b4a"
+
+[[package]]
 name = "url"
-version = "2.3.1"
+version = "2.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0d68c799ae75762b8c3fe375feb6600ef5602c883c5d21eb51c09f22b83c4643"
+checksum = "50bff7831e19200a85b17131d085c25d7811bc4e186efdaf54bbd132994a88cb"
 dependencies = [
  "form_urlencoded",
  "idna",
  "percent-encoding",
 ]
 
 [[package]]
+name = "utf-8"
+version = "0.7.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "09cc8ee72d2a9becf2f2febe0205bbed8fc6615b7cb429ad062dc7b7ddd036a9"
+
+[[package]]
 name = "uuid"
-version = "1.3.3"
+version = "1.3.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "345444e32442451b267fc254ae85a209c64be56d2890e601a0c37ff0c3c5ecd2"
+checksum = "0fa2982af2eec27de306107c027578ff7f423d65f7250e40ce0fea8f45248b81"
 dependencies = [
  "getrandom",
 ]
 
 [[package]]
+name = "valuable"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "830b7e5d4d90034032940e4ace0d9a9a057e7a45cd94e6c007832e39edb82f6d"
+
+[[package]]
 name = "vcpkg"
 version = "0.2.15"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "accd4ea62f7bb7a82fe23066fb0957d48ef677f6eeb8215f372f52e48bb32426"
 
 [[package]]
 name = "version_check"
@@ -3087,19 +3558,18 @@
 dependencies = [
  "same-file",
  "winapi-util",
 ]
 
 [[package]]
 name = "want"
-version = "0.3.0"
+version = "0.3.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1ce8a968cb1cd110d136ff8b819a556d6fb6d919363c61534f6860c7eb172ba0"
+checksum = "bfa7760aed19e106de2c7c0b581b509f2f25d3dacaf737cb82ac61bc6d760b0e"
 dependencies = [
- "log",
  "try-lock",
 ]
 
 [[package]]
 name = "wasi"
 version = "0.10.0+wasi-snapshot-preview1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -3109,77 +3579,86 @@
 name = "wasi"
 version = "0.11.0+wasi-snapshot-preview1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"
 
 [[package]]
 name = "wasm-bindgen"
-version = "0.2.86"
+version = "0.2.87"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5bba0e8cb82ba49ff4e229459ff22a191bbe9a1cb3a341610c9c33efc27ddf73"
+checksum = "7706a72ab36d8cb1f80ffbf0e071533974a60d0a308d01a5d0375bf60499a342"
 dependencies = [
  "cfg-if",
  "wasm-bindgen-macro",
 ]
 
 [[package]]
 name = "wasm-bindgen-backend"
-version = "0.2.86"
+version = "0.2.87"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "19b04bc93f9d6bdee709f6bd2118f57dd6679cf1176a1af464fca3ab0d66d8fb"
+checksum = "5ef2b6d3c510e9625e5fe6f509ab07d66a760f0885d858736483c32ed7809abd"
 dependencies = [
  "bumpalo",
  "log",
  "once_cell",
  "proc-macro2",
  "quote",
- "syn 2.0.16",
+ "syn 2.0.18",
  "wasm-bindgen-shared",
 ]
 
 [[package]]
 name = "wasm-bindgen-macro"
-version = "0.2.86"
+version = "0.2.87"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "14d6b024f1a526bb0234f52840389927257beb670610081360e5a03c5df9c258"
+checksum = "dee495e55982a3bd48105a7b947fd2a9b4a8ae3010041b9e0faab3f9cd028f1d"
 dependencies = [
  "quote",
  "wasm-bindgen-macro-support",
 ]
 
 [[package]]
 name = "wasm-bindgen-macro-support"
-version = "0.2.86"
+version = "0.2.87"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e128beba882dd1eb6200e1dc92ae6c5dbaa4311aa7bb211ca035779e5efc39f8"
+checksum = "54681b18a46765f095758388f2d0cf16eb8d4169b639ab575a8f5693af210c7b"
 dependencies = [
  "proc-macro2",
  "quote",
- "syn 2.0.16",
+ "syn 2.0.18",
  "wasm-bindgen-backend",
  "wasm-bindgen-shared",
 ]
 
 [[package]]
 name = "wasm-bindgen-shared"
-version = "0.2.86"
+version = "0.2.87"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ed9d5b4305409d1fc9482fee2d7f9bcbf24b3972bf59817ef757e23982242a93"
+checksum = "ca6ad05a4870b2bf5fe995117d3728437bd27d7cd5f06f13c17443ef369775a1"
 
 [[package]]
 name = "web-sys"
-version = "0.3.63"
+version = "0.3.64"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3bdd9ef4e984da1187bf8110c5cf5b845fbc87a23602cdf912386a76fcd3a7c2"
+checksum = "9b85cbef8c220a6abc02aefd892dfc0fc23afb1c6a426316ec33253a3877249b"
 dependencies = [
  "js-sys",
  "wasm-bindgen",
 ]
 
 [[package]]
+name = "webpki-roots"
+version = "0.23.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b03058f88386e5ff5310d9111d53f48b17d732b401aeb83a8d5190f2ac459338"
+dependencies = [
+ "rustls-webpki",
+]
+
+[[package]]
 name = "winapi"
 version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
 dependencies = [
  "winapi-i686-pc-windows-gnu",
  "winapi-x86_64-pc-windows-gnu",
@@ -3208,15 +3687,15 @@
 
 [[package]]
 name = "windows"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "e686886bc078bc1b0b600cac0147aadb815089b6e4da64016cbd754b6342700f"
 dependencies = [
- "windows-targets 0.48.0",
+ "windows-targets",
 ]
 
 [[package]]
 name = "windows-sys"
 version = "0.42.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "5a3e1820f08b8513f676f7ab6c1f99ff312fb97b553d30ff4dd86f9f15728aa7"
@@ -3228,43 +3707,19 @@
  "windows_x86_64_gnu 0.42.2",
  "windows_x86_64_gnullvm 0.42.2",
  "windows_x86_64_msvc 0.42.2",
 ]
 
 [[package]]
 name = "windows-sys"
-version = "0.45.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "75283be5efb2831d37ea142365f009c02ec203cd29a3ebecbc093d52315b66d0"
-dependencies = [
- "windows-targets 0.42.2",
-]
-
-[[package]]
-name = "windows-sys"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "677d2418bec65e3338edb076e806bc1ec15693c5d0104683f2efe857f61056a9"
 dependencies = [
- "windows-targets 0.48.0",
-]
-
-[[package]]
-name = "windows-targets"
-version = "0.42.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8e5180c00cd44c9b1c88adb3693291f1cd93605ded80c250a75d472756b4d071"
-dependencies = [
- "windows_aarch64_gnullvm 0.42.2",
- "windows_aarch64_msvc 0.42.2",
- "windows_i686_gnu 0.42.2",
- "windows_i686_msvc 0.42.2",
- "windows_x86_64_gnu 0.42.2",
- "windows_x86_64_gnullvm 0.42.2",
- "windows_x86_64_msvc 0.42.2",
+ "windows-targets",
 ]
 
 [[package]]
 name = "windows-targets"
 version = "0.48.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "7b1eb6f0cd7c80c79759c929114ef071b87354ce476d9d94271031c0497adfd5"
@@ -3378,38 +3833,19 @@
 checksum = "388c44dc09d76f1536602ead6d325eb532f5c122f17782bd57fb47baeeb767e2"
 dependencies = [
  "lzma-sys",
 ]
 
 [[package]]
 name = "zstd"
-version = "0.11.2+zstd.1.5.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "20cc960326ece64f010d2d2107537f26dc589a6573a316bd5b1dba685fa5fde4"
-dependencies = [
- "zstd-safe 5.0.2+zstd.1.5.2",
-]
-
-[[package]]
-name = "zstd"
 version = "0.12.3+zstd.1.5.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "76eea132fb024e0e13fd9c2f5d5d595d8a967aa72382ac2f9d39fcc95afd0806"
 dependencies = [
- "zstd-safe 6.0.5+zstd.1.5.4",
-]
-
-[[package]]
-name = "zstd-safe"
-version = "5.0.2+zstd.1.5.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "1d2a5585e04f9eea4b2a3d1eca508c4dee9592a89ef6f450c11719da0726f4db"
-dependencies = [
- "libc",
- "zstd-sys",
+ "zstd-safe",
 ]
 
 [[package]]
 name = "zstd-safe"
 version = "6.0.5+zstd.1.5.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "d56d9e60b4b1758206c238a10165fbcae3ca37b01744e394c463463f6529d23b"
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/Cargo.toml` & `nautilus_trader-1.175.0/nautilus_core/Cargo.toml`

 * *Files 16% similar despite different names*

```diff
@@ -2,49 +2,52 @@
 members = [
     "backtest",
     "common",
     "core",
     "indicators",
     "model",
     "network",
+    "network/tokio-tungstenite",
     "persistence",
     "pyo3"
 ]
 
 [workspace.package]
-rust-version = "1.69.0"
-version = "0.5.0"
+rust-version = "1.70.0"
+version = "0.6.0"
 edition = "2021"
 authors = ["Nautech Systems <info@nautechsystems.io>"]
 description = "A high-performance algorithmic trading platform and event-driven backtester"
 documentation = "https://docs.nautilustrader.io"
 
 [workspace.dependencies]
-chrono = "0.4.24"
+chrono = "0.4.26"
+futures = "0.3.28"
 pyo3 = "0.18.3"
 pyo3-asyncio = { version = "0.18.0", features = [ "tokio-runtime", "tokio", "attributes" ] }
 pyo3-macros = "0.18.3"
 rand = "0.8.5"
-rust_decimal = "1.29.1"
+rmp-serde = "1.1.1"
+rust_decimal = "1.30.0"
 rust_decimal_macros = "1.29.1"
-serde = { version = "1.0", features = ["derive"] }
-serde_json = "1.0"
+serde = { version = "1.0.164", features = ["derive"] }
+serde_json = "1.0.97"
 strum = { version = "0.24.1", features = ["derive"] }
 thiserror = "1.0.40"
-tokio = { version = "1.28.1", features = ["full"] }
-uuid = { version = "1.3.3", features = ["v4"] }
+tokio = { version = "1.28.2", features = ["full"] }
+uuid = { version = "1.3.4", features = ["v4"] }
 
 # dev-dependencies
 criterion = "0.4.0"
 iai = "0.1"
 rstest = "0.17.0"
-tempfile = "3.5.0"
+tempfile = "3.6.0"
 
 # build-dependencies
-cbindgen = "0.24.3"
+cbindgen = "0.24.5"
 
 [profile.dev]
 opt-level = 0
 debug = true
 debug-assertions = false  # Fails Cython build if true
 overflow-checks = true
 lto = false
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/LICENSE` & `nautilus_trader-1.175.0/nautilus_core/LICENSE`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_core/README.md` & `nautilus_trader-1.175.0/nautilus_core/README.md`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_core/backtest/Cargo.toml` & `nautilus_trader-1.175.0/nautilus_core/backtest/Cargo.toml`

 * *Files 20% similar despite different names*

```diff
@@ -1,33 +1,33 @@
 [package]
-name = "nautilus_backtest"
+name = "nautilus-backtest"
 version.workspace = true
 edition.workspace = true
 authors.workspace = true
 description.workspace = true
 documentation.workspace = true
 
 [lib]
 name = "nautilus_backtest"
 crate-type = ["rlib", "staticlib"]
 proc-macro = true
 
 [dependencies]
-nautilus_common = { path = "../common" }
-nautilus_core = { path = "../core" }
-nautilus_model = { path = "../model" }
+nautilus-common = { path = "../common" }
+nautilus-core = { path = "../core" }
+nautilus-model = { path = "../model" }
 pyo3.workspace = true
 
 [dev-dependencies]
 tempfile.workspace = true
 
 [features]
 extension-module = [
     "pyo3/extension-module",
-    "nautilus_common/extension-module",
-    "nautilus_core/extension-module",
-    "nautilus_model/extension-module",
+    "nautilus-common/extension-module",
+    "nautilus-core/extension-module",
+    "nautilus-model/extension-module",
 ]
 default = []
 
 [build-dependencies]
 cbindgen.workspace = true
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/backtest/build.rs` & `nautilus_trader-1.175.0/nautilus_core/backtest/build.rs`

 * *Files 2% similar despite different names*

```diff
@@ -11,16 +11,15 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 extern crate cbindgen;
 
-use std::env;
-use std::path::PathBuf;
+use std::{env, path::PathBuf};
 
 #[allow(clippy::expect_used)] // OK in build script
 fn main() {
     let crate_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
 
     // Generate C headers
     let config_c = cbindgen::Config::from_file("cbindgen.toml")
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/backtest/cbindgen_cython.toml` & `nautilus_trader-1.175.0/nautilus_core/backtest/cbindgen_cython.toml`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_core/backtest/src/engine.rs` & `nautilus_trader-1.175.0/nautilus_core/backtest/src/engine.rs`

 * *Files 5% similar despite different names*

```diff
@@ -11,18 +11,16 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::ops::{Deref, DerefMut};
 
-use nautilus_common::clock::{TestClock, TestClock_API};
-use nautilus_common::timer::TimeEventHandler;
-use nautilus_core::cvec::CVec;
-use nautilus_core::time::UnixNanos;
+use nautilus_common::{clock::TestClock, clock_api::TestClock_API, timer::TimeEventHandler};
+use nautilus_core::{cvec::CVec, time::UnixNanos};
 
 /// Provides a means of accumulating and draining time event handlers.
 pub struct TimeEventAccumulator {
     event_handlers: Vec<TimeEventHandler>,
 }
 
 impl TimeEventAccumulator {
@@ -104,20 +102,19 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
-    use super::*;
-
     use nautilus_common::timer::TimeEvent;
     use nautilus_core::uuid::UUID4;
-    use pyo3::types::PyList;
-    use pyo3::{AsPyPointer, Py, Python};
+    use pyo3::{types::PyList, AsPyPointer, Py, Python};
+
+    use super::*;
 
     #[test]
     fn test_accumulator_drain_sorted() {
         pyo3::prepare_freethreaded_python();
 
         Python::with_gil(|py| {
             let py_list = PyList::empty(py);
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/backtest/src/lib.rs` & `nautilus_trader-1.175.0/nautilus_core/backtest/src/lib.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_core/common/Cargo.toml` & `nautilus_trader-1.175.0/nautilus_core/common/Cargo.toml`

 * *Files 3% similar despite different names*

```diff
@@ -1,35 +1,35 @@
 [package]
-name = "nautilus_common"
+name = "nautilus-common"
 version.workspace = true
 edition.workspace = true
 authors.workspace = true
 description.workspace = true
 documentation.workspace = true
 
 [lib]
 name = "nautilus_common"
 crate-type = ["rlib", "staticlib"]
 proc-macro = true
 
 [dependencies]
-nautilus_core = { path = "../core" }
-nautilus_model = { path = "../model" }
+nautilus-core = { path = "../core" }
+nautilus-model = { path = "../model" }
 chrono.workspace = true
 serde.workspace = true
 serde_json.workspace = true
 pyo3.workspace = true
 strum.workspace = true
 
 [dev-dependencies]
 tempfile.workspace = true
 
 [features]
 extension-module = [
     "pyo3/extension-module",
-    "nautilus_core/extension-module",
-    "nautilus_model/extension-module",
+    "nautilus-core/extension-module",
+    "nautilus-model/extension-module",
 ]
 default = []
 
 [build-dependencies]
 cbindgen.workspace = true
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/common/build.rs` & `nautilus_trader-1.175.0/nautilus_core/common/build.rs`

 * *Files 4% similar despite different names*

```diff
@@ -11,18 +11,20 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 extern crate cbindgen;
 
-use std::env;
-use std::fs::File;
-use std::io::{Read, Write};
-use std::path::PathBuf;
+use std::{
+    env,
+    fs::File,
+    io::{Read, Write},
+    path::PathBuf,
+};
 
 #[allow(clippy::expect_used)] // OK in build script
 fn main() {
     let crate_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
 
     // Generate C headers
     let config_c = cbindgen::Config::from_file("cbindgen.toml")
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/common/cbindgen.toml` & `nautilus_trader-1.175.0/nautilus_core/common/cbindgen.toml`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_core/common/cbindgen_cython.toml` & `nautilus_trader-1.175.0/nautilus_core/common/cbindgen_cython.toml`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_core/common/src/clock.rs` & `nautilus_trader-1.175.0/nautilus_core/common/src/clock.rs`

 * *Files 20% similar despite different names*

```diff
@@ -9,27 +9,22 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::collections::HashMap;
-use std::ffi::c_char;
-use std::ops::{Deref, DerefMut};
-use std::time::Duration;
-
-use nautilus_core::correctness;
-use nautilus_core::cvec::CVec;
-use nautilus_core::datetime::{nanos_to_micros, nanos_to_millis, nanos_to_secs};
-use nautilus_core::string::cstr_to_string;
-use nautilus_core::time::{duration_since_unix_epoch, UnixNanos};
-use pyo3::prelude::*;
-use pyo3::types::{PyList, PyString};
-use pyo3::{ffi, AsPyPointer};
+use std::{collections::HashMap, time::Duration};
+
+use nautilus_core::{
+    correctness,
+    datetime::{nanos_to_micros, nanos_to_millis, nanos_to_secs},
+    time::{duration_since_unix_epoch, UnixNanos},
+};
+use pyo3::{prelude::*, AsPyPointer};
 
 use crate::timer::{TestTimer, TimeEvent, TimeEventHandler};
 
 const ONE_NANOSECOND_DURATION: Duration = Duration::from_nanos(1);
 
 pub struct MonotonicClock {
     /// The last recorded duration value from the clock.
@@ -88,15 +83,15 @@
     }
 }
 
 /// Represents a type of clock.
 ///
 /// # Notes
 /// An active timer is one which has not expired (`timer.is_expired == False`).
-trait Clock {
+pub trait Clock {
     /// Return a new [Clock].
     fn new() -> Self;
 
     /// Return the current UNIX time in seconds.
     fn timestamp(&mut self) -> f64;
 
     /// Return the current UNIX time in milliseconds (ms).
@@ -152,16 +147,19 @@
     default_callback: Option<Box<dyn Fn(TimeEvent)>>,
     default_callback_py: Option<PyObject>,
     _callbacks: HashMap<String, Box<dyn Fn(TimeEvent)>>,
     callbacks_py: HashMap<String, PyObject>,
 }
 
 impl TestClock {
-    #[allow(dead_code)] // Temporary
-    fn set_time(&mut self, to_time_ns: UnixNanos) {
+    pub fn get_timers(&self) -> &HashMap<String, TestTimer> {
+        &self.timers
+    }
+
+    pub fn set_time(&mut self, to_time_ns: UnixNanos) {
         self.time_ns = to_time_ns
     }
 
     pub fn advance_time(&mut self, to_time_ns: UnixNanos, set_time: bool) -> Vec<TimeEvent> {
         // Time should increase monotonically
         assert!(
             to_time_ns >= self.time_ns,
@@ -462,253 +460,20 @@
             timer.cancel()
         }
         self.timers = HashMap::new();
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
-// C API - TestClock
-////////////////////////////////////////////////////////////////////////////////
-#[allow(non_camel_case_types)]
-#[repr(C)]
-pub struct TestClock_API(Box<TestClock>);
-
-impl Deref for TestClock_API {
-    type Target = TestClock;
-
-    fn deref(&self) -> &Self::Target {
-        &self.0
-    }
-}
-
-impl DerefMut for TestClock_API {
-    fn deref_mut(&mut self) -> &mut Self::Target {
-        &mut self.0
-    }
-}
-
-#[no_mangle]
-pub extern "C" fn test_clock_new() -> TestClock_API {
-    TestClock_API(Box::new(TestClock::new()))
-}
-
-#[no_mangle]
-pub extern "C" fn test_clock_drop(clock: TestClock_API) {
-    drop(clock); // Memory freed here
-}
-
-/// # Safety
-/// - Assumes `callback_ptr` is a valid PyCallable pointer.
-#[no_mangle]
-pub unsafe extern "C" fn test_clock_register_default_handler(
-    clock: &mut TestClock_API,
-    callback_ptr: *mut ffi::PyObject,
-) {
-    assert!(!callback_ptr.is_null());
-    assert!(ffi::Py_None() != callback_ptr);
-
-    let callback_py = Python::with_gil(|py| PyObject::from_borrowed_ptr(py, callback_ptr));
-    clock.register_default_handler_py(callback_py);
-}
-
-#[no_mangle]
-pub extern "C" fn test_clock_set_time(clock: &mut TestClock_API, to_time_ns: u64) {
-    clock.set_time(to_time_ns);
-}
-
-#[no_mangle]
-pub extern "C" fn test_clock_timestamp(clock: &mut TestClock_API) -> f64 {
-    clock.timestamp()
-}
-
-#[no_mangle]
-pub extern "C" fn test_clock_timestamp_ms(clock: &mut TestClock_API) -> u64 {
-    clock.timestamp_ms()
-}
-
-#[no_mangle]
-pub extern "C" fn test_clock_timestamp_us(clock: &mut TestClock_API) -> u64 {
-    clock.timestamp_us()
-}
-
-#[no_mangle]
-pub extern "C" fn test_clock_timestamp_ns(clock: &mut TestClock_API) -> u64 {
-    clock.timestamp_ns()
-}
-
-#[no_mangle]
-pub extern "C" fn test_clock_timer_names(clock: &TestClock_API) -> *mut ffi::PyObject {
-    Python::with_gil(|py| -> Py<PyList> {
-        let names: Vec<Py<PyString>> = clock
-            .timers
-            .keys()
-            .map(|k| PyString::new(py, k).into())
-            .collect();
-        PyList::new(py, names).into()
-    })
-    .as_ptr()
-}
-
-#[no_mangle]
-pub extern "C" fn test_clock_timer_count(clock: &mut TestClock_API) -> usize {
-    clock.timer_count()
-}
-
-/// # Safety
-/// - Assumes `name_ptr` is a valid C string pointer.
-/// - Assumes `callback_ptr` is a valid PyCallable pointer.
-#[no_mangle]
-pub unsafe extern "C" fn test_clock_set_time_alert_ns(
-    clock: &mut TestClock_API,
-    name_ptr: *const c_char,
-    alert_time_ns: UnixNanos,
-    callback_ptr: *mut ffi::PyObject,
-) {
-    assert!(!callback_ptr.is_null());
-
-    let name = cstr_to_string(name_ptr);
-    let callback_py = Python::with_gil(|py| match callback_ptr {
-        ptr if ptr != ffi::Py_None() => Some(PyObject::from_borrowed_ptr(py, ptr)),
-        _ => None,
-    });
-    clock.set_time_alert_ns_py(name, alert_time_ns, callback_py);
-}
-
-/// # Safety
-/// - Assumes `name_ptr` is a valid C string pointer.
-/// - Assumes `callback_ptr` is a valid PyCallable pointer.
-#[no_mangle]
-pub unsafe extern "C" fn test_clock_set_timer_ns(
-    clock: &mut TestClock_API,
-    name_ptr: *const c_char,
-    interval_ns: u64,
-    start_time_ns: UnixNanos,
-    stop_time_ns: UnixNanos,
-    callback_ptr: *mut ffi::PyObject,
-) {
-    assert!(!callback_ptr.is_null());
-
-    let name = cstr_to_string(name_ptr);
-    let stop_time_ns = match stop_time_ns {
-        0 => None,
-        _ => Some(stop_time_ns),
-    };
-    let callback_py = Python::with_gil(|py| match callback_ptr {
-        ptr if ptr != ffi::Py_None() => Some(PyObject::from_borrowed_ptr(py, ptr)),
-        _ => None,
-    });
-    clock.set_timer_ns_py(name, interval_ns, start_time_ns, stop_time_ns, callback_py);
-}
-
-/// # Safety
-/// - Assumes `set_time` is a correct `uint8_t` of either 0 or 1.
-#[no_mangle]
-pub unsafe extern "C" fn test_clock_advance_time(
-    clock: &mut TestClock_API,
-    to_time_ns: u64,
-    set_time: u8,
-) -> CVec {
-    let events: Vec<TimeEvent> = clock.advance_time(to_time_ns, set_time != 0);
-    clock.match_handlers_py(events).into()
-}
-
-// TODO: This struct implementation potentially leaks memory
-// TODO: Skip clippy check for now since it requires large modification
-#[allow(clippy::drop_non_drop)]
-#[no_mangle]
-pub extern "C" fn vec_time_event_handlers_drop(v: CVec) {
-    let CVec { ptr, len, cap } = v;
-    let data: Vec<TimeEventHandler> =
-        unsafe { Vec::from_raw_parts(ptr as *mut TimeEventHandler, len, cap) };
-    drop(data); // Memory freed here
-}
-
-/// # Safety
-/// - Assumes `name_ptr` is a valid C string pointer.
-#[no_mangle]
-pub unsafe extern "C" fn test_clock_next_time_ns(
-    clock: &mut TestClock_API,
-    name_ptr: *const c_char,
-) -> UnixNanos {
-    let name = cstr_to_string(name_ptr);
-    clock.next_time_ns(&name)
-}
-
-/// # Safety
-/// - Assumes `name_ptr` is a valid C string pointer.
-#[no_mangle]
-pub unsafe extern "C" fn test_clock_cancel_timer(
-    clock: &mut TestClock_API,
-    name_ptr: *const c_char,
-) {
-    let name = cstr_to_string(name_ptr);
-    clock.cancel_timer(&name);
-}
-
-#[no_mangle]
-pub extern "C" fn test_clock_cancel_timers(clock: &mut TestClock_API) {
-    clock.cancel_timers();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// C API - LiveClock
-////////////////////////////////////////////////////////////////////////////////
-#[allow(non_camel_case_types)]
-#[repr(C)]
-pub struct LiveClock_API(Box<LiveClock>);
-
-impl Deref for LiveClock_API {
-    type Target = LiveClock;
-
-    fn deref(&self) -> &Self::Target {
-        &self.0
-    }
-}
-
-impl DerefMut for LiveClock_API {
-    fn deref_mut(&mut self) -> &mut Self::Target {
-        &mut self.0
-    }
-}
-
-#[no_mangle]
-pub extern "C" fn live_clock_new() -> LiveClock_API {
-    LiveClock_API(Box::new(LiveClock::new()))
-}
-
-#[no_mangle]
-pub extern "C" fn live_clock_drop(clock: LiveClock_API) {
-    drop(clock); // Memory freed here
-}
-
-#[no_mangle]
-pub extern "C" fn live_clock_timestamp(clock: &mut LiveClock_API) -> f64 {
-    clock.timestamp()
-}
-
-#[no_mangle]
-pub extern "C" fn live_clock_timestamp_ms(clock: &mut LiveClock_API) -> u64 {
-    clock.timestamp_ms()
-}
-
-#[no_mangle]
-pub extern "C" fn live_clock_timestamp_us(clock: &mut LiveClock_API) -> u64 {
-    clock.timestamp_us()
-}
-
-#[no_mangle]
-pub extern "C" fn live_clock_timestamp_ns(clock: &mut LiveClock_API) -> u64 {
-    clock.timestamp_ns()
-}
-
-////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
+    use pyo3::types::PyList;
+
     use super::*;
 
     #[test]
     fn test_monotonic_clock_increasing() {
         let mut clock = MonotonicClock::new();
         let secs1 = clock.unix_timestamp_secs();
         let secs2 = clock.unix_timestamp_secs();
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/common/src/lib.rs` & `nautilus_trader-1.175.0/nautilus_core/common/src/lib.rs`

 * *Files 13% similar despite different names*

```diff
@@ -10,12 +10,15 @@
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 pub mod clock;
+pub mod clock_api;
 pub mod enums;
 pub mod logging;
+pub mod logging_api;
 pub mod msgbus;
 pub mod testing;
 pub mod timer;
+pub mod timer_api;
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/common/src/logging.rs` & `nautilus_trader-1.175.0/nautilus_core/common/src/logging.rs`

 * *Files 21% similar despite different names*

```diff
@@ -9,96 +9,93 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::collections::HashMap;
-use std::ffi::c_char;
-use std::fmt;
-use std::fs::{create_dir_all, File};
-use std::io::{Stderr, Stdout};
-use std::path::{Path, PathBuf};
-use std::sync::mpsc::{channel, Receiver, SendError, Sender};
 use std::{
-    io::{self, BufWriter, Write},
-    ops::{Deref, DerefMut},
+    collections::HashMap,
+    fmt,
+    fs::{create_dir_all, File},
+    io::{self, BufWriter, Stderr, Stdout, Write},
+    path::{Path, PathBuf},
+    sync::mpsc::{channel, Receiver, SendError, Sender},
     thread,
 };
 
-use chrono::prelude::*;
-use chrono::Utc;
-use nautilus_core::datetime::unix_nanos_to_iso8601;
-use nautilus_core::parsing::optional_bytes_to_json;
-use nautilus_core::string::{cstr_to_string, optional_cstr_to_string, string_to_cstr};
-use nautilus_core::time::UnixNanos;
-use nautilus_core::uuid::UUID4;
+use chrono::{prelude::*, Utc};
+use nautilus_core::{datetime::unix_nanos_to_iso8601, time::UnixNanos, uuid::UUID4};
 use nautilus_model::identifiers::trader_id::TraderId;
 use serde::{Deserialize, Serialize};
 use serde_json::Value;
 
 use crate::enums::{LogColor, LogLevel};
 
+/// Provides a high-performance logger utilizing a MPSC channel under the hood.
+///
+/// A separate thead is spawned at initialization which receives [`LogEvent`] structs over the
+/// channel.
 pub struct Logger {
-    tx: Sender<LogMessage>,
+    tx: Sender<LogEvent>,
     /// The trader ID for the logger.
     pub trader_id: TraderId,
     /// The machine ID for the logger.
     pub machine_id: String,
     /// The instance ID for the logger.
     pub instance_id: UUID4,
     /// The minimum log level to write to stdout.
     pub level_stdout: LogLevel,
     /// The minimum log level to write to a log file.
     pub level_file: Option<LogLevel>,
     /// If logging is bypassed.
     pub is_bypassed: bool,
 }
 
+/// Represents a log event which includes a message.
 #[derive(Clone, Debug, Serialize, Deserialize)]
-pub struct LogMessage {
-    timestamp_ns: UnixNanos,
+pub struct LogEvent {
+    /// The UNIX nanoseconds timestamp when the log event occurred.
+    timestamp: UnixNanos,
+    /// The log level for the event.
     level: LogLevel,
     #[serde(skip_serializing)]
+    /// The color for the log message content.
     color: LogColor,
+    /// The Nautilus system component the log event originated from.
     component: String,
-    msg: String,
+    /// The log message content.
+    message: String,
 }
 
-impl fmt::Display for LogMessage {
+impl fmt::Display for LogEvent {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> std::fmt::Result {
         write!(
             f,
             "{} [{}] {}: {}",
-            self.timestamp_ns, self.level, self.component, self.msg
+            self.timestamp, self.level, self.component, self.message
         )
     }
 }
 
-/// Provides a high-performance logger utilizing a MPSC channel under the hood.
-///
-/// A separate thead is spawned at initialization which receives `LogMessage` structs over the
-/// channel. Rate limiting is implemented using a simple token bucket algorithm (maximum messages
-/// per second).
 #[allow(clippy::too_many_arguments)]
 impl Logger {
     pub fn new(
         trader_id: TraderId,
         machine_id: String,
         instance_id: UUID4,
         level_stdout: LogLevel,
         level_file: Option<LogLevel>,
         directory: Option<String>,
         file_name: Option<String>,
         file_format: Option<String>,
         component_levels: Option<HashMap<String, Value>>,
         is_bypassed: bool,
     ) -> Self {
-        let (tx, rx) = channel::<LogMessage>();
+        let (tx, rx) = channel::<LogEvent>();
         let mut level_filters = HashMap::<String, LogLevel>::new();
 
         if let Some(component_levels_map) = component_levels {
             for (key, value) in component_levels_map {
                 match serde_json::from_value::<LogLevel>(value) {
                     Ok(level) => {
                         level_filters.insert(key, level);
@@ -144,15 +141,15 @@
         instance_id: &str,
         level_stdout: LogLevel,
         level_file: Option<LogLevel>,
         directory: Option<String>,
         file_name: Option<String>,
         file_format: Option<String>,
         level_filters: HashMap<String, LogLevel>,
-        rx: Receiver<LogMessage>,
+        rx: Receiver<LogEvent>,
     ) {
         // Setup std I/O buffers
         let mut out_buf = BufWriter::new(io::stdout());
         let mut err_buf = BufWriter::new(io::stderr());
 
         // Setup log file
         let is_json_format = match file_format.as_ref().map(|s| s.to_lowercase()) {
@@ -188,35 +185,35 @@
             None
         };
 
         let mut file_buf = file.map(BufWriter::new);
 
         // Setup templates for formatting
         let template_console = String::from(
-            "\x1b[1m{ts}\x1b[0m {color}[{level}] {trader_id}.{component}: {msg}\x1b[0m\n",
+            "\x1b[1m{ts}\x1b[0m {color}[{level}] {trader_id}.{component}: {message}\x1b[0m\n",
         );
-        let template_file = String::from("{ts} [{level}] {trader_id}.{component}: {msg}\n");
+        let template_file = String::from("{ts} [{level}] {trader_id}.{component}: {message}\n");
 
-        // Continue to receive and handle log messages until channel is hung up
-        while let Ok(log_msg) = rx.recv() {
-            let component_level = level_filters.get(&log_msg.component);
+        // Continue to receive and handle log events until channel is hung up
+        while let Ok(event) = rx.recv() {
+            let component_level = level_filters.get(&event.component);
 
-            // Check if the component exists in level_filters and if its level is greater than log_msg.level
+            // Check if the component exists in level_filters and if its level is greater than event.level
             if let Some(&filter_level) = component_level {
-                if log_msg.level < filter_level {
+                if event.level < filter_level {
                     continue;
                 }
             }
 
-            if log_msg.level >= LogLevel::Error {
-                let line = Self::format_log_line_console(&log_msg, trader_id, &template_console);
+            if event.level >= LogLevel::Error {
+                let line = Self::format_log_line_console(&event, trader_id, &template_console);
                 Self::write_stderr(&mut err_buf, &line);
                 Self::flush_stderr(&mut err_buf);
-            } else if log_msg.level >= level_stdout {
-                let line = Self::format_log_line_console(&log_msg, trader_id, &template_console);
+            } else if event.level >= level_stdout {
+                let line = Self::format_log_line_console(&event, trader_id, &template_console);
                 Self::write_stdout(&mut out_buf, &line);
                 Self::flush_stdout(&mut out_buf);
             }
 
             if let Some(level_file) = level_file {
                 if Self::should_rotate_file(&file_path) {
                     // Ensure previous file buffer flushed
@@ -237,18 +234,18 @@
                         .append(true)
                         .open(file_path)
                         .expect("Error creating log file");
 
                     file_buf = Some(BufWriter::new(file));
                 }
 
-                if log_msg.level >= level_file {
+                if event.level >= level_file {
                     if let Some(file_buf) = file_buf.as_mut() {
                         let line = Self::format_log_line_file(
-                            &log_msg,
+                            &event,
                             trader_id,
                             &template_file,
                             is_json_format,
                         );
                         Self::write_file(file_buf, &line);
                         Self::flush_file(file_buf);
                     }
@@ -307,41 +304,41 @@
         }
 
         file_path.push(basename);
         file_path.set_extension(suffix);
         file_path
     }
 
-    fn format_log_line_console(log_msg: &LogMessage, trader_id: &str, template: &str) -> String {
+    fn format_log_line_console(event: &LogEvent, trader_id: &str, template: &str) -> String {
         template
-            .replace("{ts}", &unix_nanos_to_iso8601(log_msg.timestamp_ns))
-            .replace("{color}", &log_msg.color.to_string())
-            .replace("{level}", &log_msg.level.to_string())
+            .replace("{ts}", &unix_nanos_to_iso8601(event.timestamp))
+            .replace("{color}", &event.color.to_string())
+            .replace("{level}", &event.level.to_string())
             .replace("{trader_id}", trader_id)
-            .replace("{component}", &log_msg.component)
-            .replace("{msg}", &log_msg.msg)
+            .replace("{component}", &event.component)
+            .replace("{message}", &event.message)
     }
 
     fn format_log_line_file(
-        log_msg: &LogMessage,
+        event: &LogEvent,
         trader_id: &str,
         template: &str,
         is_json_format: bool,
     ) -> String {
         if is_json_format {
             let json_string =
-                serde_json::to_string(log_msg).expect("Error serializing log message to string");
+                serde_json::to_string(event).expect("Error serializing log event to string");
             format!("{}\n", json_string)
         } else {
             template
-                .replace("{ts}", &unix_nanos_to_iso8601(log_msg.timestamp_ns))
-                .replace("{level}", &log_msg.level.to_string())
+                .replace("{ts}", &unix_nanos_to_iso8601(event.timestamp))
+                .replace("{level}", &event.level.to_string())
                 .replace("{trader_id}", trader_id)
-                .replace("{component}", &log_msg.component)
-                .replace("{msg}", &log_msg.msg)
+                .replace("{component}", &event.component)
+                .replace("{message}", &event.message)
         }
     }
 
     fn write_stdout(out_buf: &mut BufWriter<Stdout>, line: &str) {
         match out_buf.write_all(line.as_bytes()) {
             Ok(_) => {}
             Err(e) => eprintln!("Error writing to stdout: {e:?}"),
@@ -379,172 +376,74 @@
     fn flush_file(file_buf: &mut BufWriter<File>) {
         match file_buf.flush() {
             Ok(_) => {}
             Err(e) => eprintln!("Error writing to file: {e:?}"),
         }
     }
 
-    fn send(
+    pub fn send(
         &mut self,
-        timestamp_ns: u64,
+        timestamp: u64,
         level: LogLevel,
         color: LogColor,
         component: String,
-        msg: String,
+        message: String,
     ) {
-        let log_message = LogMessage {
-            timestamp_ns,
+        let event = LogEvent {
+            timestamp,
             level,
             color,
             component,
-            msg,
+            message,
         };
-        if let Err(SendError(msg)) = self.tx.send(log_message) {
-            eprintln!("Error sending log message: {}", msg);
+        if let Err(SendError(e)) = self.tx.send(event) {
+            eprintln!("Error sending log event: {}", e);
         }
     }
 
-    pub fn debug(&mut self, timestamp_ns: u64, color: LogColor, component: String, msg: String) {
-        self.send(timestamp_ns, LogLevel::Debug, color, component, msg)
+    pub fn debug(&mut self, timestamp: u64, color: LogColor, component: String, message: String) {
+        self.send(timestamp, LogLevel::Debug, color, component, message)
     }
 
-    pub fn info(&mut self, timestamp_ns: u64, color: LogColor, component: String, msg: String) {
-        self.send(timestamp_ns, LogLevel::Info, color, component, msg)
+    pub fn info(&mut self, timestamp: u64, color: LogColor, component: String, message: String) {
+        self.send(timestamp, LogLevel::Info, color, component, message)
     }
 
-    pub fn warn(&mut self, timestamp_ns: u64, color: LogColor, component: String, msg: String) {
-        self.send(timestamp_ns, LogLevel::Warning, color, component, msg)
+    pub fn warn(&mut self, timestamp: u64, color: LogColor, component: String, message: String) {
+        self.send(timestamp, LogLevel::Warning, color, component, message)
     }
 
-    pub fn error(&mut self, timestamp_ns: u64, color: LogColor, component: String, msg: String) {
-        self.send(timestamp_ns, LogLevel::Error, color, component, msg)
+    pub fn error(&mut self, timestamp: u64, color: LogColor, component: String, message: String) {
+        self.send(timestamp, LogLevel::Error, color, component, message)
     }
 
-    pub fn critical(&mut self, timestamp_ns: u64, color: LogColor, component: String, msg: String) {
-        self.send(timestamp_ns, LogLevel::Critical, color, component, msg)
-    }
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// C API
-////////////////////////////////////////////////////////////////////////////////
-/// Logger is not C FFI safe, so we box and pass it as an opaque pointer.
-/// This works because Logger fields don't need to be accessed, only functions
-/// are called.
-#[repr(C)]
-pub struct CLogger(Box<Logger>);
-
-impl Deref for CLogger {
-    type Target = Logger;
-
-    fn deref(&self) -> &Self::Target {
-        &self.0
-    }
-}
-
-impl DerefMut for CLogger {
-    fn deref_mut(&mut self) -> &mut Self::Target {
-        &mut self.0
+    pub fn critical(
+        &mut self,
+        timestamp: u64,
+        color: LogColor,
+        component: String,
+        message: String,
+    ) {
+        self.send(timestamp, LogLevel::Critical, color, component, message)
     }
 }
 
-/// Creates a new logger.
-///
-/// # Safety
-/// - Assumes `trader_id_ptr` is a valid C string pointer.
-/// - Assumes `machine_id_ptr` is a valid C string pointer.
-/// - Assumes `instance_id_ptr` is a valid C string pointer.
-#[no_mangle]
-pub unsafe extern "C" fn logger_new(
-    trader_id_ptr: *const c_char,
-    machine_id_ptr: *const c_char,
-    instance_id_ptr: *const c_char,
-    level_stdout: LogLevel,
-    level_file: LogLevel,
-    file_logging: u8,
-    directory_ptr: *const c_char,
-    file_name_ptr: *const c_char,
-    file_format_ptr: *const c_char,
-    component_levels_ptr: *const c_char,
-    is_bypassed: u8,
-) -> CLogger {
-    CLogger(Box::new(Logger::new(
-        TraderId::new(&cstr_to_string(trader_id_ptr)),
-        String::from(&cstr_to_string(machine_id_ptr)),
-        UUID4::from(cstr_to_string(instance_id_ptr).as_str()),
-        level_stdout,
-        if file_logging != 0 {
-            Some(level_file)
-        } else {
-            None
-        },
-        optional_cstr_to_string(directory_ptr),
-        optional_cstr_to_string(file_name_ptr),
-        optional_cstr_to_string(file_format_ptr),
-        optional_bytes_to_json(component_levels_ptr),
-        is_bypassed != 0,
-    )))
-}
-
-#[no_mangle]
-pub extern "C" fn logger_drop(logger: CLogger) {
-    drop(logger); // Memory freed here
-}
-
-#[no_mangle]
-pub extern "C" fn logger_get_trader_id_cstr(logger: &CLogger) -> *const c_char {
-    string_to_cstr(&logger.trader_id.to_string())
-}
-
-#[no_mangle]
-pub extern "C" fn logger_get_machine_id_cstr(logger: &CLogger) -> *const c_char {
-    string_to_cstr(&logger.machine_id)
-}
-
-#[no_mangle]
-pub extern "C" fn logger_get_instance_id(logger: &CLogger) -> UUID4 {
-    logger.instance_id.clone()
-}
-
-#[no_mangle]
-pub extern "C" fn logger_is_bypassed(logger: &CLogger) -> u8 {
-    logger.is_bypassed as u8
-}
-
-/// Log a message.
-///
-/// # Safety
-/// - Assumes `component_ptr` is a valid C string pointer.
-/// - Assumes `msg_ptr` is a valid C string pointer.
-#[no_mangle]
-pub unsafe extern "C" fn logger_log(
-    logger: &mut CLogger,
-    timestamp_ns: u64,
-    level: LogLevel,
-    color: LogColor,
-    component_ptr: *const c_char,
-    msg_ptr: *const c_char,
-) {
-    let component = cstr_to_string(component_ptr);
-    let msg = cstr_to_string(msg_ptr);
-    logger.send(timestamp_ns, level, color, component, msg);
-}
-
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
-    use crate::testing::wait_until;
+    use std::time::Duration;
 
-    use super::*;
     use nautilus_core::uuid::UUID4;
     use nautilus_model::identifiers::trader_id::TraderId;
-    use std::{cell::RefCell, fs, path::PathBuf, time::Duration};
-    use tempfile::NamedTempFile;
+    use tempfile::tempdir;
+
+    use super::*;
+    use crate::testing::wait_until;
 
     fn create_logger() -> Logger {
         Logger::new(
             TraderId::new("TRADER-001"),
             String::from("user-01"),
             UUID4::new(),
             LogLevel::Info,
@@ -555,29 +454,29 @@
             None,
             false,
         )
     }
 
     #[test]
     fn log_message_serialization() {
-        let log_message = LogMessage {
-            timestamp_ns: 1_000_000_000,
+        let log_message = LogEvent {
+            timestamp: 1_000_000_000,
             level: LogLevel::Info,
             color: LogColor::Normal,
             component: "Portfolio".to_string(),
-            msg: "This is a log message".to_string(),
+            message: "This is a log message".to_string(),
         };
 
         let serialized_json = serde_json::to_string(&log_message).unwrap();
         let deserialized_value: Value = serde_json::from_str(&serialized_json).unwrap();
 
-        assert_eq!(deserialized_value["timestamp_ns"], 1_000_000_000);
+        assert_eq!(deserialized_value["timestamp"], 1_000_000_000);
         assert_eq!(deserialized_value["level"], "INFO");
         assert_eq!(deserialized_value["component"], "Portfolio");
-        assert_eq!(deserialized_value["msg"], "This is a log message");
+        assert_eq!(deserialized_value["message"], "This is a log message");
     }
 
     #[test]
     fn test_new_logger() {
         let logger = create_logger();
 
         assert_eq!(logger.trader_id, TraderId::new("TRADER-001"));
@@ -587,194 +486,220 @@
     }
 
     #[test]
     fn test_logger_debug() {
         let mut logger = create_logger();
 
         logger.debug(
-            1650000000000000,
+            1_650_000_000_000_000,
             LogColor::Normal,
             String::from("RiskEngine"),
             String::from("This is a test debug message."),
         );
     }
 
     #[test]
     fn test_logger_info() {
         let mut logger = create_logger();
 
         logger.info(
-            1650000000000000,
+            1_650_000_000_000_000,
             LogColor::Normal,
             String::from("RiskEngine"),
             String::from("This is a test info message."),
         );
     }
 
     #[test]
     fn test_logger_error() {
         let mut logger = create_logger();
 
         logger.error(
-            1650000000000000,
+            1_650_000_000_000_000,
             LogColor::Normal,
             String::from("RiskEngine"),
             String::from("This is a test error message."),
         );
     }
 
     #[test]
     fn test_logger_critical() {
         let mut logger = create_logger();
 
         logger.critical(
-            1650000000000000,
+            1_650_000_000_000_000,
             LogColor::Normal,
             String::from("RiskEngine"),
             String::from("This is a test critical message."),
         );
     }
 
-    #[ignore]
     #[test]
     fn test_logging_to_file() {
-        let temp_log_file = NamedTempFile::new().expect("Failed to create temporary log file");
-        let log_file_path = temp_log_file.path();
-
-        // Add the ".log" suffix to the log file path
-        let mut log_file_path_with_suffix = PathBuf::from(log_file_path);
-        log_file_path_with_suffix.set_extension("log");
-        let log_file_path_with_suffix_str =
-            RefCell::new(log_file_path_with_suffix.to_str().unwrap().to_string());
+        let temp_dir = tempdir().expect("Failed to create temporary directory");
 
         let mut logger = Logger::new(
             TraderId::new("TRADER-001"),
             String::from("user-01"),
             UUID4::new(),
             LogLevel::Info,
             Some(LogLevel::Debug),
-            Some(log_file_path.to_str().unwrap().to_string()),
+            Some(temp_dir.path().to_str().unwrap().to_string()),
             None,
             None,
             None,
             false,
         );
 
         logger.info(
-            1650000000000000,
+            1_650_000_000_000_000,
             LogColor::Normal,
             String::from("RiskEngine"),
             String::from("This is a test."),
         );
 
         let mut log_contents = String::new();
 
         wait_until(
             || {
-                log_contents = fs::read_to_string(log_file_path_with_suffix_str.borrow().clone())
-                    .expect("Error while reading log file");
+                let log_file_exists = std::fs::read_dir(&temp_dir)
+                    .expect("Failed to read directory")
+                    .filter_map(Result::ok)
+                    .filter(|entry| entry.path().is_file())
+                    .next()
+                    .is_some();
+
+                log_file_exists
+            },
+            Duration::from_secs(2),
+        );
+
+        wait_until(
+            || {
+                let log_file_path = std::fs::read_dir(&temp_dir)
+                    .expect("Failed to read directory")
+                    .filter_map(Result::ok)
+                    .filter(|entry| entry.path().is_file())
+                    .next()
+                    .expect("No files found in directory")
+                    .path();
+                log_contents =
+                    std::fs::read_to_string(&log_file_path).expect("Error while reading log file");
                 !log_contents.is_empty()
             },
-            Duration::from_secs(3),
+            Duration::from_secs(2),
         );
 
         assert_eq!(
             log_contents,
             "1970-01-20T02:20:00.000000000Z [INF] TRADER-001.RiskEngine: This is a test.\n"
         );
     }
 
-    #[ignore]
     #[test]
     fn test_log_component_level_filtering() {
-        let temp_log_file = NamedTempFile::new().expect("Failed to create temporary log file");
-        let log_file_path = temp_log_file.path();
-
-        // Add the ".log" suffix to the log file path
-        let mut log_file_path_with_suffix = PathBuf::from(log_file_path);
-        log_file_path_with_suffix.set_extension("log");
-        let log_file_path_with_suffix_str =
-            RefCell::new(log_file_path_with_suffix.to_str().unwrap().to_string());
-
-        let component_levels = HashMap::from_iter(std::iter::once((
-            String::from("RiskEngine"),
-            Value::from("ERROR"), // <-- This should be filtered
-        )));
+        let temp_dir = tempdir().expect("Failed to create temporary directory");
 
         let mut logger = Logger::new(
             TraderId::new("TRADER-001"),
             String::from("user-01"),
             UUID4::new(),
             LogLevel::Info,
             Some(LogLevel::Debug),
-            Some(log_file_path.to_str().unwrap().to_string()),
+            Some(temp_dir.path().to_str().unwrap().to_string()),
             None,
             None,
-            Some(component_levels),
+            Some(HashMap::from_iter(std::iter::once((
+                String::from("RiskEngine"),
+                Value::from("ERROR"), // <-- This should be filtered
+            )))),
             false,
         );
 
         logger.info(
-            1650000000000000,
+            1_650_000_000_000_000,
             LogColor::Normal,
             String::from("RiskEngine"),
             String::from("This is a test."),
         );
 
-        thread::sleep(Duration::from_secs(1));
+        wait_until(
+            || {
+                if let Some(log_file) = std::fs::read_dir(&temp_dir)
+                    .expect("Failed to read directory")
+                    .filter_map(Result::ok)
+                    .filter(|entry| entry.path().is_file())
+                    .next()
+                {
+                    let log_file_path = log_file.path();
+                    let log_contents = std::fs::read_to_string(&log_file_path)
+                        .expect("Error while reading log file");
+                    !log_contents.contains("RiskEngine")
+                } else {
+                    false
+                }
+            },
+            Duration::from_secs(3),
+        );
 
         assert!(
-            fs::read_to_string(log_file_path_with_suffix_str.borrow().clone())
-                .expect("Error while reading log file")
-                .is_empty()
+            std::fs::read_dir(&temp_dir)
+                .expect("Failed to read directory")
+                .filter_map(Result::ok)
+                .filter(|entry| entry.path().is_file())
+                .next()
+                .is_some(),
+            "Log file exists"
         );
     }
 
-    #[ignore]
     #[test]
     fn test_logging_to_file_in_json_format() {
-        let temp_log_file = NamedTempFile::new().expect("Failed to create temporary log file");
-        let log_file_path = temp_log_file.path();
-
-        // Add the ".log" suffix to the log file path
-        let mut log_file_path_with_suffix = PathBuf::from(log_file_path);
-        log_file_path_with_suffix.set_extension("json");
-        let log_file_path_with_suffix_str =
-            RefCell::new(log_file_path_with_suffix.to_str().unwrap().to_string());
+        let temp_dir = tempdir().expect("Failed to create temporary directory");
 
         let mut logger = Logger::new(
             TraderId::new("TRADER-001"),
             String::from("user-01"),
             UUID4::new(),
             LogLevel::Info,
             Some(LogLevel::Debug),
+            Some(temp_dir.path().to_str().unwrap().to_string()),
             None,
-            Some(log_file_path.to_str().unwrap().to_string()),
             Some("json".to_string()),
             None,
             false,
         );
 
         logger.info(
-            1650000000000000,
+            1_650_000_000_000_000,
             LogColor::Normal,
             String::from("RiskEngine"),
             String::from("This is a test."),
         );
 
         let mut log_contents = String::new();
 
         wait_until(
             || {
-                log_contents = fs::read_to_string(log_file_path_with_suffix_str.borrow().clone())
-                    .expect("Error while reading log file");
-                !log_contents.is_empty()
+                if let Some(log_file) = std::fs::read_dir(&temp_dir)
+                    .expect("Failed to read directory")
+                    .filter_map(Result::ok)
+                    .filter(|entry| entry.path().is_file())
+                    .next()
+                {
+                    let log_file_path = log_file.path();
+                    log_contents = std::fs::read_to_string(&log_file_path)
+                        .expect("Error while reading log file");
+                    !log_contents.is_empty()
+                } else {
+                    false
+                }
             },
-            Duration::from_secs(3),
+            Duration::from_secs(2),
         );
 
         assert_eq!(
-            log_contents,
-            "{\"timestamp_ns\":1650000000000000,\"level\":\"INFO\",\"component\":\"RiskEngine\",\"msg\":\"This is a test.\"}\n"
-        );
+        log_contents,
+        "{\"timestamp\":1650000000000000,\"level\":\"INFO\",\"component\":\"RiskEngine\",\"message\":\"This is a test.\"}\n"
+    );
     }
 }
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/common/src/msgbus.rs` & `nautilus_trader-1.175.0/nautilus_core/common/src/msgbus.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_core/common/src/testing.rs` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/schemas/wallet.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,36 +1,29 @@
-// -------------------------------------------------------------------------------------------------
-//  Copyright (C) 2015-2023 Nautech Systems Pty Ltd. All rights reserved.
-//  https://nautechsystems.io
-//
-//  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
-//  You may not use this file except in compliance with the License.
-//  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
-//
-//  Unless required by applicable law or agreed to in writing, software
-//  distributed under the License is distributed on an "AS IS" BASIS,
-//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-//  See the License for the specific language governing permissions and
-//  limitations under the License.
-// -------------------------------------------------------------------------------------------------
-
-use std::thread;
-use std::time::{Duration, Instant};
-
-pub fn wait_until<F>(mut condition: F, timeout: Duration)
-where
-    F: FnMut() -> bool,
-{
-    let start_time = Instant::now();
-
-    loop {
-        if condition() {
-            break;
-        }
-
-        if start_time.elapsed() > timeout {
-            panic!("Timeout waiting for condition");
-        }
-
-        thread::sleep(Duration::from_millis(100));
-    }
-}
+# -------------------------------------------------------------------------------------------------
+#  Copyright (C) 2015-2023 Nautech Systems Pty Ltd. All rights reserved.
+#  https://nautechsystems.io
+#
+#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
+#  You may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+# -------------------------------------------------------------------------------------------------
+
+import msgspec
+
+
+################################################################################
+# HTTP responses
+################################################################################
+
+
+class BinanceFuturesCommissionRate(msgspec.Struct, frozen=True):
+    """Schema of a single `Binance Futures` commissionRate."""
+
+    symbol: str
+    makerCommissionRate: str
+    takerCommissionRate: str
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/common/src/timer.rs` & `nautilus_trader-1.175.0/nautilus_core/common/src/timer.rs`

 * *Files 14% similar despite different names*

```diff
@@ -9,23 +9,25 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::cmp::Ordering;
-use std::ffi::c_char;
-use std::fmt::{Display, Formatter};
-use std::rc::Rc;
-
-use nautilus_core::correctness;
-use nautilus_core::string::{cstr_to_string, string_to_cstr};
-use nautilus_core::time::{TimedeltaNanos, UnixNanos};
-use nautilus_core::uuid::UUID4;
+use std::{
+    cmp::Ordering,
+    fmt::{Display, Formatter},
+    rc::Rc,
+};
+
+use nautilus_core::{
+    correctness,
+    time::{TimedeltaNanos, UnixNanos},
+    uuid::UUID4,
+};
 use pyo3::ffi;
 
 #[repr(C)]
 #[derive(Clone, Debug)]
 #[allow(clippy::redundant_allocation)] // C ABI compatibility
 /// Represents a time event occurring at the event timestamp.
 pub struct TimeEvent {
@@ -95,50 +97,14 @@
 
 impl Ord for TimeEventHandler {
     fn cmp(&self, other: &Self) -> Ordering {
         self.event.ts_event.cmp(&other.event.ts_event)
     }
 }
 
-////////////////////////////////////////////////////////////////////////////////
-// C API
-////////////////////////////////////////////////////////////////////////////////
-/// # Safety
-/// - Assumes `name` is borrowed from a valid Python UTF-8 `str`.
-#[no_mangle]
-pub unsafe extern "C" fn time_event_new(
-    name: *const c_char,
-    event_id: UUID4,
-    ts_event: u64,
-    ts_init: u64,
-) -> TimeEvent {
-    TimeEvent::new(cstr_to_string(name), event_id, ts_event, ts_init)
-}
-
-#[no_mangle]
-pub extern "C" fn time_event_clone(event: &TimeEvent) -> TimeEvent {
-    event.clone()
-}
-
-#[no_mangle]
-pub extern "C" fn time_event_drop(event: TimeEvent) {
-    drop(event); // Memory freed here
-}
-
-#[no_mangle]
-pub extern "C" fn time_event_name_to_cstr(event: &TimeEvent) -> *const c_char {
-    string_to_cstr(&event.name)
-}
-
-/// Returns a [`TimeEvent`] as a C string pointer.
-#[no_mangle]
-pub extern "C" fn time_event_to_cstr(event: &TimeEvent) -> *const c_char {
-    string_to_cstr(&event.to_string())
-}
-
 pub trait Timer {
     fn new(
         name: String,
         interval_ns: TimedeltaNanos,
         start_time_ns: UnixNanos,
         stop_time_ns: Option<UnixNanos>,
     ) -> Self;
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/common/tests/test_clock.rs` & `nautilus_trader-1.175.0/nautilus_core/common/src/testing.rs`

 * *Files 26% similar despite different names*

```diff
@@ -9,71 +9,64 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-// use std::ffi::CStr;
-//
-// use nautilus_common::clock::{test_clock_new, test_clock_set_time_alert_ns};
-// use pyo3::ffi;
-// use pyo3::types::PyList;
-// use pyo3::{IntoPyPointer, Python};
+use std::{
+    thread,
+    time::{Duration, Instant},
+};
 
-// #[test]
-// fn test_clock_advance() {
-//     unsafe {
-//         let mut clock = test_clock_new();
-//         let timer_name = "test-timer-001";
-//         let name_ptr = CStr::from_bytes_with_nul_unchecked(timer_name.as_bytes()).as_ptr();
-//
-//         test_clock_set_time_alert_ns(&mut clock, name_ptr, 2_000);
-//         assert_eq!(clock.timers.len(), 1);
-//         assert_eq!(clock.timers.keys().next().unwrap().as_str(), timer_name);
-//
-//         let events = clock.advance_time(3_000, true);
-//
-//         assert!(clock.timers.values().next().unwrap().is_expired);
-//         assert_eq!(events.len(), 1);
-//         assert_eq!(
-//             events.first().unwrap().name.to_string(),
-//             String::from_str(timer_name).unwrap()
-//         );
-//     }
-// }
+/// Repeatedly evaluates a condition with a delay until it becomes true or a timeout occurs.
+///
+/// # Arguments
+///
+/// * `condition` - A closure that represents the condition to be met. This closure should return `true`
+///                 when the condition is met and `false` otherwise.
+/// * `timeout` - The maximum amount of time to wait for the condition to be met. If this duration is
+///               exceeded, the function will panic.
+///
+/// # Panics
+///
+/// This function will panic if the timeout duration is exceeded without the condition being met.
+///
+/// # Examples
+///
+/// ```
+/// use std::time::Duration;
+/// use std::thread;
+/// use nautilus_common::testing::wait_until;
+///
+/// let start_time = std::time::Instant::now();
+/// let timeout = Duration::from_secs(5);
+///
+/// wait_until(|| {
+///     if start_time.elapsed().as_secs() > 2 {
+///         true
+///     } else {
+///         false
+///     }
+/// }, timeout);
+/// ```
+///
+/// In the above example, the `wait_until` function will block for at least 2 seconds, as that's how long
+/// it takes for the condition to be met. If the condition was not met within 5 seconds, it would panic.
+pub fn wait_until<F>(mut condition: F, timeout: Duration)
+where
+    F: FnMut() -> bool,
+{
+    let start_time = Instant::now();
 
-// #[test]
-// fn test_clock_event_callback() {
-//     unsafe {
-//         let mut test_clock = test_clock_new();
-//         let timer_name = "test-timer-001";
-//         let name_ptr = CStr::from_bytes_with_nul_unchecked(timer_name.as_bytes()).as_ptr();
-//         test_clock_set_time_alert_ns(&mut test_clock, name_ptr, 2_000, None);
-//         let events = test_clock.advance_time(3_000, true);
-//         assert_eq!(events.len(), 1); // TODO
-//     }
-// }
+    loop {
+        if condition() {
+            break;
+        }
 
-// #[test]
-// fn test_clock_event_callback() {
-//     unsafe {
-//         Python::with_gil(|py| {
-//             let mut test_clock = test_clock_new();
-//             let timer_name = "test-timer-001";
-//             let name_ptr = CStr::from_bytes_with_nul_unchecked(timer_name.as_bytes()).as_ptr();
-//
-//             let py_list = PyList::empty(py);
-//             let py_append = py_list.getattr("append").unwrap();
-//
-//             test_clock_set_time_alert_ns(
-//                 &mut test_clock,
-//                 name_ptr,
-//                 2_000,
-//                 std::ptr::null_mut() as *mut ffi::PyObject,
-//             );
-//
-//             let events = test_clock.advance_time(3_000, true);
-//             assert_eq!(events.len(), 1);
-//         })
-//     }
-// }
+        if start_time.elapsed() > timeout {
+            panic!("Timeout waiting for condition");
+        }
+
+        thread::sleep(Duration::from_millis(100));
+    }
+}
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/core/Cargo.toml` & `nautilus_trader-1.175.0/nautilus_core/core/Cargo.toml`

 * *Files 14% similar despite different names*

```diff
@@ -1,22 +1,23 @@
 [package]
-name = "nautilus_core"
+name = "nautilus-core"
 version.workspace = true
 edition.workspace = true
 authors.workspace = true
 description.workspace = true
 documentation.workspace = true
 
 [lib]
 name = "nautilus_core"
 crate-type = ["rlib", "staticlib"]
 
 [dependencies]
 chrono.workspace = true
 pyo3.workspace = true
+serde.workspace = true
 serde_json.workspace = true
 uuid.workspace = true
 
 [features]
 extension-module = ["pyo3/extension-module"]
 default = []
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/core/benches/criterion_time_benchmark.rs` & `nautilus_trader-1.175.0/nautilus_core/core/benches/criterion_time_benchmark.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_core/core/build.rs` & `nautilus_trader-1.175.0/nautilus_core/core/build.rs`

 * *Files 4% similar despite different names*

```diff
@@ -11,18 +11,20 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 extern crate cbindgen;
 
-use std::env;
-use std::fs::File;
-use std::io::{Read, Write};
-use std::path::PathBuf;
+use std::{
+    env,
+    fs::File,
+    io::{Read, Write},
+    path::PathBuf,
+};
 
 #[allow(clippy::expect_used)] // OK in build script
 fn main() {
     let crate_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
 
     // Generate C headers
     let config_c = cbindgen::Config::from_file("cbindgen.toml")
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/core/cbindgen.toml` & `nautilus_trader-1.175.0/nautilus_core/core/cbindgen.toml`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_core/core/cbindgen_cython.toml` & `nautilus_trader-1.175.0/nautilus_core/core/cbindgen_cython.toml`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_core/core/src/correctness.rs` & `nautilus_trader-1.175.0/nautilus_core/core/src/correctness.rs`

 * *Files 5% similar despite different names*

```diff
@@ -14,14 +14,15 @@
 // -------------------------------------------------------------------------------------------------
 
 const FAILED: &str = "Condition check failed:";
 
 /// Check string `s` is valid.
 ///
 /// # Panics
+///
 /// - If `s` is empty.
 /// - If `s` is all whitespace.
 /// - If `s` contains a Non-ASCII character.
 pub fn valid_string(s: &str, desc: &str) {
     if s.is_empty() {
         panic!("{FAILED} invalid string for {desc}, was empty");
     } else if s.as_bytes().iter().all(u8::is_ascii_whitespace) {
@@ -30,74 +31,81 @@
         panic!("{FAILED} invalid string for {desc} contained a non-ASCII char, was '{s}'");
     }
 }
 
 /// Check string `s` contains pattern `pat`.
 ///
 /// # Panics
+///
 /// - If `s` does not contain `pat`.
 pub fn string_contains(s: &str, pat: &str, desc: &str) {
     if !s.contains(pat) {
         panic!("{FAILED} invalid string for {desc} did not contain '{pat}', was '{s}'");
     }
 }
 
 /// Check `u8`s are equal.
 ///
 /// # Panics
+///
 /// - If `lhs` is not equal to `rhs`.
 pub fn u8_equal(lhs: u8, rhs: u8, lhs_param: &str, rhs_param: &str) {
     if lhs != rhs {
         panic!("{FAILED} '{lhs_param}' u8 of {lhs} was not equal to '{rhs_param}' `u8` of {rhs}");
     }
 }
 
 /// Check `u8` value is in range (inclusive).
 ///
 /// # Panics
+///
 /// - If `value` is not within range [`l`, `r`].
 pub fn u8_in_range_inclusive(value: u8, l: u8, r: u8, desc: &str) {
     if !(value.ge(&l) && value.le(&r)) {
         panic!("{FAILED} invalid u8 for {desc} not in range [{l}, {r}], was {value}");
     }
 }
 
 /// Check `u64` value is in range (inclusive).
 ///
 /// # Panics
+///
 /// - If `value` is not within range [`l`, `r`].
 pub fn u64_in_range_inclusive(value: u64, l: u64, r: u64, desc: &str) {
     if !(value.ge(&l) && value.le(&r)) {
         panic!("{FAILED} invalid u64 for {desc} not in range [{l}, {r}], was {value}");
     }
 }
 
 /// Check `i64` value is in range (inclusive).
 ///
 /// # Panics
+///
 /// - If `value` is not within range [`l`, `r`].
 pub fn i64_in_range_inclusive(value: i64, l: i64, r: i64, desc: &str) {
     if !(value.ge(&l) && value.le(&r)) {
         panic!("{FAILED} invalid i64 for {desc} not in range [{l}, {r}], was {value}");
     }
 }
 
 /// Check `f64` value is in range (inclusive).
 ///
 /// # Panics
+///
 /// - If `value` is not within range [`l`, `r`].
 pub fn f64_in_range_inclusive(value: f64, l: f64, r: f64, desc: &str) {
     if !(value.ge(&l) && value.le(&r)) {
         panic!("{FAILED} invalid f64 for {desc} not in range [{l}, {r}], was {value}");
     }
 }
 
 /// Check `f64` value is non negative.
 ///
 /// # Panics
+///
 /// - If `value` is negative.
 pub fn f64_non_negative(value: f64, desc: &str) {
     if value < 0.0 {
         panic!("{FAILED} invalid f64 for {desc} negative, was {value}");
     }
 }
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/core/src/cvec.rs` & `nautilus_trader-1.175.0/nautilus_core/core/src/cvec.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_core/core/src/datetime.rs` & `nautilus_trader-1.175.0/nautilus_core/core/src/datetime.rs`

 * *Files 2% similar despite different names*

```diff
@@ -11,16 +11,18 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::time::{Duration, UNIX_EPOCH};
 
-use chrono::prelude::{DateTime, Utc};
-use chrono::SecondsFormat;
+use chrono::{
+    prelude::{DateTime, Utc},
+    SecondsFormat,
+};
 
 const MILLISECONDS_IN_SECOND: u64 = 1_000;
 const NANOSECONDS_IN_SECOND: u64 = 1_000_000_000;
 const NANOSECONDS_IN_MILLISECOND: u64 = 1_000_000;
 const NANOSECONDS_IN_MICROSECOND: u64 = 1_000;
 
 /// Converts seconds to nanoseconds (ns).
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/core/src/lib.rs` & `nautilus_trader-1.175.0/nautilus_core/core/src/lib.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_core/core/src/parsing.rs` & `nautilus_trader-1.175.0/nautilus_core/core/src/string.rs`

 * *Files 27% similar despite different names*

```diff
@@ -9,146 +9,157 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::{
-    collections::HashMap,
-    ffi::{c_char, CStr},
-};
+use std::ffi::{c_char, CStr, CString};
 
-use serde_json::{Result, Value};
+use pyo3::{ffi, types::PyString, FromPyPointer, Python};
 
-use crate::string::cstr_to_string;
+/// Returns an owned string from a valid Python object pointer.
+///
+/// # Safety
+///
+/// - Assumes `ptr` is borrowed from a valid Python UTF-8 `str`.
+///
+/// # Panics
+///
+/// - If `ptr` is null.
+#[must_use]
+pub unsafe fn pystr_to_string(ptr: *mut ffi::PyObject) -> String {
+    assert!(!ptr.is_null(), "`ptr` was NULL");
+    Python::with_gil(|py| PyString::from_borrowed_ptr(py, ptr).to_string())
+}
 
-/// Convert a C bytes pointer into an owned `Option<HashMap<String, Value>>`.
+/// Convert a C string pointer into an owned `String`.
 ///
 /// # Safety
+///
 /// - Assumes `ptr` is a valid C string pointer.
+///
+/// # Panics
+///
+/// - If `ptr` is null.
 #[must_use]
-pub unsafe fn optional_bytes_to_json(ptr: *const c_char) -> Option<HashMap<String, Value>> {
+pub unsafe fn cstr_to_string(ptr: *const c_char) -> String {
+    assert!(!ptr.is_null(), "`ptr` was NULL");
+    CStr::from_ptr(ptr)
+        .to_str()
+        .expect("CStr::from_ptr failed")
+        .to_string()
+}
+
+/// Convert a C string pointer into an owned `Option<String>`.
+///
+/// # Safety
+///
+/// - Assumes `ptr` is a valid C string pointer.
+#[must_use]
+pub unsafe fn optional_cstr_to_string(ptr: *const c_char) -> Option<String> {
     if ptr.is_null() {
         None
     } else {
-        let c_str = CStr::from_ptr(ptr);
-        let bytes = c_str.to_bytes();
-        let json_string = std::str::from_utf8(bytes).unwrap();
-        let result: Result<HashMap<String, Value>> = serde_json::from_str(json_string);
-        match result {
-            Ok(map) => Some(map),
-            Err(err) => {
-                eprintln!("Error parsing JSON: {}", err);
-                None
-            }
-        }
+        Some(cstr_to_string(ptr))
     }
 }
 
-/// Return the decimal precision inferred from the given string.
-pub fn precision_from_str(s: &str) -> u8 {
-    let lower_s = s.to_lowercase();
-    // Handle scientific notation
-    if lower_s.contains("e-") {
-        return lower_s.split("e-").last().unwrap().parse::<u8>().unwrap();
-    }
-    if !lower_s.contains('.') {
-        return 0;
-    }
-    return lower_s.split('.').last().unwrap().len() as u8;
+/// Create a C string pointer to newly allocated memory from a [&str].
+#[must_use]
+pub fn str_to_cstr(s: &str) -> *const c_char {
+    CString::new(s).expect("CString::new failed").into_raw()
 }
 
-/// Return the decimal precision inferred from the given C string.
+/// Drops the C string memory at the pointer.
 ///
 /// # Safety
+///
 /// - Assumes `ptr` is a valid C string pointer.
+///
 /// # Panics
+///
 /// - If `ptr` is null.
 #[no_mangle]
-pub unsafe extern "C" fn precision_from_cstr(ptr: *const c_char) -> u8 {
-    precision_from_str(&cstr_to_string(ptr))
+pub unsafe extern "C" fn cstr_drop(ptr: *const c_char) {
+    assert!(!ptr.is_null(), "`ptr` was NULL");
+    let cstring = CString::from_raw(ptr as *mut c_char);
+    drop(cstring);
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
-    use std::ffi::CString;
-
-    use rstest::rstest;
+    use pyo3::AsPyPointer;
 
     use super::*;
 
     #[test]
-    fn test_optional_bytes_to_json_null() {
+    fn test_pystr_to_string() {
+        pyo3::prepare_freethreaded_python();
+        // Create a valid Python object pointer
+        let ptr = Python::with_gil(|py| PyString::new(py, "test string1").as_ptr());
+        let result = unsafe { pystr_to_string(ptr) };
+        assert_eq!(result, "test string1");
+    }
+
+    #[test]
+    #[should_panic]
+    fn test_pystr_to_string_with_null_ptr() {
+        // Create a null Python object pointer
+        let ptr: *mut ffi::PyObject = std::ptr::null_mut();
+        unsafe { pystr_to_string(ptr) };
+    }
+
+    #[test]
+    fn test_cstr_to_string() {
+        // Create a valid C string pointer
+        let c_string = CString::new("test string2").expect("CString::new failed");
+        let ptr = c_string.as_ptr();
+        let result = unsafe { cstr_to_string(ptr) };
+        assert_eq!(result, "test string2");
+    }
+
+    #[test]
+    #[should_panic]
+    fn test_cstr_to_string_with_null_ptr() {
+        // Create a null C string pointer
+        let ptr: *const c_char = std::ptr::null();
+        unsafe { cstr_to_string(ptr) };
+    }
+
+    #[test]
+    fn test_optional_cstr_to_string_with_null_ptr() {
+        // Call optional_cstr_to_string with null pointer
         let ptr = std::ptr::null();
-        let result = unsafe { optional_bytes_to_json(ptr) };
-        assert_eq!(result, None);
+        let result = unsafe { optional_cstr_to_string(ptr) };
+        assert!(result.is_none());
+    }
+
+    #[test]
+    fn test_optional_cstr_to_string_with_valid_ptr() {
+        // Create a valid C string
+        let input_str = "hello world";
+        let c_str = CString::new(input_str).expect("CString::new failed");
+        let result = unsafe { optional_cstr_to_string(c_str.as_ptr()) };
+        assert!(result.is_some());
+        assert_eq!(result.unwrap(), input_str);
+    }
+
+    #[test]
+    fn test_string_to_cstr() {
+        let s = "test string";
+        let c_str_ptr = str_to_cstr(s);
+        let c_str = unsafe { CStr::from_ptr(c_str_ptr) };
+        let result = c_str.to_str().expect("CStr::from_ptr failed");
+        assert_eq!(result, s);
     }
 
     #[test]
-    fn test_optional_bytes_to_json_empty() {
-        let json_str = CString::new("{}").unwrap();
-        let ptr = json_str.as_ptr() as *const c_char;
-        let result = unsafe { optional_bytes_to_json(ptr) };
-        assert_eq!(result, Some(HashMap::new()));
-    }
-
-    #[test]
-    fn test_optional_bytes_to_json_valid() {
-        let json_str = CString::new(r#"{"key1": "value1", "key2": 2}"#).unwrap();
-        let ptr = json_str.as_ptr() as *const c_char;
-        let result = unsafe { optional_bytes_to_json(ptr) };
-        let mut expected_map = HashMap::new();
-        expected_map.insert("key1".to_owned(), Value::String("value1".to_owned()));
-        expected_map.insert(
-            "key2".to_owned(),
-            Value::Number(serde_json::Number::from(2)),
-        );
-        assert_eq!(result, Some(expected_map));
-    }
-
-    #[test]
-    fn test_optional_bytes_to_json_invalid() {
-        let json_str = CString::new(r#"{"key1": "value1", "key2": }"#).unwrap();
-        let ptr = json_str.as_ptr() as *const c_char;
-        let result = unsafe { optional_bytes_to_json(ptr) };
-        assert_eq!(result, None);
-    }
-
-    #[rstest(
-        s,
-        expected,
-        case("", 0),
-        case("0", 0),
-        case("1.0", 1),
-        case("1.00", 2),
-        case("1.23456789", 8),
-        case("123456.789101112", 9),
-        case("0.000000001", 9),
-        case("1e-1", 1),
-        case("1e-2", 2),
-        case("1e-3", 3),
-        case("1e8", 0)
-    )]
-    fn test_precision_from_str(s: &str, expected: u8) {
-        let result = precision_from_str(s);
-        assert_eq!(result, expected);
-    }
-
-    #[rstest(
-        input,
-        expected,
-        case("1e8", 0),
-        case("123", 0),
-        case("123.45", 2),
-        case("123.456789", 6),
-        case("1.23456789e-2", 2),
-        case("1.23456789e-12", 12)
-    )]
-    fn test_precision_from_cstr(input: &str, expected: u8) {
-        let c_str = CString::new(input).unwrap();
-        assert_eq!(unsafe { precision_from_cstr(c_str.as_ptr()) }, expected);
+    fn test_cstr_drop() {
+        let c_string = CString::new("test string3").expect("CString::new failed");
+        let ptr = c_string.into_raw(); // <-- pointer _must_ be obtained this way
+        unsafe { cstr_drop(ptr) };
     }
 }
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/core/src/time.rs` & `nautilus_trader-1.175.0/nautilus_core/core/src/time.rs`

 * *Files 0% similar despite different names*

```diff
@@ -55,17 +55,18 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
-    use super::*;
     use std::time::UNIX_EPOCH;
 
+    use super::*;
+
     #[test]
     fn test_duration_since_unix_epoch() {
         let duration = duration_since_unix_epoch();
         let now = SystemTime::now();
 
         // Check if the duration is close to the actual difference between now and UNIX_EPOCH
         let delta = now
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/core/src/uuid.rs` & `nautilus_trader-1.175.0/nautilus_core/core/src/uuid.rs`

 * *Files 6% similar despite different names*

```diff
@@ -9,48 +9,58 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::collections::hash_map::DefaultHasher;
-use std::ffi::{c_char, CStr};
-use std::fmt::{Debug, Display, Formatter};
-use std::hash::{Hash, Hasher};
-use std::rc::Rc;
+use std::{
+    collections::hash_map::DefaultHasher,
+    ffi::{c_char, CStr},
+    fmt::{Debug, Display, Formatter},
+    hash::{Hash, Hasher},
+    str::FromStr,
+    sync::Arc,
+};
 
+use serde::{Deserialize, Deserializer, Serialize, Serializer};
 use uuid::Uuid;
 
-use crate::string::string_to_cstr;
+use crate::string::str_to_cstr;
 
 #[repr(C)]
 #[derive(Clone, Hash, PartialEq, Eq, Debug)]
-#[allow(clippy::box_collection)] // C ABI compatibility
-#[allow(clippy::redundant_allocation)] // C ABI compatibility
 pub struct UUID4 {
-    pub value: Box<Rc<String>>,
+    pub value: Box<Arc<String>>,
 }
 
 impl UUID4 {
     #[must_use]
     pub fn new() -> Self {
         let uuid = Uuid::new_v4();
         UUID4 {
-            value: Box::new(Rc::new(uuid.to_string())),
+            value: Box::new(Arc::new(uuid.to_string())),
         }
     }
 }
 
+impl FromStr for UUID4 {
+    type Err = &'static str;
+
+    fn from_str(s: &str) -> Result<Self, Self::Err> {
+        let uuid = Uuid::parse_str(s).map_err(|_| "Invalid UUID string")?;
+        Ok(Self {
+            value: Box::new(Arc::new(uuid.to_string())),
+        })
+    }
+}
+
 impl From<&str> for UUID4 {
-    fn from(s: &str) -> Self {
-        let uuid = Uuid::try_parse(s).expect("invalid UUID string");
-        Self {
-            value: Box::new(Rc::new(uuid.to_string())),
-        }
+    fn from(input: &str) -> Self {
+        input.parse().unwrap_or_else(|err| panic!("{}", err))
     }
 }
 
 impl Default for UUID4 {
     fn default() -> Self {
         Self::new()
     }
@@ -58,14 +68,33 @@
 
 impl Display for UUID4 {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
         write!(f, "{}", self.value)
     }
 }
 
+impl Serialize for UUID4 {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: Serializer,
+    {
+        self.value.serialize(serializer)
+    }
+}
+
+impl<'de> Deserialize<'de> for UUID4 {
+    fn deserialize<D>(_deserializer: D) -> Result<Self, D::Error>
+    where
+        D: Deserializer<'de>,
+    {
+        let uuid4_str: &str = Deserialize::deserialize(_deserializer)?;
+        let uuid4: UUID4 = uuid4_str.into();
+        Ok(uuid4)
+    }
+}
 ////////////////////////////////////////////////////////////////////////////////
 // C API
 ////////////////////////////////////////////////////////////////////////////////
 #[no_mangle]
 pub extern "C" fn uuid4_new() -> UUID4 {
     UUID4::new()
 }
@@ -79,29 +108,32 @@
 pub extern "C" fn uuid4_drop(uuid4: UUID4) {
     drop(uuid4); // Memory freed here
 }
 
 /// Returns a [`UUID4`] from C string pointer.
 ///
 /// # Safety
+///
 /// - Assumes `ptr` is a valid C string pointer.
+///
 /// # Panics
+///
 /// - If `ptr` cannot be cast to a valid C string.
 #[no_mangle]
 pub unsafe extern "C" fn uuid4_from_cstr(ptr: *const c_char) -> UUID4 {
     UUID4::from(
         CStr::from_ptr(ptr)
             .to_str()
             .unwrap_or_else(|_| panic!("CStr::from_ptr failed")),
     )
 }
 
 #[no_mangle]
 pub extern "C" fn uuid4_to_cstr(uuid: &UUID4) -> *const c_char {
-    string_to_cstr(&uuid.value)
+    str_to_cstr(&uuid.value)
 }
 
 #[no_mangle]
 pub extern "C" fn uuid4_eq(lhs: &UUID4, rhs: &UUID4) -> u8 {
     u8::from(lhs == rhs)
 }
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/indicators/src/ema.rs` & `nautilus_trader-1.175.0/nautilus_core/indicators/src/ema.rs`

 * *Files 15% similar despite different names*

```diff
@@ -9,96 +9,137 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use pyo3::prelude::*;
-
 use nautilus_model::{
     data::{
         bar::Bar,
         tick::{QuoteTick, TradeTick},
     },
     enums::PriceType,
 };
+use pyo3::prelude::*;
 
 use crate::Indicator;
 
-#[pyclass]
+#[repr(C)]
 #[derive(Debug)]
+#[pyclass]
 pub struct ExponentialMovingAverage {
     pub period: usize,
     pub price_type: PriceType,
     pub alpha: f64,
     pub value: f64,
     pub count: usize,
     _has_inputs: bool,
     _is_initialized: bool,
 }
 
+impl Indicator for ExponentialMovingAverage {
+    fn name(&self) -> String {
+        stringify!(ExponentialMovingAverage).to_string()
+    }
+
+    fn has_inputs(&self) -> bool {
+        self._has_inputs
+    }
+
+    fn is_initialized(&self) -> bool {
+        self._is_initialized
+    }
+
+    fn handle_quote_tick(&mut self, tick: &QuoteTick) {
+        self.update_raw(tick.extract_price(self.price_type).into())
+    }
+
+    fn handle_trade_tick(&mut self, tick: &TradeTick) {
+        self.update_raw((&tick.price).into())
+    }
+
+    fn handle_bar(&mut self, bar: &Bar) {
+        self.update_raw((&bar.close).into())
+    }
+
+    fn reset(&mut self) {
+        self.value = 0.0;
+        self.count = 0;
+        self._has_inputs = false;
+        self._is_initialized = false;
+    }
+}
+
 #[pymethods]
 impl ExponentialMovingAverage {
-    #[new]
     #[must_use]
+    #[new]
     pub fn new(period: usize, price_type: Option<PriceType>) -> Self {
         Self {
             period,
             price_type: price_type.unwrap_or(PriceType::Last),
             alpha: 2.0 / (period as f64 + 1.0),
             value: 0.0,
             count: 0,
             _has_inputs: false,
             _is_initialized: false,
         }
     }
 
-    pub fn update_raw(&mut self, value: f64) {
-        if !self._has_inputs {
-            self._has_inputs = true;
-            self.value = value;
-        }
-
-        self.value = self.alpha.mul_add(value, (1.0 - self.alpha) * self.value);
-        self.count += 1;
-
-        // Initialization logic
-        if !self._is_initialized && self.count >= self.period {
-            self._is_initialized = true;
-        }
+    #[getter]
+    #[pyo3(name = "name")]
+    #[must_use]
+    pub fn name_py(&self) -> String {
+        self.name()
     }
-}
 
-impl Indicator for ExponentialMovingAverage {
-    fn has_inputs(&self) -> bool {
-        self._has_inputs
+    #[pyo3(name = "has_inputs")]
+    fn has_inputs_py(&self) -> bool {
+        self.has_inputs()
     }
 
+    #[pyo3(name = "is_initialized")]
     fn is_initialized(&self) -> bool {
         self._is_initialized
     }
 
-    fn handle_quote_tick(&mut self, tick: &QuoteTick) {
+    #[pyo3(name = "handle_quote_tick")]
+    fn handle_quote_tick_py(&mut self, tick: &QuoteTick) {
         self.update_raw(tick.extract_price(self.price_type).into())
     }
 
-    fn handle_trade_tick(&mut self, tick: &TradeTick) {
+    #[pyo3(name = "handle_trade_tick")]
+    fn handle_trade_tick_py(&mut self, tick: &TradeTick) {
         self.update_raw((&tick.price).into())
     }
 
-    fn handle_bar(&mut self, bar: &Bar) {
+    #[pyo3(name = "handle_bar")]
+    fn handle_bar_py(&mut self, bar: &Bar) {
         self.update_raw((&bar.close).into())
     }
 
-    fn reset(&mut self) {
-        self.value = 0.0;
-        self.count = 0;
-        self._has_inputs = false;
-        self._is_initialized = false;
+    #[pyo3(name = "reset")]
+    fn reset_py(&mut self) {
+        self.reset()
+    }
+
+    pub fn update_raw(&mut self, value: f64) {
+        if !self._has_inputs {
+            self._has_inputs = true;
+            self.value = value;
+        }
+
+        self.value = self.alpha.mul_add(value, (1.0 - self.alpha) * self.value);
+        self.count += 1;
+
+        // Initialization logic
+        if !self._is_initialized && self.count >= self.period {
+            self._is_initialized = true;
+        }
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/indicators/src/lib.rs` & `nautilus_trader-1.175.0/nautilus_core/indicators/src/lib.rs`

 * *Files 14% similar despite different names*

```diff
@@ -11,19 +11,29 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 pub mod ema;
 
-use nautilus_model::data::bar::Bar;
-use nautilus_model::data::tick::QuoteTick;
-use nautilus_model::data::tick::TradeTick;
+use nautilus_model::data::{
+    bar::Bar,
+    tick::{QuoteTick, TradeTick},
+};
+use pyo3::{prelude::*, types::PyModule, Python};
 
-trait Indicator {
+/// Loaded as nautilus_pyo3.indicators
+#[pymodule]
+pub fn indicators(_: Python<'_>, m: &PyModule) -> PyResult<()> {
+    m.add_class::<ema::ExponentialMovingAverage>()?;
+    Ok(())
+}
+
+pub trait Indicator {
+    fn name(&self) -> String;
     fn has_inputs(&self) -> bool;
     fn is_initialized(&self) -> bool;
     fn handle_quote_tick(&mut self, tick: &QuoteTick);
     fn handle_trade_tick(&mut self, tick: &TradeTick);
     fn handle_bar(&mut self, bar: &Bar);
     fn reset(&mut self);
 }
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/Cargo.toml` & `nautilus_trader-1.175.0/nautilus_core/model/Cargo.toml`

 * *Files 18% similar despite different names*

```diff
@@ -1,32 +1,37 @@
 [package]
-name = "nautilus_model"
+name = "nautilus-model"
 version.workspace = true
 edition.workspace = true
 authors.workspace = true
 description.workspace = true
 documentation.workspace = true
 
 [lib]
 name = "nautilus_model"
 crate-type = ["rlib", "staticlib"]
 
 [dependencies]
-nautilus_core = { path = "../core" }
+nautilus-core = { path = "../core" }
 pyo3.workspace = true
+rmp-serde.workspace = true
 rust_decimal.workspace = true
+serde.workspace = true
+serde_json.workspace = true
 strum.workspace = true
 thiserror.workspace = true
 derive_builder = "0.12.0"
+evalexpr = "11.0.0"
 lazy_static = "1.4.0"
+tabled = "0.12.2"
 
 [features]
 extension-module = [
     "pyo3/extension-module",
-    "nautilus_core/extension-module",
+    "nautilus-core/extension-module",
 ]
 default = []
 
 [dev-dependencies]
 criterion.workspace = true
 iai.workspace = true
 rstest.workspace = true
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/build.rs` & `nautilus_trader-1.175.0/nautilus_core/model/build.rs`

 * *Files 4% similar despite different names*

```diff
@@ -11,18 +11,20 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 extern crate cbindgen;
 
-use std::env;
-use std::fs::File;
-use std::io::{Read, Write};
-use std::path::PathBuf;
+use std::{
+    env,
+    fs::File,
+    io::{Read, Write},
+    path::PathBuf,
+};
 
 #[allow(clippy::expect_used)] // OK in build script
 fn main() {
     let crate_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
 
     // Generate C headers
     let config_c = cbindgen::Config::from_file("cbindgen.toml")
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/cbindgen.toml` & `nautilus_trader-1.175.0/nautilus_core/model/cbindgen.toml`

 * *Files 12% similar despite different names*

```diff
@@ -11,35 +11,38 @@
 
 [export]
 exclude = [
     "BarAggregation",
 ]
 
 [export.rename]
-"BarAggregation" = "uint8_t"
-
-"UnixNanos" = "uint64_t"
-"TimedeltaNanos" = "int64_t"
-"Currency" = "Currency_t"
-"Money" = "Money_t"
-"Price" = "Price_t"
-"Quantity" = "Quantity_t"
-"QuoteTick" = "QuoteTick_t"
-"TradeTick" = "TradeTick_t"
-"Data" = "Data_t"
 "AccountId" = "AccountId_t"
+"Bar" = "Bar_t"
+"BarAggregation" = "uint8_t"
+"BarSpecification" = "BarSpecification_t"
+"BarType" = "BarType_t"
+"BookOrder" = "BookOrder_t"
 "ClientId" = "ClientId_t"
 "ClientOrderId" = "ClientOrderId_t"
 "ComponentId" = "ComponentId_t"
+"Currency" = "Currency_t"
+"Data" = "Data_t"
 "ExecAlgorithmId" = "ExecAlgorithmId_t"
 "InstrumentId" = "InstrumentId_t"
+"Money" = "Money_t"
+"OrderBookDelta" = "OrderBookDelta_t"
+"OrderDenied" = "OrderDenied_t"
 "OrderListId" = "OrderListId_t"
 "PositionId" = "PositionId_t"
+"Price" = "Price_t"
+"Quantity" = "Quantity_t"
+"QuoteTick" = "QuoteTick_t"
 "StrategyId" = "StrategyId_t"
 "Symbol" = "Symbol_t"
+"TimedeltaNanos" = "int64_t"
 "TradeId" = "TradeId_t"
+"TradeTick" = "TradeTick_t"
 "TraderId" = "TraderId_t"
+"UnixNanos" = "uint64_t"
+"UUID4" = "UUID4_t"
 "Venue" = "Venue_t"
 "VenueOrderId" = "VenueOrderId_t"
-"BarSpecification" = "BarSpecification_t"
-"BarType" = "BarType_t"
-"Bar" = "Bar_t"
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/cbindgen_cython.toml` & `nautilus_trader-1.175.0/nautilus_core/model/cbindgen_cython.toml`

 * *Files 7% similar despite different names*

```diff
@@ -9,14 +9,15 @@
 header = '"../includes/model.h"'
 
 [cython.cimports]
 "libc.stdint" = [
     "uint8_t",
     "uint16_t",
     "uint64_t",
+    "uintptr_t",
     "int64_t",
 ]
 
 "nautilus_trader.core.rust.core" = [
     "CVec",
     "UUID4_t",
 ]
@@ -26,36 +27,38 @@
 
 [export]
 exclude = [
     "BarAggregation",
 ]
 
 [export.rename]
-"BarAggregation" = "uint8_t"
-
-"UnixNanos" = "uint64_t"
-"TimedeltaNanos" = "int64_t"
-"TimeEvent" = "TimeEvent_t"
-"Currency" = "Currency_t"
-"Money" = "Money_t"
-"Price" = "Price_t"
-"Quantity" = "Quantity_t"
-"QuoteTick" = "QuoteTick_t"
-"TradeTick" = "TradeTick_t"
-"Data" = "Data_t"
 "AccountId" = "AccountId_t"
+"Bar" = "Bar_t"
+"BarAggregation" = "uint8_t"
+"BarSpecification" = "BarSpecification_t"
+"BarType" = "BarType_t"
+"BookOrder" = "BookOrder_t"
 "ClientId" = "ClientId_t"
 "ClientOrderId" = "ClientOrderId_t"
 "ComponentId" = "ComponentId_t"
+"Currency" = "Currency_t"
+"Data" = "Data_t"
 "ExecAlgorithmId" = "ExecAlgorithmId_t"
 "InstrumentId" = "InstrumentId_t"
+"Money" = "Money_t"
+"OrderBookDelta" = "OrderBookDelta_t"
+"OrderDenied" = "OrderDenied_t"
 "OrderListId" = "OrderListId_t"
 "PositionId" = "PositionId_t"
+"Price" = "Price_t"
+"Quantity" = "Quantity_t"
+"QuoteTick" = "QuoteTick_t"
 "StrategyId" = "StrategyId_t"
 "Symbol" = "Symbol_t"
+"TimedeltaNanos" = "int64_t"
 "TradeId" = "TradeId_t"
+"TradeTick" = "TradeTick_t"
 "TraderId" = "TraderId_t"
+"UnixNanos" = "uint64_t"
+"UUID4" = "UUID4_t"
 "Venue" = "Venue_t"
 "VenueOrderId" = "VenueOrderId_t"
-"BarSpecification" = "BarSpecification_t"
-"BarType" = "BarType_t"
-"Bar" = "Bar_t"
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/currencies.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/currencies.rs`

 * *Files 1% similar despite different names*

```diff
@@ -9,95 +9,101 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-// Defines currency definition constants
+//! Defines established currency constants and an internal currency map.
 
-use std::{collections::HashMap, sync::Arc};
+use std::{
+    collections::HashMap,
+    sync::{Arc, Mutex},
+};
 
 use crate::{enums::CurrencyType, types::currency::Currency};
 
 #[must_use]
-pub fn currency_map() -> HashMap<String, Currency> {
-    [
-        // Fiat currencies
-        (String::from("AUD"), AUD.clone()),
-        (String::from("BRL"), BRL.clone()),
-        (String::from("CAD"), CAD.clone()),
-        (String::from("CHF"), CHF.clone()),
-        (String::from("CNY"), CNY.clone()),
-        (String::from("CNH"), CNH.clone()),
-        (String::from("CZK"), CZK.clone()),
-        (String::from("DKK"), DKK.clone()),
-        (String::from("EUR"), EUR.clone()),
-        (String::from("GBP"), GBP.clone()),
-        (String::from("HKD"), HKD.clone()),
-        (String::from("HUF"), HUF.clone()),
-        (String::from("ILS"), ILS.clone()),
-        (String::from("INR"), INR.clone()),
-        (String::from("JPY"), JPY.clone()),
-        (String::from("KRW"), KRW.clone()),
-        (String::from("MXN"), MXN.clone()),
-        (String::from("NOK"), NOK.clone()),
-        (String::from("NZD"), NZD.clone()),
-        (String::from("PLN"), PLN.clone()),
-        (String::from("RUB"), RUB.clone()),
-        (String::from("SAR"), SAR.clone()),
-        (String::from("SEK"), SEK.clone()),
-        (String::from("SGD"), SGD.clone()),
-        (String::from("THB"), THB.clone()),
-        (String::from("TRY"), TRY.clone()),
-        (String::from("USD"), USD.clone()),
-        (String::from("XAG"), XAG.clone()),
-        (String::from("XAU"), XAU.clone()),
-        (String::from("ZAR"), ZAR.clone()),
-        // Crypto currencies
-        (String::from("1INCH"), ONEINCH.clone()),
-        (String::from("AAVE"), AAVE.clone()),
-        (String::from("ACA"), ACA.clone()),
-        (String::from("ADA"), ADA.clone()),
-        (String::from("AVAX"), AVAX.clone()),
-        (String::from("BCH"), BCH.clone()),
-        (String::from("BNB"), BNB.clone()),
-        (String::from("BRZ"), BRZ.clone()),
-        (String::from("BSV"), BSV.clone()),
-        (String::from("BTC"), BTC.clone()),
-        (String::from("BUSD"), BUSD.clone()),
-        (String::from("DASH"), DASH.clone()),
-        (String::from("DOGE"), DOGE.clone()),
-        (String::from("DOT"), DOT.clone()),
-        (String::from("EOS"), EOS.clone()),
-        (String::from("ETH"), ETH.clone()),
-        (String::from("ETHW"), ETHW.clone()),
-        (String::from("JOE"), JOE.clone()),
-        (String::from("LINK"), LINK.clone()),
-        (String::from("LTC"), LTC.clone()),
-        (String::from("LUNA"), LUNA.clone()),
-        (String::from("NBT"), NBT.clone()),
-        (String::from("SOL"), SOL.clone()),
-        (String::from("TRX"), TRX.clone()),
-        (String::from("TRYB"), TRYB.clone()),
-        (String::from("VTC"), VTC.clone()),
-        (String::from("WSB"), WSB.clone()),
-        (String::from("XBT"), XBT.clone()),
-        (String::from("XEC"), XEC.clone()),
-        (String::from("XLM"), XLM.clone()),
-        (String::from("XMR"), XMR.clone()),
-        (String::from("XRP"), XRP.clone()),
-        (String::from("XTZ"), XTZ.clone()),
-        (String::from("USDC"), USDC.clone()),
-        (String::from("USDT"), USDT.clone()),
-        (String::from("ZEC"), ZEC.clone()),
-    ]
-    .iter()
-    .cloned()
-    .collect()
+pub fn currency_map() -> Mutex<HashMap<String, Currency>> {
+    Mutex::new(
+        [
+            // Fiat currencies
+            (String::from("AUD"), AUD.clone()),
+            (String::from("BRL"), BRL.clone()),
+            (String::from("CAD"), CAD.clone()),
+            (String::from("CHF"), CHF.clone()),
+            (String::from("CNY"), CNY.clone()),
+            (String::from("CNH"), CNH.clone()),
+            (String::from("CZK"), CZK.clone()),
+            (String::from("DKK"), DKK.clone()),
+            (String::from("EUR"), EUR.clone()),
+            (String::from("GBP"), GBP.clone()),
+            (String::from("HKD"), HKD.clone()),
+            (String::from("HUF"), HUF.clone()),
+            (String::from("ILS"), ILS.clone()),
+            (String::from("INR"), INR.clone()),
+            (String::from("JPY"), JPY.clone()),
+            (String::from("KRW"), KRW.clone()),
+            (String::from("MXN"), MXN.clone()),
+            (String::from("NOK"), NOK.clone()),
+            (String::from("NZD"), NZD.clone()),
+            (String::from("PLN"), PLN.clone()),
+            (String::from("RUB"), RUB.clone()),
+            (String::from("SAR"), SAR.clone()),
+            (String::from("SEK"), SEK.clone()),
+            (String::from("SGD"), SGD.clone()),
+            (String::from("THB"), THB.clone()),
+            (String::from("TRY"), TRY.clone()),
+            (String::from("USD"), USD.clone()),
+            (String::from("XAG"), XAG.clone()),
+            (String::from("XAU"), XAU.clone()),
+            (String::from("ZAR"), ZAR.clone()),
+            // Crypto currencies
+            (String::from("1INCH"), ONEINCH.clone()),
+            (String::from("AAVE"), AAVE.clone()),
+            (String::from("ACA"), ACA.clone()),
+            (String::from("ADA"), ADA.clone()),
+            (String::from("AVAX"), AVAX.clone()),
+            (String::from("BCH"), BCH.clone()),
+            (String::from("BTTC"), BTTC.clone()),
+            (String::from("BNB"), BNB.clone()),
+            (String::from("BRZ"), BRZ.clone()),
+            (String::from("BSV"), BSV.clone()),
+            (String::from("BTC"), BTC.clone()),
+            (String::from("BUSD"), BUSD.clone()),
+            (String::from("DASH"), DASH.clone()),
+            (String::from("DOGE"), DOGE.clone()),
+            (String::from("DOT"), DOT.clone()),
+            (String::from("EOS"), EOS.clone()),
+            (String::from("ETH"), ETH.clone()),
+            (String::from("ETHW"), ETHW.clone()),
+            (String::from("JOE"), JOE.clone()),
+            (String::from("LINK"), LINK.clone()),
+            (String::from("LTC"), LTC.clone()),
+            (String::from("LUNA"), LUNA.clone()),
+            (String::from("NBT"), NBT.clone()),
+            (String::from("SOL"), SOL.clone()),
+            (String::from("TRX"), TRX.clone()),
+            (String::from("TRYB"), TRYB.clone()),
+            (String::from("VTC"), VTC.clone()),
+            (String::from("WSB"), WSB.clone()),
+            (String::from("XBT"), XBT.clone()),
+            (String::from("XEC"), XEC.clone()),
+            (String::from("XLM"), XLM.clone()),
+            (String::from("XMR"), XMR.clone()),
+            (String::from("XRP"), XRP.clone()),
+            (String::from("XTZ"), XTZ.clone()),
+            (String::from("USDC"), USDC.clone()),
+            (String::from("USDT"), USDT.clone()),
+            (String::from("ZEC"), ZEC.clone()),
+        ]
+        .iter()
+        .cloned()
+        .collect(),
+    )
 }
 
 lazy_static! {
     // Fiat currencies
     pub static ref AUD: Currency = Currency {
         code: Box::new(Arc::new(String::from("AUD"))),
         precision: 2,
@@ -354,14 +360,21 @@
     pub static ref BTC: Currency = Currency {
         code: Box::new(Arc::new(String::from("BTC"))),
         precision: 8,
         iso4217: 0,
         name: Box::new(Arc::new(String::from("Bitcoin"))),
         currency_type: CurrencyType::Crypto,
     };
+    pub static ref BTTC: Currency = Currency {
+        code: Box::new(Arc::new(String::from("BTTC"))),
+        precision: 8,
+        iso4217: 0,
+        name: Box::new(Arc::new(String::from("BitTorrent"))),
+        currency_type: CurrencyType::Crypto,
+    };
     pub static ref BNB: Currency = Currency {
         code: Box::new(Arc::new(String::from("BNB"))),
         precision: 8,
         iso4217: 0,
         name: Box::new(Arc::new(String::from("Binance Coin"))),
         currency_type: CurrencyType::Crypto,
     };
@@ -557,9 +570,9 @@
     pub static ref ZEC: Currency = Currency {
         code: Box::new(Arc::new(String::from("ZEC"))),
         precision: 8,
         iso4217: 0,
         name: Box::new(Arc::new(String::from("Zcash"))),
         currency_type: CurrencyType::Crypto,
     };
-    pub static ref CURRENCY_MAP: HashMap<String, Currency> = currency_map();
+    pub static ref CURRENCY_MAP: Mutex<HashMap<String, Currency>> = currency_map();
 }
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/data/bar.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/data/bar.rs`

 * *Files 19% similar despite different names*

```diff
@@ -9,29 +9,30 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::cmp::Ordering;
-use std::collections::hash_map::DefaultHasher;
-use std::ffi::c_char;
-use std::fmt::{Debug, Display, Formatter};
-use std::hash::{Hash, Hasher};
-use std::str::FromStr;
+use std::{
+    cmp::Ordering,
+    fmt::{Debug, Display, Formatter},
+    hash::{Hash, Hasher},
+    str::FromStr,
+};
 
-use nautilus_core::string::string_to_cstr;
 use nautilus_core::time::UnixNanos;
+use pyo3::prelude::*;
 use thiserror::Error;
 
-use crate::enums::{AggregationSource, BarAggregation, PriceType};
-use crate::identifiers::instrument_id::InstrumentId;
-use crate::types::price::Price;
-use crate::types::quantity::Quantity;
+use crate::{
+    enums::{AggregationSource, BarAggregation, PriceType},
+    identifiers::instrument_id::InstrumentId,
+    types::{price::Price, quantity::Quantity},
+};
 
 #[repr(C)]
 #[derive(Clone, Hash, PartialEq, Eq, Debug)]
 pub struct BarSpecification {
     pub step: u64,
     pub aggregation: BarAggregation,
     pub price_type: PriceType,
@@ -61,68 +62,14 @@
     }
 
     fn ge(&self, other: &Self) -> bool {
         self.to_string().ge(&other.to_string())
     }
 }
 
-/// Returns a [`BarSpecification`] as a C string pointer.
-#[no_mangle]
-pub extern "C" fn bar_specification_to_cstr(bar_spec: &BarSpecification) -> *const c_char {
-    string_to_cstr(&bar_spec.to_string())
-}
-
-#[no_mangle]
-pub extern "C" fn bar_specification_hash(bar_spec: &BarSpecification) -> u64 {
-    let mut h = DefaultHasher::new();
-    bar_spec.hash(&mut h);
-    h.finish()
-}
-
-#[no_mangle]
-pub extern "C" fn bar_specification_new(
-    step: u64,
-    aggregation: u8,
-    price_type: u8,
-) -> BarSpecification {
-    let aggregation =
-        BarAggregation::from_repr(aggregation as usize).expect("cannot parse enum value");
-    let price_type = PriceType::from_repr(price_type as usize).expect("cannot parse enum value");
-    BarSpecification {
-        step,
-        aggregation,
-        price_type,
-    }
-}
-
-#[no_mangle]
-pub extern "C" fn bar_specification_eq(lhs: &BarSpecification, rhs: &BarSpecification) -> u8 {
-    u8::from(lhs == rhs)
-}
-
-#[no_mangle]
-pub extern "C" fn bar_specification_lt(lhs: &BarSpecification, rhs: &BarSpecification) -> u8 {
-    u8::from(lhs < rhs)
-}
-
-#[no_mangle]
-pub extern "C" fn bar_specification_le(lhs: &BarSpecification, rhs: &BarSpecification) -> u8 {
-    u8::from(lhs <= rhs)
-}
-
-#[no_mangle]
-pub extern "C" fn bar_specification_gt(lhs: &BarSpecification, rhs: &BarSpecification) -> u8 {
-    u8::from(lhs > rhs)
-}
-
-#[no_mangle]
-pub extern "C" fn bar_specification_ge(lhs: &BarSpecification, rhs: &BarSpecification) -> u8 {
-    u8::from(lhs >= rhs)
-}
-
 #[repr(C)]
 #[derive(Clone, Debug)]
 pub struct BarType {
     pub instrument_id: InstrumentId,
     pub spec: BarSpecification,
     pub aggregation_source: AggregationSource,
 }
@@ -236,79 +183,17 @@
             f,
             "{}-{}-{}",
             self.instrument_id, self.spec, self.aggregation_source
         )
     }
 }
 
-#[no_mangle]
-pub extern "C" fn bar_type_new(
-    instrument_id: InstrumentId,
-    spec: BarSpecification,
-    aggregation_source: u8,
-) -> BarType {
-    let aggregation_source = AggregationSource::from_repr(aggregation_source as usize)
-        .expect("Error converting enum from integer");
-    BarType {
-        instrument_id,
-        spec,
-        aggregation_source,
-    }
-}
-
-#[no_mangle]
-pub extern "C" fn bar_type_clone(bar_type: &BarType) -> BarType {
-    bar_type.clone()
-}
-
-#[no_mangle]
-pub extern "C" fn bar_type_eq(lhs: &BarType, rhs: &BarType) -> u8 {
-    u8::from(lhs == rhs)
-}
-
-#[no_mangle]
-pub extern "C" fn bar_type_lt(lhs: &BarType, rhs: &BarType) -> u8 {
-    u8::from(lhs < rhs)
-}
-
-#[no_mangle]
-pub extern "C" fn bar_type_le(lhs: &BarType, rhs: &BarType) -> u8 {
-    u8::from(lhs <= rhs)
-}
-
-#[no_mangle]
-pub extern "C" fn bar_type_gt(lhs: &BarType, rhs: &BarType) -> u8 {
-    u8::from(lhs > rhs)
-}
-
-#[no_mangle]
-pub extern "C" fn bar_type_ge(lhs: &BarType, rhs: &BarType) -> u8 {
-    u8::from(lhs >= rhs)
-}
-
-#[no_mangle]
-pub extern "C" fn bar_type_hash(bar_type: &BarType) -> u64 {
-    let mut h = DefaultHasher::new();
-    bar_type.hash(&mut h);
-    h.finish()
-}
-
-/// Returns a [`BarType`] as a C string pointer.
-#[no_mangle]
-pub extern "C" fn bar_type_to_cstr(bar_type: &BarType) -> *const c_char {
-    string_to_cstr(&bar_type.to_string())
-}
-
-#[no_mangle]
-pub extern "C" fn bar_type_drop(bar_type: BarType) {
-    drop(bar_type); // Memory freed here
-}
-
 #[repr(C)]
 #[derive(Clone, Hash, PartialEq, Debug)]
+#[pyclass]
 pub struct Bar {
     pub bar_type: BarType,
     pub open: Price,
     pub high: Price,
     pub low: Price,
     pub close: Price,
     pub volume: Quantity,
@@ -322,99 +207,24 @@
             f,
             "{},{},{},{},{},{},{}",
             self.bar_type, self.open, self.high, self.low, self.close, self.volume, self.ts_event
         )
     }
 }
 
-#[no_mangle]
-pub extern "C" fn bar_new(
-    bar_type: BarType,
-    open: Price,
-    high: Price,
-    low: Price,
-    close: Price,
-    volume: Quantity,
-    ts_event: UnixNanos,
-    ts_init: UnixNanos,
-) -> Bar {
-    Bar {
-        bar_type,
-        open,
-        high,
-        low,
-        close,
-        volume,
-        ts_event,
-        ts_init,
-    }
-}
-
-#[no_mangle]
-pub extern "C" fn bar_new_from_raw(
-    bar_type: BarType,
-    open: i64,
-    high: i64,
-    low: i64,
-    close: i64,
-    price_prec: u8,
-    volume: u64,
-    size_prec: u8,
-    ts_event: UnixNanos,
-    ts_init: UnixNanos,
-) -> Bar {
-    Bar {
-        bar_type,
-        open: Price::from_raw(open, price_prec),
-        high: Price::from_raw(high, price_prec),
-        low: Price::from_raw(low, price_prec),
-        close: Price::from_raw(close, price_prec),
-        volume: Quantity::from_raw(volume, size_prec),
-        ts_event,
-        ts_init,
-    }
-}
-
-/// Returns a [`Bar`] as a C string.
-#[no_mangle]
-pub extern "C" fn bar_to_cstr(bar: &Bar) -> *const c_char {
-    string_to_cstr(&bar.to_string())
-}
-
-#[no_mangle]
-pub extern "C" fn bar_clone(bar: &Bar) -> Bar {
-    bar.clone()
-}
-
-#[no_mangle]
-pub extern "C" fn bar_drop(bar: Bar) {
-    drop(bar); // Memory freed here
-}
-
-#[no_mangle]
-pub extern "C" fn bar_eq(lhs: &Bar, rhs: &Bar) -> u8 {
-    u8::from(lhs == rhs)
-}
-
-#[no_mangle]
-pub extern "C" fn bar_hash(bar: &Bar) -> u64 {
-    let mut h = DefaultHasher::new();
-    bar.hash(&mut h);
-    h.finish()
-}
-
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
     use super::*;
-    use crate::enums::BarAggregation;
-    use crate::identifiers::symbol::Symbol;
-    use crate::identifiers::venue::Venue;
+    use crate::{
+        enums::BarAggregation,
+        identifiers::{symbol::Symbol, venue::Venue},
+    };
 
     #[test]
     fn test_bar_spec_equality() {
         let bar_spec1 = BarSpecification {
             step: 1,
             aggregation: BarAggregation::Minute,
             price_type: PriceType::Bid,
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/data/mod.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/data/mod.rs`

 * *Files 8% similar despite different names*

```diff
@@ -10,54 +10,49 @@
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 pub mod bar;
+pub mod bar_api;
 pub mod book;
+pub mod book_api;
 pub mod tick;
+pub mod tick_api;
 
 use nautilus_core::time::UnixNanos;
 
 use self::{
     bar::Bar,
-    book::{OrderBookDelta, OrderBookSnapshot},
+    book::OrderBookDelta,
     tick::{QuoteTick, TradeTick},
 };
 
 #[repr(C)]
 #[derive(Debug, Clone)]
 pub enum Data {
-    Snapshot(OrderBookSnapshot),
     Delta(OrderBookDelta),
     Quote(QuoteTick),
     Trade(TradeTick),
     Bar(Bar),
 }
 
 impl Data {
     #[must_use]
     pub fn get_ts_init(&self) -> UnixNanos {
         match self {
-            Self::Snapshot(s) => s.ts_init,
             Self::Delta(d) => d.ts_init,
             Self::Quote(q) => q.ts_init,
             Self::Trade(t) => t.ts_init,
             Self::Bar(b) => b.ts_init,
         }
     }
 }
 
-impl From<OrderBookSnapshot> for Data {
-    fn from(value: OrderBookSnapshot) -> Self {
-        Self::Snapshot(value)
-    }
-}
-
 impl From<OrderBookDelta> for Data {
     fn from(value: OrderBookDelta) -> Self {
         Self::Delta(value)
     }
 }
 
 impl From<QuoteTick> for Data {
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/data/tick.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/data/tick.rs`

 * *Files 24% similar despite different names*

```diff
@@ -9,34 +9,32 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::cmp;
-use std::ffi::c_char;
-use std::fmt::{Display, Formatter};
-
-use nautilus_core::correctness;
-use nautilus_core::string::string_to_cstr;
-use nautilus_core::time::UnixNanos;
-
-use crate::enums::{AggressorSide, PriceType};
-use crate::identifiers::instrument_id::InstrumentId;
-use crate::identifiers::trade_id::TradeId;
-use crate::types::fixed::FIXED_PRECISION;
-use crate::types::price::Price;
-use crate::types::quantity::Quantity;
-
-use super::Data;
+use std::{
+    cmp,
+    fmt::{Display, Formatter},
+};
+
+use nautilus_core::{correctness, time::UnixNanos};
+use pyo3::prelude::*;
+
+use crate::{
+    enums::{AggressorSide, PriceType},
+    identifiers::{instrument_id::InstrumentId, trade_id::TradeId},
+    types::{fixed::FIXED_PRECISION, price::Price, quantity::Quantity},
+};
 
 /// Represents a single quote tick in a financial market.
 #[repr(C)]
 #[derive(Clone, Debug, PartialEq, Eq, Hash)]
+#[pyclass]
 pub struct QuoteTick {
     pub instrument_id: InstrumentId,
     pub bid: Price,
     pub ask: Price,
     pub bid_size: Quantity,
     pub ask_size: Quantity,
     pub ts_event: UnixNanos,
@@ -76,16 +74,16 @@
             ts_init,
         }
     }
 
     #[must_use]
     pub fn extract_price(&self, price_type: PriceType) -> Price {
         match price_type {
-            PriceType::Bid => self.bid.clone(),
-            PriceType::Ask => self.ask.clone(),
+            PriceType::Bid => self.bid,
+            PriceType::Ask => self.ask,
             PriceType::Mid => Price::from_raw(
                 (self.bid.raw + self.ask.raw) / 2,
                 cmp::min(self.bid.precision + 1, FIXED_PRECISION),
             ),
             _ => panic!("Cannot extract with price type {price_type}"),
         }
     }
@@ -100,14 +98,15 @@
         )
     }
 }
 
 /// Represents a single trade tick in a financial market.
 #[repr(C)]
 #[derive(Clone, Debug, PartialEq, Eq, Hash)]
+#[pyclass]
 pub struct TradeTick {
     pub instrument_id: InstrumentId,
     pub price: Price,
     pub size: Quantity,
     pub aggressor_side: AggressorSide,
     pub trade_id: TradeId,
     pub ts_event: UnixNanos,
@@ -149,142 +148,28 @@
             self.trade_id,
             self.ts_event,
         )
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
-// C API
-////////////////////////////////////////////////////////////////////////////////
-#[no_mangle]
-pub extern "C" fn quote_tick_drop(tick: QuoteTick) {
-    drop(tick); // Memory freed here
-}
-
-#[no_mangle]
-pub extern "C" fn quote_tick_clone(tick: &QuoteTick) -> QuoteTick {
-    tick.clone()
-}
-
-#[no_mangle]
-pub extern "C" fn quote_tick_new(
-    instrument_id: InstrumentId,
-    bid: Price,
-    ask: Price,
-    bid_size: Quantity,
-    ask_size: Quantity,
-    ts_event: UnixNanos,
-    ts_init: UnixNanos,
-) -> QuoteTick {
-    QuoteTick::new(
-        instrument_id,
-        bid,
-        ask,
-        bid_size,
-        ask_size,
-        ts_event,
-        ts_init,
-    )
-}
-
-#[no_mangle]
-pub extern "C" fn quote_tick_from_raw(
-    instrument_id: InstrumentId,
-    bid: i64,
-    ask: i64,
-    bid_price_prec: u8,
-    ask_price_prec: u8,
-    bid_size: u64,
-    ask_size: u64,
-    bid_size_prec: u8,
-    ask_size_prec: u8,
-    ts_event: UnixNanos,
-    ts_init: UnixNanos,
-) -> QuoteTick {
-    QuoteTick::new(
-        instrument_id,
-        Price::from_raw(bid, bid_price_prec),
-        Price::from_raw(ask, ask_price_prec),
-        Quantity::from_raw(bid_size, bid_size_prec),
-        Quantity::from_raw(ask_size, ask_size_prec),
-        ts_event,
-        ts_init,
-    )
-}
-
-/// Returns a [`QuoteTick`] as a C string pointer.
-#[no_mangle]
-pub extern "C" fn quote_tick_to_cstr(tick: &QuoteTick) -> *const c_char {
-    string_to_cstr(&tick.to_string())
-}
-
-#[no_mangle]
-pub extern "C" fn trade_tick_drop(tick: TradeTick) {
-    drop(tick); // Memory freed here
-}
-
-#[no_mangle]
-pub extern "C" fn trade_tick_clone(tick: &TradeTick) -> TradeTick {
-    tick.clone()
-}
-
-#[no_mangle]
-pub extern "C" fn trade_tick_from_raw(
-    instrument_id: InstrumentId,
-    price: i64,
-    price_prec: u8,
-    size: u64,
-    size_prec: u8,
-    aggressor_side: AggressorSide,
-    trade_id: TradeId,
-    ts_event: u64,
-    ts_init: u64,
-) -> TradeTick {
-    TradeTick::new(
-        instrument_id,
-        Price::from_raw(price, price_prec),
-        Quantity::from_raw(size, size_prec),
-        aggressor_side,
-        trade_id,
-        ts_event,
-        ts_init,
-    )
-}
-
-/// Returns a [`TradeTick`] as a C string pointer.
-#[no_mangle]
-pub extern "C" fn trade_tick_to_cstr(tick: &TradeTick) -> *const c_char {
-    string_to_cstr(&tick.to_string())
-}
-
-#[no_mangle]
-pub extern "C" fn data_drop(data: Data) {
-    drop(data); // Memory freed here
-}
-
-#[no_mangle]
-pub extern "C" fn data_clone(data: &Data) -> Data {
-    data.clone()
-}
-
-////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
     use std::str::FromStr;
 
     use rstest::rstest;
 
-    use crate::data::tick::{QuoteTick, TradeTick};
-    use crate::enums::{AggressorSide, PriceType};
-    use crate::identifiers::instrument_id::InstrumentId;
-    use crate::identifiers::trade_id::TradeId;
-    use crate::types::price::Price;
-    use crate::types::quantity::Quantity;
+    use crate::{
+        data::tick::{QuoteTick, TradeTick},
+        enums::{AggressorSide, PriceType},
+        identifiers::{instrument_id::InstrumentId, trade_id::TradeId},
+        types::{price::Price, quantity::Quantity},
+    };
 
     #[test]
     fn test_quote_tick_to_string() {
         let tick = QuoteTick {
             instrument_id: InstrumentId::from_str("ETHUSDT-PERP.BINANCE").unwrap(),
             bid: Price::new(10000.0, 4),
             ask: Price::new(10001.0, 4),
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/events/mod.rs` & `nautilus_trader-1.175.0/nautilus_core/persistence/src/parquet/implementations/mod.rs`

 * *Files 6% similar despite different names*

```diff
@@ -9,9 +9,11 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-pub mod order;
-pub mod position;
+mod bar;
+mod delta;
+mod quote;
+mod trade;
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/events/order.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/events/order.rs`

 * *Files 15% similar despite different names*

```diff
@@ -9,38 +9,27 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::ops::Deref;
-use std::rc::Rc;
-use std::str::FromStr;
-
 use derive_builder::{self, Builder};
-use nautilus_core::time::UnixNanos;
-use nautilus_core::uuid::UUID4;
+use nautilus_core::{time::UnixNanos, uuid::UUID4};
+use serde::{Deserialize, Serialize};
 
-use crate::enums::{
-    ContingencyType, LiquiditySide, OrderSide, OrderType, TimeInForce, TriggerType,
+use crate::{
+    enums::{ContingencyType, LiquiditySide, OrderSide, OrderType, TimeInForce, TriggerType},
+    identifiers::{
+        account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
+        order_list_id::OrderListId, position_id::PositionId, strategy_id::StrategyId,
+        trade_id::TradeId, trader_id::TraderId, venue_order_id::VenueOrderId,
+    },
+    types::{currency::Currency, money::Money, price::Price, quantity::Quantity},
 };
-use crate::identifiers::account_id::AccountId;
-use crate::identifiers::client_order_id::ClientOrderId;
-use crate::identifiers::instrument_id::InstrumentId;
-use crate::identifiers::order_list_id::OrderListId;
-use crate::identifiers::position_id::PositionId;
-use crate::identifiers::strategy_id::StrategyId;
-use crate::identifiers::trade_id::TradeId;
-use crate::identifiers::trader_id::TraderId;
-use crate::identifiers::venue_order_id::VenueOrderId;
-use crate::types::currency::Currency;
-use crate::types::money::Money;
-use crate::types::price::Price;
-use crate::types::quantity::Quantity;
 
 #[derive(Clone, Hash, PartialEq, Eq, Debug)]
 pub enum OrderEvent {
     OrderInitialized(OrderInitialized),
     OrderDenied(OrderDenied),
     OrderSubmitted(OrderSubmitted),
     OrderAccepted(OrderAccepted),
@@ -54,49 +43,33 @@
     OrderCancelRejected(OrderCancelRejected),
     OrderUpdated(OrderUpdated),
     OrderPartiallyFilled(OrderFilled),
     OrderFilled(OrderFilled),
 }
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug, Builder)]
+#[derive(Clone, Hash, PartialEq, Eq, Debug, Builder, Serialize, Deserialize)]
 #[builder(default)]
-pub struct OrderIdentifiers {
+#[serde(tag = "type")]
+pub struct OrderInitialized {
     pub trader_id: TraderId,
     pub strategy_id: StrategyId,
     pub instrument_id: InstrumentId,
     pub client_order_id: ClientOrderId,
-}
-
-impl Default for OrderIdentifiers {
-    fn default() -> Self {
-        Self {
-            trader_id: TraderId::new("TRADER-001"),
-            strategy_id: StrategyId::new("S-001"),
-            instrument_id: InstrumentId::from_str("AUD/USD.SIM").unwrap(),
-            client_order_id: ClientOrderId::new("O-123456789"),
-        }
-    }
-}
-
-#[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug, Builder)]
-#[builder(default)]
-pub struct OrderInitialized {
-    pub ids: Rc<OrderIdentifiers>,
     pub order_side: OrderSide,
     pub order_type: OrderType,
     pub quantity: Quantity,
     pub price: Option<Price>,
     pub trigger_price: Option<Price>,
     pub trigger_type: Option<TriggerType>,
     pub time_in_force: TimeInForce,
     pub expire_time: Option<UnixNanos>,
     pub post_only: bool,
     pub reduce_only: bool,
+    pub quote_quantity: bool,
     pub display_qty: Option<Quantity>,
     pub limit_offset: Option<Price>,
     pub trailing_offset: Option<Price>,
     pub trailing_offset_type: Option<TriggerType>,
     pub emulation_trigger: Option<TriggerType>,
     pub contingency_type: Option<ContingencyType>,
     pub order_list_id: Option<OrderListId>,
@@ -108,26 +81,30 @@
     pub ts_init: UnixNanos,
     pub reconciliation: bool,
 }
 
 impl Default for OrderInitialized {
     fn default() -> Self {
         Self {
-            ids: Default::default(),
+            trader_id: TraderId::default(),
+            strategy_id: StrategyId::default(),
+            instrument_id: InstrumentId::default(),
+            client_order_id: ClientOrderId::default(),
             order_side: OrderSide::Buy,
             order_type: OrderType::Market,
             quantity: Quantity::new(100_000.0, 0),
             price: Default::default(),
             trigger_price: Default::default(),
             trigger_type: Default::default(),
             time_in_force: TimeInForce::Day,
             expire_time: Default::default(),
             post_only: Default::default(),
             reduce_only: Default::default(),
             display_qty: Default::default(),
+            quote_quantity: Default::default(),
             limit_offset: Default::default(),
             trailing_offset: Default::default(),
             trailing_offset_type: Default::default(),
             emulation_trigger: Default::default(),
             contingency_type: Default::default(),
             order_list_id: Default::default(),
             linked_order_ids: Default::default(),
@@ -138,164 +115,227 @@
             ts_init: Default::default(),
             reconciliation: Default::default(),
         }
     }
 }
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Builder)]
+#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
 #[builder(default)]
+#[serde(tag = "type")]
 pub struct OrderDenied {
-    pub ids: Rc<OrderIdentifiers>,
-    pub reason: String,
+    pub trader_id: TraderId,
+    pub strategy_id: StrategyId,
+    pub instrument_id: InstrumentId,
+    pub client_order_id: ClientOrderId,
+    pub reason: Box<String>,
     pub event_id: UUID4,
     pub ts_event: UnixNanos,
     pub ts_init: UnixNanos,
 }
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Builder)]
+#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
+#[builder(default)]
+#[serde(tag = "type")]
 pub struct OrderSubmitted {
-    pub ids: Rc<OrderIdentifiers>,
+    pub trader_id: TraderId,
+    pub strategy_id: StrategyId,
+    pub instrument_id: InstrumentId,
+    pub client_order_id: ClientOrderId,
     pub account_id: AccountId,
     pub event_id: UUID4,
     pub ts_event: UnixNanos,
     pub ts_init: UnixNanos,
 }
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Builder)]
+#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
+#[builder(default)]
+#[serde(tag = "type")]
 pub struct OrderAccepted {
-    pub ids: Rc<OrderIdentifiers>,
+    pub trader_id: TraderId,
+    pub strategy_id: StrategyId,
+    pub instrument_id: InstrumentId,
+    pub client_order_id: ClientOrderId,
     pub venue_order_id: VenueOrderId,
     pub account_id: AccountId,
     pub event_id: UUID4,
     pub ts_event: UnixNanos,
     pub ts_init: UnixNanos,
     pub reconciliation: bool,
 }
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Builder)]
+#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
+#[builder(default)]
+#[serde(tag = "type")]
 pub struct OrderRejected {
-    pub ids: Rc<OrderIdentifiers>,
+    pub trader_id: TraderId,
+    pub strategy_id: StrategyId,
+    pub instrument_id: InstrumentId,
+    pub client_order_id: ClientOrderId,
     pub venue_order_id: VenueOrderId,
     pub account_id: AccountId,
     pub reason: String,
     pub event_id: UUID4,
     pub ts_event: UnixNanos,
     pub ts_init: UnixNanos,
     pub reconciliation: bool,
 }
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Builder)]
+#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
+#[builder(default)]
+#[serde(tag = "type")]
 pub struct OrderCanceled {
-    pub ids: Rc<OrderIdentifiers>,
+    pub trader_id: TraderId,
+    pub strategy_id: StrategyId,
+    pub instrument_id: InstrumentId,
+    pub client_order_id: ClientOrderId,
     pub venue_order_id: Option<VenueOrderId>,
     pub account_id: Option<AccountId>,
     pub event_id: UUID4,
     pub ts_event: UnixNanos,
     pub ts_init: UnixNanos,
     pub reconciliation: bool,
 }
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Builder)]
+#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
+#[builder(default)]
+#[serde(tag = "type")]
 pub struct OrderExpired {
-    pub ids: Rc<OrderIdentifiers>,
+    pub trader_id: TraderId,
+    pub strategy_id: StrategyId,
+    pub instrument_id: InstrumentId,
+    pub client_order_id: ClientOrderId,
     pub venue_order_id: Option<VenueOrderId>,
     pub account_id: Option<AccountId>,
     pub event_id: UUID4,
     pub ts_event: UnixNanos,
     pub ts_init: UnixNanos,
     pub reconciliation: bool,
 }
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Builder)]
+#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
+#[builder(default)]
+#[serde(tag = "type")]
 pub struct OrderTriggered {
-    pub ids: Rc<OrderIdentifiers>,
+    pub trader_id: TraderId,
+    pub strategy_id: StrategyId,
+    pub instrument_id: InstrumentId,
+    pub client_order_id: ClientOrderId,
     pub venue_order_id: Option<VenueOrderId>,
     pub account_id: Option<AccountId>,
     pub event_id: UUID4,
     pub ts_event: UnixNanos,
     pub ts_init: UnixNanos,
     pub reconciliation: bool,
 }
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Builder)]
+#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
+#[builder(default)]
+#[serde(tag = "type")]
 pub struct OrderPendingUpdate {
-    pub ids: Rc<OrderIdentifiers>,
+    pub trader_id: TraderId,
+    pub strategy_id: StrategyId,
+    pub instrument_id: InstrumentId,
+    pub client_order_id: ClientOrderId,
     pub venue_order_id: Option<VenueOrderId>,
     pub account_id: AccountId,
     pub event_id: UUID4,
     pub ts_event: UnixNanos,
     pub ts_init: UnixNanos,
     pub reconciliation: bool,
 }
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Builder)]
+#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
+#[builder(default)]
+#[serde(tag = "type")]
 pub struct OrderPendingCancel {
-    pub ids: Rc<OrderIdentifiers>,
+    pub trader_id: TraderId,
+    pub strategy_id: StrategyId,
+    pub instrument_id: InstrumentId,
+    pub client_order_id: ClientOrderId,
     pub venue_order_id: Option<VenueOrderId>,
     pub account_id: AccountId,
     pub event_id: UUID4,
     pub ts_event: UnixNanos,
     pub ts_init: UnixNanos,
     pub reconciliation: bool,
 }
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Builder)]
+#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
+#[builder(default)]
+#[serde(tag = "type")]
 pub struct OrderModifyRejected {
-    pub ids: Rc<OrderIdentifiers>,
+    pub trader_id: TraderId,
+    pub strategy_id: StrategyId,
+    pub instrument_id: InstrumentId,
+    pub client_order_id: ClientOrderId,
     pub venue_order_id: Option<VenueOrderId>,
     pub account_id: Option<AccountId>,
-    pub reason: String,
+    pub reason: Box<String>,
     pub event_id: UUID4,
     pub ts_event: UnixNanos,
     pub ts_init: UnixNanos,
     pub reconciliation: bool,
 }
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Builder)]
+#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
+#[builder(default)]
+#[serde(tag = "type")]
 pub struct OrderCancelRejected {
-    pub ids: Rc<OrderIdentifiers>,
+    pub trader_id: TraderId,
+    pub strategy_id: StrategyId,
+    pub instrument_id: InstrumentId,
+    pub client_order_id: ClientOrderId,
     pub venue_order_id: Option<VenueOrderId>,
     pub account_id: Option<AccountId>,
-    pub reason: String,
+    pub reason: Box<String>,
     pub event_id: UUID4,
     pub ts_event: UnixNanos,
     pub ts_init: UnixNanos,
     pub reconciliation: bool,
 }
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug, Builder)]
+#[derive(Clone, Hash, PartialEq, Eq, Debug, Default, Serialize, Deserialize, Builder)]
+#[builder(default)]
+#[serde(tag = "type")]
 pub struct OrderUpdated {
-    pub ids: Rc<OrderIdentifiers>,
+    pub trader_id: TraderId,
+    pub strategy_id: StrategyId,
+    pub instrument_id: InstrumentId,
+    pub client_order_id: ClientOrderId,
     pub venue_order_id: Option<VenueOrderId>,
     pub account_id: Option<AccountId>,
     pub quantity: Quantity,
     pub price: Option<Price>,
     pub trigger_price: Option<Price>,
     pub event_id: UUID4,
     pub ts_event: UnixNanos,
     pub ts_init: UnixNanos,
     pub reconciliation: bool,
 }
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug, Builder)]
+#[derive(Clone, Hash, PartialEq, Eq, Debug, Serialize, Deserialize, Builder)]
+#[serde(tag = "type")]
 pub struct OrderFilled {
-    pub ids: Rc<OrderIdentifiers>,
+    pub trader_id: TraderId,
+    pub strategy_id: StrategyId,
+    pub instrument_id: InstrumentId,
+    pub client_order_id: ClientOrderId,
     pub venue_order_id: VenueOrderId,
     pub account_id: AccountId,
     pub trade_id: TradeId,
     pub position_id: Option<PositionId>,
     pub order_side: OrderSide,
     pub order_type: OrderType,
     pub last_qty: Quantity,
@@ -304,34 +344,7 @@
     pub commission: Money,
     pub liquidity_side: LiquiditySide,
     pub event_id: UUID4,
     pub ts_event: UnixNanos,
     pub ts_init: UnixNanos,
     pub reconciliation: bool,
 }
-
-macro_rules! impl_derefs_for_order {
-    ($struct: ident) => {
-        impl Deref for $struct {
-            type Target = OrderIdentifiers;
-
-            fn deref(&self) -> &Self::Target {
-                &self.ids
-            }
-        }
-    };
-}
-
-impl_derefs_for_order!(OrderTriggered);
-impl_derefs_for_order!(OrderPendingUpdate);
-impl_derefs_for_order!(OrderExpired);
-impl_derefs_for_order!(OrderCanceled);
-impl_derefs_for_order!(OrderRejected);
-impl_derefs_for_order!(OrderAccepted);
-impl_derefs_for_order!(OrderSubmitted);
-impl_derefs_for_order!(OrderDenied);
-impl_derefs_for_order!(OrderInitialized);
-impl_derefs_for_order!(OrderPendingCancel);
-impl_derefs_for_order!(OrderModifyRejected);
-impl_derefs_for_order!(OrderCancelRejected);
-impl_derefs_for_order!(OrderUpdated);
-impl_derefs_for_order!(OrderFilled);
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/events/position.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/events/position.rs`

 * *Files 8% similar despite different names*

```diff
@@ -9,27 +9,25 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use crate::enums::{OrderSide, PositionSide};
-use crate::identifiers::account_id::AccountId;
-use crate::identifiers::client_order_id::ClientOrderId;
-use crate::identifiers::instrument_id::InstrumentId;
-use crate::identifiers::position_id::PositionId;
-use crate::identifiers::strategy_id::StrategyId;
-use crate::identifiers::trader_id::TraderId;
-use crate::types::currency::Currency;
-use crate::types::money::Money;
-use crate::types::price::Price;
-use crate::types::quantity::Quantity;
 use nautilus_core::time::{TimedeltaNanos, UnixNanos};
 
+use crate::{
+    enums::{OrderSide, PositionSide},
+    identifiers::{
+        account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
+        position_id::PositionId, strategy_id::StrategyId, trader_id::TraderId,
+    },
+    types::{currency::Currency, money::Money, price::Price, quantity::Quantity},
+};
+
 pub enum PositionEvent {
     PositionOpened(PositionOpened),
     PositionChanged(PositionChanged),
     PositionClosed(PositionClosed),
 }
 
 #[repr(C)]
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/identifiers/account_id.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/account_id.rs`

 * *Files 5% similar despite different names*

```diff
@@ -9,29 +9,36 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::collections::hash_map::DefaultHasher;
-use std::ffi::{c_char, CStr};
-use std::fmt::{Debug, Display, Formatter};
-use std::hash::{Hash, Hasher};
-use std::rc::Rc;
+use std::{
+    collections::hash_map::DefaultHasher,
+    ffi::{c_char, CStr},
+    fmt::{Debug, Display, Formatter},
+    hash::{Hash, Hasher},
+    sync::Arc,
+};
 
-use nautilus_core::correctness;
-use nautilus_core::string::string_to_cstr;
+use nautilus_core::{correctness, string::str_to_cstr};
+use pyo3::prelude::*;
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug)]
-#[allow(clippy::box_collection)] // C ABI compatibility
-#[allow(clippy::redundant_allocation)] // C ABI compatibility
+#[derive(Clone, Hash, PartialEq, Eq)]
+#[pyclass]
 pub struct AccountId {
-    pub value: Box<Rc<String>>,
+    pub value: Box<Arc<String>>,
+}
+
+impl Debug for AccountId {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        write!(f, "{:?}", self.value)
+    }
 }
 
 impl Display for AccountId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
         write!(f, "{}", self.value)
     }
 }
@@ -39,33 +46,34 @@
 impl AccountId {
     #[must_use]
     pub fn new(s: &str) -> Self {
         correctness::valid_string(s, "`AccountId` value");
         correctness::string_contains(s, "-", "`TraderId` value");
 
         Self {
-            value: Box::new(Rc::new(s.to_string())),
+            value: Box::new(Arc::new(s.to_string())),
         }
     }
 }
 
 impl Default for AccountId {
     fn default() -> Self {
         Self {
-            value: Box::new(Rc::new(String::from("SIM-001"))),
+            value: Box::new(Arc::new(String::from("SIM-001"))),
         }
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // C API
 ////////////////////////////////////////////////////////////////////////////////
 /// Returns a Nautilus identifier from a C string pointer.
 ///
 /// # Safety
+///
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
 pub unsafe extern "C" fn account_id_new(ptr: *const c_char) -> AccountId {
     AccountId::new(CStr::from_ptr(ptr).to_str().expect("CStr::from_ptr failed"))
 }
 
 #[no_mangle]
@@ -78,15 +86,15 @@
 pub extern "C" fn account_id_drop(account_id: AccountId) {
     drop(account_id); // Memory freed here
 }
 
 /// Returns an [`AccountId`] as a C string pointer.
 #[no_mangle]
 pub extern "C" fn account_id_to_cstr(account_id: &AccountId) -> *const c_char {
-    string_to_cstr(&account_id.value)
+    str_to_cstr(&account_id.value)
 }
 
 #[no_mangle]
 pub extern "C" fn account_id_eq(lhs: &AccountId, rhs: &AccountId) -> u8 {
     u8::from(lhs == rhs)
 }
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/identifiers/client_id.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/client_id.rs`

 * *Files 8% similar despite different names*

```diff
@@ -9,54 +9,62 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::collections::hash_map::DefaultHasher;
-use std::ffi::{c_char, CStr};
-use std::fmt::{Debug, Display, Formatter};
-use std::hash::{Hash, Hasher};
-use std::rc::Rc;
+use std::{
+    collections::hash_map::DefaultHasher,
+    ffi::{c_char, CStr},
+    fmt::{Debug, Display, Formatter},
+    hash::{Hash, Hasher},
+    sync::Arc,
+};
 
-use nautilus_core::correctness;
-use nautilus_core::string::string_to_cstr;
+use nautilus_core::{correctness, string::str_to_cstr};
+use pyo3::prelude::*;
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug)]
-#[allow(clippy::box_collection)] // C ABI compatibility
-#[allow(clippy::redundant_allocation)] // C ABI compatibility
+#[derive(Clone, Hash, PartialEq, Eq)]
+#[pyclass]
 pub struct ClientId {
-    pub value: Box<Rc<String>>,
+    pub value: Box<Arc<String>>,
+}
+
+impl Debug for ClientId {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        write!(f, "{:?}", self.value)
+    }
 }
 
 impl Display for ClientId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
         write!(f, "{}", self.value)
     }
 }
 
 impl ClientId {
     #[must_use]
     pub fn new(s: &str) -> Self {
         correctness::valid_string(s, "`ClientId` value");
 
         Self {
-            value: Box::new(Rc::new(s.to_string())),
+            value: Box::new(Arc::new(s.to_string())),
         }
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // C API
 ////////////////////////////////////////////////////////////////////////////////
 /// Returns a Nautilus identifier from C string pointer.
 ///
 /// # Safety
+///
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
 pub unsafe extern "C" fn client_id_new(ptr: *const c_char) -> ClientId {
     ClientId::new(CStr::from_ptr(ptr).to_str().expect("CStr::from_ptr failed"))
 }
 
 #[no_mangle]
@@ -69,15 +77,15 @@
 pub extern "C" fn client_id_drop(client_id: ClientId) {
     drop(client_id); // Memory freed here
 }
 
 /// Returns a [`ClientId`] identifier as a C string pointer.
 #[no_mangle]
 pub extern "C" fn client_id_to_cstr(client_id: &ClientId) -> *const c_char {
-    string_to_cstr(&client_id.value)
+    str_to_cstr(&client_id.value)
 }
 
 #[no_mangle]
 pub extern "C" fn client_id_eq(lhs: &ClientId, rhs: &ClientId) -> u8 {
     u8::from(lhs == rhs)
 }
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/identifiers/client_order_id.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/client_order_id.rs`

 * *Files 7% similar despite different names*

```diff
@@ -9,54 +9,70 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::collections::hash_map::DefaultHasher;
-use std::ffi::{c_char, CStr};
-use std::fmt::{Debug, Display, Formatter};
-use std::hash::{Hash, Hasher};
-use std::rc::Rc;
+use std::{
+    collections::hash_map::DefaultHasher,
+    ffi::{c_char, CStr},
+    fmt::{Debug, Display, Formatter},
+    hash::{Hash, Hasher},
+    sync::Arc,
+};
 
-use nautilus_core::correctness;
-use nautilus_core::string::string_to_cstr;
+use nautilus_core::{correctness, string::str_to_cstr};
+use pyo3::prelude::*;
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug)]
-#[allow(clippy::box_collection)] // C ABI compatibility
-#[allow(clippy::redundant_allocation)] // C ABI compatibility
+#[derive(Clone, Hash, PartialEq, Eq)]
+#[pyclass]
 pub struct ClientOrderId {
-    pub value: Box<Rc<String>>,
+    pub value: Box<Arc<String>>,
+}
+
+impl Debug for ClientOrderId {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        write!(f, "{:?}", self.value)
+    }
 }
 
 impl Display for ClientOrderId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
         write!(f, "{}", self.value)
     }
 }
 
+impl Default for ClientOrderId {
+    fn default() -> Self {
+        Self {
+            value: Box::new(Arc::new(String::from("O-123456789"))),
+        }
+    }
+}
+
 impl ClientOrderId {
     #[must_use]
     pub fn new(s: &str) -> Self {
         correctness::valid_string(s, "`ClientOrderId` value");
 
         Self {
-            value: Box::new(Rc::new(s.to_string())),
+            value: Box::new(Arc::new(s.to_string())),
         }
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // C API
 ////////////////////////////////////////////////////////////////////////////////
 /// Returns a Nautilus identifier from a C string pointer.
 ///
 /// # Safety
+///
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
 pub unsafe extern "C" fn client_order_id_new(ptr: *const c_char) -> ClientOrderId {
     ClientOrderId::new(CStr::from_ptr(ptr).to_str().expect("CStr::from_ptr failed"))
 }
 
 #[no_mangle]
@@ -69,15 +85,15 @@
 pub extern "C" fn client_order_id_drop(client_order_id: ClientOrderId) {
     drop(client_order_id); // Memory freed here
 }
 
 /// Returns a [`ClientOrderId`] as a C string pointer.
 #[no_mangle]
 pub extern "C" fn client_order_id_to_cstr(client_order_id: &ClientOrderId) -> *const c_char {
-    string_to_cstr(&client_order_id.value)
+    str_to_cstr(&client_order_id.value)
 }
 
 #[no_mangle]
 pub extern "C" fn client_order_id_eq(lhs: &ClientOrderId, rhs: &ClientOrderId) -> u8 {
     u8::from(lhs == rhs)
 }
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/identifiers/component_id.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/component_id.rs`

 * *Files 7% similar despite different names*

```diff
@@ -9,54 +9,62 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::collections::hash_map::DefaultHasher;
-use std::ffi::{c_char, CStr};
-use std::fmt::{Debug, Display, Formatter};
-use std::hash::{Hash, Hasher};
-use std::rc::Rc;
+use std::{
+    collections::hash_map::DefaultHasher,
+    ffi::{c_char, CStr},
+    fmt::{Debug, Display, Formatter},
+    hash::{Hash, Hasher},
+    sync::Arc,
+};
 
-use nautilus_core::correctness;
-use nautilus_core::string::string_to_cstr;
+use nautilus_core::{correctness, string::str_to_cstr};
+use pyo3::prelude::*;
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug)]
-#[allow(clippy::box_collection)] // C ABI compatibility
-#[allow(clippy::redundant_allocation)] // C ABI compatibility
+#[derive(Clone, Hash, PartialEq, Eq)]
+#[pyclass]
 pub struct ComponentId {
-    pub value: Box<Rc<String>>,
+    pub value: Box<Arc<String>>,
+}
+
+impl Debug for ComponentId {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        write!(f, "{:?}", self.value)
+    }
 }
 
 impl Display for ComponentId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
         write!(f, "{}", self.value)
     }
 }
 
 impl ComponentId {
     #[must_use]
     pub fn new(s: &str) -> Self {
         correctness::valid_string(s, "`ComponentId` value");
 
         Self {
-            value: Box::new(Rc::new(s.to_string())),
+            value: Box::new(Arc::new(s.to_string())),
         }
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // C API
 ////////////////////////////////////////////////////////////////////////////////
 /// Returns a Nautilus identifier from a C string pointer.
 ///
 /// # Safety
+///
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
 pub unsafe extern "C" fn component_id_new(ptr: *const c_char) -> ComponentId {
     ComponentId::new(CStr::from_ptr(ptr).to_str().expect("CStr::from_ptr failed"))
 }
 
 #[no_mangle]
@@ -69,15 +77,15 @@
 pub extern "C" fn component_id_drop(component_id: ComponentId) {
     drop(component_id); // Memory freed here
 }
 
 /// Returns a [`ComponentId`] identifier as a C string pointer.
 #[no_mangle]
 pub extern "C" fn component_id_to_cstr(component_id: &ComponentId) -> *const c_char {
-    string_to_cstr(&component_id.value)
+    str_to_cstr(&component_id.value)
 }
 
 #[no_mangle]
 pub extern "C" fn component_id_eq(lhs: &ComponentId, rhs: &ComponentId) -> u8 {
     u8::from(lhs == rhs)
 }
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/identifiers/exec_algorithm_id.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/exec_algorithm_id.rs`

 * *Files 12% similar despite different names*

```diff
@@ -9,54 +9,62 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::collections::hash_map::DefaultHasher;
-use std::ffi::{c_char, CStr};
-use std::fmt::{Debug, Display, Formatter};
-use std::hash::{Hash, Hasher};
-use std::rc::Rc;
+use std::{
+    collections::hash_map::DefaultHasher,
+    ffi::{c_char, CStr},
+    fmt::{Debug, Display, Formatter},
+    hash::{Hash, Hasher},
+    sync::Arc,
+};
 
-use nautilus_core::correctness;
-use nautilus_core::string::string_to_cstr;
+use nautilus_core::{correctness, string::str_to_cstr};
+use pyo3::prelude::*;
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug)]
-#[allow(clippy::box_collection)] // C ABI compatibility
-#[allow(clippy::redundant_allocation)] // C ABI compatibility
+#[derive(Clone, Hash, PartialEq, Eq)]
+#[pyclass]
 pub struct ExecAlgorithmId {
-    pub value: Box<Rc<String>>,
+    pub value: Box<Arc<String>>,
+}
+
+impl Debug for ExecAlgorithmId {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        write!(f, "{:?}", self.value)
+    }
 }
 
 impl Display for ExecAlgorithmId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
         write!(f, "{}", self.value)
     }
 }
 
 impl ExecAlgorithmId {
     #[must_use]
     pub fn new(s: &str) -> Self {
         correctness::valid_string(s, "`ExecAlgorithmId` value");
 
         Self {
-            value: Box::new(Rc::new(s.to_string())),
+            value: Box::new(Arc::new(s.to_string())),
         }
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // C API
 ////////////////////////////////////////////////////////////////////////////////
 /// Returns a Nautilus identifier from a C string pointer.
 ///
 /// # Safety
+///
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
 pub unsafe extern "C" fn exec_algorithm_id_new(ptr: *const c_char) -> ExecAlgorithmId {
     ExecAlgorithmId::new(CStr::from_ptr(ptr).to_str().expect("CStr::from_ptr failed"))
 }
 
 #[no_mangle]
@@ -69,15 +77,15 @@
 pub extern "C" fn exec_algorithm_id_drop(exec_algorithm_id: ExecAlgorithmId) {
     drop(exec_algorithm_id); // Memory freed here
 }
 
 /// Returns an [`ExecAlgorithmId`] identifier as a C string pointer.
 #[no_mangle]
 pub extern "C" fn exec_algorithm_id_to_cstr(exec_algorithm_id: &ExecAlgorithmId) -> *const c_char {
-    string_to_cstr(&exec_algorithm_id.value)
+    str_to_cstr(&exec_algorithm_id.value)
 }
 
 #[no_mangle]
 pub extern "C" fn exec_algorithm_id_eq(lhs: &ExecAlgorithmId, rhs: &ExecAlgorithmId) -> u8 {
     u8::from(lhs == rhs)
 }
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/identifiers/instrument_id.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/instrument_id.rs`

 * *Files 12% similar despite different names*

```diff
@@ -9,29 +9,32 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::collections::hash_map::DefaultHasher;
-use std::ffi::c_char;
-use std::fmt::{Debug, Display, Formatter};
-use std::hash::{Hash, Hasher};
-use std::str::FromStr;
-
-use nautilus_core::string::{cstr_to_string, string_to_cstr};
+use std::{
+    collections::hash_map::DefaultHasher,
+    ffi::c_char,
+    fmt::{Debug, Display, Formatter},
+    hash::{Hash, Hasher},
+    str::FromStr,
+};
+
+use nautilus_core::string::{cstr_to_string, str_to_cstr};
+use pyo3::prelude::*;
+use serde::{Deserialize, Deserializer, Serialize};
 use thiserror::Error;
 
-use crate::identifiers::symbol::Symbol;
-use crate::identifiers::venue::Venue;
+use crate::identifiers::{symbol::Symbol, venue::Venue};
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug)]
-#[allow(clippy::box_collection)] // C ABI compatibility
+#[derive(Clone, Hash, PartialEq, Eq, Default)]
+#[pyclass]
 pub struct InstrumentId {
     pub symbol: Symbol,
     pub venue: Venue,
 }
 
 #[derive(Debug, Error)]
 #[error("Error parsing `InstrumentId` from '{input}'")]
@@ -51,40 +54,67 @@
             None => Err(InstrumentIdParseError {
                 input: s.to_string(),
             }),
         }
     }
 }
 
+impl Debug for InstrumentId {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        write!(f, "\"{}.{}\"", self.symbol, self.venue)
+    }
+}
+
 impl Display for InstrumentId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
         write!(f, "{}.{}", self.symbol, self.venue)
     }
 }
 
 impl InstrumentId {
     #[must_use]
     pub fn new(symbol: Symbol, venue: Venue) -> Self {
         Self { symbol, venue }
     }
 }
 
+impl Serialize for InstrumentId {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: serde::Serializer,
+    {
+        serializer.serialize_str(&format!("{}", self))
+    }
+}
+
+impl<'de> Deserialize<'de> for InstrumentId {
+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
+    where
+        D: Deserializer<'de>,
+    {
+        let instrument_id_str = String::deserialize(deserializer)?;
+        InstrumentId::from_str(&instrument_id_str)
+            .map_err(|err| serde::de::Error::custom(err.to_string()))
+    }
+}
+
 ////////////////////////////////////////////////////////////////////////////////
 // C API
 ////////////////////////////////////////////////////////////////////////////////
 #[no_mangle]
 pub extern "C" fn instrument_id_new(symbol: &Symbol, venue: &Venue) -> InstrumentId {
     let symbol = symbol.clone();
     let venue = venue.clone();
     InstrumentId::new(symbol, venue)
 }
 
 /// Returns a Nautilus identifier from a C string pointer.
 ///
 /// # Safety
+///
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
 pub unsafe extern "C" fn instrument_id_new_from_cstr(ptr: *const c_char) -> InstrumentId {
     InstrumentId::from_str(cstr_to_string(ptr).as_str()).unwrap()
 }
 
 #[no_mangle]
@@ -97,15 +127,15 @@
 pub extern "C" fn instrument_id_drop(instrument_id: InstrumentId) {
     drop(instrument_id); // Memory freed here
 }
 
 /// Returns an [`InstrumentId`] as a C string pointer.
 #[no_mangle]
 pub extern "C" fn instrument_id_to_cstr(instrument_id: &InstrumentId) -> *const c_char {
-    string_to_cstr(&instrument_id.to_string())
+    str_to_cstr(&instrument_id.to_string())
 }
 
 #[no_mangle]
 pub extern "C" fn instrument_id_eq(lhs: &InstrumentId, rhs: &InstrumentId) -> u8 {
     u8::from(lhs == rhs)
 }
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/identifiers/mod.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/orderbook/mod.rs`

 * *Files 17% similar despite different names*

```diff
@@ -9,21 +9,11 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-pub mod account_id;
-pub mod client_id;
-pub mod client_order_id;
-pub mod component_id;
-pub mod exec_algorithm_id;
-pub mod instrument_id;
-pub mod order_list_id;
-pub mod position_id;
-pub mod strategy_id;
-pub mod symbol;
-pub mod trade_id;
-pub mod trader_id;
-pub mod venue;
-pub mod venue_order_id;
+pub mod book;
+pub mod book_api;
+pub mod ladder;
+pub mod level;
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/identifiers/order_list_id.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/order_list_id.rs`

 * *Files 6% similar despite different names*

```diff
@@ -9,54 +9,62 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::collections::hash_map::DefaultHasher;
-use std::ffi::{c_char, CStr};
-use std::fmt::{Debug, Display, Formatter};
-use std::hash::{Hash, Hasher};
-use std::rc::Rc;
+use std::{
+    collections::hash_map::DefaultHasher,
+    ffi::{c_char, CStr},
+    fmt::{Debug, Display, Formatter},
+    hash::{Hash, Hasher},
+    sync::Arc,
+};
 
-use nautilus_core::correctness;
-use nautilus_core::string::string_to_cstr;
+use nautilus_core::{correctness, string::str_to_cstr};
+use pyo3::prelude::*;
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug)]
-#[allow(clippy::box_collection)] // C ABI compatibility
-#[allow(clippy::redundant_allocation)] // C ABI compatibility
+#[derive(Clone, Hash, PartialEq, Eq)]
+#[pyclass]
 pub struct OrderListId {
-    pub value: Box<Rc<String>>,
+    pub value: Box<Arc<String>>,
+}
+
+impl Debug for OrderListId {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        write!(f, "{:?}", self.value)
+    }
 }
 
 impl Display for OrderListId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
         write!(f, "{}", self.value)
     }
 }
 
 impl OrderListId {
     #[must_use]
     pub fn new(s: &str) -> Self {
         correctness::valid_string(s, "`OrderListId` value");
 
         Self {
-            value: Box::new(Rc::new(s.to_string())),
+            value: Box::new(Arc::new(s.to_string())),
         }
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // C API
 ////////////////////////////////////////////////////////////////////////////////
 /// Returns a Nautilus identifier from a C string pointer.
 ///
 /// # Safety
+///
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
 pub unsafe extern "C" fn order_list_id_new(ptr: *const c_char) -> OrderListId {
     OrderListId::new(CStr::from_ptr(ptr).to_str().expect("CStr::from_ptr failed"))
 }
 
 #[no_mangle]
@@ -69,15 +77,15 @@
 pub extern "C" fn order_list_id_drop(order_list_id: OrderListId) {
     drop(order_list_id); // Memory freed here
 }
 
 /// Returns an [`OrderListId`] as a C string pointer.
 #[no_mangle]
 pub extern "C" fn order_list_id_to_cstr(order_list_id: &OrderListId) -> *const c_char {
-    string_to_cstr(&order_list_id.value)
+    str_to_cstr(&order_list_id.value)
 }
 
 #[no_mangle]
 pub extern "C" fn order_list_id_eq(lhs: &OrderListId, rhs: &OrderListId) -> u8 {
     u8::from(lhs == rhs)
 }
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/identifiers/position_id.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/position_id.rs`

 * *Files 6% similar despite different names*

```diff
@@ -9,54 +9,61 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::collections::hash_map::DefaultHasher;
-use std::ffi::{c_char, CStr};
-use std::fmt::{Debug, Display, Formatter};
-use std::hash::{Hash, Hasher};
-use std::rc::Rc;
+use std::{
+    collections::hash_map::DefaultHasher,
+    ffi::{c_char, CStr},
+    fmt::{Debug, Display, Formatter},
+    hash::{Hash, Hasher},
+    sync::Arc,
+};
 
-use nautilus_core::correctness;
-use nautilus_core::string::string_to_cstr;
+use nautilus_core::{correctness, string::str_to_cstr};
+use pyo3::prelude::*;
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug)]
-#[allow(clippy::box_collection)] // C ABI compatibility
-#[allow(clippy::redundant_allocation)] // C ABI compatibility
+#[derive(Clone, Hash, PartialEq, Eq)]
+#[pyclass]
 pub struct PositionId {
-    pub value: Box<Rc<String>>,
+    pub value: Box<Arc<String>>,
 }
 
+impl Debug for PositionId {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        write!(f, "{:?}", self.value)
+    }
+}
 impl Display for PositionId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
         write!(f, "{}", self.value)
     }
 }
 
 impl PositionId {
     #[must_use]
     pub fn new(s: &str) -> Self {
         correctness::valid_string(s, "`PositionId` value");
 
         Self {
-            value: Box::new(Rc::new(s.to_string())),
+            value: Box::new(Arc::new(s.to_string())),
         }
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // C API
 ////////////////////////////////////////////////////////////////////////////////
 /// Returns a Nautilus identifier from a C string pointer.
 ///
 /// # Safety
+///
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
 pub unsafe extern "C" fn position_id_new(ptr: *const c_char) -> PositionId {
     PositionId::new(CStr::from_ptr(ptr).to_str().expect("CStr::from_ptr failed"))
 }
 
 #[no_mangle]
@@ -69,15 +76,15 @@
 pub extern "C" fn position_id_drop(position_id: PositionId) {
     drop(position_id); // Memory freed here
 }
 
 /// Returns a [`PositionId`] identifier as a C string pointer.
 #[no_mangle]
 pub extern "C" fn position_id_to_cstr(position_id: &PositionId) -> *const c_char {
-    string_to_cstr(&position_id.value)
+    str_to_cstr(&position_id.value)
 }
 
 #[no_mangle]
 pub extern "C" fn position_id_eq(lhs: &PositionId, rhs: &PositionId) -> u8 {
     u8::from(lhs == rhs)
 }
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/identifiers/strategy_id.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/strategy_id.rs`

 * *Files 9% similar despite different names*

```diff
@@ -9,55 +9,71 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::ffi::{c_char, CStr};
-use std::fmt::{Debug, Display, Formatter};
-use std::rc::Rc;
+use std::{
+    ffi::{c_char, CStr},
+    fmt::{Debug, Display, Formatter},
+    sync::Arc,
+};
 
-use nautilus_core::correctness;
-use nautilus_core::string::string_to_cstr;
+use nautilus_core::{correctness, string::str_to_cstr};
+use pyo3::prelude::*;
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug)]
-#[allow(clippy::box_collection)] // C ABI compatibility
-#[allow(clippy::redundant_allocation)] // C ABI compatibility
+#[derive(Clone, Hash, PartialEq, Eq)]
+#[pyclass]
 pub struct StrategyId {
-    pub value: Box<Rc<String>>,
+    pub value: Box<Arc<String>>,
+}
+
+impl Debug for StrategyId {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        write!(f, "{:?}", self.value)
+    }
 }
 
 impl Display for StrategyId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
         write!(f, "{}", self.value)
     }
 }
 
+impl Default for StrategyId {
+    fn default() -> Self {
+        Self {
+            value: Box::new(Arc::new(String::from("S-001"))),
+        }
+    }
+}
+
 impl StrategyId {
     #[must_use]
     pub fn new(s: &str) -> Self {
         correctness::valid_string(s, "`StrategyId` value");
         if s != "EXTERNAL" {
             correctness::string_contains(s, "-", "`StrategyId` value");
         }
 
         Self {
-            value: Box::new(Rc::new(s.to_string())),
+            value: Box::new(Arc::new(s.to_string())),
         }
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // C API
 ////////////////////////////////////////////////////////////////////////////////
 /// Returns a Nautilus identifier from a C string pointer.
 ///
 /// # Safety
+///
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
 pub unsafe extern "C" fn strategy_id_new(ptr: *const c_char) -> StrategyId {
     StrategyId::new(CStr::from_ptr(ptr).to_str().expect("CStr::from_ptr failed"))
 }
 
 #[no_mangle]
@@ -70,15 +86,15 @@
 pub extern "C" fn strategy_id_drop(strategy_id: StrategyId) {
     drop(strategy_id); // Memory freed here
 }
 
 /// Returns a [`StrategyId`] as a C string pointer.
 #[no_mangle]
 pub extern "C" fn strategy_id_to_cstr(strategy_id: &StrategyId) -> *const c_char {
-    string_to_cstr(&strategy_id.value)
+    str_to_cstr(&strategy_id.value)
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/identifiers/symbol.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/symbol.rs`

 * *Files 11% similar despite different names*

```diff
@@ -9,54 +9,70 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::collections::hash_map::DefaultHasher;
-use std::ffi::{c_char, CStr};
-use std::fmt::{Debug, Display, Formatter};
-use std::hash::{Hash, Hasher};
-use std::rc::Rc;
+use std::{
+    collections::hash_map::DefaultHasher,
+    ffi::{c_char, CStr},
+    fmt::{Debug, Display, Formatter},
+    hash::{Hash, Hasher},
+    sync::Arc,
+};
 
-use nautilus_core::correctness;
-use nautilus_core::string::string_to_cstr;
+use nautilus_core::{correctness, string::str_to_cstr};
+use pyo3::prelude::*;
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug)]
-#[allow(clippy::box_collection)] // C ABI compatibility
-#[allow(clippy::redundant_allocation)] // C ABI compatibility
+#[derive(Clone, Hash, PartialEq, Eq)]
+#[pyclass]
 pub struct Symbol {
-    pub value: Box<Rc<String>>,
+    pub value: Box<Arc<String>>,
+}
+
+impl Debug for Symbol {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        write!(f, "{:?}", self.value)
+    }
 }
 
 impl Display for Symbol {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
         write!(f, "{}", self.value)
     }
 }
 
+impl Default for Symbol {
+    fn default() -> Self {
+        Self {
+            value: Box::new(Arc::new(String::from("AUD/USD"))),
+        }
+    }
+}
+
 impl Symbol {
     #[must_use]
     pub fn new(s: &str) -> Self {
         correctness::valid_string(s, "`Symbol` value");
 
         Self {
-            value: Box::new(Rc::new(s.to_string())),
+            value: Box::new(Arc::new(s.to_string())),
         }
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // C API
 ////////////////////////////////////////////////////////////////////////////////
 /// Returns a Nautilus identifier from a C string pointer.
 ///
 /// # Safety
+///
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
 pub unsafe extern "C" fn symbol_new(ptr: *const c_char) -> Symbol {
     Symbol::new(CStr::from_ptr(ptr).to_str().expect("CStr::from_ptr failed"))
 }
 
 #[no_mangle]
@@ -69,15 +85,15 @@
 pub extern "C" fn symbol_drop(symbol: Symbol) {
     drop(symbol); // Memory freed here
 }
 
 /// Returns a [`Symbol`] as a C string pointer.
 #[no_mangle]
 pub extern "C" fn symbol_to_cstr(symbol: &Symbol) -> *const c_char {
-    string_to_cstr(&symbol.value)
+    str_to_cstr(&symbol.value)
 }
 
 #[no_mangle]
 pub extern "C" fn symbol_eq(lhs: &Symbol, rhs: &Symbol) -> u8 {
     u8::from(lhs == rhs)
 }
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/identifiers/trade_id.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/trade_id.rs`

 * *Files 7% similar despite different names*

```diff
@@ -9,54 +9,62 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::collections::hash_map::DefaultHasher;
-use std::ffi::{c_char, CStr};
-use std::fmt::{Debug, Display, Formatter};
-use std::hash::{Hash, Hasher};
-use std::rc::Rc;
+use std::{
+    collections::hash_map::DefaultHasher,
+    ffi::{c_char, CStr},
+    fmt::{Debug, Display, Formatter},
+    hash::{Hash, Hasher},
+    sync::Arc,
+};
 
-use nautilus_core::correctness;
-use nautilus_core::string::string_to_cstr;
+use nautilus_core::{correctness, string::str_to_cstr};
+use pyo3::prelude::*;
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug)]
-#[allow(clippy::box_collection)] // C ABI compatibility
-#[allow(clippy::redundant_allocation)] // C ABI compatibility
+#[derive(Clone, Hash, PartialEq, Eq)]
+#[pyclass]
 pub struct TradeId {
-    pub value: Box<Rc<String>>,
+    pub value: Box<Arc<String>>,
+}
+
+impl Debug for TradeId {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        write!(f, "{:?}", self.value)
+    }
 }
 
 impl Display for TradeId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
         write!(f, "{}", self.value)
     }
 }
 
 impl TradeId {
     #[must_use]
     pub fn new(s: &str) -> Self {
         correctness::valid_string(s, "`TradeId` value");
 
         Self {
-            value: Box::new(Rc::new(s.to_string())),
+            value: Box::new(Arc::new(s.to_string())),
         }
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // C API
 ////////////////////////////////////////////////////////////////////////////////
 /// Returns a Nautilus identifier from a C string pointer.
 ///
 /// # Safety
+///
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
 pub unsafe extern "C" fn trade_id_new(ptr: *const c_char) -> TradeId {
     TradeId::new(CStr::from_ptr(ptr).to_str().expect("CStr::from_ptr failed"))
 }
 
 #[no_mangle]
@@ -69,15 +77,15 @@
 pub extern "C" fn trade_id_drop(trade_id: TradeId) {
     drop(trade_id); // Memory freed here
 }
 
 /// Returns [`TradeId`] as a C string pointer.
 #[no_mangle]
 pub extern "C" fn trade_id_to_cstr(trade_id: &TradeId) -> *const c_char {
-    string_to_cstr(&trade_id.value)
+    str_to_cstr(&trade_id.value)
 }
 
 #[no_mangle]
 pub extern "C" fn trade_id_eq(lhs: &TradeId, rhs: &TradeId) -> u8 {
     u8::from(lhs == rhs)
 }
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/identifiers/trader_id.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/trader_id.rs`

 * *Files 18% similar despite different names*

```diff
@@ -9,53 +9,69 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::ffi::{c_char, CStr};
-use std::fmt::{Debug, Display, Formatter};
-use std::rc::Rc;
+use std::{
+    ffi::{c_char, CStr},
+    fmt::{Debug, Display, Formatter},
+    sync::Arc,
+};
 
-use nautilus_core::correctness;
-use nautilus_core::string::string_to_cstr;
+use nautilus_core::{correctness, string::str_to_cstr};
+use pyo3::prelude::*;
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug)]
-#[allow(clippy::box_collection)] // C ABI compatibility
-#[allow(clippy::redundant_allocation)] // C ABI compatibility
+#[derive(Clone, Hash, PartialEq, Eq)]
+#[pyclass]
 pub struct TraderId {
-    pub value: Box<Rc<String>>,
+    pub value: Box<Arc<String>>,
+}
+
+impl Debug for TraderId {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        write!(f, "{:?}", self.value)
+    }
 }
 
 impl Display for TraderId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
         write!(f, "{}", self.value)
     }
 }
 
+impl Default for TraderId {
+    fn default() -> Self {
+        Self {
+            value: Box::new(Arc::new(String::from("TRADER-000"))),
+        }
+    }
+}
+
 impl TraderId {
     #[must_use]
     pub fn new(s: &str) -> Self {
         correctness::valid_string(s, "`TraderId` value");
         correctness::string_contains(s, "-", "`TraderId` value");
 
         Self {
-            value: Box::new(Rc::new(s.to_string())),
+            value: Box::new(Arc::new(s.to_string())),
         }
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // C API
 ////////////////////////////////////////////////////////////////////////////////
 /// Returns a Nautilus identifier from a C string pointer.
 ///
 /// # Safety
+///
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
 pub unsafe extern "C" fn trader_id_new(ptr: *const c_char) -> TraderId {
     TraderId::new(CStr::from_ptr(ptr).to_str().expect("CStr::from_ptr failed"))
 }
 
 #[no_mangle]
@@ -68,15 +84,15 @@
 pub extern "C" fn trader_id_drop(trader_id: TraderId) {
     drop(trader_id); // Memory freed here
 }
 
 /// Returns a [`TraderId`] as a C string pointer.
 #[no_mangle]
 pub extern "C" fn trader_id_to_cstr(trader_id: &TraderId) -> *const c_char {
-    string_to_cstr(&trader_id.value)
+    str_to_cstr(&trader_id.value)
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/identifiers/venue.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/venue.rs`

 * *Files 10% similar despite different names*

```diff
@@ -9,54 +9,70 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::collections::hash_map::DefaultHasher;
-use std::ffi::{c_char, CStr};
-use std::fmt::{Debug, Display, Formatter};
-use std::hash::{Hash, Hasher};
-use std::rc::Rc;
+use std::{
+    collections::hash_map::DefaultHasher,
+    ffi::{c_char, CStr},
+    fmt::{Debug, Display, Formatter},
+    hash::{Hash, Hasher},
+    sync::Arc,
+};
 
-use nautilus_core::correctness;
-use nautilus_core::string::string_to_cstr;
+use nautilus_core::{correctness, string::str_to_cstr};
+use pyo3::prelude::*;
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug)]
-#[allow(clippy::box_collection)] // C ABI compatibility
-#[allow(clippy::redundant_allocation)] // C ABI compatibility
+#[derive(Clone, Hash, PartialEq, Eq)]
+#[pyclass]
 pub struct Venue {
-    pub value: Box<Rc<String>>,
+    pub value: Box<Arc<String>>,
+}
+
+impl Debug for Venue {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        write!(f, "{:?}", self.value)
+    }
 }
 
 impl Display for Venue {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
         write!(f, "{}", self.value)
     }
 }
 
+impl Default for Venue {
+    fn default() -> Self {
+        Self {
+            value: Box::new(Arc::new(String::from("SIM"))),
+        }
+    }
+}
+
 impl Venue {
     #[must_use]
     pub fn new(s: &str) -> Self {
         correctness::valid_string(s, "`Venue` value");
 
         Self {
-            value: Box::new(Rc::new(s.to_string())),
+            value: Box::new(Arc::new(s.to_string())),
         }
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // C API
 ////////////////////////////////////////////////////////////////////////////////
 /// Returns a Nautilus identifier from a C string pointer.
 ///
 /// # Safety
+///
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
 pub unsafe extern "C" fn venue_new(ptr: *const c_char) -> Venue {
     Venue::new(CStr::from_ptr(ptr).to_str().expect("CStr::from_ptr failed"))
 }
 
 #[no_mangle]
@@ -69,15 +85,15 @@
 pub extern "C" fn venue_drop(venue: Venue) {
     drop(venue); // Memory freed here
 }
 
 /// Returns a [`Venue`] identifier as a C string pointer.
 #[no_mangle]
 pub extern "C" fn venue_to_cstr(venue: &Venue) -> *const c_char {
-    string_to_cstr(&venue.value)
+    str_to_cstr(&venue.value)
 }
 
 #[no_mangle]
 pub extern "C" fn venue_eq(lhs: &Venue, rhs: &Venue) -> u8 {
     u8::from(lhs == rhs)
 }
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/identifiers/venue_order_id.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/identifiers/venue_order_id.rs`

 * *Files 6% similar despite different names*

```diff
@@ -9,62 +9,70 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::collections::hash_map::DefaultHasher;
-use std::ffi::{c_char, CStr};
-use std::fmt::{Debug, Display, Formatter};
-use std::hash::{Hash, Hasher};
-use std::rc::Rc;
+use std::{
+    collections::hash_map::DefaultHasher,
+    ffi::{c_char, CStr},
+    fmt::{Debug, Display, Formatter},
+    hash::{Hash, Hasher},
+    sync::Arc,
+};
 
-use nautilus_core::correctness;
-use nautilus_core::string::string_to_cstr;
+use nautilus_core::{correctness, string::str_to_cstr};
+use pyo3::prelude::*;
 
 #[repr(C)]
-#[derive(Clone, Hash, PartialEq, Eq, Debug)]
-#[allow(clippy::box_collection)] // C ABI compatibility
-#[allow(clippy::redundant_allocation)] // C ABI compatibility
+#[derive(Clone, Hash, PartialEq, Eq)]
+#[pyclass]
 pub struct VenueOrderId {
-    pub value: Box<Rc<String>>,
+    pub value: Box<Arc<String>>,
+}
+
+impl Debug for VenueOrderId {
+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        write!(f, "{:?}", self.value)
+    }
 }
 
 impl Display for VenueOrderId {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
         write!(f, "{}", self.value)
     }
 }
 
 impl VenueOrderId {
     #[must_use]
     pub fn new(s: &str) -> Self {
         correctness::valid_string(s, "`VenueOrderId` value");
 
         Self {
-            value: Box::new(Rc::new(s.to_string())),
+            value: Box::new(Arc::new(s.to_string())),
         }
     }
 }
 
 impl Default for VenueOrderId {
     fn default() -> Self {
         Self {
-            value: Box::new(Rc::new(String::from("001"))),
+            value: Box::new(Arc::new(String::from("001"))),
         }
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // C API
 ////////////////////////////////////////////////////////////////////////////////
 /// Returns a Nautilus identifier from a C string pointer.
 ///
 /// # Safety
+///
 /// - Assumes `ptr` is a valid C string pointer.
 #[no_mangle]
 pub unsafe extern "C" fn venue_order_id_new(ptr: *const c_char) -> VenueOrderId {
     VenueOrderId::new(CStr::from_ptr(ptr).to_str().expect("CStr::from_ptr failed"))
 }
 
 #[no_mangle]
@@ -76,15 +84,15 @@
 #[no_mangle]
 pub extern "C" fn venue_order_id_drop(venue_order_id: VenueOrderId) {
     drop(venue_order_id); // Memory freed here
 }
 
 #[no_mangle]
 pub extern "C" fn venue_order_id_to_cstr(venue_order_id: &VenueOrderId) -> *const c_char {
-    string_to_cstr(&venue_order_id.value)
+    str_to_cstr(&venue_order_id.value)
 }
 
 #[no_mangle]
 pub extern "C" fn venue_order_id_eq(lhs: &VenueOrderId, rhs: &VenueOrderId) -> u8 {
     u8::from(lhs == rhs)
 }
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/instruments/mod.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/instruments/mod.rs`

 * *Files 2% similar despite different names*

```diff
@@ -9,14 +9,17 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
+mod synthetic;
+mod synthetic_api;
+
 use rust_decimal::Decimal;
 
 use crate::{
     enums::{AssetClass, AssetType},
     identifiers::{instrument_id::InstrumentId, symbol::Symbol},
     types::{currency::Currency, price::Price, quantity::Quantity},
 };
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/lib.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/types/mod.rs`

 * *Files 16% similar despite different names*

```diff
@@ -9,32 +9,13 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-#![recursion_limit = "256"]
-#[macro_use]
-extern crate lazy_static;
-
-use crate::enums::PriceType;
-use pyo3::prelude::*;
-use pyo3::{PyResult, Python};
-
-pub mod currencies;
-pub mod data;
-pub mod enums;
-pub mod events;
-pub mod identifiers;
-pub mod instruments;
-pub mod orderbook;
-pub mod orders;
-pub mod position;
-pub mod types;
-
-/// Loaded as nautilus_model
-#[pymodule]
-pub fn model(_: Python<'_>, m: &PyModule) -> PyResult<()> {
-    m.add_class::<PriceType>()?;
-    Ok(())
-}
+pub mod balance;
+pub mod currency;
+pub mod fixed;
+pub mod money;
+pub mod price;
+pub mod quantity;
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/orderbook/level.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/orderbook/level.rs`

 * *Files 23% similar despite different names*

```diff
@@ -10,19 +10,21 @@
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::cmp::Ordering;
-use std::fmt::{Debug, Display, Formatter};
 
-use crate::data::book::BookOrder;
-use crate::orderbook::ladder::BookPrice;
+use crate::{
+    data::book::BookOrder,
+    orderbook::{book::BookIntegrityError, ladder::BookPrice},
+};
 
+#[derive(Clone, Debug, Eq)]
 pub struct Level {
     pub price: BookPrice,
     pub orders: Vec<BookOrder>,
 }
 
 impl Level {
     #[must_use]
@@ -46,15 +48,15 @@
     #[must_use]
     pub fn len(&self) -> usize {
         self.orders.len()
     }
 
     #[must_use]
     pub fn is_empty(&self) -> bool {
-        self.orders.len() == 0
+        self.orders.is_empty()
     }
 
     pub fn add_bulk(&mut self, orders: Vec<BookOrder>) {
         for order in orders {
             self.add(order)
         }
     }
@@ -71,25 +73,31 @@
         if order.size.raw == 0 {
             self.delete(&order)
         } else {
             let idx = self
                 .orders
                 .iter()
                 .position(|o| o.order_id == order.order_id)
-                .expect("Cannot update order: order not found");
+                .unwrap_or_else(|| {
+                    panic!("{}", &BookIntegrityError::OrderNotFound(order.order_id))
+                });
             self.orders[idx] = order;
         }
     }
 
     pub fn delete(&mut self, order: &BookOrder) {
+        self.remove(order.order_id);
+    }
+
+    pub fn remove(&mut self, order_id: u64) {
         let index = self
             .orders
             .iter()
-            .position(|o| o.order_id == order.order_id)
-            .expect("Cannot delete order: order not found");
+            .position(|o| o.order_id == order_id)
+            .unwrap_or_else(|| panic!("{}", &BookIntegrityError::OrderNotFound(order_id)));
         self.orders.remove(index);
     }
 
     #[must_use]
     pub fn volume(&self) -> f64 {
         let mut sum: f64 = 0.0;
         for o in self.orders.iter() {
@@ -110,16 +118,14 @@
 
 impl PartialEq for Level {
     fn eq(&self, other: &Self) -> bool {
         self.price == other.price
     }
 }
 
-impl Eq for Level {}
-
 impl PartialOrd for Level {
     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
         self.price.partial_cmp(&other.price)
     }
 
     fn lt(&self, other: &Self) -> bool {
         self.price.lt(&other.price)
@@ -140,56 +146,44 @@
 
 impl Ord for Level {
     fn cmp(&self, other: &Self) -> Ordering {
         self.price.cmp(&other.price)
     }
 }
 
-impl Debug for Level {
-    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "Level(price={})", self.price.value)
-    }
-}
-
-impl Display for Level {
-    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        write!(f, "Level(price={})", self.price.value)
-    }
-}
-
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
-    use crate::data::book::BookOrder;
-    use crate::enums::OrderSide;
-    use crate::orderbook::ladder::BookPrice;
-    use crate::orderbook::level::Level;
-    use crate::types::price::Price;
-    use crate::types::quantity::Quantity;
+    use crate::{
+        data::book::BookOrder,
+        enums::OrderSide,
+        orderbook::{ladder::BookPrice, level::Level},
+        types::{price::Price, quantity::Quantity},
+    };
 
     #[test]
-    fn test_level_comparisons_bid_side() {
+    fn test_comparisons_bid_side() {
         let level0 = Level::new(BookPrice::new(Price::new(1.00, 2), OrderSide::Buy));
         let level1 = Level::new(BookPrice::new(Price::new(1.01, 2), OrderSide::Buy));
         assert_eq!(level0, level0);
         assert!(level0 > level1);
     }
 
     #[test]
-    fn test_level_comparisons_ask_side() {
+    fn test_comparisons_ask_side() {
         let level0 = Level::new(BookPrice::new(Price::new(1.00, 2), OrderSide::Sell));
         let level1 = Level::new(BookPrice::new(Price::new(1.01, 2), OrderSide::Sell));
         assert_eq!(level0, level0);
         assert!(level0 < level1);
     }
 
     #[test]
-    fn test_level_add_one_order() {
+    fn test_add_one_order() {
         let mut level = Level::new(BookPrice::new(Price::new(1.00, 2), OrderSide::Buy));
         let order = BookOrder::new(
             OrderSide::Buy,
             Price::new(1.00, 2),
             Quantity::new(10.0, 0),
             0,
         );
@@ -197,15 +191,15 @@
         level.add(order);
         assert!(!level.is_empty());
         assert_eq!(level.len(), 1);
         assert_eq!(level.volume(), 10.0);
     }
 
     #[test]
-    fn test_level_add_multiple_orders() {
+    fn test_add_multiple_orders() {
         let mut level = Level::new(BookPrice::new(Price::new(2.00, 2), OrderSide::Buy));
         let order1 = BookOrder::new(
             OrderSide::Buy,
             Price::new(2.00, 2),
             Quantity::new(10.0, 0),
             0,
         );
@@ -220,15 +214,15 @@
         level.add(order2);
         assert_eq!(level.len(), 2);
         assert_eq!(level.volume(), 30.0);
         assert_eq!(level.exposure(), 60.0);
     }
 
     #[test]
-    fn test_level_update_order() {
+    fn test_update_order() {
         let mut level = Level::new(BookPrice::new(Price::new(1.00, 2), OrderSide::Buy));
         let order1 = BookOrder::new(
             OrderSide::Buy,
             Price::new(1.00, 2),
             Quantity::new(10.0, 0),
             0,
         );
@@ -243,15 +237,15 @@
         level.update(order2);
         assert_eq!(level.len(), 1);
         assert_eq!(level.volume(), 20.0);
         assert_eq!(level.exposure(), 20.0);
     }
 
     #[test]
-    fn test_level_update_order_with_zero_size_deletes() {
+    fn test_update_order_with_zero_size() {
         let mut level = Level::new(BookPrice::new(Price::new(1.00, 2), OrderSide::Buy));
         let order1 = BookOrder::new(
             OrderSide::Buy,
             Price::new(1.00, 2),
             Quantity::new(10.0, 0),
             0,
         );
@@ -264,8 +258,94 @@
 
         level.add(order1);
         level.update(order2);
         assert_eq!(level.len(), 0);
         assert_eq!(level.volume(), 0.0);
         assert_eq!(level.exposure(), 0.0);
     }
+
+    #[test]
+    fn test_delete_order() {
+        let mut level = Level::new(BookPrice::new(Price::new(1.00, 2), OrderSide::Buy));
+        let order1_id = 0;
+        let order1 = BookOrder::new(
+            OrderSide::Buy,
+            Price::new(1.00, 2),
+            Quantity::new(10.0, 0),
+            order1_id,
+        );
+        let order2_id = 0;
+        let order2 = BookOrder::new(
+            OrderSide::Buy,
+            Price::new(1.00, 2),
+            Quantity::new(20.0, 0),
+            order2_id,
+        );
+
+        level.add(order1);
+        level.add(order2);
+        level.delete(&order1);
+        assert_eq!(level.len(), 1);
+        assert_eq!(level.orders.first().unwrap().order_id, order2_id);
+        assert_eq!(level.volume(), 20.0);
+        assert_eq!(level.exposure(), 20.0);
+    }
+
+    #[test]
+    fn test_remove_order() {
+        let mut level = Level::new(BookPrice::new(Price::new(1.00, 2), OrderSide::Buy));
+        let order1_id = 0;
+        let order1 = BookOrder::new(
+            OrderSide::Buy,
+            Price::new(1.00, 2),
+            Quantity::new(10.0, 0),
+            order1_id,
+        );
+        let order2_id = 1;
+        let order2 = BookOrder::new(
+            OrderSide::Buy,
+            Price::new(1.00, 2),
+            Quantity::new(20.0, 0),
+            order2_id,
+        );
+
+        level.add(order1);
+        level.add(order2);
+        level.remove(order2_id);
+        assert_eq!(level.len(), 1);
+        assert_eq!(level.orders.first().unwrap().order_id, order1_id);
+        assert_eq!(level.volume(), 10.0);
+        assert_eq!(level.exposure(), 10.0);
+    }
+
+    #[test]
+    fn test_add_bulk_orders() {
+        let mut level = Level::new(BookPrice::new(Price::new(2.00, 2), OrderSide::Buy));
+        let order1_id = 0;
+        let order1 = BookOrder::new(
+            OrderSide::Buy,
+            Price::new(2.00, 2),
+            Quantity::new(10.0, 0),
+            order1_id,
+        );
+        let order2_id = 1;
+        let order2 = BookOrder::new(
+            OrderSide::Buy,
+            Price::new(2.00, 2),
+            Quantity::new(20.0, 0),
+            order2_id,
+        );
+
+        let orders = vec![order1, order2];
+        level.add_bulk(orders);
+        assert_eq!(level.len(), 2);
+        assert_eq!(level.volume(), 30.0);
+        assert_eq!(level.exposure(), 60.0);
+    }
+
+    #[test]
+    #[should_panic(expected = "Invalid book operation: order ID 1 not found")]
+    fn test_remove_nonexistent_order() {
+        let mut level = Level::new(BookPrice::new(Price::new(1.00, 2), OrderSide::Buy));
+        level.remove(1);
+    }
 }
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/orderbook/mod.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/events/mod.rs`

 * *Files 3% similar despite different names*

```diff
@@ -9,10 +9,10 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-pub mod book;
-pub mod ladder;
-pub mod level;
+pub mod order;
+pub mod order_api;
+pub mod position;
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/orders/limit.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/orders/limit.rs`

 * *Files 14% similar despite different names*

```diff
@@ -9,30 +9,26 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::rc::Rc;
-
 use nautilus_core::{time::UnixNanos, uuid::UUID4};
 
+use super::Order;
 use crate::{
     enums::{ContingencyType, OrderSide, OrderStatus, OrderType, TimeInForce, TriggerType},
-    events::order::OrderIdentifiers,
     identifiers::{
         client_order_id::ClientOrderId, instrument_id::InstrumentId, order_list_id::OrderListId,
         strategy_id::StrategyId, trader_id::TraderId,
     },
     types::{price::Price, quantity::Quantity},
 };
 
-use super::Order;
-
 pub trait LimitOrder {
     #[must_use]
     #[allow(clippy::too_many_arguments)]
     fn new(
         trader_id: TraderId,
         strategy_id: StrategyId,
         instrument_id: InstrumentId,
@@ -40,14 +36,15 @@
         order_side: OrderSide,
         quantity: Quantity,
         price: Price,
         time_in_force: TimeInForce,
         expire_time: Option<UnixNanos>,
         post_only: bool,
         reduce_only: bool,
+        quote_quantity: bool,
         display_qty: Option<Quantity>,
         emulation_trigger: Option<TriggerType>,
         contingency_type: Option<ContingencyType>,
         order_list_id: Option<OrderListId>,
         linked_order_ids: Option<Vec<ClientOrderId>>,
         parent_order_id: Option<ClientOrderId>,
         tags: Option<String>,
@@ -67,53 +64,52 @@
         order_side: OrderSide,
         quantity: Quantity,
         price: Price,
         time_in_force: TimeInForce,
         expire_time: Option<UnixNanos>,
         post_only: bool,
         reduce_only: bool,
+        quote_quantity: bool,
         display_qty: Option<Quantity>,
         emulation_trigger: Option<TriggerType>,
         contingency_type: Option<ContingencyType>,
         order_list_id: Option<OrderListId>,
         linked_order_ids: Option<Vec<ClientOrderId>>,
         parent_order_id: Option<ClientOrderId>,
         tags: Option<String>,
         init_id: UUID4,
         ts_init: UnixNanos,
     ) -> Self {
-        let metadata = OrderIdentifiers {
-            trader_id,
-            strategy_id,
-            instrument_id,
-            client_order_id,
-        };
         Self {
             events: Vec::new(),
             venue_order_ids: Vec::new(),
             trade_ids: Vec::new(),
             previous_status: None,
             triggered_price: None,
             status: OrderStatus::Initialized,
-            ids: Rc::new(metadata),
+            trader_id,
+            strategy_id,
+            instrument_id,
+            client_order_id,
             venue_order_id: None,
             position_id: None,
             account_id: None,
             last_trade_id: None,
             side: order_side,
             order_type: OrderType::Limit,
-            quantity: quantity.clone(),
+            quantity,
             price: Some(price),
             trigger_price: None,
             trigger_type: None,
             time_in_force,
             expire_time,
             liquidity_side: None,
             is_post_only: post_only,
             is_reduce_only: reduce_only,
+            is_quote_quantity: quote_quantity,
             display_qty,
             limit_offset: None,
             trailing_offset: None,
             trailing_offset_type: None,
             emulation_trigger,
             contingency_type,
             order_list_id,
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/orders/mod.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/orders/mod.rs`

 * *Files 2% similar despite different names*

```diff
@@ -13,38 +13,34 @@
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 #![allow(dead_code)]
 
 pub mod limit;
 
-use std::rc::Rc;
-
-use nautilus_core::time::UnixNanos;
-use nautilus_core::uuid::UUID4;
+use nautilus_core::{time::UnixNanos, uuid::UUID4};
 use thiserror::Error;
 
-use crate::enums::{
-    ContingencyType, LiquiditySide, OrderSide, OrderStatus, OrderType, PositionSide, TimeInForce,
-    TriggerType,
-};
-use crate::events::order::{
-    OrderAccepted, OrderCancelRejected, OrderCanceled, OrderDenied, OrderEvent, OrderExpired,
-    OrderFilled, OrderIdentifiers, OrderInitialized, OrderModifyRejected, OrderPendingCancel,
-    OrderPendingUpdate, OrderRejected, OrderSubmitted, OrderTriggered, OrderUpdated,
+use crate::{
+    enums::{
+        ContingencyType, LiquiditySide, OrderSide, OrderStatus, OrderType, PositionSide,
+        TimeInForce, TriggerType,
+    },
+    events::order::{
+        OrderAccepted, OrderCancelRejected, OrderCanceled, OrderDenied, OrderEvent, OrderExpired,
+        OrderFilled, OrderInitialized, OrderModifyRejected, OrderPendingCancel, OrderPendingUpdate,
+        OrderRejected, OrderSubmitted, OrderTriggered, OrderUpdated,
+    },
+    identifiers::{
+        account_id::AccountId, client_order_id::ClientOrderId, instrument_id::InstrumentId,
+        order_list_id::OrderListId, position_id::PositionId, strategy_id::StrategyId,
+        trade_id::TradeId, trader_id::TraderId, venue_order_id::VenueOrderId,
+    },
+    types::{fixed::fixed_i64_to_f64, price::Price, quantity::Quantity},
 };
-use crate::identifiers::account_id::AccountId;
-use crate::identifiers::client_order_id::ClientOrderId;
-use crate::identifiers::order_list_id::OrderListId;
-use crate::identifiers::position_id::PositionId;
-use crate::identifiers::trade_id::TradeId;
-use crate::identifiers::venue_order_id::VenueOrderId;
-use crate::types::fixed::fixed_i64_to_f64;
-use crate::types::price::Price;
-use crate::types::quantity::Quantity;
 
 #[derive(Error, Debug)]
 pub enum OrderError {
     #[error("Invalid state transition")]
     InvalidStateTransition,
     #[error("Unrecognized event")]
     UnrecognizedEvent,
@@ -116,15 +112,18 @@
 struct Order {
     events: Vec<OrderEvent>,
     venue_order_ids: Vec<VenueOrderId>, // TODO(cs): Should be `Vec<&VenueOrderId>` or similar
     trade_ids: Vec<TradeId>,            // TODO(cs): Should be `Vec<&TradeId>` or similar
     previous_status: Option<OrderStatus>,
     triggered_price: Option<Price>,
     pub status: OrderStatus,
-    pub ids: Rc<OrderIdentifiers>,
+    pub trader_id: TraderId,
+    pub strategy_id: StrategyId,
+    pub instrument_id: InstrumentId,
+    pub client_order_id: ClientOrderId,
     pub venue_order_id: Option<VenueOrderId>,
     pub position_id: Option<PositionId>,
     pub account_id: Option<AccountId>,
     pub last_trade_id: Option<TradeId>,
     pub side: OrderSide,
     pub order_type: OrderType,
     pub quantity: Quantity,
@@ -132,14 +131,15 @@
     pub trigger_price: Option<Price>,
     pub trigger_type: Option<TriggerType>,
     pub time_in_force: TimeInForce,
     pub expire_time: Option<UnixNanos>,
     pub liquidity_side: Option<LiquiditySide>,
     pub is_post_only: bool,
     pub is_reduce_only: bool,
+    pub is_quote_quantity: bool,
     pub display_qty: Option<Quantity>,
     pub limit_offset: Option<Price>,
     pub trailing_offset: Option<Price>,
     pub trailing_offset_type: Option<TriggerType>,
     pub emulation_trigger: Option<TriggerType>,
     pub contingency_type: Option<ContingencyType>,
     pub order_list_id: Option<OrderListId>,
@@ -154,85 +154,92 @@
     pub ts_triggered: Option<UnixNanos>,
     pub ts_init: UnixNanos,
     pub ts_last: UnixNanos,
 }
 
 impl PartialEq<Self> for Order {
     fn eq(&self, other: &Self) -> bool {
-        // TODO: can implement deref and deref mut for order metadata here too
-        self.ids.client_order_id == other.ids.client_order_id
+        self.client_order_id == other.client_order_id
     }
 }
 
 impl Eq for Order {}
 
 impl From<OrderInitialized> for Order {
     fn from(value: OrderInitialized) -> Self {
         Self {
             events: Vec::new(),
             venue_order_ids: Vec::new(),
             trade_ids: Vec::new(),
             previous_status: None,
             triggered_price: None,
             status: OrderStatus::Initialized,
-            ids: value.ids,
+            trader_id: value.trader_id,
+            strategy_id: value.strategy_id,
+            instrument_id: value.instrument_id,
+            client_order_id: value.client_order_id,
             venue_order_id: None,
             position_id: None,
             account_id: None,
             last_trade_id: None,
             side: value.order_side,
             order_type: value.order_type,
-            quantity: value.quantity.clone(),
+            quantity: value.quantity,
             price: value.price,
             trigger_price: value.trigger_price,
             trigger_type: value.trigger_type,
             time_in_force: value.time_in_force,
             expire_time: None,
             liquidity_side: None,
             is_post_only: value.post_only,
             is_reduce_only: value.reduce_only,
+            is_quote_quantity: value.quote_quantity,
             display_qty: None,
             limit_offset: None,
             trailing_offset: None,
             trailing_offset_type: None,
             emulation_trigger: value.emulation_trigger,
             contingency_type: value.contingency_type,
             order_list_id: value.order_list_id,
             linked_order_ids: value.linked_order_ids,
             parent_order_id: value.parent_order_id,
             tags: value.tags,
             filled_qty: Quantity::new(0.0, 0),
-            leaves_qty: value.quantity.clone(),
+            leaves_qty: value.quantity,
             avg_px: None,
             slippage: None,
             init_id: value.event_id,
             ts_triggered: None,
             ts_init: value.ts_event,
             ts_last: value.ts_event,
         }
     }
 }
 
 impl From<&Order> for OrderInitialized {
     fn from(value: &Order) -> Self {
         Self {
-            ids: value.ids.clone(),
+            trader_id: value.trader_id.clone(),
+            strategy_id: value.strategy_id.clone(),
+            instrument_id: value.instrument_id.clone(),
+            client_order_id: value.client_order_id.clone(),
             order_side: value.side,
             order_type: value.order_type,
-            quantity: value.quantity.clone(),
-            price: value.price.clone(),
-            trigger_price: value.triggered_price.clone(),
+            quantity: value.quantity,
+            price: value.price,
+            trigger_price: value.triggered_price,
             trigger_type: value.trigger_type,
             time_in_force: value.time_in_force,
             expire_time: value.expire_time,
             post_only: value.is_post_only,
             reduce_only: value.is_reduce_only,
-            display_qty: value.display_qty.clone(),
-            limit_offset: value.limit_offset.clone(),
-            trailing_offset: value.trailing_offset.clone(),
+            quote_quantity: value.is_quote_quantity,
+            display_qty: value.display_qty,
+            limit_offset: value.limit_offset,
+            trailing_offset: value.trailing_offset,
             trailing_offset_type: value.trailing_offset_type,
             emulation_trigger: value.emulation_trigger,
             contingency_type: value.contingency_type,
             order_list_id: value.order_list_id.clone(),
             linked_order_ids: value.linked_order_ids.clone(),
             parent_order_id: value.parent_order_id.clone(),
             tags: value.tags.clone(),
@@ -440,23 +447,23 @@
                     self.venue_order_ids.push(venue_order_id.clone()); // TODO(cs): Temporary clone
                 }
             }
             None => {}
         }
         if let Some(price) = &event.price {
             if self.price.is_some() {
-                self.price.replace(price.clone());
+                self.price.replace(*price);
             } else {
                 panic!("invalid update of `price` when None")
             }
         }
 
         if let Some(trigger_price) = &event.trigger_price {
             if self.trigger_price.is_some() {
-                self.trigger_price.replace(trigger_price.clone());
+                self.trigger_price.replace(*trigger_price);
             } else {
                 panic!("invalid update of `trigger_price` when None")
             }
         }
 
         self.quantity.raw = event.quantity.raw;
         self.leaves_qty = Quantity::from_raw(
@@ -512,18 +519,20 @@
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
     use rstest::rstest;
 
     use super::*;
-    use crate::enums::{OrderSide, OrderStatus, PositionSide};
-    use crate::events::order::{
-        OrderAcceptedBuilder, OrderDeniedBuilder, OrderEvent, OrderInitializedBuilder,
-        OrderSubmittedBuilder,
+    use crate::{
+        enums::{OrderSide, OrderStatus, PositionSide},
+        events::order::{
+            OrderAcceptedBuilder, OrderDeniedBuilder, OrderEvent, OrderInitializedBuilder,
+            OrderSubmittedBuilder,
+        },
     };
 
     #[test]
     fn test_order_initialized() {
         let order: Order = OrderInitializedBuilder::default().build().unwrap().into();
 
         assert_eq!(order.status, OrderStatus::Initialized);
@@ -618,32 +627,16 @@
         assert_eq!(order.last_event(), Some(&event));
     }
 
     #[test]
     fn test_buy_order_life_cyle_to_filled() {
         // TODO: We should be able to derive defaults for the below?
         let init = OrderInitializedBuilder::default().build().unwrap();
-        let submitted = OrderSubmittedBuilder::default()
-            .ids(init.ids.clone())
-            .account_id(AccountId::default())
-            .event_id(UUID4::default())
-            .ts_event(UnixNanos::default())
-            .ts_init(UnixNanos::default())
-            .build()
-            .unwrap();
-        let accepted = OrderAcceptedBuilder::default()
-            .ids(init.ids.clone())
-            .account_id(AccountId::default())
-            .venue_order_id(VenueOrderId::default())
-            .event_id(UUID4::default())
-            .ts_event(UnixNanos::default())
-            .ts_init(UnixNanos::default())
-            .reconciliation(false)
-            .build()
-            .unwrap();
+        let submitted = OrderSubmittedBuilder::default().build().unwrap();
+        let accepted = OrderAcceptedBuilder::default().build().unwrap();
         // let filled = OrderFilledBuilder::default()
         //     .ids(init.ids.clone())
         //     .account_id(AccountId::default())
         //     .venue_order_id(VenueOrderId::default())
         //     .position_id(None)
         //     .trade_id(TradeId::new("001"))
         //     .event_id(UUID4::default())
@@ -655,10 +648,10 @@
 
         let client_order_id = init.client_order_id.clone();
         let mut order: Order = init.into();
         let _ = order.apply(OrderEvent::OrderSubmitted(submitted));
         let _ = order.apply(OrderEvent::OrderAccepted(accepted));
         // let _ = order.apply(OrderEvent::OrderFilled(filled));
 
-        assert_eq!(order.ids.client_order_id, client_order_id);
+        assert_eq!(order.client_order_id, client_order_id);
     }
 }
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/position.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/position.rs`

 * *Files 0% similar despite different names*

```diff
@@ -94,19 +94,19 @@
             id: fill.position_id.clone().unwrap(), // TODO: Improve validation
             account_id: fill.account_id.clone(),
             opening_order_id: fill.client_order_id.clone(),
             closing_order_id: None,
             entry: fill.order_side,
             side: PositionSide::Flat,
             signed_qty: 0.0,
-            quantity: fill.last_qty.clone(),
-            peak_qty: fill.last_qty.clone(),
+            quantity: fill.last_qty,
+            peak_qty: fill.last_qty,
             price_precision: instrument.price_precision,
             size_precision: instrument.size_precision,
-            multiplier: instrument.multiplier.clone(),
+            multiplier: instrument.multiplier,
             is_inverse: instrument.is_inverse,
             quote_currency: instrument.quote_currency.clone(),
             base_currency: instrument.base_currency.clone(),
             cost_currency: instrument.cost_currency.clone(),
             ts_init: fill.ts_init,
             ts_opened: fill.ts_event,
             ts_last: fill.ts_event,
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/types/balance.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/types/balance.rs`

 * *Files 10% similar despite different names*

```diff
@@ -11,16 +11,15 @@
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::fmt::{Display, Formatter};
 
-use crate::types::currency::Currency;
-use crate::types::money::Money;
+use crate::types::{currency::Currency, money::Money};
 
 pub struct AccountBalance {
     pub currency: Currency,
     pub total: Money,
     pub locked: Money,
     pub free: Money,
 }
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/types/currency.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/types/currency.rs`

 * *Files 20% similar despite different names*

```diff
@@ -9,27 +9,34 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::collections::hash_map::DefaultHasher;
-use std::ffi::c_char;
-use std::hash::{Hash, Hasher};
-use std::sync::Arc;
+use std::{
+    collections::hash_map::DefaultHasher,
+    ffi::c_char,
+    hash::{Hash, Hasher},
+    str::FromStr,
+    sync::Arc,
+};
+
+use nautilus_core::{
+    correctness,
+    string::{cstr_to_string, str_to_cstr},
+};
+use pyo3::prelude::*;
+use serde::{Deserialize, Serialize, Serializer};
 
-use nautilus_core::correctness;
-use nautilus_core::string::{cstr_to_string, string_to_cstr};
-
-use crate::enums::CurrencyType;
+use crate::{currencies::CURRENCY_MAP, enums::CurrencyType};
 
 #[repr(C)]
-#[derive(Eq, PartialEq, Clone, Hash, Debug)]
-#[allow(clippy::redundant_allocation)] // C ABI compatibility
+#[derive(Clone, Debug, Eq)]
+#[pyclass]
 pub struct Currency {
     pub code: Box<Arc<String>>,
     pub precision: u8,
     pub iso4217: u16,
     pub name: Box<Arc<String>>,
     pub currency_type: CurrencyType,
 }
@@ -53,20 +60,71 @@
             iso4217,
             name: Box::new(Arc::new(name.to_string())),
             currency_type,
         }
     }
 }
 
+impl PartialEq for Currency {
+    fn eq(&self, other: &Self) -> bool {
+        self.code == other.code
+    }
+}
+
+impl Hash for Currency {
+    fn hash<H: Hasher>(&self, state: &mut H) {
+        self.code.hash(state);
+    }
+}
+
+impl FromStr for Currency {
+    type Err = String;
+
+    fn from_str(s: &str) -> Result<Self, Self::Err> {
+        CURRENCY_MAP
+            .lock()
+            .unwrap()
+            .get(s)
+            .cloned()
+            .ok_or_else(|| format!("Unknown currency: {}", s))
+    }
+}
+
+impl From<&str> for Currency {
+    fn from(input: &str) -> Self {
+        input.parse().unwrap_or_else(|err| panic!("{}", err))
+    }
+}
+
+impl Serialize for Currency {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: Serializer,
+    {
+        self.code.serialize(serializer)
+    }
+}
+
+impl<'de> Deserialize<'de> for Currency {
+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
+    where
+        D: serde::Deserializer<'de>,
+    {
+        let currency_str: &str = Deserialize::deserialize(deserializer)?;
+        Currency::from_str(currency_str).map_err(serde::de::Error::custom)
+    }
+}
+
 ////////////////////////////////////////////////////////////////////////////////
 // C API
 ////////////////////////////////////////////////////////////////////////////////
 /// Returns a [`Currency`] from pointers and primitives.
 ///
 /// # Safety
+///
 /// - Assumes `code_ptr` is a valid C string pointer.
 /// - Assumes `name_ptr` is a valid C string pointer.
 #[no_mangle]
 pub unsafe extern "C" fn currency_from_py(
     code_ptr: *const c_char,
     precision: u8,
     iso4217: u16,
@@ -90,51 +148,83 @@
 #[no_mangle]
 pub extern "C" fn currency_drop(currency: Currency) {
     drop(currency); // Memory freed here
 }
 
 #[no_mangle]
 pub extern "C" fn currency_to_cstr(currency: &Currency) -> *const c_char {
-    string_to_cstr(format!("{currency:?}").as_str())
+    str_to_cstr(format!("{currency:?}").as_str())
 }
 
 #[no_mangle]
 pub extern "C" fn currency_code_to_cstr(currency: &Currency) -> *const c_char {
-    string_to_cstr(&currency.code)
+    str_to_cstr(&currency.code)
 }
 
 #[no_mangle]
 pub extern "C" fn currency_name_to_cstr(currency: &Currency) -> *const c_char {
-    string_to_cstr(&currency.name)
+    str_to_cstr(&currency.name)
 }
 
 #[no_mangle]
 pub extern "C" fn currency_eq(lhs: &Currency, rhs: &Currency) -> u8 {
-    u8::from(lhs == rhs)
+    u8::from(lhs.code == rhs.code)
 }
 
 #[no_mangle]
 pub extern "C" fn currency_hash(currency: &Currency) -> u64 {
     let mut h = DefaultHasher::new();
     currency.hash(&mut h);
     h.finish()
 }
 
+#[no_mangle]
+pub extern "C" fn currency_register(currency: Currency) {
+    CURRENCY_MAP
+        .lock()
+        .unwrap()
+        .insert(currency.code.to_string(), currency);
+}
+
+/// # Safety
+///
+/// - Assumes `code_ptr` is borrowed from a valid Python UTF-8 `str`.
+#[no_mangle]
+pub unsafe extern "C" fn currency_exists(code_ptr: *const c_char) -> u8 {
+    let code = cstr_to_string(code_ptr);
+    u8::from(CURRENCY_MAP.lock().unwrap().contains_key(&code))
+}
+
+/// # Safety
+///
+/// - Assumes `code_ptr` is borrowed from a valid Python UTF-8 `str`.
+#[no_mangle]
+pub unsafe extern "C" fn currency_from_cstr(code_ptr: *const c_char) -> Currency {
+    let code = cstr_to_string(code_ptr);
+    Currency::from_str(&code).unwrap()
+}
+
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
-    use crate::enums::CurrencyType;
-    use crate::types::currency::{currency_eq, Currency};
+    use crate::{
+        enums::CurrencyType,
+        types::currency::{currency_eq, Currency},
+    };
 
     #[test]
     fn test_currency_equality() {
         let currency1 = Currency::new("AUD", 2, 36, "Australian dollar", CurrencyType::Fiat);
         let currency2 = Currency::new("AUD", 2, 36, "Australian dollar", CurrencyType::Fiat);
+        let currency3 = Currency::new("ETH", 8, 0, "Ether", CurrencyType::Crypto);
+        assert_eq!(currency1, currency2);
+        assert_ne!(currency1, currency3);
+        assert_eq!(currency_eq(&currency1, &currency2), 1);
         assert_ne!(currency_eq(&currency1, &currency2), 0);
     }
 
     #[test]
     fn test_currency_new_for_fiat() {
         let currency = Currency::new("AUD", 2, 36, "Australian dollar", CurrencyType::Fiat);
         assert_ne!(currency_eq(&currency, &currency), 0);
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/types/fixed.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/types/fixed.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/types/mod.rs` & `nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_body.pxd`

 * *Files 19% similar despite different names*

```diff
@@ -1,21 +1,22 @@
-// -------------------------------------------------------------------------------------------------
-//  Copyright (C) 2015-2023 Nautech Systems Pty Ltd. All rights reserved.
-//  https://nautechsystems.io
-//
-//  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
-//  You may not use this file except in compliance with the License.
-//  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
-//
-//  Unless required by applicable law or agreed to in writing, software
-//  distributed under the License is distributed on an "AS IS" BASIS,
-//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-//  See the License for the specific language governing permissions and
-//  limitations under the License.
-// -------------------------------------------------------------------------------------------------
+# -------------------------------------------------------------------------------------------------
+#  Copyright (C) 2015-2023 Nautech Systems Pty Ltd. All rights reserved.
+#  https://nautechsystems.io
+#
+#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
+#  You may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+# -------------------------------------------------------------------------------------------------
 
-pub mod balance;
-pub mod currency;
-pub mod fixed;
-pub mod money;
-pub mod price;
-pub mod quantity;
+
+cpdef enum CandleBodySize:
+    NONE = 0  # Doji
+    SMALL = 1
+    MEDIUM = 2
+    LARGE = 3
+    TREND = 4
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/types/money.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/types/money.rs`

 * *Files 17% similar despite different names*

```diff
@@ -9,29 +9,37 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::cmp::Ordering;
-use std::fmt::{Display, Formatter};
-use std::hash::{Hash, Hasher};
-use std::ops::{Add, AddAssign, Mul, MulAssign, Neg, Sub, SubAssign};
+use std::{
+    cmp::Ordering,
+    fmt::{Display, Formatter},
+    hash::{Hash, Hasher},
+    ops::{Add, AddAssign, Mul, MulAssign, Neg, Sub, SubAssign},
+    str::FromStr,
+};
 
 use nautilus_core::correctness;
+use pyo3::prelude::*;
+use serde::{Deserialize, Deserializer, Serialize};
 
-use crate::types::currency::Currency;
-use crate::types::fixed::{f64_to_fixed_i64, fixed_i64_to_f64};
+use crate::types::{
+    currency::Currency,
+    fixed::{f64_to_fixed_i64, fixed_i64_to_f64},
+};
 
 pub const MONEY_MAX: f64 = 9_223_372_036.0;
 pub const MONEY_MIN: f64 = -9_223_372_036.0;
 
 #[repr(C)]
 #[derive(Eq, Clone, Debug)]
+#[pyclass]
 pub struct Money {
     raw: i64,
     pub currency: Currency,
 }
 
 impl Money {
     #[must_use]
@@ -197,14 +205,49 @@
             self.currency.precision as usize,
             self.as_f64(),
             self.currency.code
         )
     }
 }
 
+impl Serialize for Money {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: serde::Serializer,
+    {
+        serializer.serialize_str(&format!("{}", self))
+    }
+}
+
+impl<'de> Deserialize<'de> for Money {
+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
+    where
+        D: Deserializer<'de>,
+    {
+        let money_str: &str = Deserialize::deserialize(deserializer)?;
+
+        let parts: Vec<&str> = money_str.splitn(2, ' ').collect();
+        if parts.len() != 2 {
+            return Err(serde::de::Error::custom("Invalid Money format"));
+        }
+
+        let amount_str = parts[0];
+        let currency_str = parts[1];
+
+        let amount = amount_str
+            .parse::<f64>()
+            .map_err(|_| serde::de::Error::custom("Failed to parse Money amount"))?;
+
+        let currency = Currency::from_str(currency_str)
+            .map_err(|_| serde::de::Error::custom("Invalid currency"))?;
+
+        Ok(Money::new(amount, currency))
+    }
+}
+
 ////////////////////////////////////////////////////////////////////////////////
 // C API
 ////////////////////////////////////////////////////////////////////////////////
 #[no_mangle]
 pub extern "C" fn money_new(amount: f64, currency: Currency) -> Money {
     Money::new(amount, currency)
 }
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/types/price.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/types/price.rs`

 * *Files 3% similar despite different names*

```diff
@@ -9,31 +9,35 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::cmp::Ordering;
-use std::fmt::{Debug, Display, Formatter};
-use std::hash::{Hash, Hasher};
-use std::ops::{Add, AddAssign, Deref, Mul, MulAssign, Neg, Sub, SubAssign};
-
-use nautilus_core::correctness;
-use nautilus_core::parsing::precision_from_str;
-
-use crate::types::fixed::{f64_to_fixed_i64, fixed_i64_to_f64};
+use std::{
+    cmp::Ordering,
+    fmt::{Debug, Display, Formatter},
+    hash::{Hash, Hasher},
+    ops::{Add, AddAssign, Deref, Mul, MulAssign, Neg, Sub, SubAssign},
+    str::FromStr,
+};
+
+use nautilus_core::{correctness, parsing::precision_from_str};
+use pyo3::prelude::*;
+use serde::{Deserialize, Deserializer, Serialize};
 
 use super::fixed::FIXED_SCALAR;
+use crate::types::fixed::{f64_to_fixed_i64, fixed_i64_to_f64};
 
 pub const PRICE_MAX: f64 = 9_223_372_036.0;
 pub const PRICE_MIN: f64 = -9_223_372_036.0;
 
 #[repr(C)]
-#[derive(Eq, Clone, Default)]
+#[derive(Copy, Clone, Eq, Default)]
+#[pyclass]
 pub struct Price {
     pub raw: i64,
     pub precision: u8,
 }
 
 impl Price {
     #[must_use]
@@ -58,22 +62,29 @@
 
     #[must_use]
     pub fn as_f64(&self) -> f64 {
         fixed_i64_to_f64(self.raw)
     }
 }
 
+impl FromStr for Price {
+    type Err = String;
+
+    fn from_str(input: &str) -> Result<Self, Self::Err> {
+        let float_from_input = input
+            .parse::<f64>()
+            .map_err(|err| format!("Cannot parse `input` string '{}' as f64: {}", input, err))?;
+
+        Ok(Self::new(float_from_input, precision_from_str(input)))
+    }
+}
+
 impl From<&str> for Price {
     fn from(input: &str) -> Self {
-        let float_from_input = input.parse::<f64>();
-        let float_res = match float_from_input {
-            Ok(number) => number,
-            Err(err) => panic!("Cannot parse `input` string '{input}' as f64, {err}"),
-        };
-        Self::new(float_res, precision_from_str(input))
+        input.parse().unwrap_or_else(|err| panic!("{}", err))
     }
 }
 
 impl From<Price> for f64 {
     fn from(value: Price) -> Self {
         value.as_f64()
     }
@@ -220,14 +231,34 @@
 
 impl Display for Price {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
         write!(f, "{:.*}", self.precision as usize, self.as_f64())
     }
 }
 
+impl Serialize for Price {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: serde::Serializer,
+    {
+        serializer.serialize_str(&format!("{}", self))
+    }
+}
+
+impl<'de> Deserialize<'de> for Price {
+    fn deserialize<D>(_deserializer: D) -> Result<Self, D::Error>
+    where
+        D: Deserializer<'de>,
+    {
+        let price_str: &str = Deserialize::deserialize(_deserializer)?;
+        let price: Price = price_str.into();
+        Ok(price)
+    }
+}
+
 ////////////////////////////////////////////////////////////////////////////////
 // C API
 ////////////////////////////////////////////////////////////////////////////////
 #[no_mangle]
 pub extern "C" fn price_new(value: f64, precision: u8) -> Price {
     Price::new(value, precision)
 }
@@ -253,15 +284,17 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
-    use super::Price;
+    use std::str::FromStr;
+
+    use super::*;
 
     #[test]
     fn test_price_new() {
         let price = Price::new(0.00812, 8);
         assert_eq!(price, price);
         assert_eq!(price.raw, 8_120_000);
         assert_eq!(price.precision, 8);
@@ -292,23 +325,38 @@
         let price = Price::new(1.001, 2);
         assert_eq!(price.raw, 1_000_000_000);
         assert_eq!(price.to_string(), "1.00");
     }
 
     #[test]
     fn test_price_new_from_str() {
-        let price = Price::from("0.00812000");
+        let price = Price::from_str("0.00812000").unwrap();
         assert_eq!(price, price);
         assert_eq!(price.raw, 8_120_000);
         assert_eq!(price.precision, 8);
         assert_eq!(price.as_f64(), 0.00812);
         assert_eq!(price.to_string(), "0.00812000");
     }
 
     #[test]
+    fn test_price_from_str_valid_input() {
+        let input = "10.5";
+        let expected_price = Price::new(10.5, precision_from_str(input));
+        let result = Price::from_str(input).unwrap();
+        assert_eq!(result, expected_price);
+    }
+
+    #[test]
+    fn test_price_from_str_invalid_input() {
+        let input = "invalid";
+        let result = Price::from_str(input);
+        assert!(result.is_err());
+    }
+
+    #[test]
     fn test_price_equality() {
         assert_eq!(Price::new(1.0, 1), Price::new(1.0, 1));
         assert_eq!(Price::new(1.0, 1), Price::new(1.0, 2));
         assert_ne!(Price::new(1.1, 1), Price::new(1.0, 1));
         assert!(Price::new(1.0, 1) <= Price::new(1.0, 2));
         assert!(Price::new(1.1, 1) > Price::new(1.0, 1));
         assert!(Price::new(1.0, 1) >= Price::new(1.0, 1));
@@ -365,23 +413,23 @@
         assert_eq!(price1.raw, 1_011_000_000_000_000_000);
     }
 
     #[test]
     fn test_price_display_works() {
         use std::fmt::Write as FmtWrite;
         let input_string = "44.12";
-        let price = Price::from(input_string);
+        let price = Price::from_str(input_string).unwrap();
         let mut res = String::new();
         write!(&mut res, "{price}").unwrap();
         assert_eq!(res, input_string);
     }
 
     #[test]
     fn test_price_display() {
         let input_string = "44.123456";
-        let price = Price::from(input_string);
+        let price = Price::from_str(input_string).unwrap();
         assert_eq!(price.raw, 44_123_456_000);
         assert_eq!(price.precision, 6);
         assert_eq!(price.as_f64(), 44.123_456_000_000_004);
-        assert_eq!(price.to_string(), "44.123456");
+        assert_eq!(price.to_string(), input_string);
     }
 }
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/model/src/types/quantity.rs` & `nautilus_trader-1.175.0/nautilus_core/model/src/types/quantity.rs`

 * *Files 4% similar despite different names*

```diff
@@ -9,31 +9,35 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::cmp::Ordering;
-use std::fmt::{Debug, Display, Formatter};
-use std::hash::{Hash, Hasher};
-use std::ops::{Add, AddAssign, Deref, Mul, MulAssign, Sub, SubAssign};
-
-use nautilus_core::correctness;
-use nautilus_core::parsing::precision_from_str;
-
-use crate::types::fixed::{f64_to_fixed_u64, fixed_u64_to_f64};
+use std::{
+    cmp::Ordering,
+    fmt::{Debug, Display, Formatter},
+    hash::{Hash, Hasher},
+    ops::{Add, AddAssign, Deref, Mul, MulAssign, Sub, SubAssign},
+    str::FromStr,
+};
+
+use nautilus_core::{correctness, parsing::precision_from_str};
+use pyo3::prelude::*;
+use serde::{Deserialize, Deserializer, Serialize};
 
 use super::fixed::FIXED_SCALAR;
+use crate::types::fixed::{f64_to_fixed_u64, fixed_u64_to_f64};
 
 pub const QUANTITY_MAX: f64 = 18_446_744_073.0;
 pub const QUANTITY_MIN: f64 = 0.0;
 
 #[repr(C)]
-#[derive(Eq, Clone, Default)]
+#[derive(Copy, Clone, Eq, Default)]
+#[pyclass]
 pub struct Quantity {
     pub raw: u64,
     pub precision: u8,
 }
 
 impl Quantity {
     #[must_use]
@@ -48,14 +52,19 @@
 
     #[must_use]
     pub fn from_raw(raw: u64, precision: u8) -> Self {
         Self { raw, precision }
     }
 
     #[must_use]
+    pub fn zero(precision: u8) -> Self {
+        Self { raw: 0, precision }
+    }
+
+    #[must_use]
     pub fn is_zero(&self) -> bool {
         self.raw == 0
     }
     #[must_use]
     pub fn as_f64(&self) -> f64 {
         fixed_u64_to_f64(self.raw)
     }
@@ -69,22 +78,29 @@
 
 impl From<&Quantity> for f64 {
     fn from(value: &Quantity) -> Self {
         value.as_f64()
     }
 }
 
+impl FromStr for Quantity {
+    type Err = String;
+
+    fn from_str(input: &str) -> Result<Self, Self::Err> {
+        let float_from_input = input
+            .parse::<f64>()
+            .map_err(|err| format!("Cannot parse `input` string '{}' as f64: {}", input, err))?;
+
+        Ok(Self::new(float_from_input, precision_from_str(input)))
+    }
+}
+
 impl From<&str> for Quantity {
     fn from(input: &str) -> Self {
-        let float_from_input = input.parse::<f64>();
-        let float_res = match float_from_input {
-            Ok(number) => number,
-            Err(err) => panic!("cannot parse `input` string '{input}' as f64, {err}"),
-        };
-        Self::new(float_res, precision_from_str(input))
+        input.parse().unwrap_or_else(|err| panic!("{}", err))
     }
 }
 
 impl From<i64> for Quantity {
     fn from(input: i64) -> Self {
         Self::new(input as f64, 0)
     }
@@ -206,14 +222,34 @@
 
 impl Display for Quantity {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
         write!(f, "{:.*}", self.precision as usize, self.as_f64())
     }
 }
 
+impl Serialize for Quantity {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: serde::Serializer,
+    {
+        serializer.serialize_str(&format!("{}", self))
+    }
+}
+
+impl<'de> Deserialize<'de> for Quantity {
+    fn deserialize<D>(_deserializer: D) -> Result<Self, D::Error>
+    where
+        D: Deserializer<'de>,
+    {
+        let qty_str: &str = Deserialize::deserialize(_deserializer)?;
+        let qty: Quantity = qty_str.into();
+        Ok(qty)
+    }
+}
+
 ////////////////////////////////////////////////////////////////////////////////
 // C API
 ////////////////////////////////////////////////////////////////////////////////
 #[no_mangle]
 pub extern "C" fn quantity_new(value: f64, precision: u8) -> Quantity {
     Quantity::new(value, precision)
 }
@@ -249,27 +285,36 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
-    use super::Quantity;
+    use std::str::FromStr;
+
+    use super::*;
 
     #[test]
-    fn test_qty_new() {
+    fn test_new() {
         let qty = Quantity::new(0.00812, 8);
         assert_eq!(qty, qty);
         assert_eq!(qty.raw, 8_120_000);
         assert_eq!(qty.precision, 8);
         assert_eq!(qty.as_f64(), 0.00812);
         assert_eq!(qty.to_string(), "0.00812000");
     }
 
     #[test]
+    fn test_zero() {
+        let qty = Quantity::zero(8);
+        assert_eq!(qty.raw, 0);
+        assert_eq!(qty.precision, 8);
+    }
+
+    #[test]
     fn test_qty_from_i64() {
         let qty = Quantity::from(100_000);
         assert_eq!(qty, qty);
         assert_eq!(qty.raw, 100_000_000_000_000);
         assert_eq!(qty.precision, 0);
     }
 
@@ -296,23 +341,38 @@
         let qty = Quantity::new(1.001, 2);
         assert_eq!(qty.raw, 1_000_000_000);
         assert_eq!(qty.to_string(), "1.00");
     }
 
     #[test]
     fn test_qty_new_from_str() {
-        let qty = Quantity::from("0.00812000");
+        let qty = Quantity::from_str("0.00812000").unwrap();
         assert_eq!(qty, qty);
         assert_eq!(qty.raw, 8_120_000);
         assert_eq!(qty.precision, 8);
         assert_eq!(qty.as_f64(), 0.00812);
         assert_eq!(qty.to_string(), "0.00812000");
     }
 
     #[test]
+    fn test_quantity_from_str_valid_input() {
+        let input = "1000.25";
+        let expected_quantity = Quantity::new(1000.25, precision_from_str(input));
+        let result = Quantity::from_str(input).unwrap();
+        assert_eq!(result, expected_quantity);
+    }
+
+    #[test]
+    fn test_quantity_from_str_invalid_input() {
+        let input = "invalid";
+        let result = Quantity::from_str(input);
+        assert!(result.is_err());
+    }
+
+    #[test]
     fn test_add() {
         let quantity1 = Quantity::new(1.0, 0);
         let quantity2 = Quantity::new(2.0, 0);
         let quantity3 = quantity1 + quantity2;
         assert_eq!(quantity3.raw, 3_000_000_000);
     }
 
@@ -371,14 +431,14 @@
         assert!(Quantity::new(0.9, 1) <= Quantity::new(1.0, 1));
     }
 
     #[test]
     fn test_qty_display() {
         use std::fmt::Write as FmtWrite;
         let input_string = "44.12";
-        let qty = Quantity::from(input_string);
+        let qty = Quantity::from_str(input_string).unwrap();
         let mut res = String::new();
         write!(&mut res, "{qty}").unwrap();
         assert_eq!(res, input_string);
         assert_eq!(qty.to_string(), input_string);
     }
 }
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/network/benches/bench_client.rs` & `nautilus_trader-1.175.0/nautilus_trader/indicators/roc.pxd`

 * *Files 24% similar despite different names*

```diff
@@ -1,43 +1,28 @@
-// -------------------------------------------------------------------------------------------------
-//  Copyright (C) 2015-2023 Nautech Systems Pty Ltd. All rights reserved.
-//  https://nautechsystems.io
-//
-//  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
-//  You may not use this file except in compliance with the License.
-//  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
-//
-//  Unless required by applicable law or agreed to in writing, software
-//  distributed under the License is distributed on an "AS IS" BASIS,
-//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-//  See the License for the specific language governing permissions and
-//  limitations under the License.
-// -------------------------------------------------------------------------------------------------
-//
-use std::collections::HashMap;
+# -------------------------------------------------------------------------------------------------
+#  Copyright (C) 2015-2023 Nautech Systems Pty Ltd. All rights reserved.
+#  https://nautechsystems.io
+#
+#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
+#  You may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+# -------------------------------------------------------------------------------------------------
 
-use hyper::Method;
-use nautilus_network::HttpClient;
+from nautilus_trader.indicators.base.indicator cimport Indicator
 
-// Testing with nginx docker container
-// `docker run --publish 8080:80 nginx`
-#[tokio::main]
-async fn main() {
-    let client = HttpClient::default();
-    let mut success = 0;
-    for _ in 0..100_000 {
-        if let Ok(resp) = client
-            .send_request(
-                Method::GET,
-                "http://localhost:8080".to_string(),
-                HashMap::new(),
-            )
-            .await
-        {
-            if resp.status == 200 {
-                success += 1;
-            }
-        }
-    }
 
-    println!("Successful requests: {success}");
-}
+cdef class RateOfChange(Indicator):
+    cdef bint _use_log
+    cdef object _prices
+
+    cdef readonly int period
+    """The window period.\n\n:returns: `int`"""
+    cdef readonly double value
+    """The current value.\n\n:returns: `double`"""
+
+    cpdef void update_raw(self, double price)
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/network/src/lib.rs` & `nautilus_trader-1.175.0/nautilus_core/network/src/http.rs`

 * *Files 6% similar despite different names*

```diff
@@ -28,15 +28,14 @@
 /// The client returns an [HttpResponse]. The client filters only the key value
 /// for the give `header_keys`.
 #[pyclass]
 #[derive(Clone)]
 pub struct HttpClient {
     client: Client<HttpsConnector<hyper::client::HttpConnector>>,
     header_keys: Vec<String>,
-    debug: bool,
 }
 
 /// HttpResponse contains relevant data from a HTTP request.
 #[pyclass]
 #[derive(Debug, Clone)]
 pub struct HttpResponse {
     #[pyo3(get)]
@@ -49,15 +48,14 @@
 impl Default for HttpClient {
     fn default() -> Self {
         let https = HttpsConnector::new();
         let client = Client::builder().build::<_, hyper::Body>(https);
         Self {
             client,
             header_keys: Default::default(),
-            debug: false,
         }
     }
 }
 
 #[pymethods]
 impl HttpResponse {
     #[getter]
@@ -65,37 +63,36 @@
         Ok(PyBytes::new(py, &self.body).into())
     }
 }
 
 #[pymethods]
 impl HttpClient {
     #[new]
-    #[pyo3(signature=(header_keys=[].to_vec(), debug=false))]
+    #[pyo3(signature=(header_keys=[].to_vec()))]
     #[must_use]
-    pub fn new(header_keys: Vec<String>, debug: bool) -> Self {
+    pub fn new(header_keys: Vec<String>) -> Self {
         let https = HttpsConnector::new();
         let client = Client::builder().build::<_, hyper::Body>(https);
 
         Self {
             client,
             header_keys,
-            debug,
         }
     }
 
     pub fn request<'py>(
         slf: PyRef<'_, Self>,
         method_str: String,
         url: String,
         headers: HashMap<String, String>,
         body: Option<&'py PyBytes>,
         py: Python<'py>,
     ) -> PyResult<&'py PyAny> {
         let method: Method = Method::from_str(&method_str.to_uppercase())
-            .unwrap_or_else(|_| panic!("Invalid HTTP method {}", method_str));
+            .unwrap_or_else(|_| panic!("Invalid HTTP method {method_str}"));
 
         let body_vec = body.map(|py_bytes| py_bytes.as_bytes().to_vec());
         let client = slf.clone();
         pyo3_asyncio::tokio::future_into_py(py, async move {
             match client.send_request(method, url, headers, body_vec).await {
                 Ok(res) => Ok(res),
                 Err(e) => Err(PyErr::new::<PyException, _>(format!(
@@ -198,37 +195,26 @@
     pub async fn send_request(
         &self,
         method: Method,
         url: String,
         headers: HashMap<String, String>,
         body: Option<Vec<u8>>,
     ) -> Result<HttpResponse, Box<dyn std::error::Error + Send + Sync>> {
-        if self.debug {
-            println!("method={:?}", method);
-            println!("url={:?}", url);
-            println!("headers={:?}", headers);
-            match &body {
-                Some(body_bytes) => println!("body={:?}", String::from_utf8_lossy(body_bytes)),
-                None => println!("No body present"),
-            }
-        }
-
         let mut req_builder = Request::builder().method(method).uri(url);
 
         for (header_name, header_value) in &headers {
             req_builder = req_builder.header(header_name, header_value);
         }
 
         let req = if let Some(body) = body {
-            req_builder
-                .header("Content-Type", "application/json")
-                .body(Body::from(body))?
+            req_builder.body(Body::from(body))?
         } else {
             req_builder.body(Body::empty())?
         };
+
         let res = self.client.request(req).await?;
         self.to_response(res).await
     }
 
     pub async fn to_response(
         &self,
         res: Response<Body>,
@@ -247,35 +233,32 @@
             status,
             headers,
             body: bytes.to_vec(),
         })
     }
 }
 
-// Uncomment to change for module name for reduced debug builds in testing
-#[pymodule]
-pub fn nautilus_network(_: Python<'_>, m: &PyModule) -> PyResult<()> {
-    m.add_class::<HttpClient>()?;
-    m.add_class::<HttpResponse>()?;
-    Ok(())
-}
-
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
-    use super::*;
-    use std::convert::Infallible;
-    use std::net::{SocketAddr, TcpListener};
-
-    use hyper::service::{make_service_fn, service_fn};
-    use hyper::{Body, Method, Request, Response, Server, StatusCode};
+    use std::{
+        convert::Infallible,
+        net::{SocketAddr, TcpListener},
+    };
+
+    use hyper::{
+        service::{make_service_fn, service_fn},
+        Body, Method, Request, Response, Server, StatusCode,
+    };
     use tokio::sync::oneshot;
 
+    use super::*;
+
     async fn handle(req: Request<Body>) -> Result<Response<Body>, Infallible> {
         match (req.method(), req.uri().path()) {
             (&Method::GET, "/get") => {
                 let response = Response::new(Body::from("hello-world!"));
                 Ok(response)
             }
             (&Method::POST, "/post") => {
@@ -327,50 +310,50 @@
 
         let (tx, rx) = oneshot::channel::<()>();
 
         let server = Server::bind(&addr).serve(make_svc);
 
         let graceful = server.with_graceful_shutdown(async {
             if let Err(e) = rx.await {
-                eprintln!("shutdown signal error: {}", e);
+                eprintln!("shutdown signal error: {e}");
             }
         });
 
         tokio::spawn(async {
             if let Err(e) = graceful.await {
-                eprintln!("server error: {}", e);
+                eprintln!("server error: {e}");
             }
         });
 
         (addr, tx)
     }
 
     #[tokio::test]
     async fn test_get() {
         let (addr, _shutdown_tx) = start_test_server();
         let url = format!("http://{}:{}", addr.ip(), addr.port());
 
         let client = HttpClient::default();
         let response = client
-            .send_request(Method::GET, format!("{}/get", url), HashMap::new(), None)
+            .send_request(Method::GET, format!("{url}/get"), HashMap::new(), None)
             .await
             .unwrap();
 
         assert_eq!(response.status, StatusCode::OK);
         assert_eq!(String::from_utf8_lossy(&response.body), "hello-world!");
     }
 
     #[tokio::test]
     async fn test_post() {
         let (addr, _shutdown_tx) = start_test_server();
         let url = format!("http://{}:{}", addr.ip(), addr.port());
 
         let client = HttpClient::default();
         let response = client
-            .send_request(Method::POST, format!("{}/post", url), HashMap::new(), None)
+            .send_request(Method::POST, format!("{url}/post"), HashMap::new(), None)
             .await
             .unwrap();
 
         assert_eq!(response.status, StatusCode::OK);
     }
 
     #[tokio::test]
@@ -392,15 +375,15 @@
 
         let body_string = serde_json::to_string(&body).unwrap();
         let body_bytes = body_string.into_bytes();
 
         let response = client
             .send_request(
                 Method::POST,
-                format!("{}/post", url),
+                format!("{url}/post"),
                 HashMap::new(),
                 Some(body_bytes),
             )
             .await
             .unwrap();
 
         assert_eq!(response.status, StatusCode::OK);
@@ -409,20 +392,15 @@
     #[tokio::test]
     async fn test_patch() {
         let (addr, _shutdown_tx) = start_test_server();
         let url = format!("http://{}:{}", addr.ip(), addr.port());
 
         let client = HttpClient::default();
         let response = client
-            .send_request(
-                Method::PATCH,
-                format!("{}/patch", url),
-                HashMap::new(),
-                None,
-            )
+            .send_request(Method::PATCH, format!("{url}/patch"), HashMap::new(), None)
             .await
             .unwrap();
 
         assert_eq!(response.status, StatusCode::OK);
     }
 
     #[tokio::test]
@@ -430,15 +408,15 @@
         let (addr, _shutdown_tx) = start_test_server();
         let url = format!("http://{}:{}", addr.ip(), addr.port());
 
         let client = HttpClient::default();
         let response = client
             .send_request(
                 Method::DELETE,
-                format!("{}/delete", url),
+                format!("{url}/delete"),
                 HashMap::new(),
                 None,
             )
             .await
             .unwrap();
 
         assert_eq!(response.status, StatusCode::OK);
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/persistence/Cargo.toml` & `nautilus_trader-1.175.0/nautilus_core/persistence/Cargo.toml`

 * *Files 25% similar despite different names*

```diff
@@ -1,36 +1,40 @@
 [package]
-name = "nautilus_persistence"
+name = "nautilus-persistence"
 version.workspace = true
 edition.workspace = true
 authors.workspace = true
 description.workspace = true
 documentation.workspace = true
 
 [lib]
 name = "nautilus_persistence"
 crate-type = ["rlib", "staticlib", "cdylib" ]
 
 [dependencies]
-nautilus_core = { path = "../core" }
-nautilus_model = { path = "../model" }
+nautilus-core = { path = "../core" }
+nautilus-model = { path = "../model" }
+futures.workspace = true
 pyo3.workspace = true
 pyo3-asyncio.workspace = true
 rand.workspace = true
 tokio.workspace = true
 binary-heap-plus = "0.5.0"
 compare = "0.1.0"
 # FIX: default feature "crypto_expressions" using using blake3 fails build on windows: https://github.com/BLAKE3-team/BLAKE3/issues/298
-datafusion = { version = "24.0.0", default-features = false, features = ["compression", "regex_expressions", "unicode_expressions"] }
-futures = "0.3.28"
+datafusion = { version = "26.0.0", default-features = false, features = ["compression", "regex_expressions", "unicode_expressions"] }
 pin-project-lite = "0.2.9"
 
 [features]
-extension-module = ["pyo3/extension-module", "nautilus_core/extension-module", "nautilus_model/extension-module"]
+extension-module = [
+  "pyo3/extension-module", 
+  "nautilus-core/extension-module", 
+  "nautilus-model/extension-module",
+]
 default = []
 
 [dev-dependencies]
 criterion.workspace = true
 
 [[bench]]
-name = "persistence_benchmark"
+name = "bench_persistence"
 harness = false
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/persistence/src/kmerge_batch.rs` & `nautilus_trader-1.175.0/nautilus_core/persistence/src/kmerge_batch.rs`

 * *Files 0% similar despite different names*

```diff
@@ -120,17 +120,18 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
-    use super::*;
     use futures::stream::iter;
 
+    use super::*;
+
     struct OrdComparator;
     impl<S> Compare<PeekElementBatchStream<S, i32>> for OrdComparator
     where
         S: Stream<Item = IntoIter<i32>>,
     {
         fn compare(
             &self,
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/persistence/src/lib.rs` & `nautilus_trader-1.175.0/nautilus_core/persistence/src/lib.rs`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_core/persistence/src/parquet/implementations/bar.rs` & `nautilus_trader-1.175.0/nautilus_core/persistence/src/parquet/implementations/bar.rs`

 * *Files 3% similar despite different names*

```diff
@@ -9,23 +9,25 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::collections::HashMap;
-use std::str::FromStr;
+use std::{collections::HashMap, str::FromStr};
 
-use datafusion::arrow::array::{Array, Int64Array, UInt64Array};
-use datafusion::arrow::datatypes::{DataType, Field, Schema, SchemaRef};
-use datafusion::arrow::record_batch::RecordBatch;
-use nautilus_model::data::bar::Bar;
-use nautilus_model::data::bar::BarType;
-use nautilus_model::types::{price::Price, quantity::Quantity};
+use datafusion::arrow::{
+    array::{Array, Int64Array, UInt64Array},
+    datatypes::{DataType, Field, Schema, SchemaRef},
+    record_batch::RecordBatch,
+};
+use nautilus_model::{
+    data::bar::{Bar, BarType},
+    types::{price::Price, quantity::Quantity},
+};
 
 use crate::parquet::{Data, DecodeDataFromRecordBatch};
 
 impl DecodeDataFromRecordBatch for Bar {
     fn decode_batch(metadata: &HashMap<String, String>, record_batch: RecordBatch) -> Vec<Data> {
         // Parse and validate metadata
         let (bar_type, price_precision, size_precision) = parse_metadata(metadata);
@@ -100,18 +102,20 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
-    use super::*;
-    use datafusion::arrow::record_batch::RecordBatch;
     use std::{collections::HashMap, sync::Arc};
 
+    use datafusion::arrow::record_batch::RecordBatch;
+
+    use super::*;
+
     fn create_metadata() -> HashMap<String, String> {
         let mut metadata = HashMap::new();
         metadata.insert(
             "bar_type".to_string(),
             "AAPL.NASDAQ-1-MINUTE-LAST-INTERNAL".to_string(),
         );
         metadata.insert("price_precision".to_string(), "2".to_string());
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/persistence/src/parquet/implementations/book_delta.rs` & `nautilus_trader-1.175.0/nautilus_core/persistence/src/parquet/implementations/delta.rs`

 * *Files 6% similar despite different names*

```diff
@@ -9,27 +9,24 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::collections::HashMap;
-use std::str::FromStr;
+use std::{collections::HashMap, str::FromStr};
 
-use datafusion::arrow::array::{Array, Int64Array, UInt64Array, UInt8Array};
-use datafusion::arrow::datatypes::{DataType, Field, Schema, SchemaRef};
-use datafusion::arrow::record_batch::RecordBatch;
-use nautilus_model::data::book::BookOrder;
-use nautilus_model::data::book::OrderBookDelta;
-use nautilus_model::enums::BookAction;
-use nautilus_model::enums::BookType;
-use nautilus_model::enums::FromU8;
-use nautilus_model::enums::OrderSide;
+use datafusion::arrow::{
+    array::{Array, Int64Array, UInt64Array, UInt8Array},
+    datatypes::{DataType, Field, Schema, SchemaRef},
+    record_batch::RecordBatch,
+};
 use nautilus_model::{
+    data::book::{BookOrder, OrderBookDelta},
+    enums::{BookAction, BookType, FromU8, OrderSide},
     identifiers::instrument_id::InstrumentId,
     types::{price::Price, quantity::Quantity},
 };
 
 use crate::parquet::{Data, DecodeDataFromRecordBatch};
 
 impl DecodeDataFromRecordBatch for OrderBookDelta {
@@ -124,18 +121,20 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
-    use super::*;
-    use datafusion::arrow::record_batch::RecordBatch;
     use std::{collections::HashMap, sync::Arc};
 
+    use datafusion::arrow::record_batch::RecordBatch;
+
+    use super::*;
+
     fn create_metadata() -> HashMap<String, String> {
         let mut metadata = HashMap::new();
         metadata.insert("instrument_id".to_string(), "AAPL.NASDAQ".to_string());
         metadata.insert("book_type".to_string(), "2".to_string());
         metadata.insert("price_precision".to_string(), "2".to_string());
         metadata.insert("size_precision".to_string(), "0".to_string());
         metadata
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/persistence/src/parquet/implementations/book_snapshot.rs` & `nautilus_trader-1.175.0/nautilus_core/persistence/src/parquet/implementations/trade.rs`

 * *Files 14% similar despite different names*

```diff
@@ -9,78 +9,82 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::collections::HashMap;
-use std::str::FromStr;
-use std::sync::Arc;
+use std::{collections::HashMap, str::FromStr};
 
-use datafusion::arrow::array::{
-    Array, ArrayRef, Int64Array, ListArray, StructArray, UInt64Array, UInt8Array,
+use datafusion::arrow::{
+    array::{Array, Int64Array, StringArray, UInt64Array, UInt8Array},
+    datatypes::{DataType, Field, Schema, SchemaRef},
+    record_batch::RecordBatch,
+};
+use nautilus_model::{
+    data::tick::TradeTick,
+    enums::AggressorSide,
+    identifiers::{instrument_id::InstrumentId, trade_id::TradeId},
+    types::{price::Price, quantity::Quantity},
 };
-use datafusion::arrow::datatypes::{DataType, Field, Schema, SchemaRef};
-use datafusion::arrow::record_batch::RecordBatch;
-use nautilus_model::data::book::{BookOrder, OrderBookSnapshot};
-use nautilus_model::enums::{FromU8, OrderSide};
-use nautilus_model::identifiers::instrument_id::InstrumentId;
-use nautilus_model::types::{price::Price, quantity::Quantity};
 
 use crate::parquet::{Data, DecodeDataFromRecordBatch};
 
-impl DecodeDataFromRecordBatch for OrderBookSnapshot {
+impl DecodeDataFromRecordBatch for TradeTick {
     fn decode_batch(metadata: &HashMap<String, String>, record_batch: RecordBatch) -> Vec<Data> {
         // Parse and validate metadata
         let (instrument_id, price_precision, size_precision) = parse_metadata(metadata);
 
         // Extract field value arrays from record batch
         let cols = record_batch.columns();
-        let bids_values = cols[0].as_any().downcast_ref::<Vec<ArrayRef>>().unwrap();
-        let asks_values = cols[1].as_any().downcast_ref::<Vec<ArrayRef>>().unwrap();
-        let sequence_values = cols[2].as_any().downcast_ref::<UInt64Array>().unwrap();
-        let ts_event_values = cols[3].as_any().downcast_ref::<UInt64Array>().unwrap();
-        let ts_init_values = cols[4].as_any().downcast_ref::<UInt64Array>().unwrap();
+        let price_values = cols[0].as_any().downcast_ref::<Int64Array>().unwrap();
+        let size_values = cols[1].as_any().downcast_ref::<UInt64Array>().unwrap();
+        let aggressor_side_values = cols[2].as_any().downcast_ref::<UInt8Array>().unwrap();
+        let trade_id_values_values = cols[3].as_any().downcast_ref::<StringArray>().unwrap();
+        let ts_event_values = cols[4].as_any().downcast_ref::<UInt64Array>().unwrap();
+        let ts_init_values = cols[5].as_any().downcast_ref::<UInt64Array>().unwrap();
 
         // Construct iterator of values from field value arrays
-        let values = bids_values
-            .iter()
-            .zip(asks_values.iter())
-            .zip(sequence_values.iter())
-            .zip(ts_event_values.iter())
-            .zip(ts_init_values.iter())
-            .map(|((((bids, asks), sequence), ts_event), ts_init)| {
-                let bids = decode_book_orders(bids, price_precision, size_precision);
-                let asks = decode_book_orders(asks, price_precision, size_precision);
-
-                Self {
-                    instrument_id: instrument_id.clone(),
-                    bids: bids.into(),
-                    asks: asks.into(),
-                    sequence: sequence.unwrap(),
-                    ts_event: ts_event.unwrap(),
-                    ts_init: ts_init.unwrap(),
-                }
-                .into()
-            });
+        let values = price_values
+            .into_iter()
+            .zip(size_values.into_iter())
+            .zip(aggressor_side_values.into_iter())
+            .zip(trade_id_values_values.into_iter())
+            .zip(ts_event_values.into_iter())
+            .zip(ts_init_values.into_iter())
+            .map(
+                |(((((price, size), aggressor_side), trade_id), ts_event), ts_init)| {
+                    Self {
+                        instrument_id: instrument_id.clone(),
+                        price: Price::from_raw(price.unwrap(), price_precision),
+                        size: Quantity::from_raw(size.unwrap(), size_precision),
+                        aggressor_side: AggressorSide::from_repr(aggressor_side.unwrap() as usize)
+                            .expect("cannot parse enum value"),
+                        trade_id: TradeId::new(trade_id.unwrap()),
+                        ts_event: ts_event.unwrap(),
+                        ts_init: ts_init.unwrap(),
+                    }
+                    .into()
+                },
+            );
 
         values.collect()
     }
 
-    fn get_schema(metadata: HashMap<String, String>) -> SchemaRef {
-        let new_fields = vec![
-            Field::new("bids", get_order_list_data_type(), false),
-            Field::new("asks", get_order_list_data_type(), false),
-            Field::new("sequence", DataType::UInt64, false),
+    fn get_schema(metadata: std::collections::HashMap<String, String>) -> SchemaRef {
+        let fields = vec![
+            Field::new("price", DataType::Int64, false),
+            Field::new("size", DataType::UInt64, false),
+            Field::new("aggressor_side", DataType::UInt8, false),
+            Field::new("trade_id", DataType::Utf8, false),
             Field::new("ts_event", DataType::UInt64, false),
             Field::new("ts_init", DataType::UInt64, false),
         ];
 
-        Arc::new(Schema::new_with_metadata(new_fields, metadata))
+        Schema::new_with_metadata(fields, metadata).into()
     }
 }
 
 fn parse_metadata(metadata: &HashMap<String, String>) -> (InstrumentId, u8, u8) {
     let instrument_id =
         InstrumentId::from_str(metadata.get("instrument_id").unwrap().as_str()).unwrap();
     let price_precision = metadata
@@ -93,89 +97,73 @@
         .unwrap()
         .parse::<u8>()
         .unwrap();
 
     (instrument_id, price_precision, size_precision)
 }
 
-fn decode_book_orders(array: &ArrayRef, price_precision: u8, size_precision: u8) -> Vec<BookOrder> {
-    let struct_array = array
-        .as_any()
-        .downcast_ref::<ListArray>()
-        .expect("Expected ListArray");
-
-    let values_array = struct_array.values();
-    let offsets = struct_array.offsets();
-
-    let mut orders = Vec::with_capacity(struct_array.len());
-
-    for i in 0..struct_array.len() {
-        let start = offsets[i] as usize;
-        let end = offsets[i + 1] as usize;
-
-        let order_array = values_array.slice(start, end);
-        let order_struct_array = order_array
-            .as_any()
-            .downcast_ref::<StructArray>()
-            .expect("Expected StructArray");
-
-        let side_array = order_struct_array.column(0);
-        let price_array = order_struct_array.column(1);
-        let size_array = order_struct_array.column(2);
-        let order_id_array = order_struct_array.column(3);
-
-        let side_values = side_array
-            .as_any()
-            .downcast_ref::<UInt8Array>()
-            .expect("Expected UInt8Array");
-        let price_values = price_array
-            .as_any()
-            .downcast_ref::<Int64Array>()
-            .expect("Expected Int64Array");
-        let size_values = size_array
-            .as_any()
-            .downcast_ref::<UInt64Array>()
-            .expect("Expected UInt64Array");
-        let order_id_values = order_id_array
-            .as_any()
-            .downcast_ref::<UInt64Array>()
-            .expect("Expected UInt64Array");
-
-        let order = BookOrder {
-            side: OrderSide::from_u8(side_values.value(i)).expect("Invalid `OrderSide`"),
-            price: Price::from_raw(price_values.value(i), price_precision),
-            size: Quantity::from_raw(size_values.value(i), size_precision),
-            order_id: order_id_values.value(i),
-        };
-
-        orders.push(order);
+////////////////////////////////////////////////////////////////////////////////
+// Tests
+////////////////////////////////////////////////////////////////////////////////
+#[cfg(test)]
+mod tests {
+    use std::{collections::HashMap, sync::Arc};
+
+    use datafusion::arrow::{
+        array::{Int64Array, StringArray, UInt64Array, UInt8Array},
+        record_batch::RecordBatch,
+    };
+
+    use super::*;
+
+    fn create_metadata() -> HashMap<String, String> {
+        let mut metadata = HashMap::new();
+        metadata.insert("instrument_id".to_string(), "AAPL.NASDAQ".to_string());
+        metadata.insert("price_precision".to_string(), "2".to_string());
+        metadata.insert("size_precision".to_string(), "0".to_string());
+        metadata
     }
 
-    orders
-}
-
-fn get_book_order_schema() -> SchemaRef {
-    let fields = vec![
-        Field::new("side", DataType::UInt8, false),
-        Field::new("price", DataType::Int64, false),
-        Field::new("size", DataType::UInt64, false),
-        Field::new("order_id", DataType::UInt64, false),
-    ];
-
-    Schema::new(fields).into()
-}
+    #[test]
+    fn test_get_schema() {
+        let metadata = create_metadata();
+        let schema = TradeTick::get_schema(metadata.clone());
+        let expected_fields = vec![
+            Field::new("price", DataType::Int64, false),
+            Field::new("size", DataType::UInt64, false),
+            Field::new("aggressor_side", DataType::UInt8, false),
+            Field::new("trade_id", DataType::Utf8, false),
+            Field::new("ts_event", DataType::UInt64, false),
+            Field::new("ts_init", DataType::UInt64, false),
+        ];
+        let expected_schema = Schema::new_with_metadata(expected_fields, metadata).into();
+        assert_eq!(schema, expected_schema);
+    }
 
-fn get_book_order_field() -> Field {
-    Field::new(
-        "order",
-        DataType::Struct(get_book_order_schema().fields().clone()),
-        false,
-    )
-}
+    #[test]
+    fn test_decode_batch() {
+        let metadata = create_metadata();
+
+        let price = Int64Array::from(vec![10000, 9900]);
+        let size = UInt64Array::from(vec![100, 90]);
+        let aggressor_side = UInt8Array::from(vec![0, 1]); // 0 for BUY, 1 for SELL
+        let trade_id = StringArray::from(vec!["trade_1", "trade_2"]);
+        let ts_event = UInt64Array::from(vec![1, 2]);
+        let ts_init = UInt64Array::from(vec![3, 4]);
+
+        let record_batch = RecordBatch::try_new(
+            TradeTick::get_schema(metadata.clone()),
+            vec![
+                Arc::new(price),
+                Arc::new(size),
+                Arc::new(aggressor_side),
+                Arc::new(trade_id),
+                Arc::new(ts_event),
+                Arc::new(ts_init),
+            ],
+        )
+        .unwrap();
 
-fn get_order_list_data_type() -> DataType {
-    DataType::List(Arc::new(get_book_order_field()))
+        let decoded_data = TradeTick::decode_batch(&metadata, record_batch);
+        assert_eq!(decoded_data.len(), 2);
+    }
 }
-
-////////////////////////////////////////////////////////////////////////////////
-// Tests
-////////////////////////////////////////////////////////////////////////////////
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/persistence/src/parquet/implementations/mod.rs` & `nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_direction.pxd`

 * *Files 14% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-// -------------------------------------------------------------------------------------------------
-//  Copyright (C) 2015-2023 Nautech Systems Pty Ltd. All rights reserved.
-//  https://nautechsystems.io
-//
-//  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
-//  You may not use this file except in compliance with the License.
-//  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
-//
-//  Unless required by applicable law or agreed to in writing, software
-//  distributed under the License is distributed on an "AS IS" BASIS,
-//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-//  See the License for the specific language governing permissions and
-//  limitations under the License.
-// -------------------------------------------------------------------------------------------------
+# -------------------------------------------------------------------------------------------------
+#  Copyright (C) 2015-2023 Nautech Systems Pty Ltd. All rights reserved.
+#  https://nautechsystems.io
+#
+#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
+#  You may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+# -------------------------------------------------------------------------------------------------
 
-mod bar;
-mod book_delta;
-mod book_snapshot;
-mod quote;
-mod trade;
+
+cpdef enum CandleDirection:
+    BULL = 1
+    NONE = 0  # Doji
+    BEAR = -1
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/persistence/src/parquet/implementations/quote.rs` & `nautilus_trader-1.175.0/nautilus_core/persistence/src/parquet/implementations/quote.rs`

 * *Files 1% similar despite different names*

```diff
@@ -9,22 +9,23 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use std::collections::HashMap;
-use std::str::FromStr;
+use std::{collections::HashMap, str::FromStr};
 
-use datafusion::arrow::array::{Array, Int64Array, UInt64Array};
-use datafusion::arrow::datatypes::{DataType, Field, Schema, SchemaRef};
-use datafusion::arrow::record_batch::RecordBatch;
-use nautilus_model::data::tick::QuoteTick;
+use datafusion::arrow::{
+    array::{Array, Int64Array, UInt64Array},
+    datatypes::{DataType, Field, Schema, SchemaRef},
+    record_batch::RecordBatch,
+};
 use nautilus_model::{
+    data::tick::QuoteTick,
     identifiers::instrument_id::InstrumentId,
     types::{price::Price, quantity::Quantity},
 };
 
 use crate::parquet::{Data, DecodeDataFromRecordBatch};
 
 impl DecodeDataFromRecordBatch for QuoteTick {
@@ -99,18 +100,20 @@
 }
 
 ////////////////////////////////////////////////////////////////////////////////
 // Tests
 ////////////////////////////////////////////////////////////////////////////////
 #[cfg(test)]
 mod tests {
-    use super::*;
-    use datafusion::arrow::record_batch::RecordBatch;
     use std::{collections::HashMap, sync::Arc};
 
+    use datafusion::arrow::record_batch::RecordBatch;
+
+    use super::*;
+
     fn create_metadata() -> HashMap<String, String> {
         let mut metadata = HashMap::new();
         metadata.insert("instrument_id".to_string(), "AAPL.NASDAQ".to_string());
         metadata.insert("price_precision".to_string(), "2".to_string());
         metadata.insert("size_precision".to_string(), "0".to_string());
         metadata
     }
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/persistence/src/parquet/mod.rs` & `nautilus_trader-1.175.0/nautilus_core/persistence/src/parquet/mod.rs`

 * *Files 4% similar despite different names*

```diff
@@ -13,29 +13,27 @@
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 mod implementations;
 
 use std::collections::HashMap;
 
-use datafusion::arrow::datatypes::SchemaRef;
-use datafusion::arrow::record_batch::RecordBatch;
+use datafusion::arrow::{datatypes::SchemaRef, record_batch::RecordBatch};
 use nautilus_model::data::Data;
 use pyo3::prelude::*;
 
 #[repr(C)]
 #[pyclass]
 #[derive(Debug, Clone, Copy)]
 pub enum ParquetType {
     // Custom = 0,  # First slot reserved for custom data
-    OrderBookSnapshot = 1,
-    OrderBookDelta = 2,
-    QuoteTick = 3,
-    TradeTick = 4,
-    Bar = 5,
+    OrderBookDelta = 1,
+    QuoteTick = 2,
+    TradeTick = 3,
+    Bar = 4,
 }
 
 #[repr(C)]
 #[pyclass]
 #[derive(Debug, Clone, Copy)]
 pub enum ParquetReaderType {
     File = 0,
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/persistence/src/session.rs` & `nautilus_trader-1.175.0/nautilus_core/persistence/src/session.rs`

 * *Files 6% similar despite different names*

```diff
@@ -12,30 +12,30 @@
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
 use std::vec::IntoIter;
 
 use compare::Compare;
-use datafusion::error::Result;
-use datafusion::physical_plan::SendableRecordBatchStream;
-use datafusion::prelude::*;
-use futures::executor::block_on;
-use futures::{Stream, StreamExt};
+use datafusion::{error::Result, physical_plan::SendableRecordBatchStream, prelude::*};
+use futures::{executor::block_on, Stream, StreamExt};
 use nautilus_core::cvec::CVec;
-use nautilus_model::data::bar::Bar;
-use nautilus_model::data::book::{OrderBookDelta, OrderBookSnapshot};
-use nautilus_model::data::tick::{QuoteTick, TradeTick};
-use nautilus_model::data::Data;
-use pyo3::prelude::*;
-use pyo3::types::PyCapsule;
+use nautilus_model::data::{
+    bar::Bar,
+    book::OrderBookDelta,
+    tick::{QuoteTick, TradeTick},
+    Data,
+};
+use pyo3::{prelude::*, types::PyCapsule};
 use pyo3_asyncio::tokio::get_runtime;
 
-use crate::kmerge_batch::{KMerge, PeekElementBatchStream};
-use crate::parquet::{DecodeDataFromRecordBatch, ParquetType};
+use crate::{
+    kmerge_batch::{KMerge, PeekElementBatchStream},
+    parquet::{DecodeDataFromRecordBatch, ParquetType},
+};
 
 #[derive(Debug, Default)]
 pub struct TsInitComparator;
 
 impl<S> Compare<PeekElementBatchStream<S, Data>> for TsInitComparator
 where
     S: Stream<Item = IntoIter<Data>>,
@@ -201,22 +201,14 @@
         file_path: &str,
         parquet_type: ParquetType,
     ) {
         let rt = get_runtime();
         let _guard = rt.enter();
 
         match parquet_type {
-            ParquetType::OrderBookSnapshot => {
-                match block_on(
-                    slf.add_file_default_query::<OrderBookSnapshot>(table_name, file_path),
-                ) {
-                    Ok(_) => (),
-                    Err(err) => panic!("Failed new_query with error {err}"),
-                }
-            }
             ParquetType::OrderBookDelta => {
                 match block_on(slf.add_file_default_query::<OrderBookDelta>(table_name, file_path))
                 {
                     Ok(_) => (),
                     Err(err) => panic!("Failed new_query with error {err}"),
                 }
             }
@@ -248,22 +240,14 @@
         sql_query: &str,
         parquet_type: ParquetType,
     ) {
         let rt = get_runtime();
         let _guard = rt.enter();
 
         match parquet_type {
-            ParquetType::OrderBookSnapshot => {
-                match block_on(slf.add_file_with_custom_query::<OrderBookSnapshot>(
-                    table_name, file_path, sql_query,
-                )) {
-                    Ok(_) => (),
-                    Err(err) => panic!("Failed new_query with error {err}"),
-                }
-            }
             ParquetType::OrderBookDelta => {
                 match block_on(
                     slf.add_file_with_custom_query::<OrderBookDelta>(
                         table_name, file_path, sql_query,
                     ),
                 ) {
                     Ok(_) => (),
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/persistence/tests/test_catalog.rs` & `nautilus_trader-1.175.0/nautilus_core/persistence/tests/test_catalog.rs`

 * *Files 6% similar despite different names*

```diff
@@ -9,16 +9,18 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use nautilus_model::data::tick::{QuoteTick, TradeTick};
-use nautilus_model::data::Data;
+use nautilus_model::data::{
+    tick::{QuoteTick, TradeTick},
+    Data,
+};
 use nautilus_persistence::session::{DataBackendSession, QueryResult};
 
 // Note: "current_thread" configuration hangs up for some reason
 #[tokio::test(flavor = "multi_thread")]
 async fn test_quote_ticks() {
     let file_path = "../../tests/test_data/quote_tick_data.parquet";
     let length = 9500;
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/persistence/tests/test_persistence_module.py` & `nautilus_trader-1.175.0/nautilus_core/persistence/tests/test_persistence_module.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_core/persistence/tests/test_util.rs` & `nautilus_trader-1.175.0/nautilus_core/persistence/tests/test_util.rs`

 * *Files 17% similar despite different names*

```diff
@@ -9,16 +9,15 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use nautilus_model::types::fixed::f64_to_fixed_i64;
-use nautilus_model::types::fixed::f64_to_fixed_u64;
+use nautilus_model::types::fixed::{f64_to_fixed_i64, f64_to_fixed_u64};
 use rand::Rng;
 
 #[allow(dead_code)]
 fn random_values_u64(len: u64) -> Vec<u64> {
     let mut rng = rand::thread_rng();
     let mut vec = Vec::new();
     for _ in 0..len {
@@ -52,16 +51,16 @@
     assert_eq!(vec.len() as u64, len);
     vec
 }
 
 #[allow(dead_code)]
 fn date_range(len: u64) -> Vec<u64> {
     let mut vec = Vec::new();
-    let mut start: u64 = 1546304400000000000;
-    let end: u64 = 1577840400000000000;
+    let mut start: u64 = 1_546_304_400_000_000_000;
+    let end: u64 = 1_577_840_400_000_000_000;
     let step = (end - start) / len;
     for _ in 0..len {
         start += step;
         vec.push(start);
     }
     vec
 }
```

### Comparing `nautilus_trader-1.174.0/nautilus_core/pyo3/src/lib.rs` & `nautilus_trader-1.175.0/nautilus_core/pyo3/src/lib.rs`

 * *Files 9% similar despite different names*

```diff
@@ -9,49 +9,57 @@
 //  Unless required by applicable law or agreed to in writing, software
 //  distributed under the License is distributed on an "AS IS" BASIS,
 //  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 //  See the License for the specific language governing permissions and
 //  limitations under the License.
 // -------------------------------------------------------------------------------------------------
 
-use nautilus_model::model;
-use nautilus_persistence::persistence;
 use pyo3::{prelude::*, types::PyDict};
 
 /// Need to modify sys modules so that submodule can be loaded directly as
 /// import supermodule.submodule
 ///
 /// refer: https://github.com/PyO3/pyo3/issues/2644
 #[pymodule]
 fn nautilus_pyo3(py: Python<'_>, m: &PyModule) -> PyResult<()> {
-    // Persistence
-    let submodule = pyo3::wrap_pymodule!(persistence);
+    // Indicators
+    let submodule = pyo3::wrap_pymodule!(nautilus_indicators::indicators);
     m.add_wrapped(submodule)?;
     let sys = PyModule::import(py, "sys")?;
     let sys_modules: &PyDict = sys.getattr("modules")?.downcast()?;
     sys_modules.set_item(
-        "nautilus_trader.core.nautilus_pyo3.persistence",
-        m.getattr("persistence")?,
+        "nautilus_trader.core.nautilus_pyo3.indicators",
+        m.getattr("indicators")?,
     )?;
 
     // Model
-    let submodule = pyo3::wrap_pymodule!(model);
+    let submodule = pyo3::wrap_pymodule!(nautilus_model::model);
     m.add_wrapped(submodule)?;
     let sys = PyModule::import(py, "sys")?;
     let sys_modules: &PyDict = sys.getattr("modules")?.downcast()?;
     sys_modules.set_item(
         "nautilus_trader.core.nautilus_pyo3.model",
         m.getattr("model")?,
     )?;
 
     // Network
-    let submodule = pyo3::wrap_pymodule!(nautilus_network::nautilus_network);
+    let submodule = pyo3::wrap_pymodule!(nautilus_network::network);
     m.add_wrapped(submodule)?;
     let sys = PyModule::import(py, "sys")?;
     let sys_modules: &PyDict = sys.getattr("modules")?.downcast()?;
     sys_modules.set_item(
         "nautilus_trader.core.nautilus_pyo3.network",
-        m.getattr("nautilus_network")?,
+        m.getattr("network")?,
+    )?;
+
+    // Persistence
+    let submodule = pyo3::wrap_pymodule!(nautilus_persistence::persistence);
+    m.add_wrapped(submodule)?;
+    let sys = PyModule::import(py, "sys")?;
+    let sys_modules: &PyDict = sys.getattr("modules")?.downcast()?;
+    sys_modules.set_item(
+        "nautilus_trader.core.nautilus_pyo3.persistence",
+        m.getattr("persistence")?,
     )?;
 
     Ok(())
 }
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/__init__.pxd` & `nautilus_trader-1.175.0/nautilus_trader/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/accounting/__init__.pxd` & `nautilus_trader-1.175.0/nautilus_trader/accounting/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/accounting/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/accounting/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/accounting/accounts/__init__.pxd` & `nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/accounting/accounts/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/accounting/accounts/base.pxd` & `nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/base.pxd`

 * *Files 1% similar despite different names*

```diff
@@ -79,15 +79,15 @@
 
     cpdef Money calculate_commission(
         self,
         Instrument instrument,
         Quantity last_qty,
         Price last_px,
         LiquiditySide liquidity_side,
-        bint inverse_as_quote=*,
+        bint use_quote_for_inverse=*,
     )
 
     cpdef list calculate_pnls(
         self,
         Instrument instrument,
         OrderFilled fill,
         Position position=*,
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/accounting/accounts/base.pyx` & `nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/base.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -464,15 +464,15 @@
 
     cpdef Money calculate_commission(
         self,
         Instrument instrument,
         Quantity last_qty,
         Price last_px,
         LiquiditySide liquidity_side,
-        bint inverse_as_quote=False,
+        bint use_quote_for_inverse=False,
     ):
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     cpdef list calculate_pnls(
         self,
         Instrument instrument,
         OrderFilled fill,
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/accounting/accounts/betting.pxd` & `nautilus_trader-1.175.0/nautilus_trader/execution/trailing.pxd`

 * *Files 17% similar despite different names*

```diff
@@ -9,24 +9,43 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.accounting.accounts.cash cimport CashAccount
 from nautilus_trader.model.enums_c cimport OrderSide
+from nautilus_trader.model.enums_c cimport TrailingOffsetType
 from nautilus_trader.model.instruments.base cimport Instrument
-from nautilus_trader.model.objects cimport Money
 from nautilus_trader.model.objects cimport Price
-from nautilus_trader.model.objects cimport Quantity
+from nautilus_trader.model.orders.base cimport Order
 
 
-cdef class BettingAccount(CashAccount):
-    cpdef Money calculate_balance_locked(
-        self,
+cdef class TrailingStopCalculator:
+
+    @staticmethod
+    cdef tuple calculate(
+        Instrument instrument,
+        Order order,
+        Price bid,
+        Price ask,
+        Price last,
+    )
+
+    @staticmethod
+    cdef Price calculate_with_last(
+        Instrument instrument,
+        TrailingOffsetType trailing_offset_type,
+        OrderSide side,
+        double offset,
+        Price last,
+    )
+
+    @staticmethod
+    cdef Price calculate_with_bid_ask(
         Instrument instrument,
+        TrailingOffsetType trailing_offset_type,
         OrderSide side,
-        Quantity quantity,
-        Price price,
-        bint inverse_as_quote=*,
+        double offset,
+        Price bid,
+        Price ask,
     )
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/accounting/accounts/betting.pyx` & `nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/cash.pxd`

 * *Files 20% similar despite different names*

```diff
@@ -9,69 +9,34 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from decimal import Decimal
-
-from nautilus_trader.accounting.accounts.cash cimport CashAccount
-from nautilus_trader.core.correctness cimport Condition
-from nautilus_trader.model.data.bet cimport Bet
-from nautilus_trader.model.enums_c cimport AccountType
+from nautilus_trader.accounting.accounts.base cimport Account
 from nautilus_trader.model.enums_c cimport OrderSide
+from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.instruments.base cimport Instrument
 from nautilus_trader.model.objects cimport Money
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.objects cimport Quantity
 
 
-cdef class BettingAccount(CashAccount):
-    """
-    Provides a betting account.
-    """
-    ACCOUNT_TYPE = AccountType.BETTING
+cdef class CashAccount(Account):
+    cdef dict _balances_locked
+
+# -- COMMANDS -------------------------------------------------------------------------------------
+
+    cpdef void update_balance_locked(self, InstrumentId instrument_id, Money locked)
+    cpdef void clear_balance_locked(self, InstrumentId instrument_id)
 
 # -- CALCULATIONS ---------------------------------------------------------------------------------
 
     cpdef Money calculate_balance_locked(
         self,
         Instrument instrument,
         OrderSide side,
         Quantity quantity,
         Price price,
-        bint inverse_as_quote=False,
-    ):
-        """
-        Calculate the locked balance.
-
-        Parameters
-        ----------
-        instrument : Instrument
-            The instrument for the calculation.
-        side : OrderSide {``BUY``, ``SELL``}
-            The order side.
-        quantity : Quantity
-            The order quantity.
-        price : Price
-            The order price.
-        inverse_as_quote : bool
-            Not applicable for betting accounts.
-
-        Returns
-        -------
-        Money
-
-        """
-        Condition.not_none(instrument, "instrument")
-        Condition.not_none(quantity, "quantity")
-        Condition.not_none(price, "price")
-        Condition.not_equal(inverse_as_quote, True, "inverse_as_quote", "True")
-
-        cdef Bet bet = Bet(
-            price=price,
-            quantity=quantity,
-            side=side
-        )
-        locked: Decimal = bet.liability()
-        return Money(locked, instrument.quote_currency)
+        bint use_quote_for_inverse=*,
+    )
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/accounting/accounts/cash.pxd` & `nautilus_trader-1.175.0/nautilus_trader/risk/sizing.pxd`

 * *Files 19% similar despite different names*

```diff
@@ -9,34 +9,37 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.accounting.accounts.base cimport Account
-from nautilus_trader.model.enums_c cimport OrderSide
-from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.instruments.base cimport Instrument
 from nautilus_trader.model.objects cimport Money
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.objects cimport Quantity
 
 
-cdef class CashAccount(Account):
-    cdef dict _balances_locked
+cdef class PositionSizer:
+    cdef readonly Instrument instrument
+    """The instrument for position sizing.\n\n:returns: `Instrument`"""
 
-# -- COMMANDS -------------------------------------------------------------------------------------
+    cpdef void update_instrument(self, Instrument instrument)
+    cpdef Quantity calculate(
+        self,
+        Price entry,
+        Price stop_loss,
+        Money equity,
+        risk,
+        commission_rate=*,
+        exchange_rate=*,
+        hard_limit=*,
+        unit_batch_size=*,
+        int units=*,
+    )
 
-    cpdef void update_balance_locked(self, InstrumentId instrument_id, Money locked)
-    cpdef void clear_balance_locked(self, InstrumentId instrument_id)
+    cdef object _calculate_risk_ticks(self, Price entry, Price stop_loss)
+    cdef object _calculate_riskable_money(self, equity, risk, commission_rate)
 
-# -- CALCULATIONS ---------------------------------------------------------------------------------
 
-    cpdef Money calculate_balance_locked(
-        self,
-        Instrument instrument,
-        OrderSide side,
-        Quantity quantity,
-        Price price,
-        bint inverse_as_quote=*,
-    )
+cdef class FixedRiskSizer(PositionSizer):
+    pass
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/accounting/accounts/cash.pyx` & `nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/cash.pyx`

 * *Files 4% similar despite different names*

```diff
@@ -138,15 +138,15 @@
 
     cpdef Money calculate_commission(
         self,
         Instrument instrument,
         Quantity last_qty,
         Price last_px,
         LiquiditySide liquidity_side,
-        bint inverse_as_quote=False,
+        bint use_quote_for_inverse=False,
     ):
         """
         Calculate the commission generated from a transaction with the given
         parameters.
 
         Result will be in quote currency for standard instruments, or base
         currency for inverse instruments.
@@ -157,15 +157,15 @@
             The instrument for the calculation.
         last_qty : Quantity
             The transaction quantity.
         last_px : Price
             The transaction price.
         liquidity_side : LiquiditySide {``MAKER``, ``TAKER``}
             The liquidity side for the transaction.
-        inverse_as_quote : bool
+        use_quote_for_inverse : bool
             If inverse instrument calculations use quote currency (instead of base).
 
         Returns
         -------
         Money
 
         Raises
@@ -177,39 +177,39 @@
         Condition.not_none(instrument, "instrument")
         Condition.not_none(last_qty, "last_qty")
         Condition.not_equal(liquidity_side, LiquiditySide.NO_LIQUIDITY_SIDE, "liquidity_side", "NO_LIQUIDITY_SIDE")
 
         cdef double notional = instrument.notional_value(
             quantity=last_qty,
             price=last_px,
-            inverse_as_quote=inverse_as_quote,
+            use_quote_for_inverse=use_quote_for_inverse,
         ).as_f64_c()
 
         cdef double commission
         if liquidity_side == LiquiditySide.MAKER:
             commission = notional * float(instrument.maker_fee)
         elif liquidity_side == LiquiditySide.TAKER:
             commission = notional * float(instrument.taker_fee)
         else:
             raise ValueError(
                 f"invalid LiquiditySide, was {liquidity_side_to_str(liquidity_side)}"
             )
 
-        if instrument.is_inverse and not inverse_as_quote:
+        if instrument.is_inverse and not use_quote_for_inverse:
             return Money(commission, instrument.base_currency)
         else:
             return Money(commission, instrument.quote_currency)
 
     cpdef Money calculate_balance_locked(
         self,
         Instrument instrument,
         OrderSide side,
         Quantity quantity,
         Price price,
-        bint inverse_as_quote=False,
+        bint use_quote_for_inverse=False,
     ):
         """
         Calculate the locked balance.
 
         Result will be in quote currency for standard instruments, or base
         currency for inverse instruments.
 
@@ -219,15 +219,15 @@
             The instrument for the calculation.
         side : OrderSide {``BUY``, ``SELL``}
             The order side.
         quantity : Quantity
             The order quantity.
         price : Price
             The order price.
-        inverse_as_quote : bool
+        use_quote_for_inverse : bool
             If inverse instrument calculations use quote currency (instead of base).
 
         Returns
         -------
         Money
 
         """
@@ -240,30 +240,30 @@
 
         cdef double notional
         # Determine notional value
         if side == OrderSide.BUY:
             notional = instrument.notional_value(
                 quantity=quantity,
                 price=price,
-                inverse_as_quote=inverse_as_quote,
+                use_quote_for_inverse=use_quote_for_inverse,
             ).as_f64_c()
         elif side == OrderSide.SELL:
             if base_currency is not None:
                 notional = quantity.as_f64_c()
             else:
                 return None  # No balance to lock
         else:
             raise RuntimeError(f"invalid `OrderSide`, was {side}")  # pragma: no cover (design-time error)
 
         # Add expected commission
         cdef double locked = notional
         locked += (notional * float(instrument.taker_fee) * 2.0)
 
         # Handle inverse
-        if instrument.is_inverse and not inverse_as_quote:
+        if instrument.is_inverse and not use_quote_for_inverse:
             return Money(locked, base_currency)
 
         if side == OrderSide.BUY:
             return Money(locked, quote_currency)
         elif side == OrderSide.SELL:
             return Money(locked, base_currency)
         else:
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/accounting/accounts/margin.pxd` & `nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/margin.pxd`

 * *Files 5% similar despite different names*

```diff
@@ -57,18 +57,18 @@
 # -- CALCULATIONS ---------------------------------------------------------------------------------
 
     cpdef Money calculate_margin_init(
         self,
         Instrument instrument,
         Quantity quantity,
         Price price,
-        bint inverse_as_quote=*,
+        bint use_quote_for_inverse=*,
     )
 
     cpdef Money calculate_margin_maint(
         self,
         Instrument instrument,
         PositionSide side,
         Quantity quantity,
         Price price,
-        bint inverse_as_quote=*,
+        bint use_quote_for_inverse=*,
     )
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/accounting/accounts/margin.pyx` & `nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/margin.pyx`

 * *Files 5% similar despite different names*

```diff
@@ -447,15 +447,15 @@
 
     cpdef Money calculate_commission(
         self,
         Instrument instrument,
         Quantity last_qty,
         Price last_px,
         LiquiditySide liquidity_side,
-        bint inverse_as_quote=False,
+        bint use_quote_for_inverse=False,
     ):
         """
         Calculate the commission generated from a transaction with the given
         parameters.
 
         Result will be in quote currency for standard instruments, or base
         currency for inverse instruments.
@@ -466,15 +466,15 @@
             The instrument for the calculation.
         last_qty : Quantity
             The transaction quantity.
         last_px : Price
             The transaction price.
         liquidity_side : LiquiditySide {``MAKER``, ``TAKER``}
             The liquidity side for the transaction.
-        inverse_as_quote : bool
+        use_quote_for_inverse : bool
             If inverse instrument calculations use quote currency (instead of base).
 
         Returns
         -------
         Money
 
         Raises
@@ -487,38 +487,38 @@
         Condition.not_none(last_qty, "last_qty")
         Condition.type(last_px, (Decimal, Price), "last_px")
         Condition.not_equal(liquidity_side, LiquiditySide.NO_LIQUIDITY_SIDE, "liquidity_side", "NO_LIQUIDITY_SIDE")
 
         cdef double notional = instrument.notional_value(
             quantity=last_qty,
             price=last_px,
-            inverse_as_quote=inverse_as_quote,
+            use_quote_for_inverse=use_quote_for_inverse,
         ).as_f64_c()
 
         cdef double commission
         if liquidity_side == LiquiditySide.MAKER:
             commission = notional * float(instrument.maker_fee)
         elif liquidity_side == LiquiditySide.TAKER:
             commission = notional * float(instrument.taker_fee)
         else:
             raise ValueError(
                 f"invalid `LiquiditySide`, was {liquidity_side_to_str(liquidity_side)}"
             )
 
-        if instrument.is_inverse and not inverse_as_quote:
+        if instrument.is_inverse and not use_quote_for_inverse:
             return Money(commission, instrument.base_currency)
         else:
             return Money(commission, instrument.quote_currency)
 
     cpdef Money calculate_margin_init(
         self,
         Instrument instrument,
         Quantity quantity,
         Price price,
-        bint inverse_as_quote=False,
+        bint use_quote_for_inverse=False,
     ):
         """
         Calculate the initial (order) margin.
 
         Result will be in quote currency for standard instruments, or base
         currency for inverse instruments.
 
@@ -526,53 +526,53 @@
         ----------
         instrument : Instrument
             The instrument for the calculation.
         quantity : Quantity
             The order quantity.
         price : Price
             The order price.
-        inverse_as_quote : bool
+        use_quote_for_inverse : bool
             If inverse instrument calculations use quote currency (instead of base).
 
         Returns
         -------
         Money
 
         """
         Condition.not_none(instrument, "instrument")
         Condition.not_none(quantity, "quantity")
         Condition.not_none(price, "price")
 
         cdef double notional = instrument.notional_value(
             quantity=quantity,
             price=price,
-            inverse_as_quote=inverse_as_quote,
+            use_quote_for_inverse=use_quote_for_inverse,
         ).as_f64_c()
 
         cdef double leverage = self._leverages.get(instrument.id, 0.0)
         if leverage == 0.0:
             leverage = self.default_leverage
             self._leverages[instrument.id] = leverage
 
         cdef double adjusted_notional = notional / leverage
         cdef double margin = adjusted_notional * float(instrument.margin_init)
         margin += (adjusted_notional * float(instrument.taker_fee) * 2.0)
 
-        if instrument.is_inverse and not inverse_as_quote:
+        if instrument.is_inverse and not use_quote_for_inverse:
             return Money(margin, instrument.base_currency)
         else:
             return Money(margin, instrument.quote_currency)
 
     cpdef Money calculate_margin_maint(
         self,
         Instrument instrument,
         PositionSide side,
         Quantity quantity,
         Price price,
-        bint inverse_as_quote=False,
+        bint use_quote_for_inverse=False,
     ):
         """
         Calculate the maintenance (position) margin.
 
         Result will be in quote currency for standard instruments, or base
         currency for inverse instruments.
 
@@ -582,41 +582,41 @@
             The instrument for the calculation.
         side : PositionSide {``LONG``, ``SHORT``}
             The currency position side.
         quantity : Quantity
             The currency position quantity.
         price : Price
             The positions current price.
-        inverse_as_quote : bool
+        use_quote_for_inverse : bool
             If inverse instrument calculations use quote currency (instead of base).
 
         Returns
         -------
         Money
 
         """
         Condition.not_none(instrument, "instrument")
         Condition.not_none(quantity, "quantity")
 
         cdef double notional = instrument.notional_value(
             quantity=quantity,
             price=price,
-            inverse_as_quote=inverse_as_quote,
+            use_quote_for_inverse=use_quote_for_inverse,
         ).as_f64_c()
 
         cdef double leverage = float(self._leverages.get(instrument.id, 0.0))
         if leverage == 0.0:
             leverage = self.default_leverage
             self._leverages[instrument.id] = leverage
 
         cdef double adjusted_notional = notional / leverage
         cdef double margin = adjusted_notional * float(instrument.margin_maint)
         margin += adjusted_notional * float(instrument.taker_fee)
 
-        if instrument.is_inverse and not inverse_as_quote:
+        if instrument.is_inverse and not use_quote_for_inverse:
             return Money(margin, instrument.base_currency)
         else:
             return Money(margin, instrument.quote_currency)
 
     cpdef list calculate_pnls(
         self,
         Instrument instrument,
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/accounting/calculators.pxd` & `nautilus_trader-1.175.0/nautilus_trader/accounting/calculators.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/accounting/calculators.pyx` & `nautilus_trader-1.175.0/nautilus_trader/accounting/calculators.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -247,17 +247,17 @@
         Notes
         -----
         1% = 0.01 bp
 
         """
         Condition.not_none(instrument_id, "instrument_id")
         Condition.not_none(date, "timestamp")
-        Condition.in_range_int(len(instrument_id.symbol.to_str()), 6, 7, "len(instrument_id)")
+        Condition.in_range_int(len(instrument_id.symbol.value), 6, 7, "len(instrument_id)")
 
-        cdef str symbol = instrument_id.symbol.to_str()
+        cdef str symbol = instrument_id.symbol.value
         cdef str base_currency = symbol[:3]
         cdef str quote_currency = symbol[-3:]
         cdef str time_monthly = f"{date.year}-{str(date.month).zfill(2)}"
         cdef str time_quarter = f"{date.year}-Q{str(int(((date.month - 1) // 3) + 1)).zfill(2)}"
 
         base_data = self._rate_data[base_currency].loc[self._rate_data[base_currency]['TIME'] == time_monthly]
         if base_data.empty:
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/accounting/error.py` & `nautilus_trader-1.175.0/nautilus_trader/accounting/error.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/accounting/factory.pxd` & `nautilus_trader-1.175.0/nautilus_trader/accounting/factory.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/accounting/factory.pyx` & `nautilus_trader-1.175.0/nautilus_trader/accounting/factory.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/accounting/manager.pxd` & `nautilus_trader-1.175.0/nautilus_trader/accounting/manager.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/accounting/manager.pyx` & `nautilus_trader-1.175.0/nautilus_trader/accounting/manager.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/_template/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/_template/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/_template/core.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/_template/core.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/_template/data.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/_template/data.py`

 * *Files 0% similar despite different names*

```diff
@@ -16,16 +16,16 @@
 from typing import Optional
 
 import pandas as pd
 
 from nautilus_trader.core.uuid import UUID4
 from nautilus_trader.live.data_client import LiveDataClient
 from nautilus_trader.live.data_client import LiveMarketDataClient
-from nautilus_trader.model.data.bar import BarType
-from nautilus_trader.model.data.base import DataType
+from nautilus_trader.model.data import BarType
+from nautilus_trader.model.data import DataType
 from nautilus_trader.model.enums import BookType
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.identifiers import Venue
 
 
 # The 'pragma: no cover' comment excludes a method from test coverage.
 # https://coverage.readthedocs.io/en/coverage-4.3.3/excluding.html
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/_template/execution.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/_template/execution.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/_template/providers.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/_template/providers.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/client/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/client/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/client/core.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/client/core.py`

 * *Files 1% similar despite different names*

```diff
@@ -18,15 +18,15 @@
 import pathlib
 import ssl
 from typing import Optional
 
 import msgspec
 from aiohttp import ClientResponse
 from aiohttp import ClientResponseError
-from betfair_parser.spec.api.navigation import Navigation
+from betfair_parser.spec.navigation import Navigation
 
 from nautilus_trader.adapters.betfair.client.enums import MarketProjection
 from nautilus_trader.adapters.betfair.client.enums import MarketSort
 from nautilus_trader.adapters.betfair.client.exceptions import BetfairAPIError
 from nautilus_trader.adapters.betfair.client.exceptions import BetfairError
 from nautilus_trader.adapters.betfair.client.spec import ClearedOrder
 from nautilus_trader.adapters.betfair.client.spec import ClearedOrdersResponse
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/client/enums.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/client/enums.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/client/exceptions.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/client/exceptions.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/client/spec.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/client/spec.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/client/util.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/client/util.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/common.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/common.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/config.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/config.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/constants.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/constants.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/data.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/data.py`

 * *Files 0% similar despite different names*

```diff
@@ -34,16 +34,16 @@
 from nautilus_trader.common.clock import LiveClock
 from nautilus_trader.common.enums import LogColor
 from nautilus_trader.common.logging import Logger
 from nautilus_trader.core.correctness import PyCondition
 from nautilus_trader.core.data import Data
 from nautilus_trader.core.message import Event
 from nautilus_trader.live.data_client import LiveMarketDataClient
-from nautilus_trader.model.data.base import DataType
-from nautilus_trader.model.data.base import GenericData
+from nautilus_trader.model.data import DataType
+from nautilus_trader.model.data import GenericData
 from nautilus_trader.model.enums import BookType
 from nautilus_trader.model.identifiers import ClientId
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.instruments.betting import BettingInstrument
 from nautilus_trader.msgbus.bus import MessageBus
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/data_types.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/data_types.py`

 * *Files 2% similar despite different names*

```diff
@@ -18,18 +18,18 @@
 from typing import Optional
 
 import pyarrow as pa
 
 # fmt: off
 from nautilus_trader.core.correctness import PyCondition
 from nautilus_trader.core.data import Data
-from nautilus_trader.model.data.book import BookOrder
-from nautilus_trader.model.data.book import OrderBookDelta
-from nautilus_trader.model.data.book import OrderBookDeltas
-from nautilus_trader.model.data.ticker import Ticker
+from nautilus_trader.model.data import BookOrder
+from nautilus_trader.model.data import OrderBookDelta
+from nautilus_trader.model.data import OrderBookDeltas
+from nautilus_trader.model.data import Ticker
 from nautilus_trader.model.enums import BookAction
 from nautilus_trader.model.enums import book_action_from_str
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.serialization.arrow.implementations.order_book import deserialize as deserialize_orderbook
 from nautilus_trader.serialization.arrow.implementations.order_book import serialize as serialize_orderbook
 from nautilus_trader.serialization.arrow.schema import NAUTILUS_PARQUET_SCHEMA
 from nautilus_trader.serialization.arrow.serializer import register_parquet
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/execution.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/execution.py`

 * *Files 0% similar despite different names*

```diff
@@ -62,16 +62,16 @@
 from nautilus_trader.live.execution_client import LiveExecutionClient
 from nautilus_trader.model.currency import Currency
 from nautilus_trader.model.enums import AccountType
 from nautilus_trader.model.enums import LiquiditySide
 from nautilus_trader.model.enums import OmsType
 from nautilus_trader.model.enums import OrderSide
 from nautilus_trader.model.enums import OrderType
-from nautilus_trader.model.events.account import AccountState
-from nautilus_trader.model.events.order import OrderFilled
+from nautilus_trader.model.events import AccountState
+from nautilus_trader.model.events import OrderFilled
 from nautilus_trader.model.identifiers import AccountId
 from nautilus_trader.model.identifiers import ClientId
 from nautilus_trader.model.identifiers import ClientOrderId
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.identifiers import TradeId
 from nautilus_trader.model.identifiers import VenueOrderId
 from nautilus_trader.model.objects import Money
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/factories.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/factories.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/historic.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/historic.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/orderbook.pxd` & `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/orderbook.pxd`

 * *Files 10% similar despite different names*

```diff
@@ -12,13 +12,13 @@
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.objects cimport Quantity
-from nautilus_trader.model.orderbook.book cimport L2OrderBook
+from nautilus_trader.model.orderbook.book cimport OrderBook
 
 
-cpdef L2OrderBook create_betfair_order_book(InstrumentId instrument_id)
+cpdef OrderBook create_betfair_order_book(InstrumentId instrument_id)
 cpdef Price betfair_float_to_price(double value)
 cpdef Quantity betfair_float_to_quantity(double value)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/orderbook.pyx` & `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/orderbook.pyx`

 * *Files 11% similar despite different names*

```diff
@@ -14,27 +14,24 @@
 # -------------------------------------------------------------------------------------------------
 
 from nautilus_trader.adapters.betfair.common import BETFAIR_FLOAT_TO_PRICE
 from nautilus_trader.adapters.betfair.common import BETFAIR_PRICE_PRECISION
 from nautilus_trader.adapters.betfair.common import BETFAIR_QUANTITY_PRECISION
 from nautilus_trader.adapters.betfair.constants import BETFAIR_PRICE_PRECISION
 from nautilus_trader.adapters.betfair.constants import BETFAIR_QUANTITY_PRECISION
-from nautilus_trader.model.orderbook.book import L2OrderBook
+from nautilus_trader.model.enums import BookType
+from nautilus_trader.model.orderbook.book import OrderBook
 
 from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.objects cimport Quantity
 
 
-cpdef inline L2OrderBook create_betfair_order_book(InstrumentId instrument_id):
-    return L2OrderBook(
-        instrument_id,
-        BETFAIR_PRICE_PRECISION,
-        BETFAIR_QUANTITY_PRECISION
-    )
+cpdef inline OrderBook create_betfair_order_book(InstrumentId instrument_id):
+    return OrderBook(instrument_id, BookType.L2_MBP)
 
 
 cpdef Price betfair_float_to_price(double value):
     try:
         return BETFAIR_FLOAT_TO_PRICE[value]
     except KeyError:
         return Price(value, BETFAIR_PRICE_PRECISION)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/parsing/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/parsing/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/parsing/common.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/parsing/common.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/parsing/core.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/parsing/core.py`

 * *Files 5% similar despite different names*

```diff
@@ -37,12 +37,12 @@
             return []
         if mcm.is_heartbeat:
             return []
         updates = []
         ts_event = millis_to_nanos(mcm.pt)
         ts_init = ts_init or ts_event
         for mc in mcm.mc:
-            if mc.marketDefinition is not None:
-                self.market_definitions[mc.id] = mc.marketDefinition
+            if mc.market_definition is not None:
+                self.market_definitions[mc.id] = mc.market_definition
             mc_updates = market_change_to_updates(mc, ts_event, ts_init)
             updates.extend(mc_updates)
         return updates
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/parsing/requests.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/parsing/requests.py`

 * *Files 1% similar despite different names*

```diff
@@ -38,15 +38,15 @@
 from nautilus_trader.model.enums import AccountType
 from nautilus_trader.model.enums import ContingencyType
 from nautilus_trader.model.enums import LiquiditySide
 from nautilus_trader.model.enums import OrderSide
 from nautilus_trader.model.enums import OrderStatus
 from nautilus_trader.model.enums import TimeInForce
 from nautilus_trader.model.enums import order_type_from_str
-from nautilus_trader.model.events.account import AccountState
+from nautilus_trader.model.events import AccountState
 from nautilus_trader.model.identifiers import AccountId
 from nautilus_trader.model.identifiers import ClientOrderId
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.identifiers import StrategyId
 from nautilus_trader.model.identifiers import Symbol
 from nautilus_trader.model.identifiers import TradeId
 from nautilus_trader.model.identifiers import VenueOrderId
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/parsing/streaming.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/parsing/streaming.py`

 * *Files 8% similar despite different names*

```diff
@@ -22,95 +22,96 @@
 from betfair_parser.spec.streaming.mcm import MarketDefinition
 from betfair_parser.spec.streaming.mcm import Runner
 from betfair_parser.spec.streaming.mcm import RunnerChange
 from betfair_parser.spec.streaming.mcm import RunnerStatus
 
 from nautilus_trader.adapters.betfair.client.spec import ClearedOrder
 from nautilus_trader.adapters.betfair.common import B2N_MARKET_STREAM_SIDE
+from nautilus_trader.adapters.betfair.constants import BETFAIR_PRICE_PRECISION
+from nautilus_trader.adapters.betfair.constants import BETFAIR_QUANTITY_PRECISION
 from nautilus_trader.adapters.betfair.constants import CLOSE_PRICE_LOSER
 from nautilus_trader.adapters.betfair.constants import CLOSE_PRICE_WINNER
 from nautilus_trader.adapters.betfair.constants import MARKET_STATUS_MAPPING
 from nautilus_trader.adapters.betfair.constants import STRICT_MARKET_DATA_HANDLING
 from nautilus_trader.adapters.betfair.constants import MarketDataKind
 from nautilus_trader.adapters.betfair.data_types import BetfairStartingPrice
 from nautilus_trader.adapters.betfair.data_types import BetfairTicker
 from nautilus_trader.adapters.betfair.data_types import BSPOrderBookDelta
 from nautilus_trader.adapters.betfair.data_types import BSPOrderBookDeltas
 from nautilus_trader.adapters.betfair.orderbook import betfair_float_to_price
 from nautilus_trader.adapters.betfair.orderbook import betfair_float_to_quantity
 from nautilus_trader.adapters.betfair.parsing.common import betfair_instrument_id
 from nautilus_trader.adapters.betfair.parsing.common import hash_market_trade
 from nautilus_trader.adapters.betfair.parsing.requests import parse_handicap
-from nautilus_trader.common.functions import one
 from nautilus_trader.execution.reports import TradeReport
-from nautilus_trader.model.data.book import BookOrder
-from nautilus_trader.model.data.book import OrderBookDelta
-from nautilus_trader.model.data.book import OrderBookDeltas
-from nautilus_trader.model.data.book import OrderBookSnapshot
-from nautilus_trader.model.data.tick import TradeTick
-from nautilus_trader.model.data.venue import InstrumentClose
-from nautilus_trader.model.data.venue import InstrumentStatusUpdate
+from nautilus_trader.model.data import BookOrder
+from nautilus_trader.model.data import InstrumentClose
+from nautilus_trader.model.data import InstrumentStatusUpdate
+from nautilus_trader.model.data import OrderBookDelta
+from nautilus_trader.model.data import OrderBookDeltas
+from nautilus_trader.model.data import TradeTick
 from nautilus_trader.model.enums import AggressorSide
 from nautilus_trader.model.enums import BookAction
 from nautilus_trader.model.enums import InstrumentCloseType
 from nautilus_trader.model.enums import LiquiditySide
 from nautilus_trader.model.enums import MarketStatus
 from nautilus_trader.model.enums import OrderSide
 from nautilus_trader.model.identifiers import AccountId
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.identifiers import Symbol
 from nautilus_trader.model.identifiers import TradeId
 from nautilus_trader.model.identifiers import VenueOrderId
+from nautilus_trader.model.objects import Price
+from nautilus_trader.model.objects import Quantity
 
 
 PARSE_TYPES = Union[
     InstrumentStatusUpdate,
     InstrumentClose,
-    OrderBookSnapshot,
     OrderBookDeltas,
     TradeTick,
     BetfairTicker,
     BSPOrderBookDelta,
     BSPOrderBookDeltas,
     BetfairStartingPrice,
 ]
 
 
-def market_change_to_updates(  # noqa: C901
+def market_change_to_updates(  # noqa: too complex
     mc: MarketChange,
     ts_event: int,
     ts_init: int,
 ) -> list[PARSE_TYPES]:
     updates: list[PARSE_TYPES] = []
 
     # Handle instrument status and close updates first
-    if mc.marketDefinition is not None:
+    if mc.market_definition is not None:
         updates.extend(
             market_definition_to_instrument_status_updates(
-                mc.marketDefinition,
+                mc.market_definition,
                 mc.id,
                 ts_event,
                 ts_init,
             ),
         )
         updates.extend(
-            market_definition_to_instrument_closes(mc.marketDefinition, mc.id, ts_event, ts_init),
+            market_definition_to_instrument_closes(mc.market_definition, mc.id, ts_event, ts_init),
         )
         updates.extend(
             market_definition_to_betfair_starting_prices(
-                mc.marketDefinition,
+                mc.market_definition,
                 mc.id,
                 ts_event,
                 ts_init,
             ),
         )
 
     # Handle market data updates
-    book_updates: list[Union[OrderBookSnapshot, OrderBookDeltas]] = []
-    bsp_book_updates: list[Union[BSPOrderBookDeltas]] = []
+    book_updates: list[OrderBookDeltas] = []
+    bsp_book_updates: list[BSPOrderBookDeltas] = []
     for rc in mc.rc:
         instrument_id = betfair_instrument_id(
             market_id=mc.id,
             selection_id=str(rc.id),
             selection_handicap=parse_handicap(rc.hc),
         )
 
@@ -167,23 +168,23 @@
 
     for runner in market_definition.runners:
         instrument_id = betfair_instrument_id(
             market_id=market_id,
             selection_id=str(runner.runner_id),
             selection_handicap=parse_handicap(runner.handicap),
         )
-        key: tuple[MarketStatus, bool] = (market_definition.status, market_definition.inPlay)
+        key: tuple[MarketStatus, bool] = (market_definition.status, market_definition.in_play)
         if runner.status == RunnerStatus.REMOVED:
             status = MarketStatus.CLOSED
         else:
             try:
                 status = MARKET_STATUS_MAPPING[key]
             except KeyError:
                 raise ValueError(
-                    f"{runner.status=} {market_definition.status=} {market_definition.inPlay=}",
+                    f"{runner.status=} {market_definition.status=} {market_definition.in_play=}",
                 )
         status = InstrumentStatusUpdate(
             instrument_id=instrument_id,
             status=status,
             ts_event=ts_event,
             ts_init=ts_init,
         )
@@ -293,15 +294,15 @@
 
 
 def runner_change_to_order_book_snapshot(
     rc: RunnerChange,
     instrument_id: InstrumentId,
     ts_event: int,
     ts_init: int,
-) -> Optional[OrderBookSnapshot]:
+) -> Optional[OrderBookDeltas]:
     try:
         market_data_kind = runner_change_to_market_data_kind(rc)
     except ValueError:
         return None
     if market_data_kind == MarketDataKind.ALL:
         return runner_change_all_depth_to_order_book_snapshot(rc, instrument_id, ts_event, ts_init)
     elif market_data_kind == MarketDataKind.BEST:
@@ -318,44 +319,42 @@
 
 
 def runner_change_all_depth_to_order_book_snapshot(
     rc: RunnerChange,
     instrument_id: InstrumentId,
     ts_event: int,
     ts_init: int,
-) -> Optional[OrderBookSnapshot]:
+) -> Optional[OrderBookDeltas]:
     # ATL = Available To Lay = Back orders
-    asks = (
-        [(betfair_float_to_price(order.price), order.volume) for order in rc.atl if order.price]
-        if rc.atl
-        else []
-    )
+    if rc.atl:
+        asks: list = [
+            (betfair_float_to_price(order.price), order.volume) for order in rc.atl if order.price
+        ]
+    else:
+        asks = []
+
     # Asks are available to back (atb)
     if rc.atb:
         bids: list = [
             (betfair_float_to_price(order.price), order.volume) for order in rc.atb if order.price
         ]
     else:
         bids = []
 
-    return OrderBookSnapshot(
-        instrument_id=instrument_id,
-        bids=bids,
-        asks=asks,
-        ts_event=ts_event,
-        ts_init=ts_init,
-    )
+    deltas = bids + asks
+    deltas.insert(0, OrderBookDelta.clear(instrument_id, ts_event, ts_init))
+    return OrderBookDeltas(instrument_id=instrument_id, deltas=deltas)
 
 
 def runner_change_best_depth_to_order_book_snapshot(
     rc: RunnerChange,
     instrument_id: InstrumentId,
     ts_event: int,
     ts_init: int,
-) -> Optional[OrderBookSnapshot]:
+) -> Optional[OrderBookDeltas]:
     # Bids are best available to lay (batl)
     if rc.batl:
         asks: list = [
             (betfair_float_to_price(order.price), order.volume) for order in rc.batl if order.price
         ]
     else:
         asks = []
@@ -363,48 +362,41 @@
     # Asks are best available to back (batb)
     if rc.batb:
         bids: list = [
             (betfair_float_to_price(order.price), order.volume) for order in rc.batb if order.price
         ]
     else:
         bids = []
-    return OrderBookSnapshot(
-        instrument_id=instrument_id,
-        bids=bids,
-        asks=asks,
-        ts_event=ts_event,
-        ts_init=ts_init,
-    )
+    deltas = bids + asks
+    deltas.insert(0, OrderBookDelta.clear(instrument_id, ts_event, ts_init))
+    return OrderBookDeltas(instrument_id=instrument_id, deltas=deltas)
 
 
 def runner_change_display_depth_to_order_book_snapshot(
     rc: RunnerChange,
     instrument_id: InstrumentId,
     ts_event: int,
     ts_init: int,
-) -> Optional[OrderBookSnapshot]:
+) -> Optional[OrderBookDeltas]:
     # Bids are best display available to lay (bdatl)
     asks = (
         [(betfair_float_to_price(order.price), order.volume) for order in rc.bdatl if order.price]
         if rc.bdatl
         else []
     )
     # Asks are best display available to back (bdatb)
     if rc.bdatb:
         bids: list = [
             (betfair_float_to_price(order.price), order.volume) for order in rc.bdatb if order.price
         ]
     else:
         bids = []
-    return OrderBookSnapshot(
+    return OrderBookDeltas(
         instrument_id=instrument_id,
-        bids=bids,
-        asks=asks,
-        ts_event=ts_event,
-        ts_init=ts_init,
+        deltas=bids + asks,
     )
 
 
 def runner_change_to_order_book_deltas(
     rc: RunnerChange,
     instrument_id: InstrumentId,
     ts_event: int,
@@ -440,44 +432,49 @@
     # Bids are available to lay (atl)
     if rc.atl:
         deltas.extend(
             [
                 OrderBookDelta(
                     instrument_id,
                     BookAction.UPDATE if back.volume != 0.0 else BookAction.DELETE,
-                    BookOrder(back.price, back.volume, OrderSide.SELL),
+                    BookOrder(
+                        OrderSide.SELL,
+                        Price(back.price, BETFAIR_PRICE_PRECISION),
+                        Quantity(back.volume, BETFAIR_QUANTITY_PRECISION),
+                        ts_init,
+                    ),
                     ts_event,
                     ts_init,
                 )
                 for back in rc.atl
             ],
         )
 
     # Asks are available to back (atb)
     if rc.atb:
         deltas.extend(
             [
                 OrderBookDelta(
                     instrument_id,
                     BookAction.UPDATE if lay.volume != 0.0 else BookAction.DELETE,
-                    BookOrder(lay.price, lay.volume, OrderSide.BUY),
+                    BookOrder(
+                        OrderSide.BUY,
+                        Price(lay.price, BETFAIR_PRICE_PRECISION),
+                        Quantity(lay.volume, BETFAIR_QUANTITY_PRECISION),
+                        ts_init,
+                    ),
                     ts_event,
                     ts_init,
                 )
                 for lay in rc.atb
             ],
         )
     if not deltas:
         return None
-    return OrderBookDeltas(
-        instrument_id=instrument_id,
-        deltas=deltas,
-        ts_event=ts_event,
-        ts_init=ts_init,
-    )
+    return OrderBookDeltas(instrument_id=instrument_id, deltas=deltas)
 
 
 def runner_change_best_depth_to_deltas(
     rc: RunnerChange,
     instrument_id: InstrumentId,
     ts_event: int,
     ts_init: int,
@@ -511,20 +508,15 @@
                     ts_init,
                 )
                 for lay in rc.batb
             ],
         )
     if not deltas:
         return None
-    return OrderBookDeltas(
-        instrument_id=instrument_id,
-        deltas=deltas,
-        ts_event=ts_event,
-        ts_init=ts_init,
-    )
+    return OrderBookDeltas(instrument_id=instrument_id, deltas=deltas)
 
 
 def runner_change_display_depth_to_deltas(
     rc: RunnerChange,
     instrument_id: InstrumentId,
     ts_event: int,
     ts_init: int,
@@ -686,25 +678,21 @@
         ts_init=ts_init,
     )
 
 
 def _merge_order_book_deltas(all_deltas: list[OrderBookDeltas]):
     cls = type(all_deltas[0])
     per_instrument_deltas = defaultdict(list)
-    ts_event = one({deltas.ts_event for deltas in all_deltas})
-    ts_init = one({deltas.ts_init for deltas in all_deltas})
 
     for deltas in all_deltas:
         per_instrument_deltas[deltas.instrument_id].extend(deltas.deltas)
     return [
         cls(
             instrument_id=instrument_id,
             deltas=deltas,
-            ts_event=ts_event,
-            ts_init=ts_init,
         )
         for instrument_id, deltas in per_instrument_deltas.items()
     ]
 
 
 async def generate_trades_list(
     self,
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/providers.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/providers.py`

 * *Files 4% similar despite different names*

```diff
@@ -14,18 +14,20 @@
 # -------------------------------------------------------------------------------------------------
 
 import time
 from typing import Optional, Union
 
 import msgspec.json
 import pandas as pd
-from betfair_parser.spec.api.markets import MarketCatalog
-from betfair_parser.spec.api.navigation import FlattenedMarket
-from betfair_parser.spec.api.navigation import Navigation
-from betfair_parser.spec.api.navigation import navigation_to_flatten_markets
+from betfair_parser.spec.betting.type_definitions import MarketCatalogue
+from betfair_parser.spec.common import decode as bf_decode
+from betfair_parser.spec.common import encode as bf_encode
+from betfair_parser.spec.navigation import FlattenedMarket
+from betfair_parser.spec.navigation import Navigation
+from betfair_parser.spec.navigation import navigation_to_flatten_markets
 from betfair_parser.spec.streaming.mcm import MarketDefinition
 
 from nautilus_trader.adapters.betfair.client.core import BetfairClient
 from nautilus_trader.adapters.betfair.client.enums import MarketProjection
 from nautilus_trader.adapters.betfair.common import BETFAIR_VENUE
 from nautilus_trader.adapters.betfair.parsing.common import chunk
 from nautilus_trader.adapters.betfair.parsing.requests import parse_handicap
@@ -174,86 +176,86 @@
 
 def _parse_date(s, tz):
     # pd.Timestamp is ~5x faster than datetime.datetime.isoformat here.
     return pd.Timestamp(s, tz=tz)
 
 
 def market_catalog_to_instruments(
-    market_catalog: MarketCatalog,
+    market_catalog: MarketCatalogue,
     currency: str,
 ) -> list[BettingInstrument]:
     instruments: list[BettingInstrument] = []
     for runner in market_catalog.runners:
         instrument = BettingInstrument(
             venue_name=BETFAIR_VENUE.value,
-            event_type_id=market_catalog.eventType.id,
-            event_type_name=market_catalog.eventType.name,
-            competition_id=market_catalog.competition_id,
-            competition_name=market_catalog.competition_name,
+            event_type_id=str(market_catalog.event_type.id),
+            event_type_name=market_catalog.event_type.name,
+            competition_id=market_catalog.competition.id if market_catalog.competition else "",
+            competition_name=market_catalog.competition.name if market_catalog.competition else "",
             event_id=market_catalog.event.id,
             event_name=market_catalog.event.name,
-            event_country_code=market_catalog.event.countryCode or "",
-            event_open_date=pd.Timestamp(market_catalog.event.openDate),
-            betting_type=market_catalog.description.bettingType,
-            market_id=market_catalog.marketId,
-            market_name=market_catalog.marketName,
-            market_start_time=pd.Timestamp(market_catalog.marketStartTime),
-            market_type=market_catalog.description.marketType,
+            event_country_code=market_catalog.event.country_code or "",
+            event_open_date=pd.Timestamp(market_catalog.event.open_date),
+            betting_type=market_catalog.description.betting_type.name,
+            market_id=market_catalog.market_id,
+            market_name=market_catalog.market_name,
+            market_start_time=pd.Timestamp(market_catalog.market_start_time),
+            market_type=market_catalog.description.market_type,
             selection_id=str(runner.runner_id),
             selection_name=runner.runner_name,
             selection_handicap=parse_handicap(runner.handicap),
             currency=currency,
             ts_event=time.time_ns(),
             ts_init=time.time_ns(),
-            info=msgspec.json.decode(msgspec.json.encode(market_catalog)),
+            info=msgspec.json.decode(bf_encode(market_catalog).decode()),
         )
         instruments.append(instrument)
     return instruments
 
 
 def market_definition_to_instruments(
     market_definition: MarketDefinition,
     currency: str,
 ) -> list[BettingInstrument]:
     instruments: list[BettingInstrument] = []
     for runner in market_definition.runners:
         instrument = BettingInstrument(
             venue_name=BETFAIR_VENUE.value,
-            event_type_id=market_definition.eventTypeId,
+            event_type_id=market_definition.event_type_id,
             event_type_name=market_definition.event_type_name,
-            competition_id=market_definition.competitionId,
-            competition_name=market_definition.competitionName,
-            event_id=market_definition.eventId,
-            event_name=market_definition.eventName,
-            event_country_code=market_definition.countryCode,
-            event_open_date=pd.Timestamp(market_definition.openDate),
-            betting_type=market_definition.bettingType,
-            market_id=market_definition.marketId,
-            market_name=market_definition.marketName,
-            market_start_time=pd.Timestamp(market_definition.marketTime)
-            if market_definition.marketTime
+            competition_id=market_definition.competition_id,
+            competition_name=market_definition.competition_name,
+            event_id=market_definition.event_id,
+            event_name=market_definition.event_name,
+            event_country_code=market_definition.country_code,
+            event_open_date=pd.Timestamp(market_definition.open_date),
+            betting_type=market_definition.betting_type,
+            market_id=market_definition.market_id,
+            market_name=market_definition.market_name,
+            market_start_time=pd.Timestamp(market_definition.market_time)
+            if market_definition.market_time
             else pd.Timestamp(0, tz="UTC"),
-            market_type=market_definition.marketType,
-            selection_id=str(runner.selectionId or runner.id),
+            market_type=market_definition.market_type,
+            selection_id=str(runner.selection_id or runner.id),
             selection_name=runner.name or "",
             selection_handicap=parse_handicap(runner.hc),
             currency=currency,
             ts_event=time.time_ns(),
             ts_init=time.time_ns(),
             info=msgspec.json.decode(msgspec.json.encode(market_definition)),
         )
         instruments.append(instrument)
     return instruments
 
 
 def make_instruments(
-    market: Union[MarketCatalog, MarketDefinition],
+    market: Union[MarketCatalogue, MarketDefinition],
     currency: str,
 ) -> list[BettingInstrument]:
-    if isinstance(market, MarketCatalog):
+    if isinstance(market, MarketCatalogue):
         return market_catalog_to_instruments(market, currency)
     elif isinstance(market, MarketDefinition):
         return market_definition_to_instruments(market, currency)
     else:
         raise TypeError(type(market))
 
 
@@ -286,22 +288,23 @@
         }
     assert all(k in VALID_MARKET_FILTER_KEYS for k in (market_filter or []))
     navigation: Navigation = await client.list_navigation()
     markets = navigation_to_flatten_markets(navigation, **market_filter)
     return markets
 
 
-def parse_market_catalog(catalog: list[dict]) -> list[MarketCatalog]:
-    return msgspec.json.decode(msgspec.json.encode(catalog), type=list[MarketCatalog])
+def parse_market_catalog(catalog: list[dict]) -> list[MarketCatalogue]:
+    raw = msgspec.json.encode(catalog)
+    return bf_decode(raw, type=list[MarketCatalogue])
 
 
 async def load_markets_metadata(
     client: BetfairClient,
     markets: list[FlattenedMarket],
-) -> list[MarketCatalog]:
+) -> list[MarketCatalogue]:
     all_results = []
     for market_id_chunk in chunk(list({m.market_id for m in markets}), 50):
         results = await client.list_market_catalogue(
             market_projection=[
                 MarketProjection.EVENT_TYPE,
                 MarketProjection.EVENT,
                 MarketProjection.COMPETITION,
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/betfair/sockets.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/betfair/sockets.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/common/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/common/constants.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/constants.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/common/data.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/data.py`

 * *Files 8% similar despite different names*

```diff
@@ -40,21 +40,20 @@
 from nautilus_trader.common.enums import LogColor
 from nautilus_trader.common.logging import Logger
 from nautilus_trader.common.providers import InstrumentProvider
 from nautilus_trader.core.correctness import PyCondition
 from nautilus_trader.core.datetime import secs_to_millis
 from nautilus_trader.core.uuid import UUID4
 from nautilus_trader.live.data_client import LiveMarketDataClient
-from nautilus_trader.model.data.bar import BarType
-from nautilus_trader.model.data.base import DataType
-from nautilus_trader.model.data.book import OrderBookDelta
-from nautilus_trader.model.data.book import OrderBookDeltas
-from nautilus_trader.model.data.book import OrderBookSnapshot
-from nautilus_trader.model.data.tick import QuoteTick
-from nautilus_trader.model.data.tick import TradeTick
+from nautilus_trader.model.data import BarType
+from nautilus_trader.model.data import DataType
+from nautilus_trader.model.data import OrderBookDelta
+from nautilus_trader.model.data import OrderBookDeltas
+from nautilus_trader.model.data import QuoteTick
+from nautilus_trader.model.data import TradeTick
 from nautilus_trader.model.enums import BookType
 from nautilus_trader.model.enums import PriceType
 from nautilus_trader.model.identifiers import ClientId
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.identifiers import Symbol
 from nautilus_trader.model.instruments import Instrument
 from nautilus_trader.msgbus.bus import MessageBus
@@ -82,15 +81,15 @@
         The clock for the client.
     logger : Logger
         The logger for the client.
     instrument_provider : InstrumentProvider
         The instrument provider.
     account_type : BinanceAccountType
         The account type for the client.
-    base_url_ws : str, optional
+    base_url_ws : str
         The base URL for the WebSocket client.
     use_agg_trade_ticks : bool, default False
         Whether to use aggregated trade tick endpoints instead of raw trade ticks.
         TradeId of ticks will be the Aggregate tradeId returned by Binance.
 
     Warnings
     --------
@@ -105,15 +104,15 @@
         enum_parser: BinanceEnumParser,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
         logger: Logger,
         instrument_provider: InstrumentProvider,
         account_type: BinanceAccountType,
-        base_url_ws: Optional[str] = None,
+        base_url_ws: str,
         use_agg_trade_ticks: bool = False,
     ) -> None:
         super().__init__(
             loop=loop,
             client_id=ClientId(BINANCE_VENUE.value),
             venue=BINANCE_VENUE,
             instrument_provider=instrument_provider,
@@ -138,26 +137,25 @@
         self._http_market = market
 
         # Enum parser
         self._enum_parser = enum_parser
 
         # WebSocket API
         self._ws_client = BinanceWebSocketClient(
-            loop=loop,
             clock=clock,
             logger=logger,
             handler=self._handle_ws_message,
             base_url=base_url_ws,
         )
 
         # Hot caches
         self._instrument_ids: dict[str, InstrumentId] = {}
         self._book_buffer: dict[
             InstrumentId,
-            list[Union[OrderBookDelta, OrderBookDeltas, OrderBookSnapshot]],
+            list[Union[OrderBookDelta, OrderBookDeltas]],
         ] = {}
 
         self._log.info(f"Base URL HTTP {self._http_client.base_url}.", LogColor.BLUE)
         self._log.info(f"Base URL WebSocket {base_url_ws}.", LogColor.BLUE)
 
         # Register common WebSocket message handlers
         self._ws_handlers = {
@@ -177,38 +175,35 @@
         self._decoder_order_book_msg = msgspec.json.Decoder(BinanceOrderBookMsg)
         self._decoder_quote_msg = msgspec.json.Decoder(BinanceQuoteMsg)
         self._decoder_ticker_msg = msgspec.json.Decoder(BinanceTickerMsg)
         self._decoder_candlestick_msg = msgspec.json.Decoder(BinanceCandlestickMsg)
         self._decoder_agg_trade_msg = msgspec.json.Decoder(BinanceAggregatedTradeMsg)
 
     async def _connect(self) -> None:
-        # Connect HTTP client
-        self._log.info("Connecting client...")
-        if not self._http_client.connected:
-            await self._http_client.connect()
-
         self._log.info("Initialising instruments...")
         await self._instrument_provider.initialize()
 
         self._send_all_instruments_to_data_engine()
         self._update_instruments_task = self.create_task(self._update_instruments())
 
         # Connect WebSocket clients
         self._connect_websockets_task = self.create_task(self._connect_websockets())
 
     async def _connect_websockets(self) -> None:
         try:
-            while not self._ws_client.is_connected:
+            while True:
                 self._log.debug(
                     f"Scheduled `connect_websockets` to run in "
                     f"{self._connect_websockets_interval}s.",
                 )
                 await asyncio.sleep(self._connect_websockets_interval)
+
                 if self._ws_client.has_subscriptions:
                     await self._ws_client.connect()
+                    break
                 else:
                     self._log.info("Awaiting subscriptions...")
         except asyncio.CancelledError:
             self._log.debug("`connect_websockets` task was canceled.")
 
     async def _update_instruments(self) -> None:
         try:
@@ -224,29 +219,25 @@
             self._log.debug("`update_instruments` task was canceled.")
 
     async def _disconnect(self) -> None:
         # Cancel update instruments task
         if self._update_instruments_task:
             self._log.debug("Canceling `update_instruments` task...")
             self._update_instruments_task.cancel()
-            self._update_instruments_task.done()
+            self._update_instruments_task = None
 
         # Cancel WebSocket connect task
         if self._connect_websockets_task:
             self._log.debug("Canceling `connect_websockets` task...")
             self._connect_websockets_task.cancel()
-            self._connect_websockets_task.done()
-        # Disconnect WebSocket client
+            self._connect_websockets_task = None
+
         if self._ws_client.is_connected:
             await self._ws_client.disconnect()
 
-        # Disconnect HTTP client
-        if self._http_client.connected:
-            await self._http_client.disconnect()
-
     # -- SUBSCRIPTIONS ----------------------------------------------------------------------------
 
     async def _subscribe(self, data_type: DataType) -> None:
         # Replace method in child class, for exchange specific data types.
         raise NotImplementedError("Cannot subscribe to {data_type.type} (not implemented).")
 
     async def _subscribe_instruments(self) -> None:
@@ -321,32 +312,29 @@
 
         if depth is None:
             depth = 0
 
         # Add delta stream buffer
         self._book_buffer[instrument_id] = []
 
-        snapshot: Optional[OrderBookSnapshot] = None
+        snapshot: Optional[OrderBookDeltas] = None
         if 0 < depth <= 20:
             if depth not in (5, 10, 20):
                 self._log.error(
                     "Cannot subscribe to order book snapshots: "
                     f"invalid `depth`, was {depth}. "
                     "Valid depths are 5, 10 or 20.",
                 )
                 return
             self._ws_client.subscribe_partial_book_depth(
                 symbol=instrument_id.symbol.value,
                 depth=depth,
                 speed=update_speed,
             )
 
-            while not self._ws_client.is_connected:
-                await asyncio.sleep(self._connect_websockets_interval)
-
             snapshot = await self._http_market.request_order_book_snapshot(
                 instrument_id=instrument_id,
                 limit=depth,
                 ts_init=self._clock.timestamp_ns(),
             )
             self._handle_data(snapshot)
         else:
@@ -398,15 +386,15 @@
 
         self._ws_client.subscribe_bars(
             symbol=bar_type.instrument_id.symbol.value,
             interval=interval.value,
         )
         self._add_subscription_bars(bar_type)
 
-    async def _unsubscribe(self, data_type: DataType):
+    async def _unsubscribe(self, data_type: DataType) -> None:
         # Replace method in child class, for exchange specific data types.
         raise NotImplementedError(f"Cannot unsubscribe from {data_type.type} (not implemented).")
 
     async def _unsubscribe_instruments(self) -> None:
         pass  # Do nothing further
 
     async def _unsubscribe_instrument(self, instrument_id: InstrumentId) -> None:
@@ -485,17 +473,17 @@
                 ts_init=self._clock.timestamp_ns(),
             )
         else:
             # Convert from timestamps to milliseconds
             start_time_ms = None
             end_time_ms = None
             if start:
-                start_time_ms = str(int(start.timestamp() * 1000))
+                start_time_ms = int(start.timestamp() * 1000)
             if end:
-                end_time_ms = str(int(end.timestamp() * 1000))
+                end_time_ms = int(end.timestamp() * 1000)
             ticks = await self._http_market.request_agg_trade_ticks(
                 instrument_id=instrument_id,
                 limit=limit,
                 start_time=start_time_ms,
                 end_time=end_time_ms,
                 ts_init=self._clock.timestamp_ns(),
             )
@@ -589,15 +577,14 @@
         return instrument_id
 
     # -- WEBSOCKET HANDLERS ---------------------------------------------------------------------------------
 
     def _handle_ws_message(self, raw: bytes) -> None:
         # TODO(cs): Uncomment for development
         # self._log.info(str(raw), LogColor.CYAN)
-
         wrapper = self._decoder_data_msg_wrapper.decode(raw)
         try:
             handled = False
             for handler in self._ws_handlers:
                 if handler in wrapper.stream:
                     self._ws_handlers[handler](raw)
                     handled = True
@@ -611,17 +598,17 @@
     def _handle_book_diff_update(self, raw: bytes) -> None:
         msg = self._decoder_order_book_msg.decode(raw)
         instrument_id: InstrumentId = self._get_cached_instrument_id(msg.data.s)
         book_deltas: OrderBookDeltas = msg.data.parse_to_order_book_deltas(
             instrument_id=instrument_id,
             ts_init=self._clock.timestamp_ns(),
         )
-        book_buffer: Optional[
-            list[Union[OrderBookDelta, OrderBookDeltas, OrderBookSnapshot]]
-        ] = self._book_buffer.get(instrument_id)
+        book_buffer: Optional[list[Union[OrderBookDelta, OrderBookDeltas]]] = self._book_buffer.get(
+            instrument_id,
+        )
         if book_buffer is not None:
             book_buffer.append(book_deltas)
         else:
             self._handle_data(book_deltas)
 
     def _handle_book_ticker(self, raw: bytes) -> None:
         msg = self._decoder_quote_msg.decode(raw)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/common/enums.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/enums.py`

 * *Files 3% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from enum import Enum
 from enum import unique
 
-from nautilus_trader.model.data.bar import BarSpecification
+from nautilus_trader.model.data import BarSpecification
 from nautilus_trader.model.enums import BarAggregation
 from nautilus_trader.model.enums import OrderSide
 from nautilus_trader.model.enums import OrderStatus
 from nautilus_trader.model.enums import OrderType
 from nautilus_trader.model.enums import PriceType
 from nautilus_trader.model.enums import TimeInForce
 from nautilus_trader.model.enums import TriggerType
@@ -107,43 +107,43 @@
 
 
 @unique
 class BinanceAccountType(Enum):
     """Represents a `Binance` account type."""
 
     SPOT = "SPOT"
-    MARGIN_CROSS = "MARGIN_CROSS"
-    MARGIN_ISOLATED = "MARGIN_ISOLATED"
-    FUTURES_USDT = "FUTURES_USDT"
-    FUTURES_COIN = "FUTURES_COIN"
+    MARGIN = "MARGIN"
+    ISOLATED_MARGIN = "ISOLATED_MARGIN"
+    USDT_FUTURE = "USDT_FUTURE"
+    COIN_FUTURE = "COIN_FUTURE"
 
     @property
     def is_spot(self):
         return self == BinanceAccountType.SPOT
 
     @property
     def is_margin(self):
         return self in (
-            BinanceAccountType.MARGIN_CROSS,
-            BinanceAccountType.MARGIN_ISOLATED,
+            BinanceAccountType.MARGIN,
+            BinanceAccountType.ISOLATED_MARGIN,
         )
 
     @property
     def is_spot_or_margin(self):
         return self in (
             BinanceAccountType.SPOT,
-            BinanceAccountType.MARGIN_CROSS,
-            BinanceAccountType.MARGIN_ISOLATED,
+            BinanceAccountType.MARGIN,
+            BinanceAccountType.ISOLATED_MARGIN,
         )
 
     @property
     def is_futures(self) -> bool:
         return self in (
-            BinanceAccountType.FUTURES_USDT,
-            BinanceAccountType.FUTURES_COIN,
+            BinanceAccountType.USDT_FUTURE,
+            BinanceAccountType.COIN_FUTURE,
         )
 
 
 @unique
 class BinanceOrderSide(Enum):
     """Represents a `Binance` order side."""
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/common/execution.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/execution.py`

 * *Files 5% similar despite different names*

```diff
@@ -101,15 +101,15 @@
         The clock for the client.
     logger : Logger
         The logger for the client.
     instrument_provider : BinanceSpotInstrumentProvider
         The instrument provider.
     account_type : BinanceAccountType
         The account type for the client.
-    base_url_ws : str, optional
+    base_url_ws : str
         The base URL for the WebSocket client.
     warn_gtd_to_gtc : bool, default True
         If log warning for GTD time in force transformed to GTC.
 
     Warnings
     --------
     This class should not be used directly, but through a concrete subclass.
@@ -125,15 +125,15 @@
         enum_parser: BinanceEnumParser,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
         logger: Logger,
         instrument_provider: InstrumentProvider,
         account_type: BinanceAccountType,
-        base_url_ws: Optional[str] = None,
+        base_url_ws: str,
         warn_gtd_to_gtc: bool = True,
     ) -> None:
         super().__init__(
             loop=loop,
             client_id=ClientId(BINANCE_VENUE.value),
             venue=BINANCE_VENUE,
             oms_type=OmsType.HEDGING if account_type.is_futures else OmsType.NETTING,
@@ -164,15 +164,14 @@
         # Listen keys
         self._ping_listen_keys_interval: int = 60 * 5  # Once every 5 mins (hardcode)
         self._ping_listen_keys_task: Optional[asyncio.Task] = None
         self._listen_key: Optional[str] = None
 
         # WebSocket API
         self._ws_client = BinanceWebSocketClient(
-            loop=loop,
             clock=clock,
             logger=logger,
             handler=self._handle_user_ws_message,
             base_url=base_url_ws,
         )
 
         # Hot caches
@@ -191,17 +190,14 @@
             OrderType.TRAILING_STOP_MARKET: self._submit_trailing_stop_market_order,
         }
 
         self._log.info(f"Base URL HTTP {self._http_client.base_url}.", LogColor.BLUE)
         self._log.info(f"Base URL WebSocket {base_url_ws}.", LogColor.BLUE)
 
     async def _connect(self) -> None:
-        # Connect HTTP client
-        if not self._http_client.connected:
-            await self._http_client.connect()
         try:
             # Initialize instrument provider
             await self._instrument_provider.initialize()
             # Authenticate API key and update account(s)
             await self._update_account_state()
             # Get listen keys
             response: BinanceListenKey = await self._http_user.create_listen_key()
@@ -218,15 +214,15 @@
 
         # Setup websocket listen key
         self._listen_key = response.listenKey
         self._log.info(f"Listen key {self._listen_key}")
         self._ping_listen_keys_task = self.create_task(self._ping_listen_keys())
 
         # Connect WebSocket client
-        self._ws_client.subscribe(key=self._listen_key)
+        await self._ws_client.subscribe(key=self._listen_key)
         await self._ws_client.connect()
 
     async def _update_account_state(self) -> None:
         # Replace method in child class
         raise NotImplementedError
 
     async def _ping_listen_keys(self) -> None:
@@ -244,24 +240,19 @@
             self._log.debug("`ping_listen_keys` task was canceled.")
 
     async def _disconnect(self) -> None:
         # Cancel tasks
         if self._ping_listen_keys_task:
             self._log.debug("Canceling `ping_listen_keys` task...")
             self._ping_listen_keys_task.cancel()
-            self._ping_listen_keys_task.done()
+            self._ping_listen_keys_task = None
 
-        # Disconnect WebSocket clients
         if self._ws_client.is_connected:
             await self._ws_client.disconnect()
 
-        # Disconnect HTTP client
-        if self._http_client.connected:
-            await self._http_client.disconnect()
-
     # -- EXECUTION REPORTS ------------------------------------------------------------------------
 
     async def generate_order_status_report(
         self,
         instrument_id: InstrumentId,
         client_order_id: Optional[ClientOrderId] = None,
         venue_order_id: Optional[VenueOrderId] = None,
@@ -286,15 +277,15 @@
             f"{repr(venue_order_id) if venue_order_id else ''}...",
         )
 
         try:
             if venue_order_id:
                 binance_order = await self._http_account.query_order(
                     symbol=instrument_id.symbol.value,
-                    order_id=venue_order_id.value,
+                    order_id=int(venue_order_id.value),
                 )
             else:
                 binance_order = await self._http_account.query_order(
                     symbol=instrument_id.symbol.value,
                     orig_client_order_id=client_order_id.value
                     if client_order_id is not None
                     else None,
@@ -603,23 +594,23 @@
             iceberg_qty=str(order.display_qty) if order.display_qty is not None else None,
             reduce_only=str(order.is_reduce_only) if order.is_reduce_only is True else None,
             new_client_order_id=order.client_order_id.value,
             recv_window=str(5000),
         )
 
     async def _submit_order_list(self, command: SubmitOrderList) -> None:
-        for order in command.order_list:
+        for order in command.order_list.orders:
             self.generate_order_submitted(
                 strategy_id=order.strategy_id,
                 instrument_id=order.instrument_id,
                 client_order_id=order.client_order_id,
                 ts_event=self._clock.timestamp_ns(),
             )
 
-        for order in command.order_list:
+        for order in command.order_list.orders:
             if order.linked_order_ids:  # TODO(cs): Implement
                 self._log.warning(f"Cannot yet handle OCO conditional orders, {order}.")
             await self._submit_order(order)
 
     async def _submit_stop_market_order(self, order: StopMarketOrder) -> None:
         time_in_force = self._enum_parser.parse_internal_time_in_force(order.time_in_force)
 
@@ -712,60 +703,14 @@
         if not instrument_id:
             instrument_id = InstrumentId(Symbol(nautilus_symbol), BINANCE_VENUE)
             self._instrument_ids[nautilus_symbol] = instrument_id
         return instrument_id
 
     async def _modify_order(self, command: ModifyOrder) -> None:
         self._log.error("Cannot modify order: not supported by the venue.")
-        # TODO: Below is an experimental WIP (will potentially be removed)
-
-        # order = self._cache.order(command.client_order_id)
-        # if order is None:
-        #     self._log.error(
-        #         f"Cannot modify order: order not found for {repr(command.client_order_id)}",
-        #     )
-        #
-        # self._modifying_orders[order.client_order_id] = order.venue_order_id
-        #
-        # await self._cancel_order_single(
-        #     instrument_id=command.instrument_id,
-        #     client_order_id=command.client_order_id,
-        #     venue_order_id=command.venue_order_id,
-        # )
-        #
-        # try:
-        #     await self._submit_order_method[order.order_type](order)
-        # except BinanceError as e:
-        #     self.generate_order_rejected(
-        #         strategy_id=order.strategy_id,
-        #         instrument_id=order.instrument_id,
-        #         client_order_id=order.client_order_id,
-        #         reason=e.message,
-        #         ts_event=self._clock.timestamp_ns(),
-        #     )
-        #     return
-
-        # now = self._clock.timestamp_ns()
-        # updated = OrderUpdated(
-        #     trader_id=order.trader_id,
-        #     strategy_id=order.strategy_id,
-        #     instrument_id=order.instrument_id,
-        #     client_order_id=order.client_order_id,
-        #     venue_order_id=order.venue_order_id,
-        #     account_id=order.account_id,
-        #     quantity=command.quantity or order.quantity,
-        #     price=command.price,
-        #     trigger_price=command.trigger_price,
-        #     event_id=UUID4(),
-        #     ts_event=now,
-        #     ts_init=now,
-        # )
-        #
-        # order.apply(updated)
-        # self._cache.update_order(order)
 
     async def _cancel_order(self, command: CancelOrder) -> None:
         await self._cancel_order_single(
             instrument_id=command.instrument_id,
             client_order_id=command.client_order_id,
             venue_order_id=command.venue_order_id,
         )
@@ -811,15 +756,15 @@
         client_order_id: ClientOrderId,
         venue_order_id: Optional[VenueOrderId],
     ) -> None:
         try:
             if venue_order_id is not None:
                 await self._http_account.cancel_order(
                     symbol=instrument_id.symbol.value,
-                    order_id=venue_order_id.value,
+                    order_id=int(venue_order_id.value),
                 )
             else:
                 await self._http_account.cancel_order(
                     symbol=instrument_id.symbol.value,
                     orig_client_order_id=client_order_id.value,
                 )
         except BinanceError as e:
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/common/schemas/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/schemas/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/common/schemas/account.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/schemas/account.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/common/schemas/market.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/schemas/market.py`

 * *Files 10% similar despite different names*

```diff
@@ -23,21 +23,20 @@
 from nautilus_trader.adapters.binance.common.enums import BinanceKlineInterval
 from nautilus_trader.adapters.binance.common.enums import BinanceRateLimitInterval
 from nautilus_trader.adapters.binance.common.enums import BinanceRateLimitType
 from nautilus_trader.adapters.binance.common.enums import BinanceSymbolFilterType
 from nautilus_trader.adapters.binance.common.types import BinanceBar
 from nautilus_trader.adapters.binance.common.types import BinanceTicker
 from nautilus_trader.core.datetime import millis_to_nanos
-from nautilus_trader.model.data.bar import BarType
-from nautilus_trader.model.data.book import BookOrder
-from nautilus_trader.model.data.book import OrderBookDelta
-from nautilus_trader.model.data.book import OrderBookDeltas
-from nautilus_trader.model.data.book import OrderBookSnapshot
-from nautilus_trader.model.data.tick import QuoteTick
-from nautilus_trader.model.data.tick import TradeTick
+from nautilus_trader.model.data import BarType
+from nautilus_trader.model.data import BookOrder
+from nautilus_trader.model.data import OrderBookDelta
+from nautilus_trader.model.data import OrderBookDeltas
+from nautilus_trader.model.data import QuoteTick
+from nautilus_trader.model.data import TradeTick
 from nautilus_trader.model.enums import AggregationSource
 from nautilus_trader.model.enums import AggressorSide
 from nautilus_trader.model.enums import BookAction
 from nautilus_trader.model.enums import OrderSide
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.identifiers import TradeId
 from nautilus_trader.model.objects import Price
@@ -135,23 +134,37 @@
     E: Optional[int] = None  # FUTURES only, Message output time
     T: Optional[int] = None  # FUTURES only, Transaction time
 
     def parse_to_order_book_snapshot(
         self,
         instrument_id: InstrumentId,
         ts_init: int,
-    ) -> OrderBookSnapshot:
-        return OrderBookSnapshot(
-            instrument_id=instrument_id,
-            bids=[[float(o[0]), float(o[1])] for o in self.bids or []],
-            asks=[[float(o[0]), float(o[1])] for o in self.asks or []],
-            ts_event=ts_init,
-            ts_init=ts_init,
-            sequence=self.lastUpdateId or 0,
-        )
+    ) -> OrderBookDeltas:
+        bids = [
+            BookOrder(OrderSide.BUY, Price.from_str(o[0]), Quantity.from_str(o[1]), 0)
+            for o in self.bids or []
+        ]
+        asks = [
+            BookOrder(OrderSide.SELL, Price.from_str(o[0]), Quantity.from_str(o[1]), 0)
+            for o in self.asks or []
+        ]
+
+        deltas = [OrderBookDelta.clear(instrument_id, ts_init, ts_init, self.lastUpdateId)]
+        deltas += [
+            OrderBookDelta(
+                instrument_id,
+                BookAction.ADD,
+                o,
+                ts_init,
+                ts_init,
+                sequence=self.lastUpdateId or 0,
+            )
+            for o in bids + asks
+        ]
+        return OrderBookDeltas(instrument_id=instrument_id, deltas=deltas)
 
 
 class BinanceTrade(msgspec.Struct, frozen=True):
     """Schema of a single trade."""
 
     id: int
     price: str
@@ -321,30 +334,30 @@
         self,
         instrument_id: InstrumentId,
         side: OrderSide,
         ts_event: int,
         ts_init: int,
         update_id: int,
     ) -> OrderBookDelta:
-        price = float(self.price)
-        size = float(self.size)
-
+        size = Quantity.from_str(self.size)
         order = BookOrder(
-            price=price,
-            size=size,
             side=side,
+            price=Price.from_str(self.price),
+            size=Quantity.from_str(self.size),
+            order_id=0,
         )
 
         return OrderBookDelta(
             instrument_id=instrument_id,
-            action=BookAction.UPDATE if size > 0.0 else BookAction.DELETE,
+            action=BookAction.UPDATE if size > 0 else BookAction.DELETE,
             order=order,
             ts_event=ts_event,
             ts_init=ts_init,
             sequence=update_id,
+            flags=0,
         )
 
 
 class BinanceOrderBookData(msgspec.Struct, frozen=True):
     """WebSocket message 'inner struct' for `Binance` Partial & Diff. Book Depth Streams."""
 
     e: str  # Event type
@@ -353,60 +366,66 @@
     U: int  # First update ID in event
     u: int  # Final update ID in event
     b: list[BinanceOrderBookDelta]  # Bids to be updated
     a: list[BinanceOrderBookDelta]  # Asks to be updated
 
     T: Optional[int] = None  # FUTURES only, transaction time
     pu: Optional[int] = None  # FUTURES only, previous final update ID
-
     ps: Optional[str] = None  # COIN-M FUTURES only, pair
 
     def parse_to_order_book_deltas(
         self,
         instrument_id: InstrumentId,
         ts_init: int,
     ) -> OrderBookDeltas:
         ts_event: int = millis_to_nanos(self.T) if self.T is not None else millis_to_nanos(self.E)
 
         bid_deltas: list[OrderBookDelta] = [
-            delta.parse_to_order_book_delta(instrument_id, OrderSide.BUY, ts_event, ts_init, self.u)
+            delta.parse_to_order_book_delta(
+                instrument_id,
+                OrderSide.BUY,
+                ts_event,
+                ts_init,
+                self.u,
+            )
             for delta in self.b
         ]
         ask_deltas: list[OrderBookDelta] = [
             delta.parse_to_order_book_delta(
                 instrument_id,
                 OrderSide.SELL,
                 ts_event,
                 ts_init,
                 self.u,
             )
             for delta in self.a
         ]
 
-        return OrderBookDeltas(
-            instrument_id=instrument_id,
-            deltas=bid_deltas + ask_deltas,
-            ts_event=ts_event,
-            ts_init=ts_init,
-            sequence=self.u,
-        )
+        return OrderBookDeltas(instrument_id=instrument_id, deltas=bid_deltas + ask_deltas)
 
     def parse_to_order_book_snapshot(
         self,
         instrument_id: InstrumentId,
         ts_init: int,
-    ) -> OrderBookSnapshot:
-        return OrderBookSnapshot(
-            instrument_id=instrument_id,
-            bids=[[float(o.price), float(o.size)] for o in self.b],
-            asks=[[float(o.price), float(o.size)] for o in self.a],
-            ts_event=millis_to_nanos(self.T),
-            ts_init=ts_init,
-            sequence=self.u,
-        )
+    ) -> OrderBookDeltas:
+        ts_event: int = millis_to_nanos(self.T)
+        bids: list[BookOrder] = [
+            BookOrder(OrderSide.BUY, Price.from_str(o.price), Quantity.from_str(o.size), 0)
+            for o in self.b
+        ]
+        asks: list[BookOrder] = [
+            BookOrder(OrderSide.SELL, Price.from_str(o.price), Quantity.from_str(o.size), 0)
+            for o in self.a
+        ]
+
+        deltas = [OrderBookDelta.clear(instrument_id, ts_init, ts_event)]
+        deltas += [
+            OrderBookDelta(instrument_id, BookAction.ADD, o, ts_event, ts_init) for o in bids + asks
+        ]
+        return OrderBookDeltas(instrument_id=instrument_id, deltas=deltas)
 
 
 class BinanceOrderBookMsg(msgspec.Struct, frozen=True):
     """WebSocket message from `Binance` Partial & Diff. Book Depth Streams."""
 
     stream: str
     data: BinanceOrderBookData
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/common/schemas/symbol.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/schemas/symbol.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/common/schemas/user.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/schemas/user.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/common/types.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/common/types.py`

 * *Files 0% similar despite different names*

```diff
@@ -12,17 +12,17 @@
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from decimal import Decimal
 from typing import Any, Optional
 
-from nautilus_trader.model.data.bar import Bar
-from nautilus_trader.model.data.bar import BarType
-from nautilus_trader.model.data.ticker import Ticker
+from nautilus_trader.model.data import Bar
+from nautilus_trader.model.data import BarType
+from nautilus_trader.model.data import Ticker
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.objects import Price
 from nautilus_trader.model.objects import Quantity
 
 
 class BinanceBar(Bar):
     """
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/config.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/config.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/factories.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/factories.py`

 * *Files 3% similar despite different names*

```diff
@@ -37,15 +37,14 @@
 from nautilus_trader.msgbus.bus import MessageBus
 
 
 BINANCE_HTTP_CLIENTS: dict[str, BinanceHttpClient] = {}
 
 
 def get_cached_binance_http_client(
-    loop: asyncio.AbstractEventLoop,
     clock: LiveClock,
     logger: Logger,
     account_type: BinanceAccountType,
     key: Optional[str] = None,
     secret: Optional[str] = None,
     base_url: Optional[str] = None,
     is_testnet: bool = False,
@@ -55,16 +54,14 @@
     Cache and return a Binance HTTP client with the given key and secret.
 
     If a cached client with matching key and secret already exists, then that
     cached client will be returned.
 
     Parameters
     ----------
-    loop : asyncio.AbstractEventLoop
-        The event loop for the client.
     clock : LiveClock
         The clock for the client.
     logger : Logger
         The logger for the client.
     account_type : BinanceAccountType
         The account type for the client.
     key : str, optional
@@ -88,15 +85,14 @@
     key = key or _get_api_key(account_type, is_testnet)
     secret = secret or _get_api_secret(account_type, is_testnet)
     default_http_base_url = _get_http_base_url(account_type, is_testnet, is_us)
 
     client_key: str = "|".join((key, secret))
     if client_key not in BINANCE_HTTP_CLIENTS:
         client = BinanceHttpClient(
-            loop=loop,
             clock=clock,
             logger=logger,
             key=key,
             secret=secret,
             base_url=base_url or default_http_base_url,
         )
         BINANCE_HTTP_CLIENTS[client_key] = client
@@ -226,15 +222,14 @@
         ------
         ValueError
             If `config.account_type` is not a valid `BinanceAccountType`.
 
         """
         # Get HTTP client singleton
         client: BinanceHttpClient = get_cached_binance_http_client(
-            loop=loop,
             clock=clock,
             logger=logger,
             account_type=config.account_type,
             key=config.api_key,
             secret=config.api_secret,
             base_url=config.base_url_http,
             is_testnet=config.testnet,
@@ -339,15 +334,14 @@
         ------
         ValueError
             If `config.account_type` is not a valid `BinanceAccountType`.
 
         """
         # Get HTTP client singleton
         client: BinanceHttpClient = get_cached_binance_http_client(
-            loop=loop,
             clock=clock,
             logger=logger,
             account_type=config.account_type,
             key=config.api_key,
             secret=config.api_secret,
             base_url=config.base_url_http,
             is_testnet=config.testnet,
@@ -376,16 +370,16 @@
                 loop=loop,
                 client=client,
                 msgbus=msgbus,
                 cache=cache,
                 clock=clock,
                 logger=logger,
                 instrument_provider=provider,
-                account_type=config.account_type,
                 base_url_ws=config.base_url_ws or default_base_url_ws,
+                account_type=config.account_type,
                 warn_gtd_to_gtc=config.warn_gtd_to_gtc,
             )
         else:
             # Get instrument provider singleton
             provider = get_cached_binance_futures_instrument_provider(
                 client=client,
                 logger=logger,
@@ -399,16 +393,16 @@
                 loop=loop,
                 client=client,
                 msgbus=msgbus,
                 cache=cache,
                 clock=clock,
                 logger=logger,
                 instrument_provider=provider,
-                account_type=config.account_type,
                 base_url_ws=config.base_url_ws or default_base_url_ws,
+                account_type=config.account_type,
                 warn_gtd_to_gtc=config.warn_gtd_to_gtc,
             )
 
 
 def _get_api_key(account_type: BinanceAccountType, is_testnet: bool) -> str:
     if is_testnet:
         if account_type.is_spot_or_margin:
@@ -436,58 +430,58 @@
 
 
 def _get_http_base_url(account_type: BinanceAccountType, is_testnet: bool, is_us: bool) -> str:
     # Testnet base URLs
     if is_testnet:
         if account_type.is_spot_or_margin:
             return "https://testnet.binance.vision"
-        elif account_type == BinanceAccountType.FUTURES_USDT:
+        elif account_type == BinanceAccountType.USDT_FUTURE:
             return "https://testnet.binancefuture.com"
-        elif account_type == BinanceAccountType.FUTURES_COIN:
+        elif account_type == BinanceAccountType.COIN_FUTURE:
             return "https://testnet.binancefuture.com"
         else:
             raise RuntimeError(  # pragma: no cover (design-time error)
                 f"invalid `BinanceAccountType`, was {account_type}",  # pragma: no cover
             )
 
     # Live base URLs
     top_level_domain: str = "us" if is_us else "com"
     if account_type.is_spot:
         return f"https://api.binance.{top_level_domain}"
     elif account_type.is_margin:
         return f"https://sapi.binance.{top_level_domain}"
-    elif account_type == BinanceAccountType.FUTURES_USDT:
+    elif account_type == BinanceAccountType.USDT_FUTURE:
         return f"https://fapi.binance.{top_level_domain}"
-    elif account_type == BinanceAccountType.FUTURES_COIN:
+    elif account_type == BinanceAccountType.COIN_FUTURE:
         return f"https://dapi.binance.{top_level_domain}"
     else:
         raise RuntimeError(  # pragma: no cover (design-time error)
             f"invalid `BinanceAccountType`, was {account_type}",  # pragma: no cover
         )
 
 
 def _get_ws_base_url(account_type: BinanceAccountType, is_testnet: bool, is_us: bool) -> str:
     # Testnet base URLs
     if is_testnet:
         if account_type.is_spot_or_margin:
             return "wss://testnet.binance.vision"
-        elif account_type == BinanceAccountType.FUTURES_USDT:
+        elif account_type == BinanceAccountType.USDT_FUTURE:
             return "wss://stream.binancefuture.com"
-        elif account_type == BinanceAccountType.FUTURES_COIN:
+        elif account_type == BinanceAccountType.COIN_FUTURE:
             raise ValueError("no testnet for COIN-M futures")
         else:
             raise RuntimeError(  # pragma: no cover (design-time error)
                 f"invalid `BinanceAccountType`, was {account_type}",  # pragma: no cover
             )
 
     # Live base URLs
     top_level_domain: str = "us" if is_us else "com"
     if account_type.is_spot_or_margin:
         return f"wss://stream.binance.{top_level_domain}:9443"
-    elif account_type == BinanceAccountType.FUTURES_USDT:
+    elif account_type == BinanceAccountType.USDT_FUTURE:
         return f"wss://fstream.binance.{top_level_domain}"
-    elif account_type == BinanceAccountType.FUTURES_COIN:
+    elif account_type == BinanceAccountType.COIN_FUTURE:
         return f"wss://dstream.binance.{top_level_domain}"
     else:
         raise RuntimeError(
             f"invalid `BinanceAccountType`, was {account_type}",
         )  # pragma: no cover (design-time error)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/data.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/data.py`

 * *Files 1% similar despite different names*

```diff
@@ -27,20 +27,19 @@
 from nautilus_trader.adapters.binance.futures.types import BinanceFuturesMarkPriceUpdate
 from nautilus_trader.adapters.binance.http.client import BinanceHttpClient
 from nautilus_trader.cache.cache import Cache
 from nautilus_trader.common.clock import LiveClock
 from nautilus_trader.common.logging import Logger
 from nautilus_trader.common.providers import InstrumentProvider
 from nautilus_trader.core.correctness import PyCondition
-from nautilus_trader.model.data.base import DataType
-from nautilus_trader.model.data.base import GenericData
-from nautilus_trader.model.data.book import OrderBookDelta
-from nautilus_trader.model.data.book import OrderBookDeltas
-from nautilus_trader.model.data.book import OrderBookSnapshot
-from nautilus_trader.model.data.tick import TradeTick
+from nautilus_trader.model.data import DataType
+from nautilus_trader.model.data import GenericData
+from nautilus_trader.model.data import OrderBookDelta
+from nautilus_trader.model.data import OrderBookDeltas
+from nautilus_trader.model.data import TradeTick
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.msgbus.bus import MessageBus
 
 
 class BinanceFuturesDataClient(BinanceCommonDataClient):
     """
     Provides a data client for the `Binance Futures` exchange.
@@ -57,39 +56,39 @@
         The cache for the client.
     clock : LiveClock
         The clock for the client.
     logger : Logger
         The logger for the client.
     instrument_provider : InstrumentProvider
         The instrument provider.
+    base_url_ws : str
+        The base URL for the WebSocket client.
     account_type : BinanceAccountType
         The account type for the client.
-    base_url_ws : str, optional
-        The base URL for the WebSocket client.
     use_agg_trade_ticks : bool, default False
         Whether to use aggregated trade tick endpoints instead of raw trade ticks.
         TradeId of ticks will be the Aggregate tradeId returned by Binance.
     """
 
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
         client: BinanceHttpClient,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
         logger: Logger,
         instrument_provider: InstrumentProvider,
-        account_type: BinanceAccountType = BinanceAccountType.FUTURES_USDT,
-        base_url_ws: Optional[str] = None,
+        base_url_ws: str,
+        account_type: BinanceAccountType = BinanceAccountType.USDT_FUTURE,
         use_agg_trade_ticks: bool = False,
     ):
         PyCondition.true(
             account_type.is_futures,
-            "account_type was not FUTURES_USDT or FUTURES_COIN",
+            "account_type was not USDT_FUTURE or COIN_FUTURE",
         )
 
         # Futures HTTP API
         self._futures_http_market = BinanceFuturesMarketHttpAPI(client, account_type)
 
         # Futures enum parser
         self._futures_enum_parser = BinanceFuturesEnumParser()
@@ -160,22 +159,22 @@
             )
 
     # -- WEBSOCKET HANDLERS ---------------------------------------------------------------------------------
 
     def _handle_book_partial_update(self, raw: bytes) -> None:
         msg = self._decoder_order_book_msg.decode(raw)
         instrument_id: InstrumentId = self._get_cached_instrument_id(msg.data.s)
-        book_snapshot: OrderBookSnapshot = msg.data.parse_to_order_book_snapshot(
+        book_snapshot: OrderBookDeltas = msg.data.parse_to_order_book_snapshot(
             instrument_id=instrument_id,
             ts_init=self._clock.timestamp_ns(),
         )
         # Check if book buffer active
-        book_buffer: Optional[
-            list[Union[OrderBookDelta, OrderBookDeltas, OrderBookSnapshot]]
-        ] = self._book_buffer.get(instrument_id)
+        book_buffer: Optional[list[Union[OrderBookDelta, OrderBookDeltas]]] = self._book_buffer.get(
+            instrument_id,
+        )
         if book_buffer is not None:
             book_buffer.append(book_snapshot)
         else:
             self._handle_data(book_snapshot)
 
     def _handle_trade(self, raw: bytes) -> None:
         # NOTE @trade is an undocumented endpoint for Futures exchanges
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/enums.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/enums.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/execution.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/execution.py`

 * *Files 1% similar despite different names*

```diff
@@ -66,38 +66,38 @@
         The cache for the client.
     clock : LiveClock
         The clock for the client.
     logger : Logger
         The logger for the client.
     instrument_provider : BinanceFuturesInstrumentProvider
         The instrument provider.
+    base_url_ws : str
+        The base URL for the WebSocket client.
     account_type : BinanceAccountType
         The account type for the client.
-    base_url_ws : str, optional
-        The base URL for the WebSocket client.
     warn_gtd_to_gtc : bool, default True
         If log warning for GTD time in force transformed to GTC.
     """
 
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
         client: BinanceHttpClient,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
         logger: Logger,
         instrument_provider: BinanceFuturesInstrumentProvider,
-        account_type: BinanceAccountType = BinanceAccountType.FUTURES_USDT,
-        base_url_ws: Optional[str] = None,
+        base_url_ws: str,
+        account_type: BinanceAccountType = BinanceAccountType.USDT_FUTURE,
         warn_gtd_to_gtc: bool = True,
     ):
         PyCondition.true(
             account_type.is_futures,
-            "account_type was not FUTURES_USDT or FUTURES_COIN",
+            "account_type was not USDT_FUTURE or COIN_FUTURE",
         )
 
         # Futures HTTP API
         self._futures_http_account = BinanceFuturesAccountHttpAPI(client, clock, account_type)
         self._futures_http_market = BinanceFuturesMarketHttpAPI(client, account_type)
         self._futures_http_user = BinanceFuturesUserDataHttpAPI(client, account_type)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/http/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/http/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/http/account.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/http/account.py`

 * *Files 2% similar despite different names*

```diff
@@ -278,27 +278,27 @@
         The Binance account type.
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         clock: LiveClock,
-        account_type: BinanceAccountType = BinanceAccountType.FUTURES_USDT,
+        account_type: BinanceAccountType = BinanceAccountType.USDT_FUTURE,
     ):
         super().__init__(
             client=client,
             clock=clock,
             account_type=account_type,
         )
         if not account_type.is_futures:
             raise RuntimeError(  # pragma: no cover (design-time error)
-                f"`BinanceAccountType` not FUTURES_USDT or FUTURES_COIN, was {account_type}",  # pragma: no cover
+                f"`BinanceAccountType` not USDT_FUTURE or COIN_FUTURE, was {account_type}",  # pragma: no cover
             )
         v2_endpoint_base = self.base_endpoint
-        if account_type == BinanceAccountType.FUTURES_USDT:
+        if account_type == BinanceAccountType.USDT_FUTURE:
             v2_endpoint_base = "/fapi/v2/"
 
         # Create endpoints
         self._endpoint_futures_position_mode = BinanceFuturesPositionModeHttp(
             client,
             self.base_endpoint,
         )
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/http/market.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/http/market.py`

 * *Files 2% similar despite different names*

```diff
@@ -70,24 +70,24 @@
     account_type : BinanceAccountType
         The Binance account type, used to select the endpoint.
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
-        account_type: BinanceAccountType = BinanceAccountType.FUTURES_USDT,
+        account_type: BinanceAccountType = BinanceAccountType.USDT_FUTURE,
     ):
         super().__init__(
             client=client,
             account_type=account_type,
         )
 
         if not account_type.is_futures:
             raise RuntimeError(  # pragma: no cover (design-time error)
-                f"`BinanceAccountType` not FUTURES_USDT or FUTURES_COIN, was {account_type}",  # pragma: no cover
+                f"`BinanceAccountType` not USDT_FUTURE or COIN_FUTURE, was {account_type}",  # pragma: no cover
             )
 
         self._endpoint_futures_exchange_info = BinanceFuturesExchangeInfoHttp(
             client,
             self.base_endpoint,
         )
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/http/user.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/http/user.py`

 * *Files 5% similar despite different names*

```diff
@@ -30,18 +30,18 @@
     account_type : BinanceAccountType
         The Binance account type, used to select the endpoint.
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
-        account_type: BinanceAccountType = BinanceAccountType.FUTURES_USDT,
+        account_type: BinanceAccountType = BinanceAccountType.USDT_FUTURE,
     ):
         super().__init__(
             client=client,
             account_type=account_type,
         )
 
         if not account_type.is_futures:
             raise RuntimeError(  # pragma: no cover (design-time error)
-                f"`BinanceAccountType` not FUTURES_USDT or FUTURES_COIN, was {account_type}",  # pragma: no cover (design-time error)
+                f"`BinanceAccountType` not USDT_FUTURE or COIN_FUTURE, was {account_type}",  # pragma: no cover (design-time error)
             )
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/http/wallet.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/http/wallet.py`

 * *Files 6% similar despite different names*

```diff
@@ -89,27 +89,27 @@
         The Binance REST API client.
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         clock: LiveClock,
-        account_type: BinanceAccountType = BinanceAccountType.FUTURES_USDT,
+        account_type: BinanceAccountType = BinanceAccountType.USDT_FUTURE,
     ):
         self.client = client
         self._clock = clock
 
-        if account_type == BinanceAccountType.FUTURES_USDT:
+        if account_type == BinanceAccountType.USDT_FUTURE:
             self.base_endpoint = "/fapi/v1/"
-        elif account_type == BinanceAccountType.FUTURES_COIN:
+        elif account_type == BinanceAccountType.COIN_FUTURE:
             self.base_endpoint = "/dapi/v1/"
 
         if not account_type.is_futures:
             raise RuntimeError(  # pragma: no cover (design-time error)
-                f"`BinanceAccountType` not FUTURES_USDT or FUTURES_COIN, was {account_type}",  # pragma: no cover
+                f"`BinanceAccountType` not USDT_FUTURE or COIN_FUTURE, was {account_type}",  # pragma: no cover
             )
 
         self._endpoint_futures_commission_rate = BinanceFuturesCommissionRateHttp(
             client,
             self.base_endpoint,
         )
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/providers.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/providers.py`

 * *Files 2% similar despite different names*

```diff
@@ -66,15 +66,15 @@
     """
 
     def __init__(
         self,
         client: BinanceHttpClient,
         logger: Logger,
         clock: LiveClock,
-        account_type: BinanceAccountType = BinanceAccountType.FUTURES_USDT,
+        account_type: BinanceAccountType = BinanceAccountType.USDT_FUTURE,
         config: Optional[InstrumentProviderConfig] = None,
     ):
         super().__init__(
             venue=BINANCE_VENUE,
             logger=logger,
             config=config,
         )
@@ -293,16 +293,16 @@
                     size_increment=size_increment,
                     max_quantity=max_quantity,
                     min_quantity=min_quantity,
                     max_notional=None,
                     min_notional=min_notional,
                     max_price=max_price,
                     min_price=min_price,
-                    margin_init=Decimal(float(symbol_info.requiredMarginPercent) / 100),
-                    margin_maint=Decimal(float(symbol_info.maintMarginPercent) / 100),
+                    margin_init=Decimal(symbol_info.requiredMarginPercent) / 100,
+                    margin_maint=Decimal(symbol_info.maintMarginPercent) / 100,
                     maker_fee=maker_fee,
                     taker_fee=taker_fee,
                     ts_event=ts_event,
                     ts_init=ts_init,
                     info=self._decoder.decode(self._encoder.encode(symbol_info)),
                 )
                 self.add_currency(currency=instrument.base_currency)
@@ -325,16 +325,16 @@
                     size_increment=size_increment,
                     max_quantity=max_quantity,
                     min_quantity=min_quantity,
                     max_notional=None,
                     min_notional=min_notional,
                     max_price=max_price,
                     min_price=min_price,
-                    margin_init=Decimal(float(symbol_info.requiredMarginPercent) / 100),
-                    margin_maint=Decimal(float(symbol_info.maintMarginPercent) / 100),
+                    margin_init=Decimal(symbol_info.requiredMarginPercent) / 100,
+                    margin_maint=Decimal(symbol_info.maintMarginPercent) / 100,
                     maker_fee=maker_fee,
                     taker_fee=taker_fee,
                     ts_event=ts_event,
                     ts_init=ts_init,
                     info=self._decoder.decode(self._encoder.encode(symbol_info)),
                 )
                 self.add_currency(currency=instrument.underlying)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/schemas/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/schemas/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/schemas/account.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/schemas/account.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/schemas/market.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/schemas/market.py`

 * *Files 1% similar despite different names*

```diff
@@ -23,15 +23,15 @@
 from nautilus_trader.adapters.binance.common.schemas.market import BinanceExchangeFilter
 from nautilus_trader.adapters.binance.common.schemas.market import BinanceRateLimit
 from nautilus_trader.adapters.binance.common.schemas.market import BinanceSymbolFilter
 from nautilus_trader.adapters.binance.futures.enums import BinanceFuturesContractStatus
 from nautilus_trader.adapters.binance.futures.types import BinanceFuturesMarkPriceUpdate
 from nautilus_trader.core.datetime import millis_to_nanos
 from nautilus_trader.model.currency import Currency
-from nautilus_trader.model.data.tick import TradeTick
+from nautilus_trader.model.data import TradeTick
 from nautilus_trader.model.enums import AggressorSide
 from nautilus_trader.model.enums import CurrencyType
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.identifiers import TradeId
 from nautilus_trader.model.objects import Price
 from nautilus_trader.model.objects import Quantity
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/schemas/user.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/schemas/user.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/schemas/wallet.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/schemas/wallet.py`

 * *Files 15% similar despite different names*

```diff
@@ -17,13 +17,13 @@
 
 
 ################################################################################
 # HTTP responses
 ################################################################################
 
 
-class BinanceFuturesCommissionRate(msgspec.Struct, frozen=True):
-    """Schema of a single `Binance Futures` commissionRate."""
+class BinanceSpotTradeFee(msgspec.Struct, frozen=True):
+    """Schema of a single `Binance Spot/Margin` tradeFee."""
 
     symbol: str
-    makerCommissionRate: str
-    takerCommissionRate: str
+    makerCommission: str
+    takerCommission: str
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/futures/types.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/futures/types.py`

 * *Files 4% similar despite different names*

```diff
@@ -57,36 +57,60 @@
         index: Price,
         estimated_settle: Price,
         funding_rate: Decimal,
         ts_next_funding: int,
         ts_event: int,
         ts_init: int,
     ):
-        super().__init__(ts_event=ts_event, ts_init=ts_init)
-
         self.instrument_id = instrument_id
         self.mark = mark
         self.index = index
         self.estimated_settle = estimated_settle
         self.funding_rate = funding_rate
         self.ts_next_funding = ts_next_funding
+        self._ts_event = ts_event
+        self._ts_init = ts_init
 
     def __repr__(self) -> str:
         return (
             f"{type(self).__name__}("
             f"instrument_id={self.instrument_id}, "
             f"mark={self.mark}, "
             f"index={self.index}, "
             f"estimated_settle={self.estimated_settle}, "
             f"funding_rate={self.funding_rate}, "
             f"ts_next_funding={self.ts_next_funding}, "
             f"ts_event={self.ts_event}, "
             f"ts_init={self.ts_init})"
         )
 
+    @property
+    def ts_event(self) -> int:
+        """
+        The UNIX timestamp (nanoseconds) when the data event occurred.
+
+        Returns
+        -------
+        int
+
+        """
+        return self._ts_event
+
+    @property
+    def ts_init(self) -> int:
+        """
+        The UNIX timestamp (nanoseconds) when the object was initialized.
+
+        Returns
+        -------
+        int
+
+        """
+        return self._ts_init
+
     @staticmethod
     def from_dict(values: dict[str, Any]) -> "BinanceFuturesMarkPriceUpdate":
         """
         Return a `Binance Futures` mark price update parsed from the given values.
 
         Parameters
         ----------
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/http/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/http/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/http/account.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/http/account.py`

 * *Files 2% similar despite different names*

```diff
@@ -84,29 +84,29 @@
 
         Parameters
         ----------
         symbol : BinanceSymbol
             The symbol of the order
         timestamp : str
             The millisecond timestamp of the request
-        orderId : str, optional
+        orderId : int, optional
             the order identifier
         origClientOrderId : str, optional
             the client specified order identifier
         recvWindow : str, optional
             the millisecond timeout window.
 
         Warnings
         --------
         Either orderId or origClientOrderId must be sent.
         """
 
         symbol: BinanceSymbol
         timestamp: str
-        orderId: Optional[str] = None
+        orderId: Optional[int] = None
         origClientOrderId: Optional[str] = None
         recvWindow: Optional[str] = None
 
     class PostParameters(msgspec.Struct, omit_defaults=True, frozen=True):
         """
         Order creation POST endpoint parameters.
 
@@ -266,33 +266,33 @@
 
         Parameters
         ----------
         symbol : BinanceSymbol
             The symbol of the orders
         timestamp : str
             The millisecond timestamp of the request
-        orderId : str, optional
+        orderId : int, optional
             The order ID for the request.
             If included, request will return orders from this orderId INCLUSIVE
-        startTime : str, optional
+        startTime : int, optional
             The start time (UNIX milliseconds) filter for the request.
-        endTime : str, optional
+        endTime : int, optional
             The end time (UNIX milliseconds) filter for the request.
         limit : int, optional
             The limit for the response.
             Default 500, max 1000
         recvWindow : str, optional
             The response receive window for the request (cannot be greater than 60000).
         """
 
         symbol: BinanceSymbol
         timestamp: str
-        orderId: Optional[str] = None
-        startTime: Optional[str] = None
-        endTime: Optional[str] = None
+        orderId: Optional[int] = None
+        startTime: Optional[int] = None
+        endTime: Optional[int] = None
         limit: Optional[int] = None
         recvWindow: Optional[str] = None
 
     async def _get(self, parameters: GetParameters) -> list[BinanceOrder]:
         method_type = BinanceMethodType.GET
         raw = await self._method(method_type, parameters)
         return self._get_resp_decoder.decode(raw)
@@ -396,36 +396,36 @@
 
         Parameters
         ----------
         symbol : BinanceSymbol
             The symbol of the orders
         timestamp : str
             The millisecond timestamp of the request
-        orderId : str, optional
+        orderId : int, optional
             The order ID for the request.
             If included, request will return orders from this orderId INCLUSIVE
-        startTime : str, optional
+        startTime : int, optional
             The start time (UNIX milliseconds) filter for the request.
-        endTime : str, optional
+        endTime : int, optional
             The end time (UNIX milliseconds) filter for the request.
-        fromId : str, optional
+        fromId : int, optional
             TradeId to fetch from. Default gets most recent trades.
         limit : int, optional
             The limit for the response.
             Default 500, max 1000
         recvWindow : str, optional
             The response receive window for the request (cannot be greater than 60000).
         """
 
         symbol: BinanceSymbol
         timestamp: str
-        orderId: Optional[str] = None
-        startTime: Optional[str] = None
-        endTime: Optional[str] = None
-        fromId: Optional[str] = None
+        orderId: Optional[int] = None
+        startTime: Optional[int] = None
+        endTime: Optional[int] = None
+        fromId: Optional[int] = None
         limit: Optional[int] = None
         recvWindow: Optional[str] = None
 
     async def _get(self, parameters: GetParameters) -> list[BinanceUserTrade]:
         method_type = BinanceMethodType.GET
         raw = await self._method(method_type, parameters)
         return self._get_resp_decoder.decode(raw)
@@ -456,18 +456,18 @@
         PyCondition.not_none(client, "client")
         self.client = client
         self._clock = clock
 
         if account_type.is_spot_or_margin:
             self.base_endpoint = "/api/v3/"
             user_trades_url = self.base_endpoint + "myTrades"
-        elif account_type == BinanceAccountType.FUTURES_USDT:
+        elif account_type == BinanceAccountType.USDT_FUTURE:
             self.base_endpoint = "/fapi/v1/"
             user_trades_url = self.base_endpoint + "userTrades"
-        elif account_type == BinanceAccountType.FUTURES_COIN:
+        elif account_type == BinanceAccountType.COIN_FUTURE:
             self.base_endpoint = "/dapi/v1/"
             user_trades_url = self.base_endpoint + "userTrades"
         else:
             raise RuntimeError(  # pragma: no cover (design-time error)
                 f"invalid `BinanceAccountType`, was {account_type}",  # pragma: no cover
             )
 
@@ -480,15 +480,15 @@
     def _timestamp(self) -> str:
         """Create Binance timestamp from internal clock."""
         return str(self._clock.timestamp_ms())
 
     async def query_order(
         self,
         symbol: str,
-        order_id: Optional[str] = None,
+        order_id: Optional[int] = None,
         orig_client_order_id: Optional[str] = None,
         recv_window: Optional[str] = None,
     ) -> BinanceOrder:
         """Check an order status."""
         if order_id is None and orig_client_order_id is None:
             raise RuntimeError(
                 "Either orderId or origClientOrderId must be sent.",
@@ -511,15 +511,15 @@
     ) -> bool:
         # Implement in child class
         raise NotImplementedError
 
     async def cancel_order(
         self,
         symbol: str,
-        order_id: Optional[str] = None,
+        order_id: Optional[int] = None,
         orig_client_order_id: Optional[str] = None,
         recv_window: Optional[str] = None,
     ) -> BinanceOrder:
         """Cancel an active order."""
         if order_id is None and orig_client_order_id is None:
             raise RuntimeError(
                 "Either orderId or origClientOrderId must be sent.",
@@ -587,17 +587,17 @@
             ),
         )
         return binance_order
 
     async def query_all_orders(
         self,
         symbol: str,
-        order_id: Optional[str] = None,
-        start_time: Optional[str] = None,
-        end_time: Optional[str] = None,
+        order_id: Optional[int] = None,
+        start_time: Optional[int] = None,
+        end_time: Optional[int] = None,
         limit: Optional[int] = None,
         recv_window: Optional[str] = None,
     ) -> list[BinanceOrder]:
         """Query all orders, active or filled."""
         return await self._endpoint_all_orders._get(
             parameters=self._endpoint_all_orders.GetParameters(
                 symbol=BinanceSymbol(symbol),
@@ -623,18 +623,18 @@
                 recvWindow=recv_window,
             ),
         )
 
     async def query_user_trades(
         self,
         symbol: str,
-        order_id: Optional[str] = None,
-        start_time: Optional[str] = None,
-        end_time: Optional[str] = None,
-        from_id: Optional[str] = None,
+        order_id: Optional[int] = None,
+        start_time: Optional[int] = None,
+        end_time: Optional[int] = None,
+        from_id: Optional[int] = None,
         limit: Optional[int] = None,
         recv_window: Optional[str] = None,
     ) -> list[BinanceUserTrade]:
         """Query user's trade history for a symbol, with provided filters."""
         if (order_id or from_id) is not None and (start_time or end_time) is not None:
             raise RuntimeError(
                 "Cannot specify both order_id/from_id AND start_time/end_time parameters.",
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/http/client.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/deribit/http/client.py`

 * *Files 24% similar despite different names*

```diff
@@ -12,182 +12,169 @@
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 import asyncio
 import hashlib
 import hmac
+import json
+import urllib.parse
 from typing import Any, Optional
 
-import aiohttp
 import msgspec
+from aiohttp import ClientResponse
+from aiohttp import ClientResponseError
 
-import nautilus_trader
-from nautilus_trader.adapters.binance.http.error import BinanceClientError
-from nautilus_trader.adapters.binance.http.error import BinanceServerError
+from nautilus_trader.adapters.deribit.http.error import DeribitClientError
+from nautilus_trader.adapters.deribit.http.error import DeribitServerError
 from nautilus_trader.common.clock import LiveClock
 from nautilus_trader.common.logging import Logger
 from nautilus_trader.network.http import HttpClient
 
 
-class BinanceHttpClient(HttpClient):
+class DeribitHttpClient(HttpClient):
     """
-    Provides a `Binance` asynchronous HTTP client.
+    Provides a `Deribit` asynchronous HTTP client.
     """
 
-    BASE_URL = "https://api.binance.com"  # Default Spot/Margin
+    BASE_URL = "https://www.deribit.com"
 
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
         clock: LiveClock,
         logger: Logger,
         key: str,
         secret: str,
         base_url: Optional[str] = None,
-        timeout: Optional[int] = None,
-        show_limit_usage: bool = False,
     ):
         super().__init__(
             loop=loop,
             logger=logger,
         )
         self._clock = clock
         self._key = key
         self._secret = secret
         self._base_url = base_url or self.BASE_URL
-        self._show_limit_usage = show_limit_usage
-        self._proxies = None
-        self._headers: dict[str, Any] = {
-            "Content-Type": "application/json;charset=utf-8",
-            "User-Agent": "nautilus-trader/" + nautilus_trader.__version__,
-            "X-MBX-APIKEY": key,
-        }
-
-        if timeout is not None:
-            self._headers["timeout"] = timeout
-
-        # TODO(cs): Implement limit usage
+        self._nonce = 0
 
     @property
     def base_url(self) -> str:
         return self._base_url
 
     @property
     def api_key(self) -> str:
         return self._key
 
     @property
     def api_secret(self) -> str:
         return self._secret
 
-    @property
-    def headers(self):
-        return self._headers
-
-    async def query(self, url_path, payload: Optional[dict[str, str]] = None) -> Any:
-        return await self.send_request("GET", url_path, payload=payload)
+    @staticmethod
+    def _prepare_payload(payload: dict[str, str]) -> Optional[str]:
+        return json.dumps(payload, separators=(",", ":")) if payload else None
+
+    @staticmethod
+    def _url_encode(params: dict[str, str]) -> str:
+        return "?" + urllib.parse.urlencode(params) if params else ""
 
-    async def limit_request(
+    def _generate_authorization(
         self,
-        http_method: str,
-        url_path: str,
-        payload: Optional[dict[str, Any]] = None,
-    ) -> Any:
-        """
-        Limit request is for those endpoints requiring an API key in the header.
-        """
-        return await self.send_request(http_method, url_path, payload=payload)
+        action,
+        uri,
+        payload,
+    ):
+        # https://docs.deribit.com/#authentication
 
-    async def sign_request(
-        self,
-        http_method: str,
-        url_path: str,
-        payload: Optional[dict[str, str]] = None,
-    ) -> Any:
-        if payload is None:
-            payload = {}
-        query_string = self._prepare_params(payload)
-        signature = self._get_sign(query_string)
-        payload["signature"] = signature
-        return await self.send_request(http_method, url_path, payload)
+        tstamp = self._clock.timestamp_ms()
+
+        nonce = self._nonce
+        self._nonce += 1
 
-    async def limited_encoded_sign_request(
+        body = '{"jsonrpc": "2.0","id": "5647","method": "private/list_api_keys"}'
+
+        request_data = action + "\n" + uri + "\n" + body + "\n"
+        base_signature_string = tstamp + "\n" + nonce + "\n" + request_data
+        byte_key = self._secret.encode()
+        message = base_signature_string.encode()
+        sig = hmac.new(byte_key, message, hashlib.sha256).hexdigest()
+
+        authorization = (
+            "deri-hmac-sha256 id=" + self._key + ",ts=" + tstamp + ",sig=" + sig + ",nonce=" + nonce
+        )
+
+        return authorization
+
+    async def _sign_request(
         self,
         http_method: str,
         url_path: str,
-        payload: Optional[dict[str, str]] = None,
+        payload: dict[str, str] = None,
+        params: dict[str, Any] = None,
     ) -> Any:
-        """
-        Limit encoded sign request.
+        auth = self._generate_authorization(
+            http_method,
+            url_path,
+            payload,
+        )
+        headers = {"Authorization": auth}
 
-        This is used for some endpoints has special symbol in the url.
-        In some endpoints these symbols should not encoded.
-        - @
-        - [
-        - ]
-        so we have to append those parameters in the url.
-        """
-        if payload is None:
-            payload = {}
-        query_string = self._prepare_params(payload)
-        signature = self._get_sign(query_string)
-        url_path = url_path + "?" + query_string + "&signature=" + signature
-        return await self.send_request(http_method, url_path)
+        return await self._send_request(
+            http_method=http_method,
+            url_path=url_path,
+            headers=headers,
+            payload=payload,
+            params=params,
+        )
 
-    async def send_request(
+    async def _send_request(
         self,
         http_method: str,
         url_path: str,
-        payload: Optional[dict[str, str]] = None,
+        headers: dict[str, Any] = None,
+        payload: dict[str, str] = None,
+        params: dict[str, str] = None,
     ) -> Any:
-        # TODO(cs): Uncomment for development
-        # print(f"{http_method} {url_path} {payload}")
         if payload is None:
             payload = {}
+        # TODO(cs): Uncomment for development
+        print(f"{http_method} {url_path} {headers} {payload}")
+        query = self._url_encode(params)
         try:
-            resp: aiohttp.ClientResponse = await self.request(
+            resp: ClientResponse = await self.request(
                 method=http_method,
-                url=self._base_url + url_path,
-                headers=self._headers,
-                params=payload,
+                url=self._base_url + url_path + query,
+                headers=headers,
+                data=self._prepare_payload(payload),
             )
-        except aiohttp.ServerDisconnectedError:
-            self._log.error("Server was disconnected.")
-            return b""
-        except aiohttp.ClientResponseError as e:
+        except ClientResponseError as e:
             await self._handle_exception(e)
             return
 
-        if self._show_limit_usage:
-            limit_usage = {}
-            for key in resp.headers:
-                key = key.lower()
-                if key.startswith(("x-mbx-used-weight", "x-mbx-order-count", "x-sapi-used")):
-                    limit_usage[key] = resp.headers[key]
-
         try:
-            return resp.data
+            data = msgspec.json.decode(resp.data)
+            if not data["success"]:
+                return data["error"]
+            return data["result"]
         except msgspec.MsgspecError:
-            self._log.error(f"Could not decode data to JSON: {resp.data}.")
+            self._log.error(
+                f"Could not decode data to JSON: {resp.data}.",
+            )
 
-    def _get_sign(self, data) -> str:
-        m = hmac.new(self._secret.encode(), data.encode(), hashlib.sha256)
-        return m.hexdigest()
-
-    async def _handle_exception(self, error: aiohttp.ClientResponseError) -> None:
-        has_json = hasattr(error, "json")
-        message = f"{error.message}, code={error.json['code'] if has_json else None}, msg='{error.json['msg'] if has_json else None}'"
+    async def _handle_exception(self, error: ClientResponseError) -> None:
         if error.status < 400:
             return
         elif 400 <= error.status < 500:
-            raise BinanceClientError(
+            raise DeribitClientError(
                 status=error.status,
-                message=message,
+                message=error.message,
                 headers=error.headers,
             )
         else:
-            raise BinanceServerError(
+            raise DeribitServerError(
                 status=error.status,
-                message=message,
+                message=error.message,
                 headers=error.headers,
             )
+
+    async def access_log(self):
+        return await self._sign_request("GET", "/api/v2/private/get_access_log", {})
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/http/endpoint.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/http/endpoint.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/http/error.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/http/error.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/http/market.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/http/market.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,14 +9,15 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+import sys
 from typing import Optional
 
 import msgspec
 
 from nautilus_trader.adapters.binance.common.enums import BinanceAccountType
 from nautilus_trader.adapters.binance.common.enums import BinanceKlineInterval
 from nautilus_trader.adapters.binance.common.enums import BinanceMethodType
@@ -31,17 +32,17 @@
 from nautilus_trader.adapters.binance.common.schemas.market import BinanceTrade
 from nautilus_trader.adapters.binance.common.schemas.symbol import BinanceSymbol
 from nautilus_trader.adapters.binance.common.schemas.symbol import BinanceSymbols
 from nautilus_trader.adapters.binance.common.types import BinanceBar
 from nautilus_trader.adapters.binance.http.client import BinanceHttpClient
 from nautilus_trader.adapters.binance.http.endpoint import BinanceHttpEndpoint
 from nautilus_trader.core.correctness import PyCondition
-from nautilus_trader.model.data.bar import BarType
-from nautilus_trader.model.data.book import OrderBookSnapshot
-from nautilus_trader.model.data.tick import TradeTick
+from nautilus_trader.model.data import BarType
+from nautilus_trader.model.data import OrderBookDeltas
+from nautilus_trader.model.data import TradeTick
 from nautilus_trader.model.identifiers import InstrumentId
 
 
 class BinancePingHttp(BinanceHttpEndpoint):
     """
     Endpoint for testing connectivity to the REST API.
 
@@ -257,21 +258,21 @@
 
         Parameters
         ----------
         symbol : BinanceSymbol
             The trading pair.
         limit : int, optional
             The limit for the response. Default 500; max 1000.
-        fromId : str, optional
+        fromId : int, optional
             Trade id to fetch from. Default gets most recent trades
         """
 
         symbol: BinanceSymbol
         limit: Optional[int] = None
-        fromId: Optional[str] = None
+        fromId: Optional[int] = None
 
     async def _get(self, parameters: GetParameters) -> list[BinanceTrade]:
         method_type = BinanceMethodType.GET
         raw = await self._method(method_type, parameters)
         return self._get_resp_decoder.decode(raw)
 
 
@@ -314,27 +315,27 @@
 
         Parameters
         ----------
         symbol : BinanceSymbol
             The trading pair.
         limit : int, optional
             The limit for the response. Default 500; max 1000.
-        fromId : str, optional
+        fromId : int, optional
             Trade id to fetch from INCLUSIVE.
-        startTime : str, optional
+        startTime : int, optional
             Timestamp in ms to get aggregate trades from INCLUSIVE.
-        endTime : str, optional
+        endTime : int, optional
             Timestamp in ms to get aggregate trades until INCLUSIVE.
         """
 
         symbol: BinanceSymbol
         limit: Optional[int] = None
-        fromId: Optional[str] = None
-        startTime: Optional[str] = None
-        endTime: Optional[str] = None
+        fromId: Optional[int] = None
+        startTime: Optional[int] = None
+        endTime: Optional[int] = None
 
     async def _get(self, parameters: GetParameters) -> list[BinanceAggTrade]:
         method_type = BinanceMethodType.GET
         raw = await self._method(method_type, parameters)
         return self._get_resp_decoder.decode(raw)
 
 
@@ -378,25 +379,25 @@
         ----------
         symbol : BinanceSymbol
             The trading pair.
         interval : str
             The interval of kline, e.g 1m, 5m, 1h, 1d, etc.
         limit : int, optional
             The limit for the response. Default 500; max 1000.
-        startTime : str, optional
+        startTime : int, optional
             Timestamp in ms to get klines from INCLUSIVE.
-        endTime : str, optional
+        endTime : int, optional
             Timestamp in ms to get klines until INCLUSIVE.
         """
 
         symbol: BinanceSymbol
         interval: BinanceKlineInterval
         limit: Optional[int] = None
-        startTime: Optional[str] = None
-        endTime: Optional[str] = None
+        startTime: Optional[int] = None
+        endTime: Optional[int] = None
 
     async def _get(self, parameters: GetParameters) -> list[BinanceKline]:
         method_type = BinanceMethodType.GET
         raw = await self._method(method_type, parameters)
         return self._get_resp_decoder.decode(raw)
 
 
@@ -605,17 +606,17 @@
         account_type: BinanceAccountType,
     ):
         PyCondition.not_none(client, "client")
         self.client = client
 
         if account_type.is_spot_or_margin:
             self.base_endpoint = "/api/v3/"
-        elif account_type == BinanceAccountType.FUTURES_USDT:
+        elif account_type == BinanceAccountType.USDT_FUTURE:
             self.base_endpoint = "/fapi/v1/"
-        elif account_type == BinanceAccountType.FUTURES_COIN:
+        elif account_type == BinanceAccountType.COIN_FUTURE:
             self.base_endpoint = "/dapi/v1/"
         else:
             raise RuntimeError(  # pragma: no cover (design-time error)
                 f"invalid `BinanceAccountType`, was {account_type}",  # pragma: no cover
             )
 
         # Create Endpoints
@@ -653,15 +654,15 @@
         )
 
     async def request_order_book_snapshot(
         self,
         instrument_id: InstrumentId,
         ts_init: int,
         limit: Optional[int] = None,
-    ) -> OrderBookSnapshot:
+    ) -> OrderBookDeltas:
         """Request snapshot of order book depth."""
         depth = await self.query_depth(instrument_id.symbol.value, limit)
         return depth.parse_to_order_book_snapshot(
             instrument_id=instrument_id,
             ts_init=ts_init,
         )
 
@@ -694,17 +695,17 @@
             for trade in trades
         ]
 
     async def query_agg_trades(
         self,
         symbol: str,
         limit: Optional[int] = None,
-        start_time: Optional[str] = None,
-        end_time: Optional[str] = None,
-        from_id: Optional[str] = None,
+        start_time: Optional[int] = None,
+        end_time: Optional[int] = None,
+        from_id: Optional[int] = None,
     ) -> list[BinanceAggTrade]:
         """Query aggregated trades for symbol."""
         return await self._endpoint_agg_trades._get(
             parameters=self._endpoint_agg_trades.GetParameters(
                 symbol=BinanceSymbol(symbol),
                 limit=limit,
                 startTime=start_time,
@@ -714,17 +715,17 @@
         )
 
     async def request_agg_trade_ticks(
         self,
         instrument_id: InstrumentId,
         ts_init: int,
         limit: int = 1000,
-        start_time: Optional[str] = None,
-        end_time: Optional[str] = None,
-        from_id: Optional[str] = None,
+        start_time: Optional[int] = None,
+        end_time: Optional[int] = None,
+        from_id: Optional[int] = None,
     ) -> list[TradeTick]:
         """
         Request TradeTicks from Binance aggregated trades.
         If start_time and end_time are both specified, will fetch *all* TradeTicks
         in the interval, making multiple requests if necessary.
         """
         ticks: list[TradeTick] = []
@@ -736,18 +737,18 @@
             )
 
         # Only split into separate requests if both start_time and end_time are specified
         max_interval = (1000 * 60 * 60) - 1  # 1ms under an hour, as specified in Futures docs.
         last_id = 0
         interval_limited = False
 
-        def _calculate_next_end_time(start_time: str, end_time: str):
-            next_interval = int(start_time) + max_interval
-            interval_limited = next_interval < int(end_time)
-            next_end_time = str(next_interval) if interval_limited is True else end_time
+        def _calculate_next_end_time(start_time: int, end_time: int) -> tuple[int, bool]:
+            next_interval = start_time + max_interval
+            interval_limited = next_interval < end_time
+            next_end_time = next_interval if interval_limited is True else end_time
             return next_end_time, interval_limited
 
         if start_time is not None and end_time is not None:
             next_end_time, interval_limited = _calculate_next_end_time(start_time, end_time)
         else:
             next_end_time = end_time
 
@@ -775,28 +776,28 @@
                 # end loop regardless when limit is not hit
                 break
             if start_time is None or end_time is None:
                 break
             else:
                 last = response[-1]
                 last_id = last.a
-                next_start_time = str(last.T)
+                next_start_time = last.T
                 next_end_time, interval_limited = _calculate_next_end_time(
                     next_start_time,
                     end_time,
                 )
                 continue
 
         return ticks
 
     async def query_historical_trades(
         self,
         symbol: str,
         limit: Optional[int] = None,
-        from_id: Optional[str] = None,
+        from_id: Optional[int] = None,
     ) -> list[BinanceTrade]:
         """Query historical trades for symbol."""
         return await self._endpoint_historical_trades._get(
             parameters=self._endpoint_historical_trades.GetParameters(
                 symbol=BinanceSymbol(symbol),
                 limit=limit,
                 fromId=from_id,
@@ -804,15 +805,15 @@
         )
 
     async def request_historical_trade_ticks(
         self,
         instrument_id: InstrumentId,
         ts_init: int,
         limit: Optional[int] = None,
-        from_id: Optional[str] = None,
+        from_id: Optional[int] = None,
     ) -> list[TradeTick]:
         """Request historical TradeTicks from Binance."""
         historical_trades = await self.query_historical_trades(
             symbol=instrument_id.symbol.value,
             limit=limit,
             from_id=from_id,
         )
@@ -825,16 +826,16 @@
         ]
 
     async def query_klines(
         self,
         symbol: str,
         interval: BinanceKlineInterval,
         limit: Optional[int] = None,
-        start_time: Optional[str] = None,
-        end_time: Optional[str] = None,
+        start_time: Optional[int] = None,
+        end_time: Optional[int] = None,
     ) -> list[BinanceKline]:
         """Query klines for a symbol over an interval."""
         return await self._endpoint_klines._get(
             parameters=self._endpoint_klines.GetParameters(
                 symbol=BinanceSymbol(symbol),
                 interval=interval,
                 limit=limit,
@@ -845,27 +846,47 @@
 
     async def request_binance_bars(
         self,
         bar_type: BarType,
         ts_init: int,
         interval: BinanceKlineInterval,
         limit: Optional[int] = None,
-        start_time: Optional[str] = None,
-        end_time: Optional[str] = None,
+        start_time: Optional[int] = None,
+        end_time: Optional[int] = None,
     ) -> list[BinanceBar]:
         """Request Binance Bars from Klines."""
-        klines = await self.query_klines(
-            symbol=bar_type.instrument_id.symbol.value,
-            interval=interval,
-            limit=limit,
-            start_time=start_time,
-            end_time=end_time,
-        )
-        bars: list[BinanceBar] = [kline.parse_to_binance_bar(bar_type, ts_init) for kline in klines]
-        return bars
+        end_time_ms = int(end_time) if end_time is not None else sys.maxsize
+        all_bars: list[BinanceBar] = []
+        while True:
+            klines = await self.query_klines(
+                symbol=bar_type.instrument_id.symbol.value,
+                interval=interval,
+                limit=limit,
+                start_time=start_time,
+                end_time=end_time,
+            )
+            bars: list[BinanceBar] = [
+                kline.parse_to_binance_bar(bar_type, ts_init) for kline in klines
+            ]
+            all_bars.extend(bars)
+
+            # Update the start_time to fetch the next set of bars
+            if klines:
+                next_start_time = klines[-1].open_time + 1
+            else:
+                # Handle the case when klines is empty
+                break
+
+            # No more bars to fetch
+            if (limit and len(klines) < limit) or next_start_time >= end_time_ms:
+                break
+
+            start_time = next_start_time
+
+        return all_bars
 
     async def query_ticker_24hr(
         self,
         symbol: Optional[str] = None,
         symbols: Optional[list[str]] = None,
         response_type: Optional[str] = None,
     ) -> list[BinanceTicker24hr]:
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/http/user.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/http/user.py`

 * *Files 4% similar despite different names*

```diff
@@ -143,24 +143,24 @@
         PyCondition.not_none(client, "client")
         self.client = client
         self.account_type = account_type
 
         if account_type == BinanceAccountType.SPOT:
             self.base_endpoint = "/api/v3/"
             listen_key_url = self.base_endpoint + "userDataStream"
-        elif account_type == BinanceAccountType.MARGIN_CROSS:
+        elif account_type == BinanceAccountType.MARGIN:
             self.base_endpoint = "/sapi/v1/"
             listen_key_url = self.base_endpoint + "userDataStream"
-        elif account_type == BinanceAccountType.MARGIN_ISOLATED:
+        elif account_type == BinanceAccountType.ISOLATED_MARGIN:
             self.base_endpoint = "/sapi/v1/"
             listen_key_url = self.base_endpoint + "userDataStream/isolated"
-        elif account_type == BinanceAccountType.FUTURES_USDT:
+        elif account_type == BinanceAccountType.USDT_FUTURE:
             self.base_endpoint = "/fapi/v1/"
             listen_key_url = self.base_endpoint + "listenKey"
-        elif account_type == BinanceAccountType.FUTURES_COIN:
+        elif account_type == BinanceAccountType.COIN_FUTURE:
             self.base_endpoint = "/dapi/v1/"
             listen_key_url = self.base_endpoint + "listenKey"
         else:
             raise RuntimeError(  # pragma: no cover (design-time error)
                 f"invalid `BinanceAccountType`, was {account_type}",  # pragma: no cover (design-time error)
             )
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/spot/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/spot/data.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/data.py`

 * *Files 5% similar despite different names*

```diff
@@ -26,18 +26,17 @@
 from nautilus_trader.adapters.binance.spot.schemas.market import BinanceSpotOrderBookPartialDepthMsg
 from nautilus_trader.adapters.binance.spot.schemas.market import BinanceSpotTradeMsg
 from nautilus_trader.cache.cache import Cache
 from nautilus_trader.common.clock import LiveClock
 from nautilus_trader.common.logging import Logger
 from nautilus_trader.common.providers import InstrumentProvider
 from nautilus_trader.core.correctness import PyCondition
-from nautilus_trader.model.data.book import OrderBookDelta
-from nautilus_trader.model.data.book import OrderBookDeltas
-from nautilus_trader.model.data.book import OrderBookSnapshot
-from nautilus_trader.model.data.tick import TradeTick
+from nautilus_trader.model.data import OrderBookDelta
+from nautilus_trader.model.data import OrderBookDeltas
+from nautilus_trader.model.data import TradeTick
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.msgbus.bus import MessageBus
 
 
 class BinanceSpotDataClient(BinanceCommonDataClient):
     """
     Provides a data client for the `Binance Spot/Margin` exchange.
@@ -54,39 +53,39 @@
         The cache for the client.
     clock : LiveClock
         The clock for the client.
     logger : Logger
         The logger for the client.
     instrument_provider : InstrumentProvider
         The instrument provider.
+    base_url_ws : str
+        The base URL for the WebSocket client.
     account_type : BinanceAccountType
         The account type for the client.
-    base_url_ws : str, optional
-        The base URL for the WebSocket client.
     use_agg_trade_ticks : bool, default False
         Whether to use aggregated trade tick endpoints instead of raw trade ticks.
         TradeId of ticks will be the Aggregate tradeId returned by Binance.
     """
 
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
         client: BinanceHttpClient,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
         logger: Logger,
         instrument_provider: InstrumentProvider,
+        base_url_ws: str,
         account_type: BinanceAccountType = BinanceAccountType.SPOT,
-        base_url_ws: Optional[str] = None,
         use_agg_trade_ticks: bool = False,
     ):
         PyCondition.true(
             account_type.is_spot_or_margin,
-            "account_type was not SPOT, MARGIN_CROSS or MARGIN_ISOLATED",
+            "account_type was not SPOT, MARGIN or ISOLATED_MARGIN",
         )
 
         # Spot HTTP API
         self._spot_http_market = BinanceSpotMarketHttpAPI(client, account_type)
 
         # Spot enum parser
         self._spot_enum_parser = BinanceSpotEnumParser()
@@ -115,22 +114,22 @@
     # -- WEBSOCKET HANDLERS ---------------------------------------------------------------------------------
 
     def _handle_book_partial_update(self, raw: bytes) -> None:
         msg = self._decoder_spot_order_book_partial_depth.decode(raw)
         instrument_id: InstrumentId = self._get_cached_instrument_id(
             msg.stream.partition("@")[0],
         )
-        book_snapshot: OrderBookSnapshot = msg.data.parse_to_order_book_snapshot(
+        book_snapshot: OrderBookDeltas = msg.data.parse_to_order_book_snapshot(
             instrument_id=instrument_id,
             ts_init=self._clock.timestamp_ns(),
         )
         # Check if book buffer active
-        book_buffer: Optional[
-            list[Union[OrderBookDelta, OrderBookDeltas, OrderBookSnapshot]]
-        ] = self._book_buffer.get(instrument_id)
+        book_buffer: Optional[list[Union[OrderBookDelta, OrderBookDeltas]]] = self._book_buffer.get(
+            instrument_id,
+        )
         if book_buffer is not None:
             book_buffer.append(book_snapshot)
         else:
             self._handle_data(book_snapshot)
 
     def _handle_trade(self, raw: bytes) -> None:
         msg = self._decoder_spot_trade.decode(raw)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/spot/enums.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/enums.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/spot/execution.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/execution.py`

 * *Files 1% similar despite different names*

```diff
@@ -84,15 +84,15 @@
         instrument_provider: BinanceSpotInstrumentProvider,
         account_type: BinanceAccountType = BinanceAccountType.SPOT,
         base_url_ws: Optional[str] = None,
         warn_gtd_to_gtc: bool = True,
     ):
         PyCondition.true(
             account_type.is_spot_or_margin,
-            "account_type was not SPOT, MARGIN_CROSS or MARGIN_ISOLATED",
+            "account_type was not SPOT, MARGIN or ISOLATED_MARGIN",
         )
 
         # Spot HTTP API
         self._spot_http_account = BinanceSpotAccountHttpAPI(client, clock, account_type)
         self._spot_http_market = BinanceSpotMarketHttpAPI(client, account_type)
         self._spot_http_user = BinanceSpotUserDataHttpAPI(client, account_type)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/spot/http/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/http/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/spot/http/account.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/http/account.py`

 * *Files 2% similar despite different names*

```diff
@@ -329,36 +329,36 @@
         """
         Parameters of allOrderList GET request.
 
         Parameters
         ----------
         timestamp : str
             The millisecond timestamp of the request.
-        fromId : str, optional
+        fromId : int, optional
             The order ID for the request.
             If included, request will return orders from this orderId INCLUSIVE.
-        startTime : str, optional
+        startTime : int, optional
             The start time (UNIX milliseconds) filter for the request.
-        endTime : str, optional
+        endTime : int, optional
             The end time (UNIX milliseconds) filter for the request.
         limit : int, optional
             The limit for the response.
             Default 500, max 1000
         recvWindow : str, optional
             The response receive window for the request (cannot be greater than 60000).
 
         Warnings
         --------
         If fromId is specified, neither startTime endTime can be provided.
         """
 
         timestamp: str
-        fromId: Optional[str] = None
-        startTime: Optional[str] = None
-        endTime: Optional[str] = None
+        fromId: Optional[int] = None
+        startTime: Optional[int] = None
+        endTime: Optional[int] = None
         limit: Optional[int] = None
         recvWindow: Optional[str] = None
 
     async def _get(self, parameters: GetParameters) -> list[BinanceSpotOrderOco]:
         method_type = BinanceMethodType.GET
         raw = await self._method(method_type, parameters)
         return self._resp_decoder.decode(raw)
@@ -532,15 +532,15 @@
             client=client,
             clock=clock,
             account_type=account_type,
         )
 
         if not account_type.is_spot_or_margin:
             raise RuntimeError(  # pragma: no cover (design-time error)
-                f"`BinanceAccountType` not SPOT, MARGIN_CROSS or MARGIN_ISOLATED, was {account_type}",  # pragma: no cover
+                f"`BinanceAccountType` not SPOT, MARGIN or ISOLATED_MARGIN, was {account_type}",  # pragma: no cover
             )
 
         # Create endpoints
         self._endpoint_spot_open_orders = BinanceSpotOpenOrdersHttp(client, self.base_endpoint)
         self._endpoint_spot_order_oco = BinanceSpotOrderOcoHttp(client, self.base_endpoint)
         self._endpoint_spot_order_list = BinanceSpotOrderListHttp(client, self.base_endpoint)
         self._endpoint_spot_all_order_list = BinanceSpotAllOrderListHttp(client, self.base_endpoint)
@@ -667,17 +667,17 @@
                 newClientOrderId=new_client_order_id,
                 recvWindow=recv_window,
             ),
         )
 
     async def query_spot_all_oco(
         self,
-        from_id: Optional[str] = None,
-        start_time: Optional[str] = None,
-        end_time: Optional[str] = None,
+        from_id: Optional[int] = None,
+        start_time: Optional[int] = None,
+        end_time: Optional[int] = None,
         limit: Optional[int] = None,
         recv_window: Optional[str] = None,
     ) -> list[BinanceSpotOrderOco]:
         """Check all spot OCO orders' information, matching provided filter parameters."""
         if from_id is not None and (start_time or end_time) is not None:
             raise RuntimeError(
                 "Cannot specify both fromId and a startTime/endTime.",
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/spot/http/market.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/http/market.py`

 * *Files 0% similar despite different names*

```diff
@@ -146,15 +146,15 @@
         super().__init__(
             client=client,
             account_type=account_type,
         )
 
         if not account_type.is_spot_or_margin:
             raise RuntimeError(  # pragma: no cover (design-time error)
-                f"`BinanceAccountType` not SPOT, MARGIN_CROSS or MARGIN_ISOLATED, was {account_type}",  # pragma: no cover
+                f"`BinanceAccountType` not SPOT, MARGIN or ISOLATED_MARGIN, was {account_type}",  # pragma: no cover
             )
 
         self._endpoint_spot_exchange_info = BinanceSpotExchangeInfoHttp(client, self.base_endpoint)
         self._endpoint_spot_average_price = BinanceSpotAvgPriceHttp(client, self.base_endpoint)
 
     async def query_spot_exchange_info(
         self,
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/spot/http/user.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/http/user.py`

 * *Files 7% similar despite different names*

```diff
@@ -39,9 +39,9 @@
         super().__init__(
             client=client,
             account_type=account_type,
         )
 
         if not account_type.is_spot_or_margin:
             raise RuntimeError(  # pragma: no cover (design-time error)
-                f"`BinanceAccountType` not SPOT, MARGIN_CROSS or MARGIN_ISOLATED, was {account_type}",  # pragma: no cover (design-time error)
+                f"`BinanceAccountType` not SPOT, MARGIN or ISOLATED_MARGIN, was {account_type}",  # pragma: no cover (design-time error)
             )
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/spot/http/wallet.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/http/wallet.py`

 * *Files 1% similar despite different names*

```diff
@@ -99,15 +99,15 @@
     ):
         self.client = client
         self._clock = clock
         self.base_endpoint = "/sapi/v1/asset/"
 
         if not account_type.is_spot_or_margin:
             raise RuntimeError(  # pragma: no cover (design-time error)
-                f"`BinanceAccountType` not SPOT, MARGIN_CROSS or MARGIN_ISOLATED, was {account_type}",  # pragma: no cover
+                f"`BinanceAccountType` not SPOT, MARGIN or ISOLATED_MARGIN, was {account_type}",  # pragma: no cover
             )
 
         self._endpoint_spot_trade_fee = BinanceSpotTradeFeeHttp(client, self.base_endpoint)
 
     def _timestamp(self) -> str:
         """Create Binance timestamp from internal clock."""
         return str(self._clock.timestamp_ms())
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/spot/providers.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/providers.py`

 * *Files 1% similar despite different names*

```diff
@@ -242,21 +242,21 @@
             price_precision = abs(int(Decimal(tick_size).as_tuple().exponent))
             size_precision = abs(int(Decimal(step_size).as_tuple().exponent))
             price_increment = Price.from_str(tick_size)
             size_increment = Quantity.from_str(step_size)
             lot_size = Quantity.from_str(step_size)
 
             PyCondition.in_range(
-                float(lot_size_filter.maxQty),
+                Decimal(lot_size_filter.maxQty),
                 QUANTITY_MIN,
                 QUANTITY_MAX,
                 "maxQty",
             )
             PyCondition.in_range(
-                float(lot_size_filter.minQty),
+                Decimal(lot_size_filter.minQty),
                 QUANTITY_MIN,
                 QUANTITY_MAX,
                 "minQty",
             )
             max_quantity = Quantity(float(lot_size_filter.maxQty), precision=size_precision)
             min_quantity = Quantity(float(lot_size_filter.minQty), precision=size_precision)
             min_notional = None
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/spot/schemas/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/schemas/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/spot/schemas/account.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/schemas/account.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/spot/schemas/market.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/schemas/market.py`

 * *Files 10% similar despite different names*

```diff
@@ -19,18 +19,22 @@
 from nautilus_trader.adapters.binance.common.schemas.market import BinanceExchangeFilter
 from nautilus_trader.adapters.binance.common.schemas.market import BinanceOrderBookDelta
 from nautilus_trader.adapters.binance.common.schemas.market import BinanceRateLimit
 from nautilus_trader.adapters.binance.common.schemas.market import BinanceSymbolFilter
 from nautilus_trader.adapters.binance.spot.enums import BinanceSpotPermissions
 from nautilus_trader.core.datetime import millis_to_nanos
 from nautilus_trader.model.currency import Currency
-from nautilus_trader.model.data.book import OrderBookSnapshot
-from nautilus_trader.model.data.tick import TradeTick
+from nautilus_trader.model.data import BookOrder
+from nautilus_trader.model.data import OrderBookDelta
+from nautilus_trader.model.data import OrderBookDeltas
+from nautilus_trader.model.data import TradeTick
 from nautilus_trader.model.enums import AggressorSide
+from nautilus_trader.model.enums import BookAction
 from nautilus_trader.model.enums import CurrencyType
+from nautilus_trader.model.enums import OrderSide
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.identifiers import TradeId
 from nautilus_trader.model.objects import Price
 from nautilus_trader.model.objects import Quantity
 
 
 ################################################################################
@@ -106,23 +110,37 @@
     bids: list[BinanceOrderBookDelta]
     asks: list[BinanceOrderBookDelta]
 
     def parse_to_order_book_snapshot(
         self,
         instrument_id: InstrumentId,
         ts_init: int,
-    ) -> OrderBookSnapshot:
-        return OrderBookSnapshot(
-            instrument_id=instrument_id,
-            bids=[[float(o.price), float(o.size)] for o in self.bids],
-            asks=[[float(o.price), float(o.size)] for o in self.asks],
-            ts_event=ts_init,
-            ts_init=ts_init,
-            sequence=self.lastUpdateId,
-        )
+    ) -> OrderBookDeltas:
+        bids = [
+            BookOrder(OrderSide.BUY, Price.from_str(o.price), Quantity.from_str(o.size), 0)
+            for o in self.bids
+        ]
+        asks = [
+            BookOrder(OrderSide.SELL, Price.from_str(o.price), Quantity.from_str(o.size), 0)
+            for o in self.asks
+        ]
+
+        deltas = [OrderBookDelta.clear(instrument_id, ts_init, ts_init, self.lastUpdateId)]
+        deltas += [
+            OrderBookDelta(
+                instrument_id,
+                BookAction.ADD,
+                o,
+                ts_init,
+                ts_init,
+                sequence=self.lastUpdateId,
+            )
+            for o in bids + asks
+        ]
+        return OrderBookDeltas(instrument_id=instrument_id, deltas=deltas)
 
 
 class BinanceSpotOrderBookPartialDepthMsg(msgspec.Struct):
     """WebSocket message for 'Binance Spot/Margin' Partial Book Depth Streams."""
 
     stream: str
     data: BinanceSpotOrderBookPartialDepthData
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/spot/schemas/user.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/spot/schemas/user.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/spot/schemas/wallet.py` & `nautilus_trader-1.175.0/nautilus_trader/indicators/bias.pxd`

 * *Files 16% similar despite different names*

```diff
@@ -9,21 +9,21 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-import msgspec
+from nautilus_trader.indicators.average.moving_average cimport MovingAverage
+from nautilus_trader.indicators.base.indicator cimport Indicator
 
 
-################################################################################
-# HTTP responses
-################################################################################
+cdef class Bias(Indicator):
+    cdef MovingAverage _ma
 
+    cdef readonly int period
+    """The window period.\n\n:returns: `int`"""
+    cdef readonly double value
+    """The current value.\n\n:returns: `double`"""
 
-class BinanceSpotTradeFee(msgspec.Struct, frozen=True):
-    """Schema of a single `Binance Spot/Margin` tradeFee."""
-
-    symbol: str
-    makerCommission: str
-    takerCommission: str
+    cpdef void update_raw(self, double close)
+    cdef void _check_initialized(self)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/websocket/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/websocket/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/binance/websocket/client.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/websocket/client.py`

 * *Files 12% similar despite different names*

```diff
@@ -9,92 +9,159 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-import asyncio
-from typing import Any, Callable, Optional
+from typing import Callable, Optional
 
 from nautilus_trader.adapters.binance.common.schemas.symbol import BinanceSymbol
 from nautilus_trader.common.clock import LiveClock
 from nautilus_trader.common.logging import Logger
-from nautilus_trader.network.websocket import WebSocketClient
+from nautilus_trader.common.logging import LoggerAdapter
+from nautilus_trader.core.nautilus_pyo3.network import WebSocketClient
 
 
-class BinanceWebSocketClient(WebSocketClient):
+class BinanceWebSocketClient:
     """
     Provides a `Binance` streaming WebSocket client.
+
+    Parameters
+    ----------
+    clock : LiveClock
+        The clock for the client.
+    logger : Logger
+        The logger for the client.
+    base_url : str
+        The base URL for the WebSocket connection.
+    handler : Callable[[bytes], None]
+        The callback handler for message events.
     """
 
     def __init__(
         self,
-        loop: asyncio.AbstractEventLoop,
         clock: LiveClock,
         logger: Logger,
-        handler: Callable[[bytes], None],
         base_url: str,
+        handler: Callable[[bytes], None],
     ) -> None:
-        super().__init__(
-            loop=loop,
-            logger=logger,
-            handler=handler,
-            max_retry_connection=6,
-        )
+        self._clock = clock
+        self._logger = logger
+        self._log: LoggerAdapter = LoggerAdapter(type(self).__name__, logger=logger)
 
+        self._client: Optional[WebSocketClient] = None
         self._base_url: str = base_url
-
-        self._clock: LiveClock = clock
+        self._handler: Callable[[bytes], None] = handler
         self._streams: list[str] = []
+        self._msg_id: int = 0
 
     @property
-    def base_url(self) -> Optional[str]:
+    def url(self) -> str:
+        """
+        Return the server URL being used by the client.
+
+        Returns
+        -------
+        str
+
+        """
         return self._base_url
 
     @property
+    def is_connected(self) -> bool:
+        """
+        Return whether the client is connected.
+
+        Returns
+        -------
+        bool
+
+        """
+        return self._client is not None and self._client.is_alive
+
+    @property
     def subscriptions(self) -> list[str]:
+        """
+        Return the current active subscriptions for the client.
+
+        Returns
+        -------
+        str
+
+        """
         return self._streams.copy()
 
     @property
     def has_subscriptions(self) -> bool:
+        """
+        Return whether the client has subscriptions.
+
+        Returns
+        -------
+        bool
+
+        """
         return bool(self._streams)
 
-    async def connect(
-        self,
-        key: Optional[str] = None,
-        start: bool = True,
-        **ws_kwargs: dict[str, Any],
-    ) -> None:
+    async def connect(self, key: Optional[str] = None) -> None:
+        """
+        Connect the client to the server.
+        """
         if not self._streams:
             raise RuntimeError("no subscriptions for connection.")
 
         # Always connecting combined streams for consistency
         ws_url = self._base_url + "/stream?streams=" + "/".join(self._streams)
         if key is not None:
             ws_url += f"&listenKey={key}"
 
         self._log.info(f"Connecting to {ws_url}")
-        await super().connect(ws_url=ws_url, start=start, **ws_kwargs)
+        self._client = await WebSocketClient.connect(
+            url=ws_url,
+            handler=self._handler,
+            heartbeat=60,
+        )
+        self._log.info("Connected.")
+
+    async def disconnect(self) -> None:
+        """
+        Disconnect the client from the server.
+        """
+        if not self.is_connected:
+            self._log.error("Cannot disconnect websocket, not connected.")
+            return
+        assert self._client is not None  # Type checking
+
+        self._log.info("Disconnecting...")
+        await self._client.disconnect()
+        self._log.info("Disconnected.")
 
     def _add_stream(self, stream: str) -> None:
         if stream not in self._streams:
             self._streams.append(stream)
 
-    def subscribe(self, key: str) -> None:
+    async def subscribe(self, key: str) -> None:
         """
         Subscribe to the user data stream.
 
         Parameters
         ----------
         key : str
             The listen key for the subscription.
 
         """
         self._add_stream(key)
+        # self._msg_id += 1
+        # message = {
+        #     "method": "SUBSCRIBE",
+        #     "params": [key],
+        #     "id": self._msg_id,
+        # }
+        # await self.send(msgspec.json.encode(message))
 
     def subscribe_agg_trades(self, symbol: str) -> None:
         """
         Aggregate Trade Streams.
 
         The Aggregate Trade Streams push trade information that is aggregated for a single taker order.
         Stream Name: <symbol>@aggTrade
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/deribit/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/deribit/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/deribit/http/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/deribit/http/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/deribit/http/client.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/binance/http/client.py`

 * *Files 22% similar despite different names*

```diff
@@ -9,172 +9,154 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-import asyncio
 import hashlib
 import hmac
-import json
 import urllib.parse
 from typing import Any, Optional
 
 import msgspec
-from aiohttp import ClientResponse
-from aiohttp import ClientResponseError
 
-from nautilus_trader.adapters.deribit.http.error import DeribitClientError
-from nautilus_trader.adapters.deribit.http.error import DeribitServerError
+import nautilus_trader
+from nautilus_trader.adapters.binance.http.error import BinanceClientError
+from nautilus_trader.adapters.binance.http.error import BinanceServerError
 from nautilus_trader.common.clock import LiveClock
 from nautilus_trader.common.logging import Logger
-from nautilus_trader.network.http import HttpClient
+from nautilus_trader.common.logging import LoggerAdapter
+from nautilus_trader.core.nautilus_pyo3.network import HttpClient
+from nautilus_trader.core.nautilus_pyo3.network import HttpResponse
 
 
-class DeribitHttpClient(HttpClient):
-    """
-    Provides a `Deribit` asynchronous HTTP client.
+class BinanceHttpClient:
     """
+    Provides a `Binance` asynchronous HTTP client.
 
-    BASE_URL = "https://www.deribit.com"
+    Parameters
+    ----------
+    clock : LiveClock
+        The clock for the client.
+    logger : Logger
+        The logger for the client.
+    key : str
+        The Binance API key for requests.
+    secret : str
+        The Binance API secret for signed requests.
+    base_url : str, optional
+    """
 
     def __init__(
         self,
-        loop: asyncio.AbstractEventLoop,
         clock: LiveClock,
         logger: Logger,
         key: str,
         secret: str,
-        base_url: Optional[str] = None,
+        base_url: str,
     ):
-        super().__init__(
-            loop=loop,
-            logger=logger,
-        )
-        self._clock = clock
-        self._key = key
-        self._secret = secret
-        self._base_url = base_url or self.BASE_URL
-        self._nonce = 0
+        self._clock: LiveClock = clock
+        self._log: LoggerAdapter = LoggerAdapter(type(self).__name__, logger=logger)
+        self._key: str = key
+
+        self._base_url: str = base_url
+        self._secret: str = secret
+        self._headers: dict[str, Any] = {
+            "Content-Type": "application/json",
+            "User-Agent": "nautilus-trader/" + nautilus_trader.__version__,
+            "X-MBX-APIKEY": key,
+        }
+        self._client = HttpClient()
 
     @property
     def base_url(self) -> str:
+        """
+        Return the base URL being used by the client.
+
+        Returns
+        -------
+        str
+
+        """
         return self._base_url
 
     @property
     def api_key(self) -> str:
-        return self._key
-
-    @property
-    def api_secret(self) -> str:
-        return self._secret
-
-    @staticmethod
-    def _prepare_payload(payload: dict[str, str]) -> Optional[str]:
-        return json.dumps(payload, separators=(",", ":")) if payload else None
-
-    @staticmethod
-    def _url_encode(params: dict[str, str]) -> str:
-        return "?" + urllib.parse.urlencode(params) if params else ""
-
-    def _generate_authorization(
-        self,
-        action,
-        uri,
-        payload,
-    ):
-        # https://docs.deribit.com/#authentication
-
-        tstamp = self._clock.timestamp_ms()
-
-        nonce = self._nonce
-        self._nonce += 1
-
-        body = '{"jsonrpc": "2.0","id": "5647","method": "private/list_api_keys"}'
+        """
+        Return the Binance API key being used by the client.
 
-        request_data = action + "\n" + uri + "\n" + body + "\n"
-        base_signature_string = tstamp + "\n" + nonce + "\n" + request_data
-        byte_key = self._secret.encode()
-        message = base_signature_string.encode()
-        sig = hmac.new(byte_key, message, hashlib.sha256).hexdigest()
+        Returns
+        -------
+        str
 
-        authorization = (
-            "deri-hmac-sha256 id=" + self._key + ",ts=" + tstamp + ",sig=" + sig + ",nonce=" + nonce
-        )
+        """
+        return self._key
 
-        return authorization
+    @property
+    def headers(self):
+        """
+        Return the headers being used by the client.
+
+        Returns
+        -------
+        str
+
+        """
+        return self._headers
+
+    def _prepare_params(self, params: dict[str, Any]) -> str:
+        # Encode a dict into a URL query string
+        return urllib.parse.urlencode(params)
+
+    def _get_sign(self, data: str) -> str:
+        m = hmac.new(self._secret.encode(), data.encode(), hashlib.sha256)
+        return m.hexdigest()
 
-    async def _sign_request(
+    async def sign_request(
         self,
         http_method: str,
         url_path: str,
-        payload: dict[str, str] = None,
-        params: dict[str, Any] = None,
+        payload: Optional[dict[str, str]] = None,
     ) -> Any:
-        auth = self._generate_authorization(
+        if payload is None:
+            payload = {}
+        query_string = self._prepare_params(payload)
+        signature = self._get_sign(query_string)
+        payload["signature"] = signature
+        return await self.send_request(
             http_method,
             url_path,
-            payload,
-        )
-        headers = {"Authorization": auth}
-
-        return await self._send_request(
-            http_method=http_method,
-            url_path=url_path,
-            headers=headers,
             payload=payload,
-            params=params,
         )
 
-    async def _send_request(
+    async def send_request(
         self,
         http_method: str,
         url_path: str,
-        headers: dict[str, Any] = None,
-        payload: dict[str, str] = None,
-        params: dict[str, str] = None,
-    ) -> Any:
-        if payload is None:
-            payload = {}
-        # TODO(cs): Uncomment for development
-        print(f"{http_method} {url_path} {headers} {payload}")
-        query = self._url_encode(params)
-        try:
-            resp: ClientResponse = await self.request(
-                method=http_method,
-                url=self._base_url + url_path + query,
-                headers=headers,
-                data=self._prepare_payload(payload),
-            )
-        except ClientResponseError as e:
-            await self._handle_exception(e)
-            return
-
-        try:
-            data = msgspec.json.decode(resp.data)
-            if not data["success"]:
-                return data["error"]
-            return data["result"]
-        except msgspec.MsgspecError:
-            self._log.error(
-                f"Could not decode data to JSON: {resp.data}.",
-            )
+        payload: Optional[dict[str, str]] = None,
+    ) -> bytes:
+        if payload:
+            url_path += "?" + urllib.parse.urlencode(payload)
+            payload = None  # Don't send payload in the body
+
+        response: HttpResponse = await self._client.request(
+            http_method,
+            url=self._base_url + url_path,
+            headers=self._headers,
+            body=msgspec.json.encode(payload) if payload else None,
+        )
 
-    async def _handle_exception(self, error: ClientResponseError) -> None:
-        if error.status < 400:
-            return
-        elif 400 <= error.status < 500:
-            raise DeribitClientError(
-                status=error.status,
-                message=error.message,
-                headers=error.headers,
+        if 400 <= response.status < 500:
+            raise BinanceClientError(
+                status=response.status,
+                message=response.body.decode(),
+                headers=response.headers,
             )
-        else:
-            raise DeribitServerError(
-                status=error.status,
-                message=error.message,
-                headers=error.headers,
+        elif response.status >= 500:
+            raise BinanceServerError(
+                status=response.status,
+                message=response.body.decode(),
+                headers=response.headers,
             )
 
-    async def access_log(self):
-        return await self._sign_request("GET", "/api/v2/private/get_access_log", {})
+        return response.body
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/deribit/http/error.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/deribit/http/error.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/interactive_brokers/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/interactive_brokers/common.py` & `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/winner_max.py`

 * *Files 22% similar despite different names*

```diff
@@ -9,32 +9,26 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.model.identifiers import Venue
+from typing import Any, Optional
 
+import pandas as pd
 
-IB_VENUE = Venue("InteractiveBrokers")
+from nautilus_trader.analysis.statistic import PortfolioStatistic
 
 
-class ContractId(int):
+class MaxWinner(PortfolioStatistic):
     """
-    ContractId type.
+    Calculates the maximum winner from a series of PnLs.
     """
 
+    def calculate_from_realized_pnls(self, realized_pnls: pd.Series) -> Optional[Any]:
+        # Preconditions
+        if realized_pnls is None or realized_pnls.empty:
+            return 0.0
 
-# https://interactivebrokers.github.io/tws-api/tick_types.html
-TickTypeMapping = {
-    0: "Bid Size",
-    1: "Bid Price",
-    2: "Ask Price",
-    3: "Ask Size",
-    4: "Last Price",
-    5: "Last Size",
-    6: "High",
-    7: "Low",
-    8: "Volume",
-    9: "Close Price",
-}
+        # Calculate statistic
+        return max(realized_pnls)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/interactive_brokers/data.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/data.py`

 * *Files 20% similar despite different names*

```diff
@@ -10,516 +10,448 @@
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 import asyncio
-from collections import defaultdict
-from functools import partial
-from typing import Callable, Optional
+from operator import attrgetter
+from typing import Any, Optional, Union
 
-import ib_insync
 import pandas as pd
-from ib_insync import BarDataList
-from ib_insync import Contract
-from ib_insync import ContractDetails
-from ib_insync import RealTimeBar
-from ib_insync import RealTimeBarList
-from ib_insync import Ticker
-from ib_insync.ticker import nan
 
 # fmt: off
+from nautilus_trader.adapters.interactive_brokers.client import InteractiveBrokersClient
 from nautilus_trader.adapters.interactive_brokers.common import IB_VENUE
-from nautilus_trader.adapters.interactive_brokers.common import ContractId
-from nautilus_trader.adapters.interactive_brokers.parsing.data import bar_spec_to_bar_size
-from nautilus_trader.adapters.interactive_brokers.parsing.data import generate_trade_id
-from nautilus_trader.adapters.interactive_brokers.parsing.data import parse_bar_data
-from nautilus_trader.adapters.interactive_brokers.parsing.data import timedelta_to_duration_str
+from nautilus_trader.adapters.interactive_brokers.common import IBContract
+from nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersDataClientConfig
 from nautilus_trader.adapters.interactive_brokers.providers import InteractiveBrokersInstrumentProvider
 from nautilus_trader.cache.cache import Cache
 from nautilus_trader.common.clock import LiveClock
+from nautilus_trader.common.enums import LogColor
 from nautilus_trader.common.logging import Logger
-from nautilus_trader.core.datetime import dt_to_unix_nanos
+from nautilus_trader.core.uuid import UUID4
 from nautilus_trader.live.data_client import LiveMarketDataClient
-from nautilus_trader.model.data.bar import Bar
-from nautilus_trader.model.data.bar import BarType
-from nautilus_trader.model.data.book import OrderBookSnapshot
-from nautilus_trader.model.data.tick import QuoteTick
-from nautilus_trader.model.data.tick import TradeTick
-from nautilus_trader.model.enums import AggressorSide
+from nautilus_trader.model.data import Bar
+from nautilus_trader.model.data import BarType
+from nautilus_trader.model.data import DataType
+from nautilus_trader.model.data import QuoteTick
+from nautilus_trader.model.data import TradeTick
 from nautilus_trader.model.enums import BookType
-from nautilus_trader.model.enums import PriceType
 from nautilus_trader.model.identifiers import ClientId
 from nautilus_trader.model.identifiers import InstrumentId
-from nautilus_trader.model.objects import Price
-from nautilus_trader.model.objects import Quantity
+from nautilus_trader.model.identifiers import Venue
+from nautilus_trader.model.instruments.currency_pair import CurrencyPair
 from nautilus_trader.msgbus.bus import MessageBus
 
 
 # fmt: on
 
 
 class InteractiveBrokersDataClient(LiveMarketDataClient):
     """
     Provides a data client for the InteractiveBrokers exchange.
-
-    Parameters
-    ----------
-    loop : asyncio.AbstractEventLoop
-        The event loop for the client.
-    client : IB
-        The ib_insync IB client.
-    msgbus : MessageBus
-        The message bus for the client.
-    cache : Cache
-        The cache for the client.
-    clock : LiveClock
-        The clock for the client.
-    logger : Logger
-        The logger for the client.
-    instrument_provider : InteractiveBrokersInstrumentProvider
-        The instrument provider.
-    handle_revised_bars : bool
-        If DataClient will emit bar updates as soon new bar opens.
     """
 
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
-        client: ib_insync.IB,
+        client: InteractiveBrokersClient,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
         logger: Logger,
         instrument_provider: InteractiveBrokersInstrumentProvider,
-        handle_revised_bars: bool,
+        ibg_client_id: int,
+        config: InteractiveBrokersDataClientConfig,
     ):
+        """
+        Initialize a new instance of the ``InteractiveBrokersDataClient`` class.
+
+        Parameters
+        ----------
+        loop : asyncio.AbstractEventLoop
+            The event loop for the client.
+        client : InteractiveBrokersClient
+            The nautilus InteractiveBrokersClient using ibapi.
+        msgbus : MessageBus
+            The message bus for the client.
+        cache : Cache
+            The cache for the client.
+        clock : LiveClock
+            The clock for the client.
+        logger : Logger
+            The logger for the client.
+        instrument_provider : InteractiveBrokersInstrumentProvider
+            The instrument provider.
+        ibg_client_id : int
+            Client ID used to connect TWS/Gateway.
+        config : InteractiveBrokersDataClientConfig
+            Configuration for the client.
+        """
         super().__init__(
             loop=loop,
-            client_id=ClientId(IB_VENUE.value),
+            client_id=ClientId(f"{IB_VENUE.value}-{ibg_client_id:03d}"),
             venue=None,
             instrument_provider=instrument_provider,
             msgbus=msgbus,
             cache=cache,
             clock=clock,
             logger=logger,
-            config={"name": "InteractiveBrokersDataClient"},
+            config={
+                "name": f"{type(self).__name__}-{ibg_client_id:03d}",
+                "client_id": ibg_client_id,
+            },
         )
-
         self._client = client
-        self._handle_revised_bars = handle_revised_bars
-        self._tickers: dict[ContractId, list[Ticker]] = defaultdict(list)
-        self._last_bar_time: pd.Timestamp = pd.Timestamp("1970-01-01", tz="UTC")
-
-        # Tasks
-        self._watch_dog_task: Optional[asyncio.Task] = None
-
-        # Event hooks
-        self._client.errorEvent += self._on_error_event
+        self._handle_revised_bars = config.handle_revised_bars
+        self._use_regular_trading_hours = config.use_regular_trading_hours
+        self._market_data_type = config.market_data_type
 
     @property
     def instrument_provider(self) -> InteractiveBrokersInstrumentProvider:
         return self._instrument_provider  # type: ignore
 
     async def _connect(self):
-        if not self._client.isConnected():
-            await self._client.connect()
+        # Connect client
+        await self._client.is_running_async()
+        self._client.registered_nautilus_clients.add(self.id)
 
-        # Create long running tasks
-        self._watch_dog_task = self.create_task(self._watch_dog())
+        # Set Market Data Type
+        await self._client.set_market_data_type(self._market_data_type)
 
         # Load instruments based on config
         await self.instrument_provider.initialize()
-        for instrument in self.instrument_provider.get_all().values():
+        for instrument in self._instrument_provider.list_all():
             self._handle_data(instrument)
 
     async def _disconnect(self):
-        if self._client.isConnected():
-            self._client.disconnect()
+        self._client.registered_nautilus_clients.remove(self.id)
+        if self._client.is_running and self._client.registered_nautilus_clients == set():
+            self._client.stop()
 
-        # Cancel tasks
-        if self._watch_dog_task:
-            self._log.debug("Canceling `watch_dog` task...")
-            self._watch_dog_task.cancel()
-            self._watch_dog_task.done()
-
-    async def _watch_dog(self):
-        try:
-            while True:
-                await asyncio.sleep(5)
-                if not self._client.isConnected():
-                    try:
-                        self._log.warning(
-                            "IB Gateway disconnected. Trying to reconnect clientId {id} on {host}:{port}".format(
-                                id=self._client.client.clientId,
-                                host=self._client.client.host,
-                                port=self._client.client.port,
-                            ),
-                        )
-                        await self._client.connectAsync(
-                            host=self._client.client.host,
-                            port=self._client.client.port,
-                            clientId=self._client.client.clientId,
-                            timeout=30,
-                        )
-                        self._resubscribe_on_reset()
-                    except Exception as e:
-                        self._log.info(f"{e!r}")
-        except asyncio.CancelledError:
-            self._log.debug("`watch_dog` task was canceled.")
+    async def _subscribe(self, data_type: DataType) -> None:
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_subscribe` coroutine",  # pragma: no cover
+        )
 
-    async def _subscribe_order_book_snapshots(
+    async def _subscribe_instruments(self) -> None:
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_subscribe_instruments` coroutine",  # pragma: no cover
+        )
+
+    async def _subscribe_instrument(self, instrument_id: InstrumentId) -> None:
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_subscribe_instrument` coroutine",  # pragma: no cover
+        )
+
+    async def _subscribe_order_book_deltas(
         self,
         instrument_id: InstrumentId,
         book_type: BookType,
-        depth: int = 5,
-        kwargs: Optional[dict] = None,
-    ):
-        if book_type == BookType.L1_TBBO:
-            return self._request_top_of_book(instrument_id=instrument_id)
-        elif book_type == BookType.L2_MBP:
-            if depth in (None, 0):
-                depth = (
-                    5  # depth = 0 is default for Nautilus, but not handled by Interactive Brokers
-                )
-            return self._request_market_depth(
-                instrument_id=instrument_id,
-                handler=self._on_order_book_snapshot,
-                depth=depth,
-            )
-        else:
-            raise NotImplementedError("L3 orderbook not available for Interactive Brokers")
+        depth: Optional[int] = None,
+        kwargs: dict[str, Any] = None,
+    ) -> None:
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_subscribe_order_book_deltas` coroutine",  # pragma: no cover
+        )
 
-    async def _subscribe_order_book_deltas(
+    async def _subscribe_order_book_snapshots(
         self,
         instrument_id: InstrumentId,
         book_type: BookType,
-        depth: int = 5,
-        kwargs: Optional[dict] = None,
-    ):
-        raise NotImplementedError("Orderbook deltas not implemented for Interactive Brokers (yet)")
+        depth: Optional[int] = None,
+        kwargs: dict[str, Any] = None,
+    ) -> None:
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_subscribe_order_book_snapshots` coroutine",  # pragma: no cover
+        )
 
-    async def _subscribe_trade_ticks(self, instrument_id: InstrumentId):
-        contract_details: ContractDetails = self.instrument_provider.contract_details[
-            instrument_id.value
-        ]
-        ticker = self._client.reqMktData(contract=contract_details.contract)
-        ticker.updateEvent += self._on_trade_ticker_update
-        self._tickers[ContractId(ticker.contract.conId)].append(ticker)
-
-    async def _subscribe_quote_ticks(self, instrument_id: InstrumentId):
-        contract_details: ContractDetails = self.instrument_provider.contract_details[
-            instrument_id.value
-        ]
-        ticker = self._client.reqMktData(
-            contract=contract_details.contract,
-        )
-        ticker.updateEvent += partial(
-            self._on_quote_tick_update,
-            contract=contract_details.contract,
+    async def _subscribe_ticker(self, instrument_id: InstrumentId) -> None:
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_subscribe_ticker` coroutine",  # pragma: no cover
         )
-        self._tickers[ContractId(ticker.contract.conId)].append(ticker)
 
-    async def _subscribe_bars(self, bar_type: BarType):
-        price_type: PriceType = bar_type.spec.price_type
-        contract_details: ContractDetails = self.instrument_provider.contract_details[
-            bar_type.instrument_id.value
-        ]
-
-        what_to_show = {
-            PriceType.ASK: "ASK",
-            PriceType.BID: "BID",
-            PriceType.LAST: "TRADES",
-            PriceType.MID: "MIDPOINT",
-        }
-
-        realtime_request, bar_size_setting = bar_spec_to_bar_size(bar_type.spec)
-        if realtime_request:
-            bar_list: RealTimeBarList = self._client.reqRealTimeBars(
-                contract=contract_details.contract,
-                barSize=bar_type.spec.step,
-                whatToShow=what_to_show[price_type],
-                useRTH=False,
+    async def _subscribe_quote_ticks(self, instrument_id: InstrumentId) -> None:
+        if not (instrument := self._cache.instrument(instrument_id)):
+            self._log.error(
+                f"Cannot subscribe to QuoteTicks for {instrument_id}, Instrument not found.",
+            )
+            return
+
+        await self._client.subscribe_ticks(
+            instrument_id=instrument_id,
+            contract=IBContract(**instrument.info["contract"]),
+            tick_type="BidAsk",
+        )
+
+    async def _subscribe_trade_ticks(self, instrument_id: InstrumentId) -> None:
+        if not (instrument := self._cache.instrument(instrument_id)):
+            self._log.error(
+                f"Cannot subscribe to TradeTicks for {instrument_id}, Instrument not found.",
             )
-            bar_list.bar_type = bar_type
-            bar_list.instrument = self.instrument_provider.find(bar_type.instrument_id)
+            return
+
+        if isinstance(instrument, CurrencyPair):
+            self._log.error(
+                "InteractiveBrokers doesn't support Trade Ticks for CurrencyPair.",
+            )
+            return
 
-            bar_list.updateEvent += partial(self._on_bar_update, bar_type=bar_type)
+        await self._client.subscribe_ticks(
+            instrument_id=instrument_id,
+            contract=IBContract(**instrument.info["contract"]),
+            tick_type="AllLast",
+        )
+
+    async def _subscribe_bars(self, bar_type: BarType):
+        if not (instrument := self._cache.instrument(bar_type.instrument_id)):
+            self._log.error(f"Cannot subscribe to {bar_type}, Instrument not found.")
+            return
+
+        if bar_type.spec.timedelta.total_seconds() == 5:
+            await self._client.subscribe_realtime_bars(
+                bar_type=bar_type,
+                contract=IBContract(**instrument.info["contract"]),
+                use_rth=self._use_regular_trading_hours,
+            )
         else:
-            last_bar: Bar = self._cache.bar(bar_type)
-            if last_bar is None:
-                duration = pd.Timedelta(
-                    bar_type.spec.timedelta.total_seconds() * self._cache.bar_capacity,
-                    "sec",
-                )
-            else:
-                duration = pd.Timedelta(
-                    self._clock.timestamp_ns() - last_bar.ts_event,
-                    "ns",
-                )
-            bar_data_list: BarDataList = await self._client.reqHistoricalDataAsync(
-                contract=contract_details.contract,
-                endDateTime="",
-                durationStr=timedelta_to_duration_str(duration),
-                barSizeSetting=bar_size_setting,
-                whatToShow=what_to_show[bar_type.spec.price_type],
-                useRTH=contract_details.contract.secType == "STK",
-                formatDate=2,
-                keepUpToDate=True,
-            )
-            bar_data_list.bar_type = bar_type
-            bar_data_list.instrument = self.instrument_provider.find(bar_type.instrument_id)
-
-            self._on_historical_bar_update(
-                bar_data_list=bar_data_list,
-                has_new_bar=True,
-                process_all=True,
+            await self._client.subscribe_historical_bars(
+                bar_type=bar_type,
+                contract=IBContract(**instrument.info["contract"]),
+                use_rth=self._use_regular_trading_hours,
+                handle_revised_bars=self._handle_revised_bars,
             )
-            bar_data_list.updateEvent += partial(self._on_historical_bar_update)
+
+    async def _subscribe_instrument_status_updates(self, instrument_id: InstrumentId) -> None:
+        pass  # Subscribed as part of orderbook
+
+    async def _subscribe_instrument_close(self, instrument_id: InstrumentId) -> None:
+        pass  # Subscribed as part of orderbook
+
+    async def _unsubscribe(self, data_type: DataType) -> None:
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_unsubscribe` coroutine",  # pragma: no cover
+        )
+
+    async def _unsubscribe_instruments(self) -> None:
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_unsubscribe_instruments` coroutine",  # pragma: no cover
+        )
+
+    async def _unsubscribe_instrument(self, instrument_id: InstrumentId) -> None:
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_unsubscribe_instrument` coroutine",  # pragma: no cover
+        )
+
+    async def _unsubscribe_order_book_deltas(self, instrument_id: InstrumentId) -> None:
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_unsubscribe_order_book_deltas` coroutine",  # pragma: no cover
+        )
+
+    async def _unsubscribe_order_book_snapshots(self, instrument_id: InstrumentId) -> None:
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_unsubscribe_order_book_snapshots` coroutine",  # pragma: no cover
+        )
+
+    async def _unsubscribe_ticker(self, instrument_id: InstrumentId) -> None:
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_unsubscribe_ticker` coroutine",  # pragma: no cover
+        )
 
     async def _unsubscribe_quote_ticks(self, instrument_id: InstrumentId) -> None:
-        contract_details: ContractDetails = self.instrument_provider.contract_details[
-            instrument_id.value
-        ]
-        self._client.cancelMktData(contract_details.contract)
+        await self._client.unsubscribe_ticks(instrument_id, "BidAsk")
 
     async def _unsubscribe_trade_ticks(self, instrument_id: InstrumentId) -> None:
-        contract_details: ContractDetails = self.instrument_provider.contract_details[
-            instrument_id.value
-        ]
-        self._client.cancelMktData(contract_details.contract)
+        await self._client.unsubscribe_ticks(instrument_id, "AllLast")
 
     async def _unsubscribe_bars(self, bar_type: BarType) -> None:
-        for bars_list in self._client.wrapper.reqId2Subscriber.values():
-            self._log.debug(f"Trying to unsubscribe {bars_list.contract}, reqId: {bars_list.reqId}")
-            if getattr(bars_list, "bar_type", None) == bar_type:
-                if isinstance(bars_list, RealTimeBarList):
-                    self._client.cancelRealTimeBars(bars_list)
-                elif isinstance(bars_list, BarDataList):
-                    self._client.cancelHistoricalData(bars_list)
-                break
+        if bar_type.spec.timedelta == 5:
+            await self._client.unsubscribe_realtime_bars(bar_type)
+        else:
+            await self._client.unsubscribe_historical_bars(bar_type)
 
-    def _request_top_of_book(self, instrument_id: InstrumentId):
-        contract_details: ContractDetails = self.instrument_provider.contract_details[
-            instrument_id.value
-        ]
-        ticker = self._client.reqTickByTickData(
-            contract=contract_details.contract,
-            tickType="BidAsk",
-        )
-        ticker.updateEvent += self._on_top_level_snapshot
-        self._tickers[ContractId(ticker.contract.conId)].append(ticker)
-
-    def _request_market_depth(self, instrument_id: InstrumentId, handler: Callable, depth: int = 5):
-        contract_details: ContractDetails = self.instrument_provider.contract_details[
-            instrument_id.value
-        ]
-        ticker = self._client.reqMktDepth(
-            contract=contract_details.contract,
-            numRows=depth,
-        )
-        ticker.updateEvent += handler
-        self._tickers[ContractId(ticker.contract.conId)].append(ticker)
-
-    # def _on_order_book_delta(self, ticker: Ticker):
-    #     instrument_id = self.instrument_provider.contract_id_to_instrument_id[
-    #         ticker.contract.conId
-    #     ]
-    #     for depth in ticker.domTicks:
-    #         update = OrderBookDelta(
-    #             instrument_id=instrument_id,
-    #             action=MKT_DEPTH_OPERATIONS[depth.operation],
-    #             order=Order(
-    #                 price=Price.from_str(str(depth.price)),
-    #                 size=Quantity.from_str(str(depth.size)),
-    #                 side=IB_SIDE[depth.side],
-    #             ),
-    #             ts_event=dt_to_unix_nanos(depth.time),
-    #             ts_init=self._clock.timestamp_ns(),
-    #         )
-    #         self._handle_data(update)
-
-    def _on_quote_tick_update(self, tick: Ticker, contract: Contract):
-        instrument_id = self.instrument_provider.contract_id_to_instrument_id[contract.conId]
-        instrument = self.instrument_provider.find(instrument_id)
-        ts_init = self._clock.timestamp_ns()
-        ts_event = min(dt_to_unix_nanos(tick.time), ts_init)
-        quote_tick = QuoteTick(
-            instrument_id=instrument_id,
-            bid=Price(
-                value=tick.bid if tick.bid not in (None, nan) else 0,
-                precision=instrument.price_precision,
-            ),
-            bid_size=Quantity(
-                value=tick.bidSize if tick.bidSize not in (None, nan) else 0,
-                precision=instrument.size_precision,
-            ),
-            ask=Price(
-                value=tick.ask if tick.ask not in (None, nan) else 0,
-                precision=instrument.price_precision,
-            ),
-            ask_size=Quantity(
-                value=tick.askSize if tick.askSize not in (None, nan) else 0,
-                precision=instrument.size_precision,
-            ),
-            ts_event=ts_event,
-            ts_init=ts_init,
-        )
-        self._handle_data(quote_tick)
-
-    def _on_top_level_snapshot(self, ticker: Ticker):
-        instrument_id = self.instrument_provider.contract_id_to_instrument_id[ticker.contract.conId]
-        ts_init = self._clock.timestamp_ns()
-        ts_event = min(dt_to_unix_nanos(ticker.time), ts_init)
-        snapshot = OrderBookSnapshot(
-            instrument_id=instrument_id,
-            bids=[(ticker.bid, ticker.bidSize)],
-            asks=[(ticker.ask, ticker.askSize)],
-            ts_event=ts_event,
-            ts_init=ts_init,
-        )
-        self._handle_data(snapshot)
-
-    def _on_order_book_snapshot(self, ticker: Ticker, book_type: BookType = BookType.L2_MBP):
-        instrument_id = self.instrument_provider.contract_id_to_instrument_id[ticker.contract.conId]
-        ts_init = self._clock.timestamp_ns()
-        ts_event = min(dt_to_unix_nanos(ticker.time), ts_init)
-        if not (ticker.domBids or ticker.domAsks):
+    async def _unsubscribe_instrument_status_updates(self, instrument_id: InstrumentId) -> None:
+        pass  # Subscribed as part of orderbook
+
+    async def _unsubscribe_instrument_close(self, instrument_id: InstrumentId) -> None:
+        pass  # Subscribed as part of orderbook
+
+    async def _request(self, data_type: DataType, correlation_id: UUID4) -> None:
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_request` coroutine",  # pragma: no cover
+        )
+
+    async def _request_instrument(self, instrument_id: InstrumentId, correlation_id: UUID4):
+        await self.instrument_provider.load_async(instrument_id)
+        if instrument := self.instrument_provider.find(instrument_id):
+            self._handle_data(instrument)
+        else:
+            self._log.warning(f"{instrument_id} not available.")
             return
-        snapshot = OrderBookSnapshot(
-            instrument_id=instrument_id,
-            bids=[(level.price, level.size) for level in ticker.domBids],
-            asks=[(level.price, level.size) for level in ticker.domAsks],
-            ts_event=ts_event,
-            ts_init=ts_init,
-        )
-        self._handle_data(snapshot)
-
-    def _on_trade_ticker_update(self, ticker: Ticker):
-        instrument_id = self.instrument_provider.contract_id_to_instrument_id[ticker.contract.conId]
-        instrument = self.instrument_provider.find(instrument_id)
-        for tick in ticker.ticks:
-            ts_init = self._clock.timestamp_ns()
-            ts_event = min(dt_to_unix_nanos(tick.time), ts_init)
-            update = TradeTick(
-                instrument_id=instrument_id,
-                price=Price(tick.price, precision=instrument.price_precision),
-                size=Quantity(tick.size, precision=instrument.size_precision),
-                aggressor_side=AggressorSide.NO_AGGRESSOR,
-                trade_id=generate_trade_id(
-                    ts_event=ts_event,
-                    price=tick.price,
-                    size=tick.size,
-                ),
-                ts_event=ts_event,
-                ts_init=ts_init,
+        self._handle_instrument(instrument, correlation_id)
+
+    async def _request_instruments(self, venue: Venue, correlation_id: UUID4):
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_request_instruments` coroutine",  # pragma: no cover
+        )
+
+    async def _request_quote_ticks(
+        self,
+        instrument_id: InstrumentId,
+        limit: int,
+        correlation_id: UUID4,
+        start: Optional[pd.Timestamp] = None,
+        end: Optional[pd.Timestamp] = None,
+    ) -> None:
+        if not (instrument := self._cache.instrument(instrument_id)):
+            self._log.error(
+                f"Cannot request QuoteTicks for {instrument_id}, Instrument not found.",
             )
-            self._handle_data(update)
+            return
+
+        ticks = await self._handle_ticks_request(
+            IBContract(**instrument.info["contract"]),
+            "BID_ASK",
+            limit,
+            start,
+            end,
+        )
+        if not ticks:
+            self._log.warning(f"QuoteTicks not received for {instrument_id}")
+            return
 
-    def _on_bar_update(
+        self._handle_quote_ticks(instrument_id, ticks, correlation_id)
+
+    async def _request_trade_ticks(
         self,
-        bars: list[RealTimeBar],
-        has_new_bar: bool,
-        bar_type: BarType,
-    ):
-        if not has_new_bar:
+        instrument_id: InstrumentId,
+        limit: int,
+        correlation_id: UUID4,
+        start: Optional[pd.Timestamp] = None,
+        end: Optional[pd.Timestamp] = None,
+    ) -> None:
+        if not (instrument := self._cache.instrument(instrument_id)):
+            self._log.error(
+                f"Cannot request TradeTicks for {instrument_id}, Instrument not found.",
+            )
             return
 
-        for bar in bars:
-            if bar.time <= self._last_bar_time:
-                continue
-            instrument = self._cache.instrument(bar_type.instrument_id)
-            ts_init = self._clock.timestamp_ns()
-            ts_event = min(dt_to_unix_nanos(bar.time), ts_init)
-            data = Bar(
-                bar_type=bar_type,
-                open=Price(bar.open_, instrument.price_precision),
-                high=Price(bar.high, instrument.price_precision),
-                low=Price(bar.low, instrument.price_precision),
-                close=Price(bar.close, instrument.price_precision),
-                volume=Quantity(max(0, bar.volume), instrument.size_precision),
-                ts_event=ts_event,
-                ts_init=ts_init,
+        if isinstance(instrument, CurrencyPair):
+            self._log.error(
+                "InteractiveBrokers doesn't support Trade Ticks for CurrencyPair.",
             )
-            self._handle_data(data)
-            self._last_bar_time = bar.time
+            return
 
-    def _on_historical_bar_update(
+        ticks = await self._handle_ticks_request(
+            IBContract(**instrument.info["contract"]),
+            "TRADES",
+            limit,
+            start,
+            end,
+        )
+        if not ticks:
+            self._log.warning(f"TradeTicks not received for {instrument_id}")
+            return
+
+        self._handle_trade_ticks(instrument_id, ticks, correlation_id)
+
+    async def _handle_ticks_request(
+        self,
+        contract: IBContract,
+        tick_type: str,
+        limit: int,
+        start: Optional[pd.Timestamp] = None,
+        end: Optional[pd.Timestamp] = None,
+    ):
+        if not start:
+            limit = self._cache.tick_capacity
+
+        if not end:
+            end = pd.Timestamp.utcnow()
+
+        ticks: list[Union[QuoteTick, TradeTick]] = []
+        while (start and end > start) or (len(ticks) < limit > 0):
+            await self._client.is_running_async()
+            ticks_part = await self._client.get_historical_ticks(
+                contract,
+                tick_type,
+                end,
+                self._use_regular_trading_hours,
+            )
+            if not ticks_part:
+                break
+            end = pd.Timestamp(min(ticks_part, key=attrgetter("ts_init")).ts_init, tz="UTC")
+            ticks.extend(ticks_part)
+
+        ticks.sort(key=lambda x: x.ts_init)
+        return ticks
+
+    async def _request_bars(
         self,
-        bar_data_list: BarDataList,
-        has_new_bar: bool,
-        process_all: bool = False,
+        bar_type: BarType,
+        limit: int,
+        correlation_id: UUID4,
+        start: Optional[pd.Timestamp] = None,
+        end: Optional[pd.Timestamp] = None,
     ) -> None:
-        if not process_all:
-            if self._handle_revised_bars:
-                bars = [bar_data_list[-1]]
-                is_revision = not has_new_bar
-            elif not self._handle_revised_bars and has_new_bar:
-                bars = [bar_data_list[-2]]
-                is_revision = False
-            else:
-                return
-        else:
-            bars = bar_data_list
-            is_revision = False
+        if not (instrument := self._cache.instrument(bar_type.instrument_id)):
+            self._log.error(
+                f"Cannot request {bar_type}, Instrument not found.",
+            )
+            return
 
-        for bar in bars:
-            data = parse_bar_data(
-                bar=bar,
-                is_revision=is_revision,
-                bar_type=bar_data_list.bar_type,
-                instrument=bar_data_list.instrument,
-                ts_init=self._clock.timestamp_ns(),
-            )
-            self._handle_data(data)
-
-    def _on_error_event(self, req_id, error_code, error_string, contract) -> None:
-        # Connectivity between IB and Trader Workstation has been restored
-        if error_code in (1101, 1102):
-            self._log.info(f"{error_code}: {error_string}")
-            self._resubscribe_on_reset()
+        if bar_type.is_internally_aggregated():
+            self._log.error(
+                f"Cannot request {bar_type}: "
+                f"only historical bars with EXTERNAL aggregation available from InteractiveBrokers.",
+            )
+            return
+
+        if not bar_type.spec.is_time_aggregated():
+            self._log.error(
+                f"Cannot request {bar_type}: only time bars are aggregated by InteractiveBrokers.",
+            )
+            return
+
+        if not start:
+            limit = self._cache.bar_capacity
+
+        if not end:
+            end = pd.Timestamp.utcnow()
+
+        if bar_type.spec.timedelta.total_seconds() >= 60:
+            duration_str = "7 D"
         else:
-            self._log.warning(f"{error_code}: {error_string}")
+            duration_str = "1 D"
+        bars: list[Bar] = []
+        while (start and end > start) or (len(bars) < limit):
+            self._log.info(f"{start=}", LogColor.MAGENTA)
+            self._log.info(f"{end=}", LogColor.MAGENTA)
+            self._log.info(f"{limit=}", LogColor.MAGENTA)
+            bars_part = await self._client.get_historical_bars(
+                bar_type=bar_type,
+                contract=IBContract(**instrument.info["contract"]),
+                use_rth=self._use_regular_trading_hours,
+                end_date_time=end.strftime("%Y%m%d %H:%M:%S %Z"),
+                duration=duration_str,
+            )
+            if not bars_part:
+                break
+            bars.extend(bars_part)
+            end = pd.Timestamp(min(bars, key=attrgetter("ts_event")).ts_event, tz="UTC")
+            self._log.info(f"NEW {end=}", LogColor.MAGENTA)
+
+        if bars:
+            bars = list(set(bars))
+            bars.sort(key=lambda x: x.ts_init)
+            self._handle_bars(bar_type, bars, bars[0], correlation_id)
+            status_msg = {"id": correlation_id, "status": "Success"}
+        else:
+            self._log.warning(f"Bar Data not received for {bar_type}")
+            status_msg = {"id": correlation_id, "status": "Failed"}
 
-    def _resubscribe_on_reset(self) -> None:
-        self._handle_resubscribe_on_reset(
-            list(self.subscribed_order_book_deltas()),
-            self.subscribe_order_book_deltas,
-            self.unsubscribe_order_book_deltas,
-        )
-        self._handle_resubscribe_on_reset(
-            list(self.subscribed_order_book_snapshots()),
-            self.subscribe_order_book_snapshots,
-            self.unsubscribe_order_book_snapshots,
-        )
-        self._handle_resubscribe_on_reset(
-            list(self.subscribed_tickers()),
-            self.subscribe_ticker,
-            self.unsubscribe_ticker,
-        )
-        self._handle_resubscribe_on_reset(
-            list(self.subscribed_quote_ticks()),
-            self.subscribe_quote_ticks,
-            self.unsubscribe_quote_ticks,
-        )
-        self._handle_resubscribe_on_reset(
-            list(self.subscribed_trade_ticks()),
-            self.subscribe_trade_ticks,
-            self.unsubscribe_trade_ticks,
-        )
-        self._handle_resubscribe_on_reset(
-            list(self.subscribed_bars()),
-            self.subscribe_bars,
-            self.unsubscribe_bars,
-        )
-
-    @staticmethod
-    def _handle_resubscribe_on_reset(
-        subscription: list,
-        subscriber: Callable,
-        unsubscriber: Callable,
-    ) -> None:
-        for instrument_id in subscription:
-            unsubscriber(instrument_id)
-        for instrument_id in subscription:
-            subscriber(instrument_id)
+        # Publish Status event
+        self._msgbus.publish(
+            topic=f"requests.{correlation_id}",
+            msg=status_msg,
+        )
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/interactive_brokers/execution.py` & `nautilus_trader-1.175.0/nautilus_trader/live/execution_client.py`

 * *Files 26% similar despite different names*

```diff
@@ -9,376 +9,486 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+"""
+The `LiveExecutionClient` class is responsible for interfacing with a particular
+API which may be presented directly by an exchange, or broker intermediary.
+"""
+
 import asyncio
-from typing import Optional
+import functools
+from asyncio import Task
+from collections.abc import Coroutine
+from datetime import timedelta
+from typing import Any, Callable, Optional
 
-import ib_insync
 import pandas as pd
-from ib_insync import AccountValue
-from ib_insync import Fill as IBFill
-from ib_insync import Order as IBOrder
-from ib_insync import OrderStatus as IBOrderStatus
-from ib_insync import Trade as IBTrade
-
-# fmt: off
-from nautilus_trader.adapters.interactive_brokers.common import IB_VENUE
-from nautilus_trader.adapters.interactive_brokers.parsing.execution import account_values_to_nautilus_account_info
-from nautilus_trader.adapters.interactive_brokers.parsing.execution import ib_order_to_nautilus_order_type
-from nautilus_trader.adapters.interactive_brokers.parsing.execution import nautilus_order_to_ib_order
-from nautilus_trader.adapters.interactive_brokers.providers import InteractiveBrokersInstrumentProvider
+
 from nautilus_trader.cache.cache import Cache
 from nautilus_trader.common.clock import LiveClock
+from nautilus_trader.common.enums import LogColor
 from nautilus_trader.common.logging import Logger
+from nautilus_trader.common.providers import InstrumentProvider
 from nautilus_trader.core.correctness import PyCondition
-from nautilus_trader.core.datetime import dt_to_unix_nanos
+from nautilus_trader.core.uuid import UUID4
+from nautilus_trader.execution.client import ExecutionClient
+from nautilus_trader.execution.messages import CancelAllOrders
 from nautilus_trader.execution.messages import CancelOrder
 from nautilus_trader.execution.messages import ModifyOrder
+from nautilus_trader.execution.messages import QueryOrder
 from nautilus_trader.execution.messages import SubmitOrder
+from nautilus_trader.execution.messages import SubmitOrderList
+from nautilus_trader.execution.reports import ExecutionMassStatus
 from nautilus_trader.execution.reports import OrderStatusReport
 from nautilus_trader.execution.reports import PositionStatusReport
 from nautilus_trader.execution.reports import TradeReport
-from nautilus_trader.live.execution_client import LiveExecutionClient
 from nautilus_trader.model.currency import Currency
 from nautilus_trader.model.enums import AccountType
-from nautilus_trader.model.enums import LiquiditySide
 from nautilus_trader.model.enums import OmsType
-from nautilus_trader.model.enums import OrderStatus
-from nautilus_trader.model.enums import order_side_from_str
-from nautilus_trader.model.identifiers import AccountId
 from nautilus_trader.model.identifiers import ClientId
 from nautilus_trader.model.identifiers import ClientOrderId
 from nautilus_trader.model.identifiers import InstrumentId
-from nautilus_trader.model.identifiers import TradeId
+from nautilus_trader.model.identifiers import Venue
 from nautilus_trader.model.identifiers import VenueOrderId
-from nautilus_trader.model.instruments import Instrument
-from nautilus_trader.model.objects import Money
-from nautilus_trader.model.objects import Price
-from nautilus_trader.model.objects import Quantity
-from nautilus_trader.model.orders import Order
 from nautilus_trader.msgbus.bus import MessageBus
 
 
-# fmt: on
-
-
-class InteractiveBrokersExecutionClient(LiveExecutionClient):
+class LiveExecutionClient(ExecutionClient):
     """
-    Provides an execution client for Interactive Brokers TWS API.
+    The base class for all live execution clients.
 
     Parameters
     ----------
     loop : asyncio.AbstractEventLoop
         The event loop for the client.
-    client : IB
-        The ib_insync IB client.
+    client_id : ClientId
+        The client ID.
+    venue : Venue, optional with no default so ``None`` must be passed explicitly
+        The client venue. If multi-venue then can be ``None``.
+    instrument_provider : InstrumentProvider
+        The instrument provider for the client.
+    account_type : AccountType
+        The account type for the client.
+    base_currency : Currency, optional
+        The account base currency for the client. Use ``None`` for multi-currency accounts.
     msgbus : MessageBus
         The message bus for the client.
     cache : Cache
         The cache for the client.
     clock : LiveClock
         The clock for the client.
     logger : Logger
         The logger for the client.
-    instrument_provider : InteractiveBrokersInstrumentProvider
-        The instrument provider.
+    config : dict[str, object], optional
+        The configuration for the instance.
+
+    Raises
+    ------
+    ValueError
+        If `oms_type` is ``UNSPECIFIED`` (must be specified).
+
+    Warnings
+    --------
+    This class should not be used directly, but through a concrete subclass.
     """
 
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
-        client: ib_insync.IB,
-        account_id: AccountId,
+        client_id: ClientId,
+        venue: Optional[Venue],
+        oms_type: OmsType,
+        account_type: AccountType,
+        base_currency: Optional[Currency],
+        instrument_provider: InstrumentProvider,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
         logger: Logger,
-        instrument_provider: InteractiveBrokersInstrumentProvider,
-    ):
+        config: Optional[dict[str, Any]] = None,
+    ) -> None:
+        PyCondition.type(instrument_provider, InstrumentProvider, "instrument_provider")
+
         super().__init__(
-            loop=loop,
-            client_id=ClientId(IB_VENUE.value),
-            venue=IB_VENUE,
-            oms_type=OmsType.NETTING,
-            instrument_provider=instrument_provider,
-            account_type=AccountType.CASH,
-            base_currency=None,
+            client_id=client_id,
+            venue=venue,
+            oms_type=oms_type,
+            account_type=account_type,
+            base_currency=base_currency,
             msgbus=msgbus,
             cache=cache,
             clock=clock,
             logger=logger,
+            config=config,
         )
 
-        self._client: ib_insync.IB = client
-        self._set_account_id(account_id)
+        self._loop = loop
+        self._instrument_provider = instrument_provider
 
-        # Hot caches
-        self._instrument_ids: dict[str, InstrumentId] = {}
-        self._ib_insync_orders: dict[ClientOrderId, IBTrade] = {}
-
-        # Event hooks
-        self._client.newOrderEvent += self._on_order_update_event
-        self._client.orderModifyEvent += self._on_order_update_event
-        self._client.cancelOrderEvent += self._on_order_update_event
-        self._client.openOrderEvent += self._on_order_update_event
-        self._client.orderStatusEvent += self._on_order_update_event
-        self._client.execDetailsEvent += self._on_execution_detail
-
-    @property
-    def instrument_provider(self) -> InteractiveBrokersInstrumentProvider:
-        return self._instrument_provider  # type: ignore
+        self.reconciliation_active = False
 
-    async def _connect(self) -> None:
-        # Connect client
-        if not self._client.isConnected():
-            await self._client.connectAsync()
-
-        # Load account balance
-        account_values: list[AccountValue] = self._client.accountValues()
-        self.on_account_update(account_values)
+    async def run_after_delay(
+        self,
+        delay: float,
+        coro: Coroutine,
+    ) -> None:
+        """
+        Run the given coroutine after a delay.
+
+        Parameters
+        ----------
+        delay : float
+            The delay (seconds) before running the coroutine.
+        coro : Coroutine
+            The coroutine to run after the initial delay.
+
+        """
+        await asyncio.sleep(delay)
+        return await coro
 
-        self._set_connected(True)
+    def create_task(
+        self,
+        coro: Coroutine,
+        log_msg: Optional[str] = None,
+        actions: Optional[Callable] = None,
+        success: Optional[str] = None,
+    ) -> asyncio.Task:
+        """
+        Run the given coroutine with error handling and optional callback
+        actions when done.
+
+        Parameters
+        ----------
+        coro : Coroutine
+            The coroutine to run.
+        log_msg : str, optional
+            The log message for the task.
+        actions : Callable, optional
+            The actions callback to run when the coroutine is done.
+        success : str, optional
+            The log message to write on actions success.
+
+        Returns
+        -------
+        asyncio.Task
+
+        """
+        log_msg = log_msg or coro.__name__
+        self._log.debug(f"Creating task {log_msg}.")
+        task = self._loop.create_task(
+            coro,
+            name=coro.__name__,
+        )
+        task.add_done_callback(
+            functools.partial(
+                self._on_task_completed,
+                actions,
+                success,
+            ),
+        )
+        return task
 
-    async def _disconnect(self) -> None:
-        # Disconnect clients
-        if self._client.isConnected():
-            self._client.disconnect()
+    def _on_task_completed(
+        self,
+        actions: Optional[Callable],
+        success: Optional[str],
+        task: Task,
+    ) -> None:
+        if task.exception():
+            self._log.error(
+                f"Error on `{task.get_name()}`: " f"{task.exception()!r}",
+            )
+        else:
+            if actions:
+                try:
+                    actions()
+                except Exception as e:
+                    self._log.error(
+                        f"Failed triggering action {actions.__name__} on `{task.get_name()}`: "
+                        f"{e!r}",
+                    )
+            if success:
+                self._log.info(success, LogColor.GREEN)
+
+    def connect(self) -> None:
+        """
+        Connect the client.
+        """
+        self._log.info("Connecting...")
+        self.create_task(
+            self._connect(),
+            actions=lambda: self._set_connected(True),
+            success="Connected",
+        )
+
+    def disconnect(self) -> None:
+        """
+        Disconnect the client.
+        """
+        self._log.info("Disconnecting...")
+        self.create_task(
+            self._disconnect(),
+            actions=lambda: self._set_connected(False),
+            success="Disconnected",
+        )
+
+    def submit_order(self, command: SubmitOrder) -> None:
+        self.create_task(
+            self._submit_order(command),
+            log_msg=f"submit_order: {command}",
+        )
+
+    def submit_order_list(self, command: SubmitOrderList) -> None:
+        self.create_task(
+            self._submit_order_list(command),
+            log_msg=f"submit_order_list: {command}",
+        )
+
+    def modify_order(self, command: ModifyOrder) -> None:
+        self.create_task(
+            self._modify_order(command),
+            log_msg=f"modify_order: {command}",
+        )
+
+    def cancel_order(self, command: CancelOrder) -> None:
+        self.create_task(
+            self._cancel_order(command),
+            log_msg=f"cancel_order: {command}",
+        )
+
+    def cancel_all_orders(self, command: CancelAllOrders) -> None:
+        self.create_task(
+            self._cancel_all_orders(command),
+            log_msg=f"cancel_all_orders: {command}",
+        )
+
+    def query_order(self, command: QueryOrder) -> None:
+        self.create_task(
+            self._query_order(command),
+            log_msg=f"query_order: {command}",
+        )
 
     async def generate_order_status_report(
         self,
         instrument_id: InstrumentId,
         client_order_id: Optional[ClientOrderId] = None,
         venue_order_id: Optional[VenueOrderId] = None,
     ) -> Optional[OrderStatusReport]:
-        self._log.warning("Cannot generate `IBOrderStatusReport`: not yet implemented.")
+        """
+        Generate an `OrderStatusReport` for the given order identifier parameter(s).
+
+        If the order is not found, or an error occurs, then logs and returns ``None``.
 
-        return None  # TODO: Implement
+        Parameters
+        ----------
+        instrument_id : InstrumentId
+            The instrument ID for the report.
+        client_order_id : ClientOrderId, optional
+            The client order ID for the report.
+        venue_order_id : VenueOrderId, optional
+            The venue order ID for the report.
+
+        Returns
+        -------
+        OrderStatusReport or ``None``
+
+        Raises
+        ------
+        ValueError
+            If both the `client_order_id` and `venue_order_id` are ``None``.
+
+        """
+        raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     async def generate_order_status_reports(
         self,
         instrument_id: Optional[InstrumentId] = None,
         start: Optional[pd.Timestamp] = None,
         end: Optional[pd.Timestamp] = None,
         open_only: bool = False,
     ) -> list[OrderStatusReport]:
-        self._log.warning("Cannot generate `list[IBOrderStatusReport]`: not yet implemented.")
+        """
+        Generate a list of `OrderStatusReport`s with optional query filters.
+
+        The returned list may be empty if no orders match the given parameters.
+
+        Parameters
+        ----------
+        instrument_id : InstrumentId, optional
+            The instrument ID query filter.
+        start : pd.Timestamp, optional
+            The start datetime query filter.
+        end : pd.Timestamp, optional
+            The end datetime query filter.
+        open_only : bool, default False
+            If the query is for open orders only.
+
+        Returns
+        -------
+        list[OrderStatusReport]
 
-        return []  # TODO: Implement
+        """
+        raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     async def generate_trade_reports(
         self,
         instrument_id: Optional[InstrumentId] = None,
         venue_order_id: Optional[VenueOrderId] = None,
         start: Optional[pd.Timestamp] = None,
         end: Optional[pd.Timestamp] = None,
     ) -> list[TradeReport]:
-        self._log.warning("Cannot generate `list[TradeReport]`: not yet implemented.")
+        """
+        Generate a list of `TradeReport`s with optional query filters.
+
+        The returned list may be empty if no trades match the given parameters.
+
+        Parameters
+        ----------
+        instrument_id : InstrumentId, optional
+            The instrument ID query filter.
+        venue_order_id : VenueOrderId, optional
+            The venue order ID (assigned by the venue) query filter.
+        start : pd.Timestamp, optional
+            The start datetime query filter.
+        end : pd.Timestamp, optional
+            The end datetime query filter.
+
+        Returns
+        -------
+        list[TradeReport]
 
-        return []  # TODO: Implement
+        """
+        raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     async def generate_position_status_reports(
         self,
         instrument_id: Optional[InstrumentId] = None,
         start: Optional[pd.Timestamp] = None,
         end: Optional[pd.Timestamp] = None,
     ) -> list[PositionStatusReport]:
-        self._log.warning("Cannot generate `list[PositionStatusReport]`: not yet implemented.")
+        """
+        Generate a list of `PositionStatusReport`s with optional query filters.
 
-        return []  # TODO: Implement
+        The returned list may be empty if no positions match the given parameters.
 
-    def submit_order(self, command: SubmitOrder) -> None:
-        PyCondition.not_none(command, "command")
+        Parameters
+        ----------
+        instrument_id : InstrumentId, optional
+            The instrument ID query filter.
+        start : pd.Timestamp, optional
+            The start datetime query filter.
+        end : pd.Timestamp, optional
+            The end datetime query filter.
+
+        Returns
+        -------
+        list[PositionStatusReport]
+
+        """
+        raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
-        contract_details = self.instrument_provider.contract_details[command.instrument_id.value]
-        order: IBOrder = nautilus_order_to_ib_order(order=command.order)
-        order.account = self.account_id.get_id()
-        trade: IBTrade = self._client.placeOrder(contract=contract_details.contract, order=order)
-        self._ib_insync_orders[command.order.client_order_id] = trade
-        self.generate_order_submitted(
-            strategy_id=command.strategy_id,
+    async def generate_mass_status(
+        self,
+        lookback_mins: Optional[int] = None,
+    ) -> ExecutionMassStatus:
+        """
+        Generate an `ExecutionMassStatus` report.
+
+        Parameters
+        ----------
+        lookback_mins : int, optional
+            The maximum lookback for querying closed orders, trades and positions.
+
+        Returns
+        -------
+        ExecutionMassStatus
+
+        """
+        self._log.info(f"Generating ExecutionMassStatus for {self.id}...")
+
+        self.reconciliation_active = True
+
+        mass_status = ExecutionMassStatus(
+            client_id=self.id,
+            account_id=self.account_id,
+            venue=self.venue,
+            report_id=UUID4(),
+            ts_init=self._clock.timestamp_ns(),
+        )
+
+        since: Optional[pd.Timestamp] = None
+        if lookback_mins is not None:
+            since = self._clock.utc_now() - timedelta(minutes=lookback_mins)
+
+        try:
+            reports = await asyncio.gather(
+                self.generate_order_status_reports(start=since),
+                self.generate_trade_reports(start=since),
+                self.generate_position_status_reports(start=since),
+            )
+
+            mass_status.add_order_reports(reports=reports[0])
+            mass_status.add_trade_reports(reports=reports[1])
+            mass_status.add_position_reports(reports=reports[2])
+
+            self.reconciliation_active = False
+
+            return mass_status
+        except Exception as e:
+            self._log.exception("Cannot reconcile execution state", e)
+
+    async def _query_order(self, command: QueryOrder) -> None:
+        self._log.debug(f"Synchronizing order status {command}.")
+
+        report: OrderStatusReport = await self.generate_order_status_report(
             instrument_id=command.instrument_id,
-            client_order_id=command.order.client_order_id,
-            ts_event=command.ts_init,
+            client_order_id=command.client_order_id,
+            venue_order_id=command.venue_order_id,
         )
 
-    def modify_order(self, command: ModifyOrder) -> None:
-        # TODO - NEEDS TESTING
-        if not (command.quantity or command.price):
+        if report is None:
+            self._log.warning("Did not received `OrderStatusReport` from request.")
             return
-        # ib_insync modifies orders by modifying the original order object and
-        # calling placeOrder again.
-        PyCondition.not_none(command, "command")
-        # TODO - Can we just reconstruct the IBOrder object from the `command` ?
-        trade: IBTrade = self._ib_insync_orders[command.client_order_id]
-        order = trade.order
-
-        if command.quantity and order.totalQuantity != command.quantity:
-            order.totalQuantity = command.quantity.as_double()
-        if getattr(order, "lmtPrice", None) != command.price:
-            order.lmtPrice = command.price.as_double()
-        order.account = self.account_id.get_id()
-        new_trade: IBTrade = self._client.placeOrder(contract=trade.contract, order=order)
-        self._ib_insync_orders[command.client_order_id] = new_trade
-        trade.modifyEvent += self._on_order_modify
-        new_trade.modifyEvent += self._on_order_modify
 
-    def cancel_order(self, command: CancelOrder) -> None:
-        PyCondition.not_none(command, "command")
-        trade: IBTrade = self._ib_insync_orders[command.client_order_id]
-        order = trade.order
-        new_trade: IBTrade = self._client.cancelOrder(order=order)
-        self._ib_insync_orders[command.client_order_id] = new_trade
-
-    def _on_order_update_event(self, trade: IBTrade):
-        self._log.debug(
-            f"_on_order_update_event {trade.order.orderRef}: {trade.orderStatus.status=}",
-        )
-        status: str = trade.orderStatus.status
-        if status == IBOrderStatus.PreSubmitted:
-            self._on_pre_submitted_event(trade)
-        elif status == IBOrderStatus.PendingSubmit:
-            self._on_pending_submit_event(trade)
-        elif status == IBOrderStatus.Submitted:
-            self._on_submitted_event(trade)
-        elif status == IBOrderStatus.PendingCancel:
-            self._on_order_pending_cancel(trade)
-        elif status in (IBOrderStatus.Cancelled, IBOrderStatus.ApiCancelled):
-            self._on_order_cancelled(trade)
-        elif status == IBOrderStatus.Filled:
-            self._on_filled_event(trade)
-        else:
-            self._log.warning(
-                f"UNHANDLED status {trade.order.orderRef}: {trade.orderStatus.status}",
-            )
+        self._send_order_status_report(report)
 
-    def _on_pending_submit_event(self, trade: IBTrade):
-        self._log.debug(f"order pending_submit {trade.order.orderRef}: {trade}")
+    ############################################################################
+    # Coroutines to implement
+    ############################################################################
+    async def _connect(self) -> None:
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_connect` coroutine",  # pragma: no cover
+        )
 
-    def _on_pre_submitted_event(self, trade: IBTrade):
-        self._log.debug(f"order pre_submitted {trade.order.orderRef}: {trade}")
-        client_order_id = ClientOrderId(trade.order.orderRef)
-        order: Order = self._cache.order(client_order_id)
-        if order.status in (OrderStatus.SUBMITTED,):
-            self.generate_order_accepted(
-                strategy_id=order.strategy_id,
-                instrument_id=order.instrument_id,
-                client_order_id=client_order_id,
-                venue_order_id=VenueOrderId(str(trade.order.permId)),
-                ts_event=dt_to_unix_nanos(trade.log[-1].time),
-            )
+    async def _disconnect(self) -> None:
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_disconnect` coroutine",  # pragma: no cover
+        )
 
-    def _on_submitted_event(self, trade: IBTrade):
-        self._log.debug(f"order submitted {trade.order.orderRef}: {trade}")
-        client_order_id = ClientOrderId(trade.order.orderRef)
-        order: Order = self._cache.order(client_order_id)
-        if order.status in (OrderStatus.SUBMITTED,):
-            self.generate_order_accepted(
-                strategy_id=order.strategy_id,
-                instrument_id=order.instrument_id,
-                client_order_id=client_order_id,
-                venue_order_id=VenueOrderId(str(trade.order.permId)),
-                ts_event=dt_to_unix_nanos(trade.log[-1].time),
-            )
+    async def _submit_order(self, command: SubmitOrder) -> None:
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_submit_order` coroutine",  # pragma: no cover
+        )
 
-    def _on_order_modify(self, trade: IBTrade):
-        # TODO - NEEDS TESTING
-        client_order_id = ClientOrderId(trade.order.orderRef)
-        order: Order = self._cache.order(client_order_id)
-        instrument: Instrument = self._cache.instrument(order.instrument_id)
-        self.generate_order_updated(
-            strategy_id=order.strategy_id,
-            instrument_id=order.instrument_id,
-            client_order_id=client_order_id,
-            venue_order_id=order.venue_order_id,
-            quantity=Quantity(trade.order.totalQuantity, precision=instrument.size_precision),
-            price=Price(trade.order.lmtPrice, precision=instrument.price_precision),
-            trigger_price=None,
-            ts_event=dt_to_unix_nanos(trade.log[-1].time),
-            venue_order_id_modified=False,  # TODO (bm) - does this happen?
-        )
-
-    def _on_order_pending_cancel(self, trade: IBTrade):
-        assert trade.orderStatus.status == IBOrderStatus.PendingCancel
-        client_order_id = ClientOrderId(trade.order.orderRef)
-        order: Order = self._cache.order(client_order_id)
-        assert order.status == OrderStatus.PENDING_CANCEL
-
-    def _on_order_cancelled(self, trade: IBTrade):
-        assert trade.orderStatus.status in (IBOrderStatus.Cancelled, IBOrderStatus.ApiCancelled)
-        client_order_id = ClientOrderId(trade.order.orderRef)
-        order: Order = self._cache.order(client_order_id)
-        self.generate_order_canceled(
-            strategy_id=order.strategy_id,
-            instrument_id=order.instrument_id,
-            client_order_id=client_order_id,
-            venue_order_id=order.venue_order_id,
-            ts_event=dt_to_unix_nanos(trade.log[-1].time),
-        )
-
-    def _on_filled_event(self, trade: IBTrade):
-        self._log.debug(f"order filled {trade.order.orderRef}: {trade}")
-        self._log.warning(f"fill should be handled in _on_execution_detail {trade.order.orderRef}")
-
-    def _on_execution_detail(self, trade: IBTrade, fill: IBFill):
-        self._log.debug(f"_on_execution_detail {trade.order.orderRef}: {trade}")
-        if trade.orderStatus.status not in ("Submitted", "Filled"):
-            self._log.warning(
-                f"Called `_on_execution_detail` without order filled status: {trade.orderStatus.status=}",
-            )
-            return
+    async def _submit_order_list(self, command: SubmitOrderList) -> None:
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_submit_order_list` coroutine",  # pragma: no cover
+        )
+
+    async def _modify_order(self, command: ModifyOrder) -> None:
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_modify_order` coroutine",  # pragma: no cover
+        )
+
+    async def _cancel_order(self, command: CancelOrder) -> None:
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_cancel_order` coroutine",  # pragma: no cover
+        )
 
-        client_order_id = ClientOrderId(trade.order.orderRef)
-        order: Order = self._cache.order(client_order_id)
-        instrument = self.instrument_provider.find(order.instrument_id)
-        trade_id = TradeId(fill.execution.execId)
-        venue_order_id = VenueOrderId(str(trade.order.permId))
-        order_side = order_side_from_str(trade.order.action.upper())
-        order_type = ib_order_to_nautilus_order_type(trade.order)
-        last_qty = Quantity(fill.execution.shares, precision=instrument.size_precision)
-        last_px = Price(fill.execution.price, precision=instrument.price_precision)
-        currency = Currency.from_str(fill.contract.currency)
-        commission = Money(fill.commissionReport.commission, currency)
-        ts_event = dt_to_unix_nanos(fill.time)
-        self.generate_order_filled(
-            strategy_id=order.strategy_id,
-            instrument_id=order.instrument_id,
-            client_order_id=client_order_id,
-            venue_order_id=venue_order_id,
-            venue_position_id=None,
-            trade_id=trade_id,
-            order_side=order_side,
-            order_type=order_type,
-            last_qty=last_qty,
-            last_px=last_px,
-            quote_currency=currency,
-            commission=commission,
-            liquidity_side=LiquiditySide.NO_LIQUIDITY_SIDE,
-            ts_event=ts_event,
-        )
-
-    def on_account_update(self, account_values: list[AccountValue]):
-        self._log.debug(str(account_values))
-        account_id = self.account_id.get_id()
-        balances, margins = account_values_to_nautilus_account_info(
-            account_values,
-            account_id,
-        )
-        if not balances:
-            self._log.error(f"Failed to parse balances for {account_id=}")
-            # Log some information about the other values
-            search_keys = ("FullAvailableFunds", "CashBalance", "NetLiquidation")
-            other_values = [acc_val for acc_val in account_values if acc_val.tag in search_keys]
-            for value in other_values:
-                self._log.info(f"Found account_value = {value}")
-            raise RuntimeError("No account information")
-
-        ts_event: int = self._clock.timestamp_ns()
-        self.generate_account_state(
-            balances=balances,
-            margins=margins,
-            reported=True,
-            ts_event=ts_event,
+    async def _cancel_all_orders(self, command: CancelAllOrders) -> None:
+        raise NotImplementedError(  # pragma: no cover
+            "implement the `_cancel_all_orders` coroutine",  # pragma: no cover
         )
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/interactive_brokers/gateway.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/gateway.py`

 * *Files 6% similar despite different names*

```diff
@@ -10,28 +10,28 @@
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 import logging
+import os
 import warnings
 from enum import IntEnum
 from time import sleep
 from typing import Optional
 
 
 try:
     import docker
 except ImportError as e:
     warnings.warn(
         f"Docker required for Gateway, install manually via `pip install docker` ({e})",
     )
     docker = None
-from ib_insync import IB
 
 
 class ContainerStatus(IntEnum):
     NO_CONTAINER = 1
     CONTAINER_CREATED = 2
     CONTAINER_STARTING = 3
     CONTAINER_STOPPED = 4
@@ -41,45 +41,47 @@
 
 
 class InteractiveBrokersGateway:
     """
     A class to manage starting an Interactive Brokers Gateway docker container
     """
 
-    IMAGE = "ghcr.io/unusualalpha/ib-gateway"
+    IMAGE = "ghcr.io/unusualalpha/ib-gateway:stable"
     CONTAINER_NAME = "nautilus-ib-gateway"
     PORTS = {"paper": 4002, "live": 4001}
 
     def __init__(
         self,
         username: str,
         password: str,
         host: Optional[str] = "localhost",
         port: Optional[int] = None,
         trading_mode: Optional[str] = "paper",
         start: bool = False,
         read_only_api: bool = True,
+        timeout: int = 90,
         logger: Optional[logging.Logger] = None,
     ):
-        assert username is not None, "`username` not set"
-        assert password is not None, "`password` not set"
+        username = username if username is not None else os.environ["TWS_USERNAME"]
+        password = password if password is not None else os.environ["TWS_PASSWORD"]
+        assert username is not None, "`username` not set nor available in env `TWS_USERNAME`"
+        assert password is not None, "`password` not set nor available in env `TWS_PASSWORD`"
         self.username = username
         self.password = password
         self.trading_mode = trading_mode
         self.read_only_api = read_only_api
         self.host = host
         self.port = port or self.PORTS[trading_mode]
         if docker is None:
             raise RuntimeError("Docker not installed")
         self._docker = docker.from_env()
-        self._client: Optional[IB] = None
         self._container = None
         self.log = logger or logging.getLogger("nautilus_trader")
         if start:
-            self.start()
+            self.start(timeout)
 
     @classmethod
     def from_container(cls, **kwargs):
         """Connect to an already running container - don't stop/start"""
         self = cls(username="", password="", **kwargs)
         assert self.container, "Container does not exist"
         return self
@@ -99,24 +101,17 @@
         else:
             return ContainerStatus.UNKNOWN
 
     @property
     def container(self):
         if self._container is None:
             all_containers = {c.name: c for c in self._docker.containers.list(all=True)}
-            self._container = all_containers.get(self.CONTAINER_NAME)
+            self._container = all_containers.get(f"{self.CONTAINER_NAME}-{self.port}")
         return self._container
 
-    @property
-    def client(self) -> IB:
-        if self._client is None:
-            self._client = IB()
-            self._client.connect(host=self.host, port=self.port)
-        return self._client
-
     @staticmethod
     def is_logged_in(container) -> bool:
         try:
             logs = container.logs()
         except NoContainer:
             return False
         return any(b"Forking :::" in line for line in logs.split(b"\n"))
@@ -142,43 +137,47 @@
         status = self.container_status
         if status == ContainerStatus.NO_CONTAINER:
             self.log.debug("No container, starting")
         elif status in broken_statuses:
             self.log.debug(f"{status=}, removing existing container")
             self.stop()
         elif status in (ContainerStatus.READY, ContainerStatus.CONTAINER_STARTING):
-            raise ContainerExists
+            self.log.info(f"{status=}, using existing container")
+            return
 
         self.log.debug("Starting new container")
         self._container = self._docker.containers.run(
             image=self.IMAGE,
-            name=self.CONTAINER_NAME,
+            name=f"{self.CONTAINER_NAME}-{self.port}",
+            restart_policy={"Name": "always"},
             detach=True,
-            ports={"4001": "4001", "4002": "4002", "5900": "5900"},
+            ports={str(self.port): self.PORTS[self.trading_mode], str(self.port + 100): "5900"},
             platform="amd64",
             environment={
                 "TWS_USERID": self.username,
                 "TWS_PASSWORD": self.password,
                 "TRADING_MODE": self.trading_mode,
                 "READ_ONLY_API": {True: "yes", False: "no"}[self.read_only_api],
             },
         )
-        self.log.info("Container starting, waiting for ready")
+        self.log.info(f"Container `{self.CONTAINER_NAME}-{self.port}` starting, waiting for ready")
 
         if wait is not None:
             for _ in range(wait):
                 if self.is_logged_in(container=self._container):
                     break
                 else:
                     self.log.debug("Waiting for IB Gateway to start ..")
                     sleep(1)
             else:
                 raise GatewayLoginFailure
 
-        self.log.info("Gateway ready")
+        self.log.info(
+            f"Gateway `{self.CONTAINER_NAME}-{self.port}` ready. VNC port is {self.port+100}",
+        )
 
     def safe_start(self, wait: int = 90):
         try:
             self.start(wait=wait)
         except ContainerExists:
             return
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/interactive_brokers/historic.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/historic.py`

 * *Files 2% similar despite different names*

```diff
@@ -25,19 +25,19 @@
 from ib_insync import Contract
 from ib_insync import HistoricalTickBidAsk
 from ib_insync import HistoricalTickLast
 
 from nautilus_trader.adapters.interactive_brokers.parsing.data import generate_trade_id
 from nautilus_trader.adapters.interactive_brokers.parsing.instruments import parse_instrument
 from nautilus_trader.core.datetime import dt_to_unix_nanos
-from nautilus_trader.model.data.bar import Bar
-from nautilus_trader.model.data.bar import BarSpecification
-from nautilus_trader.model.data.bar import BarType
-from nautilus_trader.model.data.tick import QuoteTick
-from nautilus_trader.model.data.tick import TradeTick
+from nautilus_trader.model.data import Bar
+from nautilus_trader.model.data import BarSpecification
+from nautilus_trader.model.data import BarType
+from nautilus_trader.model.data import QuoteTick
+from nautilus_trader.model.data import TradeTick
 from nautilus_trader.model.enums import AggregationSource
 from nautilus_trader.model.enums import AggressorSide
 from nautilus_trader.model.enums import bar_aggregation_to_str
 from nautilus_trader.model.enums import price_type_to_str
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.instruments import Instrument
 from nautilus_trader.model.objects import Price
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/interactive_brokers/parsing/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/parsing/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/interactive_brokers/parsing/data.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/parsing/data.py`

 * *Files 20% similar despite different names*

```diff
@@ -10,28 +10,28 @@
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 import datetime
+from decimal import Decimal
 
-from ib_insync import BarData
-
-from nautilus_trader.core.datetime import dt_to_unix_nanos
+# fmt: off
 from nautilus_trader.core.datetime import nanos_to_secs
-from nautilus_trader.model.data.bar import Bar
-from nautilus_trader.model.data.bar import BarSpecification
-from nautilus_trader.model.data.bar_aggregation import BarAggregation
+from nautilus_trader.model.data import BarAggregation
+from nautilus_trader.model.data import BarSpecification
 from nautilus_trader.model.enums import BookAction
 from nautilus_trader.model.enums import OrderSide
+from nautilus_trader.model.enums import PriceType
 from nautilus_trader.model.identifiers import TradeId
-from nautilus_trader.model.instruments import Instrument
 
 
+# fmt: on
+
 MKT_DEPTH_OPERATIONS = {
     0: BookAction.ADD,
     1: BookAction.UPDATE,
     2: BookAction.DELETE,
 }
 
 IB_SIDE = {1: OrderSide.BUY, 0: OrderSide.SELL}
@@ -40,57 +40,43 @@
 IB_TICK_TYPE = {
     1: "Last",
     2: "AllLast",
     3: "BidAsk",
     4: "MidPoint",
 }
 
+what_to_show = {
+    PriceType.ASK: "ASK",
+    PriceType.BID: "BID",
+    PriceType.LAST: "TRADES",
+    PriceType.MID: "MIDPOINT",
+}
+
 
-def generate_trade_id(ts_event: int, price: float, size: float) -> TradeId:
+def generate_trade_id(ts_event: int, price: float, size: Decimal) -> TradeId:
     id = TradeId(f"{int(nanos_to_secs(ts_event))}-{price}-{size}")
     assert len(id.value) < 36, f"TradeId too long, was {len(id.value)}"
     return id
 
 
-def parse_bar_data(
-    bar: BarData,
-    is_revision: bool,
-    bar_type: Bar,
-    instrument: Instrument,
-    ts_init: int,
-) -> Bar:
-    return Bar(
-        bar_type=bar_type,
-        open=instrument.make_price(bar.open),
-        high=instrument.make_price(bar.high),
-        low=instrument.make_price(bar.low),
-        close=instrument.make_price(bar.close),
-        volume=instrument.make_qty(max(bar.volume, 0)),
-        ts_event=dt_to_unix_nanos(bar.date),
-        ts_init=ts_init,
-        is_revision=is_revision,
-    )
-
-
-def bar_spec_to_bar_size(bar_spec: BarSpecification) -> tuple:
+def bar_spec_to_bar_size(bar_spec: BarSpecification) -> str:
     aggregation = bar_spec.aggregation
     step = bar_spec.step
     if aggregation == BarAggregation.SECOND and step == 5:
-        return True, f"{step} secs"  # When True uses RealTimeBar (existing behavior),
-        # When False uses subscription with Historical Data
+        return f"{step} secs"
     elif aggregation == BarAggregation.SECOND and step in [10, 15, 30]:
-        return False, f"{step} secs"
+        return f"{step} secs"
     elif aggregation == BarAggregation.MINUTE and step in [1, 2, 3, 5, 10, 15, 20, 30]:
-        return False, f"{step} min{'' if step == 1 else 's'}"
+        return f"{step} min{'' if step == 1 else 's'}"
     elif aggregation == BarAggregation.HOUR and step in [1, 2, 3, 4, 8]:
-        return False, f"{step} hour{'' if step == 1 else 's'}"
+        return f"{step} hour{'' if step == 1 else 's'}"
     elif aggregation == BarAggregation.DAY and step == 1:
-        return False, f"{step} day"
+        return f"{step} day"
     elif aggregation == BarAggregation.WEEK and step == 1:
-        return False, f"{step} week"
+        return f"{step} week"
     else:
         raise ValueError(
             f"InteractiveBrokers doesn't support subscription for {bar_spec!r}",
         )
 
 
 def timedelta_to_duration_str(duration: datetime.timedelta) -> str:
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/interactive_brokers/providers.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/providers.py`

 * *Files 24% similar despite different names*

```diff
@@ -9,240 +9,283 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-import asyncio
-import datetime as dt
-import json
-from typing import Optional
-
-import ib_insync
-import msgspec
-import numpy as np
+import copy
+from typing import Optional, Union
+
 import pandas as pd
-from ib_insync import Contract
-from ib_insync import ContractDetails
-from ib_insync import Future
+from ibapi.contract import ContractDetails
 
+# fmt: off
+from nautilus_trader.adapters.interactive_brokers.client import InteractiveBrokersClient
 from nautilus_trader.adapters.interactive_brokers.common import IB_VENUE
+from nautilus_trader.adapters.interactive_brokers.common import IBContract
+from nautilus_trader.adapters.interactive_brokers.common import IBContractDetails
+from nautilus_trader.adapters.interactive_brokers.config import InteractiveBrokersInstrumentProviderConfig
+from nautilus_trader.adapters.interactive_brokers.parsing.instruments import instrument_id_to_ib_contract
 from nautilus_trader.adapters.interactive_brokers.parsing.instruments import parse_instrument
-from nautilus_trader.common.functions import one
 from nautilus_trader.common.logging import Logger
 from nautilus_trader.common.providers import InstrumentProvider
-from nautilus_trader.config import InstrumentProviderConfig
 from nautilus_trader.config.common import resolve_path
 from nautilus_trader.model.identifiers import InstrumentId
-from nautilus_trader.model.instruments import Instrument
+from nautilus_trader.model.instruments.base import Instrument
+
+
+# fmt: on
 
 
 class InteractiveBrokersInstrumentProvider(InstrumentProvider):
     """
     Provides a means of loading `Instrument` objects through Interactive Brokers.
-
-    Parameters
-    ----------
-    client : ib_insync.IB
-        The Interactive Brokers client.
-    config : InstrumentProviderConfig
-        The instrument provider config
-    logger : Logger
-        The logger for the instrument provider.
-    host : str
-        The client host name or IP address.
-    port : str
-        The client port number.
-    client_id : int
-        The unique client ID number for the connection.
     """
 
     def __init__(
         self,
-        client: ib_insync.IB,
-        config: InstrumentProviderConfig,
+        client: InteractiveBrokersClient,
+        config: InteractiveBrokersInstrumentProviderConfig,
         logger: Logger,
-        host: str = "127.0.0.1",
-        port: int = 7497,
-        client_id: int = 1,
-    ) -> None:
+    ):
+        """
+        Initialize a new instance of the ``InteractiveBrokersInstrumentProvider`` class.
+
+        Parameters
+        ----------
+        client : InteractiveBrokersClient
+            The Interactive Brokers client.
+        config : InteractiveBrokersInstrumentProviderConfig
+            The instrument provider config
+        logger : Logger
+            The logger for the instrument provider.
+
+        """
         super().__init__(
             venue=IB_VENUE,
             logger=logger,
             config=config,
         )
 
+        # Settings
+        self._load_contracts_on_start = (
+            set(config.load_contracts) if config.load_contracts is not None else None
+        )
+        self._min_expiry_days = config.min_expiry_days
+        self._max_expiry_days = config.max_expiry_days
+        self._build_options_chain = config.build_options_chain
+        self._build_futures_chain = config.build_futures_chain
+        self._cache_validity_days = config.cache_validity_days
+        # TODO: If cache_validity_days > 0 and Catalog is provided
+
         self._client = client
-        self._host = host
-        self._port = port
-        self._client_id = client_id
         self.config = config
-        self.contract_details: dict[str, ContractDetails] = {}
+        self.contract_details: dict[str, IBContractDetails] = {}
         self.contract_id_to_instrument_id: dict[int, InstrumentId] = {}
 
     async def load_all_async(self, filters: Optional[dict] = None) -> None:
-        for f in self._parse_filters(filters=filters or {}):
-            filt = dict(f)
-            kw = {
-                "build_options_chain": filt.pop("build_options_chain", False),
-                "option_kwargs": filt.pop("option_kwargs", None),
-            }
-            await self.load(**filt, **kw)
-
-    @staticmethod
-    def _one_not_both(a, b):
-        return a or b and not (a and b)
-
-    @staticmethod
-    def _parse_contract(**kwargs) -> Contract:
-        sec_type = kwargs.pop("secType", None)
-        return Contract(secType=sec_type, **kwargs)
-
-    @staticmethod
-    def _parse_filters(filters):
-        return msgspec.json.decode(filters)
+        await self.load_ids_async([])
 
     async def load_ids_async(
         self,
         instrument_ids: list[InstrumentId],
         filters: Optional[dict] = None,
     ) -> None:
-        assert self._one_not_both(instrument_ids, filters)
-        for filt in self._parse_filters(filters):
-            await self.load(**dict(filt or {}))
+        # Parse and load InstrumentIds
+        if self._load_ids_on_start:
+            for instrument_id in [
+                (InstrumentId.from_str(i) if isinstance(i, str) else i)
+                for i in self._load_ids_on_start
+            ]:
+                await self.load_async(instrument_id)
+        # Load IBContracts
+        if self._load_contracts_on_start:
+            for contract in [
+                (IBContract(**c) if isinstance(c, dict) else c)
+                for c in self._load_contracts_on_start
+            ]:
+                await self.load_async(contract)
 
     async def get_contract_details(
         self,
-        contract: Contract,
-        build_futures_chain=False,
-        build_options_chain=False,
-        option_kwargs: Optional[str] = None,
+        contract: IBContract,
     ) -> list[ContractDetails]:
-        if build_futures_chain:
-            return await self.get_future_chain_details(contract)
-        elif build_options_chain:
-            return await self.get_option_chain_details(
-                underlying=contract, **(json.loads(option_kwargs or "{}"))
+        try:
+            details = await self._client.get_contract_details(contract=contract)
+            [qualified] = details
+            self._log.info(
+                f"Contract qualified for {qualified.contract.localSymbol}."
+                f"{qualified.contract.primaryExchange or qualified.contract.exchange} "
+                f"with ConId={qualified.contract.conId}",
             )
-        else:
-            # Regular contract
-            return await self._client.reqContractDetailsAsync(contract=contract)
+            self._log.debug(f"Got {details=}")
+        except ValueError as e:
+            self._log.error(f"No contract details found for the given kwargs {contract}, {e}")
+            return []
+        min_expiry = pd.Timestamp.now() + pd.Timedelta(
+            days=(contract.min_expiry_days or self._min_expiry_days or 0),
+        )
+        max_expiry = pd.Timestamp.now() + pd.Timedelta(
+            days=(contract.max_expiry_days or self._max_expiry_days or 90),
+        )
+
+        if (
+            contract.secType in ["FUT", "CONTFUT"]
+            and contract.build_futures_chain
+            or self._build_futures_chain
+        ):
+            # Return Underlying contract details with Future Chains
+            details = await self.get_future_chain_details(
+                underlying=qualified.contract,
+                min_expiry=min_expiry,
+                max_expiry=max_expiry,
+            )
+        elif contract.secType == "CONTFUT":
+            # Get Active Month's Future
+            details = await self._client.get_contract_details(
+                IBContract(
+                    secType="FUT",
+                    localSymbol=qualified.contract.localSymbol,
+                    exchange=qualified.contract.exchange,
+                    tradingClass=qualified.contract.tradingClass,
+                ),
+            )
+            self._log.debug(f"Got {details=}")
+
+        if (
+            contract.secType in ["STK", "FUT"]
+            and contract.build_options_chain
+            or self._build_options_chain
+        ):
+            # Return Underlying contract details with Option Chains, including for the Future Chains if apply
+            for detail in set(details):
+                details.extend(
+                    await self.get_option_chain_details(
+                        underlying=detail.contract,
+                        min_expiry=min_expiry,
+                        max_expiry=max_expiry,
+                        last_trading_date=contract.lastTradeDateOrContractMonth,
+                    ),
+                )
+        return details
 
     async def get_future_chain_details(
         self,
-        underlying: Contract,
-        exchange: Optional[str] = None,
-        currency: Optional[str] = None,
-        **kwargs,
+        underlying: IBContract,
+        min_expiry: pd.Timestamp,
+        max_expiry: pd.Timestamp,
     ) -> list[ContractDetails]:
-        futures = self._client.reqContractDetails(
-            Future(
+        self._log.info(f"Building futures chain for {underlying.symbol}.{underlying.exchange}")
+        details = await self._client.get_contract_details(
+            IBContract(
+                secType="FUT",
                 symbol=underlying.symbol,
-                exchange=exchange or underlying.exchange or "SMART",
-                currency=currency or underlying.currency,
-                **kwargs,
+                exchange=underlying.exchange,
+                tradingClass=underlying.tradingClass,
+                includeExpired=True,
             ),
         )
-        return futures
+        self._log.debug(f"Got {details=}")
+        return details
 
     async def get_option_chain_details(
         self,
-        underlying: Contract,
-        min_expiry: Optional[dt.date] = None,
-        max_expiry: Optional[dt.date] = None,
-        min_strike: Optional[float] = None,
-        max_strike: Optional[float] = None,
-        kind: Optional[str] = None,
+        underlying: IBContract,
+        min_expiry: pd.Timestamp,
+        max_expiry: pd.Timestamp,
+        last_trading_date: str,
         exchange: Optional[str] = None,
     ) -> list[ContractDetails]:
-        chains = await self._client.reqSecDefOptParamsAsync(
-            underlying.symbol,
-            "",
-            underlying.secType,
-            underlying.conId,
-        )
-
-        chain = one(
-            [chain for chain in chains if chain.exchange == (exchange or underlying.exchange)],
-        )
+        if last_trading_date:
+            expirations = [last_trading_date]
+        else:
+            try:
+                chains = await self._client.get_option_chains(underlying)
+                [chain] = [chain for chain in chains if chain[0] == (exchange or "SMART")]
+            except ValueError as e:
+                self._log.error(
+                    f"No chain details loaded for the given underlying {underlying}, {e}",
+                )
+                return []
 
-        strikes = [
-            strike
-            for strike in chain.strikes
-            if (min_strike or -np.inf) <= strike <= (max_strike or np.inf)
-        ]
-        expirations = sorted(
-            exp
-            for exp in chain.expirations
-            if (pd.Timestamp(min_expiry or pd.Timestamp.min) <= pd.Timestamp(exp))
-            and (pd.Timestamp(exp) <= pd.Timestamp(max_expiry or pd.Timestamp.max))
-        )
-        rights = [kind] if kind is not None else ["P", "C"]
+            expirations = sorted(
+                exp for exp in chain[1] if (min_expiry <= pd.Timestamp(exp) <= max_expiry)
+            )
 
-        contracts = [
-            ib_insync.Option(
-                underlying.symbol,
-                expiration,
-                strike,
-                right,
-                exchange or underlying.exchange or "SMART",
-            )
-            for right in rights
-            for expiration in expirations
-            for strike in strikes
-        ]
-        qualified = await self._client.qualifyContractsAsync(*contracts)
-        details = await asyncio.gather(
-            *[self._client.reqContractDetailsAsync(contract=c) for c in qualified]
-        )
-        return [x for d in details for x in d]
+        details = []
+        for expiration in expirations:
+            [option_details] = (
+                await self._client.get_contract_details(
+                    IBContract(
+                        secType="OPT",
+                        symbol=underlying.symbol,
+                        lastTradeDateOrContractMonth=expiration,
+                        exchange=exchange or "SMART",
+                    ),
+                ),
+            )
+            option_details = [d for d in option_details if d.underConId == underlying.conId]
+            self._log.info(
+                f"Received {len(option_details)} Option Contracts for "
+                f"{underlying.symbol}.{underlying.primaryExchange or underlying.exchange} expiring on {expiration}",
+            )
+            self._log.debug(f"Got {option_details=}")
+            details.extend(option_details)
+        # Finally we need to match the conId with underlying because results may include other securities
+        return details
 
-    async def load(  # type: ignore
+    async def load_async(
         self,
-        build_options_chain=False,
-        option_kwargs=None,
-        **kwargs,
-    ) -> None:
+        instrument_id: Union[InstrumentId, IBContract],
+        filters: Optional[dict] = None,
+    ):
         """
-        Search and load the instrument for the given symbol, exchange and (optional) kwargs.
+        Search and load the instrument for the given IBContract.
+        It is important that the Contract shall have enough parameters so only one match is returned.
 
         Parameters
         ----------
-        build_options_chain : bool, default False
-            Search for full option chain.
-        option_kwargs : str, default False
-            JSON string for options filtering, available fields: min_expiry, max_expiry, min_strike, max_strike, kind.
-        kwargs : **kwargs
-            Optional extra kwargs to search for, examples:
-                secType, conId, symbol, lastTradeDateOrContractMonth, strike, right, multiplier, exchange,
-                primaryExchange, currency, localSymbol, tradingClass, includeExpired, secIdType, secId,
-                comboLegsDescrip, comboLegs,  deltaNeutralContract.
+        instrument_id : IBContract
+            InteractiveBroker's Contract.
+        filters : dict, optional
+            Not applicable in this case.
         """
-        self._log.debug(f"Attempting to find instrument for {kwargs=}")
-        contract = self._parse_contract(**kwargs)
-        self._log.debug(f"Parsed {contract=}")
-        qualified = await self._client.qualifyContractsAsync(contract)
-        qualified = one(qualified)
-        self._log.debug(f"Qualified {contract=}")
-        contract_details: list[ContractDetails] = await self.get_contract_details(
-            qualified,
-            build_options_chain=build_options_chain,
-            option_kwargs=option_kwargs,
-        )
-        if not contract_details:
-            raise ValueError(f"No contract details found for the given kwargs ({kwargs})")
-        self._log.debug(f"Got {contract_details=}")
+        if isinstance(instrument_id, InstrumentId):
+            try:
+                contract = instrument_id_to_ib_contract(instrument_id)
+            except ValueError as e:
+                self._log.error(f"{e}")
+                return
+        elif isinstance(instrument_id, IBContract):
+            contract = instrument_id
+        else:
+            self._log.error(f"Expected InstrumentId or IBContract, received {instrument_id}")
+            return
 
-        for details in contract_details:
+        self._log.debug(f"Attempting to find instrument for {contract=}")
+        contract_details: list[ContractDetails]
+        if not (contract_details := await self.get_contract_details(contract)):
+            return
+        for details in copy.deepcopy(contract_details):
+            details.contract = IBContract(**details.contract.__dict__)
+            details = IBContractDetails(**details.__dict__)
             self._log.debug(f"Attempting to create instrument from {details}")
             instrument: Instrument = parse_instrument(
                 contract_details=details,
             )
             if self.config.filter_callable is not None:
                 filter_callable = resolve_path(self.config.filter_callable)
                 if not filter_callable(instrument):
                     continue
-            self._log.info(f"Adding {instrument=} from IB instrument provider")
+            self._log.info(f"Adding {instrument=} from InteractiveBrokersInstrumentProvider")
             self.add(instrument)
             self.contract_details[instrument.id.value] = details
             self.contract_id_to_instrument_id[details.contract.conId] = instrument.id
+
+    async def find_with_contract_id(self, contract_id: int) -> Instrument:
+        instrument_id = self.contract_id_to_instrument_id.get(contract_id)
+        if not instrument_id:
+            await self.load_async(IBContract(conId=contract_id))
+            instrument_id = self.contract_id_to_instrument_id.get(contract_id)
+        instrument = self.find(instrument_id)
+        return instrument
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/interactive_brokers/web.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/web.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/sandbox/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/sandbox/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/sandbox/config.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/sandbox/config.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/sandbox/execution.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/sandbox/execution.py`

 * *Files 4% similar despite different names*

```diff
@@ -30,20 +30,19 @@
 from nautilus_trader.common.providers import InstrumentProvider
 from nautilus_trader.core.data import Data
 from nautilus_trader.execution.reports import OrderStatusReport
 from nautilus_trader.execution.reports import PositionStatusReport
 from nautilus_trader.execution.reports import TradeReport
 from nautilus_trader.live.execution_client import LiveExecutionClient
 from nautilus_trader.model.currency import Currency
-from nautilus_trader.model.data.bar import Bar
-from nautilus_trader.model.data.book import OrderBookDelta
-from nautilus_trader.model.data.book import OrderBookDeltas
-from nautilus_trader.model.data.book import OrderBookSnapshot
-from nautilus_trader.model.data.tick import QuoteTick
-from nautilus_trader.model.data.tick import TradeTick
+from nautilus_trader.model.data import Bar
+from nautilus_trader.model.data import OrderBookDelta
+from nautilus_trader.model.data import OrderBookDeltas
+from nautilus_trader.model.data import QuoteTick
+from nautilus_trader.model.data import TradeTick
 from nautilus_trader.model.enums import AccountType
 from nautilus_trader.model.enums import OmsType
 from nautilus_trader.model.identifiers import ClientId
 from nautilus_trader.model.identifiers import ClientOrderId
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.identifiers import Venue
 from nautilus_trader.model.identifiers import VenueOrderId
@@ -81,15 +80,15 @@
         clock: LiveClock,
         logger: Logger,
         venue: str,
         currency: str,
         balance: int,
         oms_type: OmsType = OmsType.NETTING,
         account_type: AccountType = AccountType.MARGIN,
-    ):
+    ) -> None:
         self._currency = Currency.from_str(currency)
         money = Money(value=balance, currency=self._currency)
         self.balance = AccountBalance(total=money, locked=Money(0, money.currency), free=money)
         self.test_clock = TestClock()
         self._account_type = account_type
         sandbox_venue = Venue(venue)
         super().__init__(
@@ -129,25 +128,25 @@
             msgbus=msgbus,
             cache=self._cache,
             clock=self.test_clock,
             logger=logger,
         )
         self.exchange.register_client(self._client)
 
-    def connect(self):
+    def connect(self) -> None:
         """
         Connect the client.
         """
         self._log.info("Connecting...")
         self._msgbus.subscribe("data.*", handler=self.on_data)
         self._client._set_connected(True)
         self._set_connected(True)
         self._log.info("Connected.")
 
-    def disconnect(self):
+    def disconnect(self) -> None:
         """
         Disconnect the client.
         """
         self._log.info("Disconnecting...")
         self._set_connected(False)
         self._log.info("Disconnected.")
 
@@ -193,18 +192,20 @@
 
     def cancel_order(self, command):
         return self._client.cancel_order(command)
 
     def cancel_all_orders(self, command):
         return self._client.cancel_all_orders(command)
 
-    def on_data(self, data: Data):
+    def on_data(self, data: Data) -> None:
         # Taken from main backtest loop of BacktestEngine
-        if isinstance(data, (OrderBookDelta, OrderBookDeltas, OrderBookSnapshot)):
-            self.exchange.process_order_book(data)
+        if isinstance(data, (OrderBookDelta)):
+            self.exchange.process_order_book_delta(data)
+        elif isinstance(data, (OrderBookDeltas)):
+            self.exchange.process_order_book_deltas(data)
         elif isinstance(data, QuoteTick):
             self.exchange.process_quote_tick(data)
         elif isinstance(data, TradeTick):
             self.exchange.process_trade_tick(data)
         elif isinstance(data, Bar):
             self.exchange.process_bar(data)
         self.exchange.process(data.ts_init)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/adapters/sandbox/factory.py` & `nautilus_trader-1.175.0/nautilus_trader/adapters/sandbox/factory.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/analysis/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/analysis/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/analysis/analyzer.py` & `nautilus_trader-1.175.0/nautilus_trader/analysis/analyzer.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/analysis/reporter.py` & `nautilus_trader-1.175.0/nautilus_trader/analysis/reporter.py`

 * *Files 1% similar despite different names*

```diff
@@ -15,15 +15,15 @@
 
 import msgspec
 import pandas as pd
 
 from nautilus_trader.accounting.accounts.base import Account
 from nautilus_trader.core.datetime import unix_nanos_to_dt
 from nautilus_trader.model.enums import OrderStatus
-from nautilus_trader.model.events.account import AccountState
+from nautilus_trader.model.events import AccountState
 from nautilus_trader.model.orders import Order
 from nautilus_trader.model.position import Position
 
 
 class ReportProvider:
     """
     Provides various portfolio analysis reports.
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/analysis/statistic.py` & `nautilus_trader-1.175.0/nautilus_trader/analysis/statistic.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/expectancy.py` & `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/expectancy.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/long_ratio.py` & `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/long_ratio.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/loser_avg.py` & `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/loser_avg.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/loser_max.py` & `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/loser_max.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/loser_min.py` & `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/loser_min.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/profit_factor.py` & `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/profit_factor.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/returns_avg.py` & `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/returns_avg.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/returns_avg_loss.py` & `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/returns_avg_loss.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/returns_avg_win.py` & `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/returns_avg_win.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/returns_volatility.py` & `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/returns_volatility.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/risk_return_ratio.py` & `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/risk_return_ratio.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/sharpe_ratio.py` & `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/sharpe_ratio.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/sortino_ratio.py` & `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/sortino_ratio.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/win_rate.py` & `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/win_rate.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/winner_avg.py` & `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/winner_avg.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/winner_max.py` & `nautilus_trader-1.175.0/nautilus_trader/analysis/statistics/winner_min.py`

 * *Files 18% similar despite different names*

```diff
@@ -11,24 +11,29 @@
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from typing import Any, Optional
 
+import numpy as np
 import pandas as pd
 
 from nautilus_trader.analysis.statistic import PortfolioStatistic
 
 
-class MaxWinner(PortfolioStatistic):
+class MinWinner(PortfolioStatistic):
     """
-    Calculates the maximum winner from a series of PnLs.
+    Calculates the minimum winner from a series of PnLs.
     """
 
     def calculate_from_realized_pnls(self, realized_pnls: pd.Series) -> Optional[Any]:
         # Preconditions
         if realized_pnls is None or realized_pnls.empty:
             return 0.0
 
         # Calculate statistic
-        return max(realized_pnls)
+        winners = [x for x in realized_pnls if x > 0.0]
+        if not winners:
+            return 0.0
+
+        return min(np.asarray(winners, dtype=np.float64))
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/analysis/statistics/winner_min.py` & `nautilus_trader-1.175.0/nautilus_trader/indicators/obv.pxd`

 * *Files 25% similar despite different names*

```diff
@@ -9,31 +9,19 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from typing import Any, Optional
+from nautilus_trader.indicators.base.indicator cimport Indicator
 
-import numpy as np
-import pandas as pd
 
-from nautilus_trader.analysis.statistic import PortfolioStatistic
+cdef class OnBalanceVolume(Indicator):
+    cdef object _obv
 
+    cdef readonly int period
+    """The window period.\n\n:returns: `int`"""
+    cdef readonly double value
+    """The current value.\n\n:returns: `double`"""
 
-class MinWinner(PortfolioStatistic):
-    """
-    Calculates the minimum winner from a series of PnLs.
-    """
-
-    def calculate_from_realized_pnls(self, realized_pnls: pd.Series) -> Optional[Any]:
-        # Preconditions
-        if realized_pnls is None or realized_pnls.empty:
-            return 0.0
-
-        # Calculate statistic
-        winners = [x for x in realized_pnls if x > 0.0]
-        if not winners:
-            return 0.0
-
-        return min(np.asarray(winners, dtype=np.float64))
+    cpdef void update_raw(self, double open, double close, double volume)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/backtest/__init__.pxd` & `nautilus_trader-1.175.0/nautilus_trader/backtest/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/backtest/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/backtest/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/backtest/__main__.py` & `nautilus_trader-1.175.0/nautilus_trader/backtest/__main__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/backtest/auction.py` & `nautilus_trader-1.175.0/nautilus_trader/backtest/auction.py`

 * *Files 10% similar despite different names*

```diff
@@ -9,81 +9,77 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.model.data.book import BookOrder
-from nautilus_trader.model.enums import OrderSide
-from nautilus_trader.model.orderbook.ladder import Ladder
 
-
-def default_auction_match(left: Ladder, right: Ladder) -> tuple[list, list]:
-    """Match bid/ask Ladders as default auction match function."""
-    if not (left.top() and right.top()):
-        return [], []
-    bid_volume = volume_traded_at_price(left, right.top().price, side=OrderSide.BUY)
-    ask_volume = volume_traded_at_price(right, left.top().price, side=OrderSide.SELL)
-    matched_volume = min(bid_volume, ask_volume)
-
-    if matched_volume == 0:
-        return [], []
-
-    traded_bids = find_trades_for_volume(left, matched_volume)
-    traded_asks = find_trades_for_volume(right, matched_volume)
-
-    return traded_bids, traded_asks
-
-
-def valid_trade_price(order_price, side, target_price):
-    if side == OrderSide.BUY:
-        return target_price <= order_price
-    if side == OrderSide.SELL:
-        return target_price >= order_price
-    else:
-        raise RuntimeError(side)
-
-
-def volume_traded_at_price(ladder: Ladder, price: float, side: OrderSide) -> float:
-    """Determine the total volume available to trade in `ladder` up to a certain `price`."""
-    total_volume = 0.0
-    for level in ladder.levels:
-        if not valid_trade_price(order_price=level.price, side=side, target_price=price):
-            break
-        else:
-            total_volume += level.volume()
-    return total_volume
-
-
-def find_trades_for_volume(ladder: Ladder, target_volume: float) -> list[BookOrder]:
-    """Assuming `target_volume` size has traded, find all trades up to that volume."""
-    remaining_size = target_volume
-    orders: list[BookOrder] = []
-    for level in ladder.levels:
-        if (remaining_size - level.volume()) > 0:
-            # Add the whole level
-            orders.extend(level.orders)
-            remaining_size -= level.volume()
-        elif remaining_size == 0.0:
-            break
-        else:
-            # We're going to be fully filled somewhere on this level
-            for order in level.orders:
-                order_volume = remaining_size - order.size
-                if order_volume > 0:
-                    # Size remaining, add this order and continue
-                    orders.append(order)
-                    remaining_size -= order.size
-                elif order_volume == 0.0:
-                    # Exactly this order volume remaining, add and break
-                    orders.append(order)
-                    remaining_size -= order.size
-                    break
-                elif order_volume < 0:
-                    # Less than this whole order volume remaining, add a partial fill
-                    fill_volume = remaining_size
-                    partial_order = BookOrder(order.price, fill_volume, order.side, order.order_id)
-                    orders.append(partial_order)
-                    remaining_size -= partial_order.size
-                    break
-    return orders
+# def default_auction_match(left: Ladder, right: Ladder) -> tuple[list, list]:
+#     """Match bid/ask Ladders as default auction match function."""
+#     if not (left.top() and right.top()):
+#         return [], []
+#     bid_volume = volume_traded_at_price(left, right.top().price, side=OrderSide.BUY)
+#     ask_volume = volume_traded_at_price(right, left.top().price, side=OrderSide.SELL)
+#     matched_volume = min(bid_volume, ask_volume)
+#
+#     if matched_volume == 0:
+#         return [], []
+#
+#     traded_bids = find_trades_for_volume(left, matched_volume)
+#     traded_asks = find_trades_for_volume(right, matched_volume)
+#
+#     return traded_bids, traded_asks
+#
+#
+# def valid_trade_price(order_price, side, target_price):
+#     if side == OrderSide.BUY:
+#         return target_price <= order_price
+#     if side == OrderSide.SELL:
+#         return target_price >= order_price
+#     else:
+#         raise RuntimeError(side)
+#
+#
+# def volume_traded_at_price(ladder: Ladder, price: float, side: OrderSide) -> float:
+#     """Determine the total volume available to trade in `ladder` up to a certain `price`."""
+#     total_volume = 0.0
+#     for level in ladder.levels:
+#         if not valid_trade_price(order_price=level.price, side=side, target_price=price):
+#             break
+#         else:
+#             total_volume += level.volume()
+#     return total_volume
+#
+#
+# def find_trades_for_volume(ladder: Ladder, target_volume: float) -> list[BookOrder]:
+#     """Assuming `target_volume` size has traded, find all trades up to that volume."""
+#     remaining_size = target_volume
+#     orders: list[BookOrder] = []
+#     for level in ladder.levels:
+#         if (remaining_size - level.volume()) > 0:
+#             # Add the whole level
+#             orders.extend(level.orders)
+#             remaining_size -= level.volume()
+#         elif remaining_size == 0.0:
+#             break
+#         else:
+#             # We're going to be fully filled somewhere on this level
+#             for order in level.orders:
+#                 order_volume = remaining_size - order.size
+#                 if order_volume > 0:
+#                     # Size remaining, add this order and continue
+#                     orders.append(order)
+#                     remaining_size -= order.size
+#                 elif order_volume == 0.0:
+#                     # Exactly this order volume remaining, add and break
+#                     orders.append(order)
+#                     remaining_size -= order.size
+#                     break
+#                 elif order_volume < 0:
+#                     # Less than this whole order volume remaining, add a partial fill
+#                     fill_volume = remaining_size
+#                     partial_order = BookOrder(order.price, fill_volume, order.side, order.order_id)
+#                     orders.append(partial_order)
+#                     remaining_size -= partial_order.size
+#                     break
+#     return orders
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/backtest/data_client.pxd` & `nautilus_trader-1.175.0/nautilus_trader/backtest/data_client.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/backtest/data_client.pyx` & `nautilus_trader-1.175.0/nautilus_trader/backtest/data_client.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/backtest/engine.pxd` & `nautilus_trader-1.175.0/nautilus_trader/backtest/engine.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/backtest/engine.pyx` & `nautilus_trader-1.175.0/nautilus_trader/backtest/engine.pyx`

 * *Files 3% similar despite different names*

```diff
@@ -9,14 +9,15 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+import asyncio
 import pickle
 from decimal import Decimal
 from typing import Optional, Union
 
 import pandas as pd
 
 from nautilus_trader.accounting.error import AccountError
@@ -63,15 +64,16 @@
 from nautilus_trader.core.rust.common cimport TimeEventHandler_t
 from nautilus_trader.core.rust.common cimport vec_time_event_handlers_drop
 from nautilus_trader.core.rust.core cimport CVec
 from nautilus_trader.core.uuid cimport UUID4
 from nautilus_trader.execution.algorithm cimport ExecAlgorithm
 from nautilus_trader.model.data.bar cimport Bar
 from nautilus_trader.model.data.base cimport GenericData
-from nautilus_trader.model.data.book cimport ORDER_BOOK_DATA
+from nautilus_trader.model.data.book cimport OrderBookDelta
+from nautilus_trader.model.data.book cimport OrderBookDeltas
 from nautilus_trader.model.data.tick cimport QuoteTick
 from nautilus_trader.model.data.tick cimport TradeTick
 from nautilus_trader.model.data.venue cimport InstrumentStatusUpdate
 from nautilus_trader.model.data.venue cimport VenueStatusUpdate
 from nautilus_trader.model.enums_c cimport AccountType
 from nautilus_trader.model.enums_c cimport AggregationSource
 from nautilus_trader.model.enums_c cimport BookType
@@ -355,14 +357,15 @@
         latency_model: Optional[LatencyModel] = None,
         book_type: BookType = BookType.L1_TBBO,
         routing: bool = False,
         frozen_account: bool = False,
         bar_execution: bool = True,
         reject_stop_orders: bool = True,
         support_gtd_orders: bool = True,
+        use_random_ids: bool = False,
     ) -> None:
         """
         Add a `SimulatedExchange` with the given parameters to the backtest engine.
 
         Parameters
         ----------
         venue : Venue
@@ -394,14 +397,16 @@
             If the account for this exchange is frozen (balances will not change).
         bar_execution : bool, default True
             If bars should be processed by the matching engine(s) (and move the market).
         reject_stop_orders : bool, default True
             If stop orders are rejected on submission if trigger price is in the market.
         support_gtd_orders : bool, default True
             If orders with GTD time in force will be supported by the venue.
+        use_random_ids : bool, default False
+            If venue order and position IDs will be randomly generated UUID4s.
 
         Raises
         ------
         ValueError
             If `venue` is already registered with the engine.
 
         """
@@ -439,14 +444,15 @@
             book_type=book_type,
             clock=self.kernel.clock,
             logger=self.kernel.logger,
             frozen_account=frozen_account,
             bar_execution=bar_execution,
             reject_stop_orders=reject_stop_orders,
             support_gtd_orders=support_gtd_orders,
+            use_random_ids=use_random_ids,
         )
 
         self._venues[venue] = exchange
 
         # Create execution client for exchange
         exec_client = BacktestExecClient(
             exchange=exchange,
@@ -718,14 +724,18 @@
         self.kernel.trader.add_exec_algorithms(exec_algorithms)
 
     def reset(self) -> None:
         """
         Reset the backtest engine.
 
         All stateful fields are reset to their initial value.
+
+        Note: instruments and data are not dropped/reset, this can be done through a
+        separate call to `.clear_data()` if desired.
+
         """
         self._log.debug(f"Resetting...")
 
         if self.kernel.trader.is_running:
             # End current backtest run
             self.end()
 
@@ -775,20 +785,41 @@
         Does not clear added instruments.
 
         """
         self._data.clear()
         self._data_len = 0
         self._index = 0
 
+    def clear_actors(self) -> None:
+        """
+        Clear all actors from the engines internal trader.
+
+        """
+        self._trader.clear_actors()
+
+    def clear_strategies(self) -> None:
+        """
+        Clear all trading strategies from the engines internal trader.
+
+        """
+        self._trader.clear_strategies()
+
+    def clear_exec_algorthms(self) -> None:
+        """
+        Clear all execution algorithms from the engines internal trader.
+
+        """
+        self._trader.clear_exec_algorthms()
+
     def dispose(self) -> None:
         """
         Dispose of the backtest engine by disposing the trader and releasing system resources.
 
-        This method is idempotent and irreversible. No other methods should be
-        called after disposal.
+        Calling this method multiple times has the same effect as calling it once (it is idempotent).
+        Once called, it cannot be reversed, and no other methods should be called on this instance.
 
         """
         self.clear_data()
         self.kernel.dispose()
 
     def run(
         self,
@@ -946,19 +977,32 @@
             # Initialize run
             self._run_config_id = run_config_id  # Can be None
             self._run_id = UUID4()
             self._run_started = self._clock.utc_now()
             self._backtest_start = start
             for exchange in self._venues.values():
                 exchange.initialize_account()
-            self._kernel.data_engine.start()
-            self._kernel.risk_engine.start()
-            self._kernel.exec_engine.start()
-            self._kernel.emulator.start()
-            self._kernel.trader.start()
+                ###################################################################################
+                open_orders = self._kernel.cache.orders_open(venue=exchange.id)
+                for order in open_orders:
+                    if order.is_emulated:
+                        # Order should be loaded in the emulator already
+                        continue
+                    matching_engine = exchange.get_matching_engine(order.instrument_id)
+                    if matching_engine is None:
+                        self._log.error(
+                            f"No matching engine for {order.instrument_id} to process {order}.",
+                        )
+                        continue
+                    matching_engine.process_order(order, order.account_id)
+                ###################################################################################
+
+            # Common kernel start-up sequence
+            asyncio.run(self._kernel.start())
+
             # Change logger clock for the run
             self._kernel.logger.change_clock(self.kernel.clock)
             self._log_pre_run()
 
         self._log_run(start, end)
 
         # Set data stream length
@@ -984,16 +1028,18 @@
                     break
                 if data.ts_init > last_ns:
                     # Advance clocks to the next data time
                     raw_handlers = self._advance_time(data.ts_init, clocks)
                     raw_handlers_count = raw_handlers.len
 
                 # Process data through venue
-                if isinstance(data, ORDER_BOOK_DATA):
-                    self._venues[data.instrument_id.venue].process_order_book(data)
+                if isinstance(data, OrderBookDelta):
+                    self._venues[data.instrument_id.venue].process_order_book_delta(data)
+                elif isinstance(data, OrderBookDeltas):
+                    self._venues[data.instrument_id.venue].process_order_book_deltas(data)
                 elif isinstance(data, QuoteTick):
                     self._venues[data.instrument_id.venue].process_quote_tick(data)
                 elif isinstance(data, TradeTick):
                     self._venues[data.instrument_id.venue].process_trade_tick(data)
                 elif isinstance(data, Bar):
                     self._venues[data.bar_type.instrument_id.venue].process_bar(data)
                 elif isinstance(data, VenueStatusUpdate):
@@ -1255,15 +1301,15 @@
                 cache=self._kernel.cache,
                 clock=self._kernel.clock,
                 logger=self._kernel.logger,
             )
             self._kernel.data_engine.register_client(client)
 
     def _add_market_data_client_if_not_exists(self, Venue venue) -> None:
-        cdef ClientId client_id = ClientId(venue.to_str())
+        cdef ClientId client_id = ClientId(venue.value)
         if client_id not in self._kernel.data_engine.registered_clients:
             client = BacktestMarketDataClient(
                 client_id=client_id,
                 msgbus=self._kernel.msgbus,
                 cache=self._kernel.cache,
                 clock=self._kernel.clock,
                 logger=self._kernel.logger,
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/backtest/exchange.pxd` & `nautilus_trader-1.175.0/nautilus_trader/backtest/exchange.pxd`

 * *Files 5% similar despite different names*

```diff
@@ -24,14 +24,16 @@
 from nautilus_trader.common.clock cimport Clock
 from nautilus_trader.common.logging cimport LoggerAdapter
 from nautilus_trader.common.queue cimport Queue
 from nautilus_trader.core.data cimport Data
 from nautilus_trader.execution.messages cimport TradingCommand
 from nautilus_trader.model.currency cimport Currency
 from nautilus_trader.model.data.bar cimport Bar
+from nautilus_trader.model.data.book cimport OrderBookDelta
+from nautilus_trader.model.data.book cimport OrderBookDeltas
 from nautilus_trader.model.data.tick cimport QuoteTick
 from nautilus_trader.model.data.tick cimport TradeTick
 from nautilus_trader.model.data.venue cimport InstrumentStatusUpdate
 from nautilus_trader.model.data.venue cimport VenueStatusUpdate
 from nautilus_trader.model.enums_c cimport AccountType
 from nautilus_trader.model.enums_c cimport BookType
 from nautilus_trader.model.enums_c cimport OmsType
@@ -79,14 +81,16 @@
     """The fill model for the exchange.\n\n:returns: `FillModel`"""
     cdef readonly bint bar_execution
     """If bars should be processed by the matching engine(s) (and move the market).\n\n:returns: `bool`"""
     cdef readonly bint reject_stop_orders
     """If stop orders are rejected on submission if in the market.\n\n:returns: `bool`"""
     cdef readonly bint support_gtd_orders
     """If orders with GTD time in force will be supported by the venue.\n\n:returns: `bool`"""
+    cdef readonly bint use_random_ids
+    """If venue order and position IDs will be randomly generated UUID4s.\n\n:returns: `bool`"""
     cdef readonly list modules
     """The simulation modules registered with the exchange.\n\n:returns: `list[SimulationModule]`"""
     cdef readonly dict instruments
     """The exchange instruments.\n\n:returns: `dict[InstrumentId, Instrument]`"""
 
     cdef dict _matching_engines
     cdef Queue _message_queue
@@ -115,15 +119,16 @@
     cpdef Account get_account(self)
 
 # -- COMMANDS -------------------------------------------------------------------------------------
 
     cpdef void adjust_account(self, Money adjustment)
     cdef tuple generate_inflight_command(self, TradingCommand command)
     cpdef void send(self, TradingCommand command)
-    cpdef void process_order_book(self, Data data)
+    cpdef void process_order_book_delta(self, OrderBookDelta delta)
+    cpdef void process_order_book_deltas(self, OrderBookDeltas deltas)
     cpdef void process_quote_tick(self, QuoteTick tick)
     cpdef void process_trade_tick(self, TradeTick tick)
     cpdef void process_bar(self, Bar bar)
     cpdef void process_venue_status(self, VenueStatusUpdate update)
     cpdef void process_instrument_status(self, InstrumentStatusUpdate update)
     cpdef void process(self, uint64_t ts_now)
     cpdef void reset(self)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/backtest/exchange.pyx` & `nautilus_trader-1.175.0/nautilus_trader/backtest/exchange.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -97,14 +97,16 @@
         If the account for this exchange is frozen (balances will not change).
     bar_execution : bool, default True
         If bars should be processed by the matching engine(s) (and move the market).
     reject_stop_orders : bool, default True
         If stop orders are rejected on submission if in the market.
     support_gtd_orders : bool, default True
         If orders with GTD time in force will be supported by the venue.
+    use_random_ids : bool, default False
+        If venue order and position IDs will be randomly generated UUID4s.
 
     Raises
     ------
     ValueError
         If `instruments` is empty.
     ValueError
         If `instruments` contains a type other than `Instrument`.
@@ -136,14 +138,15 @@
         FillModel fill_model not None,
         LatencyModel latency_model = None,
         BookType book_type = BookType.L1_TBBO,
         bint frozen_account = False,
         bint bar_execution = True,
         bint reject_stop_orders = True,
         bint support_gtd_orders = True,
+        bint use_random_ids = False,
     ):
         Condition.list_type(instruments, Instrument, "instruments", "Instrument")
         Condition.not_empty(starting_balances, "starting_balances")
         Condition.list_type(starting_balances, Money, "starting_balances")
         Condition.list_type(modules, SimulationModule, "modules", "SimulationModule")
         if base_currency:
             Condition.true(len(starting_balances) == 1, "single-currency account has multiple starting currencies")
@@ -173,14 +176,15 @@
         self.leverages = leverages
         self.is_frozen_account = frozen_account
 
         # Execution
         self.bar_execution = bar_execution
         self.reject_stop_orders = reject_stop_orders
         self.support_gtd_orders = support_gtd_orders
+        self.use_random_ids = use_random_ids
         self.fill_model = fill_model
         self.latency_model = latency_model
 
         # Load modules
         self.modules = []
         for module in modules:
             Condition.not_in(module, self.modules, "module", "modules")
@@ -276,63 +280,62 @@
         """
         self._generate_fresh_account_state()
 
     cpdef void add_instrument(self, Instrument instrument):
         """
         Add the given instrument to the venue.
 
+        A random and unique 32-bit unsigned integer raw ID will be generated.
+
         Parameters
         ----------
         instrument : Instrument
             The instrument to add.
 
         Raises
         ------
         ValueError
             If `instrument.id.venue` is not equal to the venue ID.
-        KeyError
-            If `instrument` is already contained within the venue.
-            This is to enforce correct internal identifier indexing.
         InvalidConfiguration
             If `instrument` is invalid for this venue.
 
         """
         Condition.not_none(instrument, "instrument")
         Condition.equal(instrument.id.venue, self.id, "instrument.id.venue", "self.id")
-        Condition.not_in(instrument.id, self.instruments, "instrument.id", "self.instruments")
 
         # Validate instrument
         if isinstance(instrument, (CryptoPerpetual, CryptoFuture)):
             if self.account_type == AccountType.CASH:
                 raise InvalidConfiguration(
                     f"Cannot add a `{type(instrument).__name__}` type instrument "
                     f"to a venue with a `CASH` account type. Add to a "
                     f"venue with a `MARGIN` account type.",
                 )
 
         self.instruments[instrument.id] = instrument
 
-        matching_engine = OrderMatchingEngine(
+        cdef OrderMatchingEngine matching_engine = OrderMatchingEngine(
             instrument=instrument,
-            product_id=len(self.instruments),
+            raw_id=len(self.instruments),
             fill_model=self.fill_model,
             book_type=self.book_type,
             oms_type=self.oms_type,
             msgbus=self.msgbus,
             cache=self.cache,
             clock=self._clock,
             logger=self._log.get_logger(),
             bar_execution=self.bar_execution,
             reject_stop_orders=self.reject_stop_orders,
             support_gtd_orders=self.support_gtd_orders,
+            use_random_ids=self.use_random_ids,
         )
 
         self._matching_engines[instrument.id] = matching_engine
 
-        self._log.info(f"Loaded instrument {instrument.id}.")
+        self._log.info(f"Added instrument {instrument.id} and created matching engine.")
 
 # -- QUERIES --------------------------------------------------------------------------------------
 
     cpdef Price best_bid_price(self, InstrumentId instrument_id):
         """
         Return the best bid price for the given instrument ID (if found).
 
@@ -614,31 +617,49 @@
             raise ValueError(f"invalid `TradingCommand`, was {command}")  # pragma: no cover (design-time error)
         if ts not in self._inflight_counter:
             self._inflight_counter[ts] = 0
         self._inflight_counter[ts] += 1
         cdef (uint64_t, uint64_t) key = (ts, self._inflight_counter[ts])
         return key, command
 
-    cpdef void process_order_book(self, Data data):
+    cpdef void process_order_book_delta(self, OrderBookDelta delta):
+        """
+        Process the exchanges market for the given order book delta.
+
+        Parameters
+        ----------
+        data : OrderBookDelta
+            The order book delta to process.
+
+        """
+        Condition.not_none(delta, "delta")
+
+        cdef OrderMatchingEngine matching_engine = self._matching_engines.get(delta.instrument_id)
+        if matching_engine is None:
+            raise RuntimeError(f"No matching engine found for {delta.instrument_id}")
+
+        matching_engine.process_order_book_delta(delta)
+
+    cpdef void process_order_book_deltas(self, OrderBookDeltas deltas):
         """
-        Process the exchanges market for the given order book data.
+        Process the exchanges market for the given order book deltas.
 
         Parameters
         ----------
-        data : OrderBookDelta, OrderBookDeltas, OrderBookSnapshot
-            The order book data to process.
+        data : OrderBookDeltas
+            The order book deltas to process.
 
         """
-        Condition.not_none(data, "data")
+        Condition.not_none(deltas, "deltas")
 
-        cdef OrderMatchingEngine matching_engine = self._matching_engines.get(data.instrument_id)
+        cdef OrderMatchingEngine matching_engine = self._matching_engines.get(deltas.instrument_id)
         if matching_engine is None:
-            raise RuntimeError(f"No matching engine found for {data.instrument_id}")
+            raise RuntimeError(f"No matching engine found for {deltas.instrument_id}")
 
-        matching_engine.process_order_book(data)
+        matching_engine.process_order_book_deltas(deltas)
 
     cpdef void process_quote_tick(self, QuoteTick tick):
         """
         Process the exchanges market for the given quote tick.
 
         Market dynamics are simulated by auctioning open orders.
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/backtest/execution_client.pxd` & `nautilus_trader-1.175.0/nautilus_trader/backtest/execution_client.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/backtest/execution_client.pyx` & `nautilus_trader-1.175.0/nautilus_trader/backtest/execution_client.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/backtest/matching_engine.pxd` & `nautilus_trader-1.175.0/nautilus_trader/backtest/matching_engine.pxd`

 * *Files 2% similar despite different names*

```diff
@@ -10,28 +10,31 @@
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from libc.stdint cimport int64_t
+from libc.stdint cimport uint32_t
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.backtest.models cimport FillModel
 from nautilus_trader.cache.base cimport CacheFacade
 from nautilus_trader.common.clock cimport Clock
 from nautilus_trader.common.logging cimport LoggerAdapter
 from nautilus_trader.core.data cimport Data
 from nautilus_trader.execution.matching_core cimport MatchingCore
 from nautilus_trader.execution.messages cimport CancelAllOrders
 from nautilus_trader.execution.messages cimport CancelOrder
 from nautilus_trader.execution.messages cimport ModifyOrder
 from nautilus_trader.model.currency cimport Currency
 from nautilus_trader.model.data.bar cimport Bar
 from nautilus_trader.model.data.book cimport BookOrder
+from nautilus_trader.model.data.book cimport OrderBookDelta
+from nautilus_trader.model.data.book cimport OrderBookDeltas
 from nautilus_trader.model.data.tick cimport QuoteTick
 from nautilus_trader.model.data.tick cimport TradeTick
 from nautilus_trader.model.enums_c cimport BookType
 from nautilus_trader.model.enums_c cimport LiquiditySide
 from nautilus_trader.model.enums_c cimport MarketStatus
 from nautilus_trader.model.enums_c cimport OmsType
 from nautilus_trader.model.enums_c cimport TimeInForce
@@ -67,26 +70,27 @@
     cdef Clock _clock
     cdef LoggerAdapter _log
     cdef MessageBus _msgbus
     cdef OrderBook _book
     cdef OrderBook _opening_auction_book
     cdef OrderBook _closing_auction_book
     cdef FillModel _fill_model
-    cdef object _auction_match_algo
+    # cdef object _auction_match_algo
     cdef bint _bar_execution
     cdef bint _reject_stop_orders
     cdef bint _support_gtd_orders
+    cdef bint _use_random_ids
     cdef dict _account_ids
 
     cdef readonly Venue venue
     """The venue for the matching engine.\n\n:returns: `Venue`"""
     cdef readonly Instrument instrument
     """The instrument for the matching engine.\n\n:returns: `Instrument`"""
-    cdef readonly int product_id
-    """The instruments product ID for the exchange.\n\n:returns: `int`"""
+    cdef readonly uint32_t raw_id
+    """The instruments raw integer ID for the exchange.\n\n:returns: `int`"""
     cdef readonly BookType book_type
     """The order book type for the matching engine.\n\n:returns: `BookType`"""
     cdef readonly OmsType oms_type
     """The order management system type for the matching engine.\n\n:returns: `OmsType`"""
     cdef readonly MarketStatus market_status
     """The market status for the matching engine.\n\n:returns: `MarketStatus`"""
     cdef readonly CacheFacade cache
@@ -117,15 +121,16 @@
     cpdef list get_open_orders(self)
     cpdef list get_open_bid_orders(self)
     cpdef list get_open_ask_orders(self)
     cpdef bint order_exists(self, ClientOrderId client_order_id)
 
 # -- DATA PROCESSING ------------------------------------------------------------------------------
 
-    cpdef void process_order_book(self, Data data)
+    cpdef void process_order_book_delta(self, OrderBookDelta delta)
+    cpdef void process_order_book_deltas(self, OrderBookDeltas deltas)
     cpdef void process_quote_tick(self, QuoteTick tick)
     cpdef void process_trade_tick(self, TradeTick tick)
     cpdef void process_bar(self, Bar bar)
     cpdef void process_status(self, MarketStatus status)
     cpdef void process_auction_book(self, OrderBook book)
     cdef void _process_trade_ticks_from_bar(self, Bar bar)
     cdef void _process_quote_ticks_from_bar(self)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/backtest/matching_engine.pyx` & `nautilus_trader-1.175.0/nautilus_trader/backtest/matching_engine.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -9,43 +9,46 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+import uuid
 from typing import Optional
 
-from nautilus_trader.backtest.auction import default_auction_match
 
-from libc.limits cimport INT_MAX
-from libc.limits cimport INT_MIN
+# from nautilus_trader.backtest.auction import default_auction_match
+
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.backtest.models cimport FillModel
 from nautilus_trader.cache.base cimport CacheFacade
 from nautilus_trader.common.clock cimport TestClock
 from nautilus_trader.common.logging cimport LogColor
 from nautilus_trader.common.logging cimport Logger
 from nautilus_trader.core.correctness cimport Condition
 from nautilus_trader.core.data cimport Data
 from nautilus_trader.core.rust.model cimport Price_t
+from nautilus_trader.core.rust.model cimport orderbook_best_ask_price
+from nautilus_trader.core.rust.model cimport orderbook_best_bid_price
+from nautilus_trader.core.rust.model cimport orderbook_has_ask
+from nautilus_trader.core.rust.model cimport orderbook_has_bid
 from nautilus_trader.core.rust.model cimport price_new
 from nautilus_trader.core.rust.model cimport trade_id_new
 from nautilus_trader.core.string cimport pystr_to_cstr
 from nautilus_trader.core.uuid cimport UUID4
 from nautilus_trader.execution.matching_core cimport MatchingCore
 from nautilus_trader.execution.trailing cimport TrailingStopCalculator
 from nautilus_trader.model.data.book cimport BookOrder
 from nautilus_trader.model.data.tick cimport QuoteTick
 from nautilus_trader.model.data.tick cimport TradeTick
 from nautilus_trader.model.enums_c cimport AggressorSide
 from nautilus_trader.model.enums_c cimport BookType
 from nautilus_trader.model.enums_c cimport ContingencyType
-from nautilus_trader.model.enums_c cimport DepthType
 from nautilus_trader.model.enums_c cimport LiquiditySide
 from nautilus_trader.model.enums_c cimport OmsType
 from nautilus_trader.model.enums_c cimport OrderSide
 from nautilus_trader.model.enums_c cimport OrderStatus
 from nautilus_trader.model.enums_c cimport OrderType
 from nautilus_trader.model.enums_c cimport PriceType
 from nautilus_trader.model.enums_c cimport TimeInForce
@@ -91,16 +94,16 @@
     """
     Provides an order matching engine for a single market.
 
     Parameters
     ----------
     instrument : Instrument
         The market instrument for the matching engine.
-    product_id : int
-        The product ID for the instrument.
+    raw_id : uint32_t
+        The raw integer ID for the instrument.
     fill_model : FillModel
         The fill model for the matching engine.
     book_type : BookType
         The order book type for the engine.
     oms_type : OmsType
         The order management system type for the matching engine. Determines
         the generation and handling of venue position IDs.
@@ -114,68 +117,69 @@
         The logger for the matching engine.
     bar_execution : bool, default True
         If bars should be processed by the matching engine(s) (and move the market).
     reject_stop_orders : bool, default True
         If stop orders are rejected if already in the market on submitting.
     support_gtd_orders : bool, default True
         If orders with GTD time in force will be supported by the venue.
+    use_random_ids : bool, default False
+        If venue order and position IDs will be randomly generated UUID4s.
     auction_match_algo : Callable[[Ladder, Ladder], Tuple[List, List], optional
         The auction matching algorithm.
     """
 
     def __init__(
         self,
         Instrument instrument not None,
-        int product_id,
+        uint32_t raw_id,
         FillModel fill_model not None,
         BookType book_type,
         OmsType oms_type,
         MessageBus msgbus not None,
         CacheFacade cache not None,
         TestClock clock not None,
         Logger logger not None,
         bint bar_execution = True,
         bint reject_stop_orders = True,
         bint support_gtd_orders = True,
-        auction_match_algo = default_auction_match
+        bint use_random_ids = False,
+        # auction_match_algo = default_auction_match
     ):
         self._clock = clock
         self._log = LoggerAdapter(
             component_name=f"{type(self).__name__}({instrument.id.venue})",
             logger=logger,
         )
         self.msgbus = msgbus
         self.cache = cache
 
         self.venue = instrument.id.venue
         self.instrument = instrument
-        self.product_id = product_id
+        self.raw_id = raw_id
         self.book_type = book_type
         self.oms_type = oms_type
         self.market_status = MarketStatus.OPEN
 
         self._bar_execution = bar_execution
         self._reject_stop_orders = reject_stop_orders
         self._support_gtd_orders = support_gtd_orders
-        self._auction_match_algo = auction_match_algo
+        self._use_random_ids = use_random_ids
+        # self._auction_match_algo = auction_match_algo
         self._fill_model = fill_model
-        self._book = OrderBook.create(
-            instrument=instrument,
+        self._book = OrderBook(
+            instrument_id=instrument.id,
             book_type=book_type,
-            simulated=True,
         )
-        self._opening_auction_book = OrderBook.create(
-            instrument=instrument,
+        self._opening_auction_book = OrderBook(
+            instrument_id=instrument.id,
             book_type=BookType.L3_MBO,
-            simulated=True,
         )
-        self._closing_auction_book = OrderBook.create(
-            instrument=instrument,
+        self._closing_auction_book = OrderBook(
+            instrument_id=instrument.id,
             book_type=BookType.L3_MBO,
-            simulated=True,
         )
 
         self._account_ids: dict[TraderId, AccountId]  = {}
 
         # Market
         self._core = MatchingCore(
             instrument=instrument,
@@ -196,21 +200,21 @@
         self._execution_count = 0
 
     def __repr__(self) -> str:
         return (
             f"{type(self).__name__}("
             f"venue={self.venue.value}, "
             f"instrument_id={self.instrument.id.value}, "
-            f"product_id={self.product_id})"
+            f"raw_id={self.raw_id})"
         )
 
     cpdef void reset(self):
         self._log.debug(f"Resetting OrderMatchingEngine {self.instrument.id}...")
 
-        self._book.clear()
+        self._book.clear(0, 0)
         self._account_ids.clear()
         self._core.reset()
         self._target_bid = 0
         self._target_ask = 0
         self._target_last = 0
         self._has_targets = False
         self._last_bid_bar = None
@@ -245,32 +249,26 @@
         Return the best bid price for the given instrument ID (if found).
 
         Returns
         -------
         Price or ``None``
 
         """
-        best_bid_price = self._book.best_bid_price()
-        if best_bid_price is None:
-            return None
-        return Price(best_bid_price, self.instrument.price_precision)
+        return self._book.best_bid_price()
 
     cpdef Price best_ask_price(self):
         """
         Return the best ask price for the given instrument ID (if found).
 
         Returns
         -------
         Price or ``None``
 
         """
-        best_ask_price = self._book.best_ask_price()
-        if best_ask_price is None:
-            return None
-        return Price(best_ask_price, self.instrument.price_precision)
+        return self._book.best_ask_price()
 
     cpdef OrderBook get_book(self):
         """
         Return the internal order book.
 
         Returns
         -------
@@ -313,42 +311,71 @@
         return self._core.get_orders_ask()
 
     cpdef bint order_exists(self, ClientOrderId client_order_id):
         return self._core.order_exists(client_order_id)
 
 # -- DATA PROCESSING ------------------------------------------------------------------------------
 
-    cpdef void process_order_book(self, Data data):
+    cpdef void process_order_book_delta(self, OrderBookDelta delta):
         """
-        Process the exchanges market for the given order book data.
+        Process the exchanges market for the given order book delta.
 
         Parameters
         ----------
-        data : OrderBookDelta, OrderBookDeltas, OrderBookSnapshot
-            The order book data to process.
+        delta : OrderBookDelta
+            The order book delta to process.
 
         """
-        Condition.not_none(data, "data")
+        Condition.not_none(delta, "delta")
 
         if not self._log.is_bypassed:
-            self._log.debug(f"Processing {repr(data)}...")
+            self._log.debug(f"Processing {repr(delta)}...")
 
-        self._book.apply(data)
+        self._book.apply_delta(delta)
 
         # TODO(cs): WIP to introduce flags
         # if data.flags == TimeInForce.GTC:
         #     self._book.apply(data)
         # elif data.flags == TimeInForce.AT_THE_OPEN:
         #     self._opening_auction_book.apply(data)
         # elif data.flags == TimeInForce.AT_THE_CLOSE:
         #     self._closing_auction_book.apply(data)
         # else:
         #     raise RuntimeError(data.time_in_force)
 
-        self.iterate(data.ts_init)
+        self.iterate(delta.ts_init)
+
+    cpdef void process_order_book_deltas(self, OrderBookDeltas deltas):
+        """
+        Process the exchanges market for the given order book deltas.
+
+        Parameters
+        ----------
+        delta : OrderBookDeltas
+            The order book deltas to process.
+
+        """
+        Condition.not_none(deltas, "deltas")
+
+        if not self._log.is_bypassed:
+            self._log.debug(f"Processing {repr(deltas)}...")
+
+        self._book.apply_deltas(deltas)
+
+        # TODO(cs): WIP to introduce flags
+        # if data.flags == TimeInForce.GTC:
+        #     self._book.apply(data)
+        # elif data.flags == TimeInForce.AT_THE_OPEN:
+        #     self._opening_auction_book.apply(data)
+        # elif data.flags == TimeInForce.AT_THE_CLOSE:
+        #     self._closing_auction_book.apply(data)
+        # else:
+        #     raise RuntimeError(data.time_in_force)
+
+        self.iterate(deltas.ts_init)
 
     cpdef void process_quote_tick(self, QuoteTick tick) :
         """
         Process the exchanges market for the given quote tick.
 
         Market dynamics are simulated by auctioning open orders.
 
@@ -463,36 +490,36 @@
     cpdef void process_auction_book(self, OrderBook book):
         Condition.not_none(book, "book")
 
         cdef:
             list traded_bids
             list traded_asks
         # Perform an auction match on this auction order book
-        traded_bids, traded_asks = self._auction_match_algo(book.bids, book.asks)
+        # traded_bids, traded_asks = self._auction_match_algo(book.bids, book.asks)
 
         cdef set client_order_ids = {c.value for c in self.cache.client_order_ids()}
 
-        cdef:
-            BookOrder order
-            Order real_order
-            PositionId venue_position_id
-        # Check filled orders from auction for any client orders and emit fills
-        for order in traded_bids + traded_asks:
-            if order.order_id in client_order_ids:
-                real_order = self.cache.order(ClientOrderId(order.order_id))
-                venue_position_id = self._get_position_id(real_order)
-                self._generate_order_filled(
-                    real_order,
-                    venue_position_id,
-                    Quantity(order.size, self.instrument.size_precision),
-                    Price(order.price, self.instrument.price_precision),
-                    self.instrument.quote_currency,
-                    Money(0.0, self.instrument.quote_currency),
-                    LiquiditySide.NO_LIQUIDITY_SIDE,
-                )
+        # cdef:
+        #     BookOrder order
+        #     Order real_order
+        #     PositionId venue_position_id
+        # # Check filled orders from auction for any client orders and emit fills
+        # for order in traded_bids + traded_asks:
+        #     if order.order_id in client_order_ids:
+        #         real_order = self.cache.order(ClientOrderId(order.order_id))
+        #         venue_position_id = self._get_position_id(real_order)
+        #         self._generate_order_filled(
+        #             real_order,
+        #             venue_position_id,
+        #             Quantity(order.size, self.instrument.size_precision),
+        #             Price(order.price, self.instrument.price_precision),
+        #             self.instrument.quote_currency,
+        #             Money(0.0, self.instrument.quote_currency),
+        #             LiquiditySide.NO_LIQUIDITY_SIDE,
+        #         )
 
     cdef void _process_trade_ticks_from_bar(self, Bar bar):
         cdef Quantity size = Quantity(bar.volume.as_double() / 4.0, bar._mem.volume.precision)
 
         # Create reusable tick
         cdef TradeTick tick = TradeTick(
             bar.bar_type.instrument_id,
@@ -857,39 +884,38 @@
 
         # Order is valid and accepted
         self.accept_order(order)
 
     cdef void _process_auction_market_order(self, MarketOrder order):
         cdef:
             Instrument instrument = self.instrument
-            double price = instrument.max_price.as_double() if order.is_buy_c() else instrument.min_price.as_double()
             BookOrder book_order = BookOrder(
-                price=price,
-                size=order.quantity.as_double(),
                 side=order.side,
-                order_id=order.client_order_id.to_str(),
+                price=instrument.max_price if order.is_buy_c() else instrument.min_price,
+                size=order.quantity,
+                order_id=self._clock.timestamp_ns(),
             )
         self._process_auction_book_order(book_order, time_in_force=order.time_in_force)
 
     cdef void _process_auction_limit_order(self, LimitOrder order):
         cdef:
             Instrument instrument = self.instrument
             BookOrder book_order = BookOrder(
-                price=order.price.as_double(),
-                size=order.quantity.as_double(),
+                price=order.price,
+                size=order.quantity,
                 side=order.side,
-                order_id=order.client_order_id.to_str(),
+                order_id=self._clock.timestamp_ns(),
             )
         self._process_auction_book_order(book_order, time_in_force=order.time_in_force)
 
     cdef void _process_auction_book_order(self, BookOrder order, TimeInForce time_in_force):
         if time_in_force == TimeInForce.AT_THE_OPEN:
-            self._opening_auction_book.add(order)
+            self._opening_auction_book.add(order, 0, 0)
         elif time_in_force == TimeInForce.AT_THE_CLOSE:
-            self._closing_auction_book.add(order)
+            self._closing_auction_book.add(order, 0, 0)
         else:
             raise RuntimeError(time_in_force)
 
     cdef void _update_limit_order(
         self,
         Order order,
         Quantity qty,
@@ -1092,26 +1118,22 @@
         ----------
         timestamp_ns : uint64_t
             The UNIX timestamp to advance the matching engine time to.
 
         """
         self._clock.set_time(timestamp_ns)
 
-        # TODO: Convert order book to use ints rather than doubles
-        cdef list bid_levels = self._book.bids.levels
-        cdef list ask_levels = self._book.asks.levels
-
         cdef Price_t bid
         cdef Price_t ask
 
-        if bid_levels:
-            bid = price_new(bid_levels[0].price, self.instrument.price_precision)
+        if orderbook_has_bid(&self._book._mem):
+            bid = orderbook_best_bid_price(&self._book._mem)
             self._core.set_bid_raw(bid.raw)
-        if ask_levels:
-            ask = price_new(ask_levels[0].price, self.instrument.price_precision)
+        if orderbook_has_ask(&self._book._mem):
+            ask = orderbook_best_ask_price(&self._book._mem)
             self._core.set_ask_raw(ask.raw)
 
         self._core.iterate(timestamp_ns)
 
         cdef list orders = self._core.get_orders()
         cdef Order order
         for order in orders:
@@ -1156,30 +1178,27 @@
         ------
         ValueError
             If the `order` does not have a LIMIT `price`.
 
         """
         Condition.true(order.has_price_c(), "order has no limit `price`")
 
-        cdef list fills
-        cdef BookOrder submit_order = BookOrder(price=order.price, size=order.leaves_qty, side=order.side)
-        if order.side == OrderSide.BUY:
-            fills = self._book.asks.simulate_order_fills(order=submit_order, depth_type=DepthType.VOLUME)
-        elif order.side == OrderSide.SELL:
-            fills = self._book.bids.simulate_order_fills(order=submit_order, depth_type=DepthType.VOLUME)
-        else:
-            raise RuntimeError(f"invalid `OrderSide`, was {order.side}")  # pragma: no cover (design-time error)
+        cdef list fills = self._book.simulate_fills(
+            order,
+            price_prec=self.instrument.price_precision,
+            is_aggressive=False,
+        )
 
         cdef Price triggered_price = order.get_triggered_price_c()
         cdef Price price = order.price
 
         if (
             fills
             and triggered_price is not None
-            and self._book.type == BookType.L1_TBBO
+            and self._book.book_type == BookType.L1_TBBO
             and order.liquidity_side == LiquiditySide.TAKER
         ):
             ########################################################################
             # Filling as TAKER from a trigger
             ########################################################################
             if order.side == OrderSide.BUY and price._mem.raw > triggered_price._mem.raw:
                 fills[0] = (triggered_price, fills[0][1])
@@ -1198,15 +1217,15 @@
                 self._core.set_bid_raw(price._mem.raw)
                 self._core.set_last_raw(price._mem.raw)
 
         cdef tuple initial_fill
         cdef Price initial_fill_price
         if (
             fills
-            and self._book.type == BookType.L1_TBBO
+            and self._book.book_type == BookType.L1_TBBO
             and order.liquidity_side == LiquiditySide.MAKER
         ):
             ########################################################################
             # Filling as MAKER
             ########################################################################
             initial_fill = fills[0]
             initial_fill_price = initial_fill[0]
@@ -1241,40 +1260,37 @@
                 raise RuntimeError(f"invalid `OrderSide`, was {order.side}")  # pragma: no cover (design-time error)
 
         return fills
 
     cpdef list determine_market_price_and_volume(self, Order order):
         """
         Return the projected fills for the given *marketable* order filling
-        aggressively into its order side.
+        aggressively into the opposite order side.
 
         The list may be empty if no fills.
 
         Parameters
         ----------
         order : Order
             The order to determine fills for.
 
         Returns
         -------
         list[tuple[Price, Quantity]]
 
         """
-        cdef list fills
-        cdef Price price = Price.from_int_c(INT_MAX if order.side == OrderSide.BUY else INT_MIN)
-        cdef BookOrder submit_order = BookOrder(price=price, size=order.leaves_qty, side=order.side)
-        if order.side == OrderSide.BUY:
-            fills = self._book.asks.simulate_order_fills(order=submit_order)
-        elif order.side == OrderSide.SELL:
-            fills = self._book.bids.simulate_order_fills(order=submit_order)
-        else:
-            raise RuntimeError(f"invalid `OrderSide`, was {order.side}")  # pragma: no cover (design-time error)
+        cdef list fills = self._book.simulate_fills(
+            order,
+            price_prec=self.instrument.price_precision,
+            is_aggressive=True,
+        )
 
+        cdef Price price
         cdef Price triggered_price
-        if self._book.type == BookType.L1_TBBO and fills:
+        if self._book.book_type == BookType.L1_TBBO and fills:
             triggered_price = order.get_triggered_price_c()
             if order.order_type == OrderType.MARKET or order.order_type == OrderType.MARKET_TO_LIMIT or order.order_type == OrderType.MARKET_IF_TOUCHED:
                 if order.side == OrderSide.BUY:
                     if self._core.is_ask_initialized:
                         price = self._core.ask
                     else:
                         price = self.best_ask_price()
@@ -1335,18 +1351,19 @@
                 f"Canceling REDUCE_ONLY {order.type_string_c()} "
                 f"as would increase position.",
             )
             self.cancel_order(order)
             return  # Order canceled
 
         order.liquidity_side = LiquiditySide.TAKER
+        cdef list fills = self.determine_market_price_and_volume(order)
 
         self.apply_fills(
             order=order,
-            fills=self.determine_market_price_and_volume(order),
+            fills=fills,
             liquidity_side=order.liquidity_side,
             venue_position_id=venue_position_id,
             position=position,
         )
 
     cpdef void fill_limit_order(self, Order order):
         """
@@ -1380,17 +1397,19 @@
             self._log.warning(
                 f"Canceling REDUCE_ONLY {order.type_string_c()} "
                 f"as would increase position.",
             )
             self.cancel_order(order)
             return  # Order canceled
 
+        cdef list fills = self.determine_limit_price_and_volume(order)
+
         self.apply_fills(
             order=order,
-            fills=self.determine_limit_price_and_volume(order),
+            fills=fills,
             liquidity_side=order.liquidity_side,
             venue_position_id=venue_position_id,
             position=position,
         )
 
     cpdef void apply_fills(
         self,
@@ -1483,16 +1502,15 @@
                 else:
                     raise ValueError(  # pragma: no cover (design-time error)
                         f"invalid `OrderSide`, was {order.side}",  # pragma: no cover (design-time error)
                     )
             if order.is_reduce_only and fill_qty._mem.raw > position.quantity._mem.raw:
                 # Adjust fill to honor reduce only execution
                 raw_org_qty = fill_qty._mem.raw
-                raw_adj_qty = fill_qty._mem.raw - (
-                            fill_qty._mem.raw - position.quantity._mem.raw)
+                raw_adj_qty = fill_qty._mem.raw - (fill_qty._mem.raw - position.quantity._mem.raw)
                 fill_qty = Quantity.from_raw_c(raw_adj_qty, fill_qty._mem.precision)
                 updated_qty = Quantity.from_raw_c(
                     order.quantity._mem.raw - (raw_org_qty - raw_adj_qty),
                     fill_qty._mem.precision)
                 if updated_qty._mem.raw > 0:
                     self._generate_order_updated(
                         order=order,
@@ -1592,29 +1610,29 @@
 
         order.liquidity_side = liquidity_side
 
         # Calculate commission
         cdef double notional = self.instrument.notional_value(
             quantity=last_qty,
             price=last_px,
-            inverse_as_quote=False,
+            use_quote_for_inverse=False,
         ).as_f64_c()
 
         cdef double commission_f64
         if order.liquidity_side == LiquiditySide.MAKER:
             commission_f64 = notional * float(self.instrument.maker_fee)
         elif order.liquidity_side == LiquiditySide.TAKER:
             commission_f64 = notional * float(self.instrument.taker_fee)
         else:
             raise ValueError(
                 f"invalid `LiquiditySide`, was {liquidity_side_to_str(order.liquidity_side)}"
             )
 
         cdef Money commission
-        if self.instrument.is_inverse:  # and not inverse_as_quote:
+        if self.instrument.is_inverse:  # Not using quote for inverse (see above):
             commission = Money(commission_f64, self.instrument.base_currency)
         else:
             commission = Money(commission_f64, self.instrument.quote_currency)
 
         self._generate_order_filled(
             order=order,
             venue_position_id=venue_position_id,
@@ -1713,40 +1731,49 @@
         if positions_open:
             return positions_open[0].id
         else:
             return None
 
     cdef PositionId _generate_venue_position_id(self):
         self._position_count += 1
-        return PositionId(
-            f"{self.venue.to_str()}-{self.product_id}-{self._position_count:03d}")
+        if self._use_random_ids:
+            return PositionId(str(uuid.uuid4()))
+        else:
+            return PositionId(f"{self.venue.to_str()}-{self.raw_id}-{self._position_count:03d}")
 
     cdef VenueOrderId _generate_venue_order_id(self):
         self._order_count += 1
-        return VenueOrderId(
-            f"{self.venue.to_str()}-{self.product_id}-{self._order_count:03d}")
+        if self._use_random_ids:
+            return VenueOrderId(str(uuid.uuid4()))
+        else:
+            return VenueOrderId(f"{self.venue.to_str()}-{self.raw_id}-{self._order_count:03d}")
 
     cdef TradeId _generate_trade_id(self):
         self._execution_count += 1
         return TradeId(self._generate_trade_id_str())
 
     cdef str _generate_trade_id_str(self):
-        return f"{self.venue.to_str()}-{self.product_id}-{self._execution_count:03d}"
+        if self._use_random_ids:
+            return str(uuid.uuid4())
+        else:
+            return f"{self.venue.to_str()}-{self.raw_id}-{self._execution_count:03d}"
 
 # -- EVENT HANDLING -------------------------------------------------------------------------------
 
     cpdef void accept_order(self, Order order):
-        self._generate_order_accepted(order)
+        # Check if order already accepted (being added back into the matching engine)
+        if not order.status_c() == OrderStatus.ACCEPTED:
+            self._generate_order_accepted(order)
 
-        if (
-            order.order_type == OrderType.TRAILING_STOP_MARKET
-            or order.order_type == OrderType.TRAILING_STOP_LIMIT
-        ):
-            if order.trigger_price is None:
-                self._update_trailing_stop_order(order)
+            if (
+                order.order_type == OrderType.TRAILING_STOP_MARKET
+                or order.order_type == OrderType.TRAILING_STOP_LIMIT
+            ):
+                if order.trigger_price is None:
+                    self._update_trailing_stop_order(order)
 
         self._core.add_order(order)
 
     cpdef void expire_order(self, Order order):
         if order.contingency_type != ContingencyType.NO_CONTINGENCY:
             self._cancel_contingent_orders(order)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/backtest/models.pxd` & `nautilus_trader-1.175.0/nautilus_trader/backtest/models.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/backtest/models.pyx` & `nautilus_trader-1.175.0/nautilus_trader/backtest/models.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/backtest/modules.pxd` & `nautilus_trader-1.175.0/nautilus_trader/backtest/modules.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/backtest/modules.pyx` & `nautilus_trader-1.175.0/nautilus_trader/backtest/modules.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/backtest/node.py` & `nautilus_trader-1.175.0/nautilus_trader/backtest/node.py`

 * *Files 1% similar despite different names*

```diff
@@ -24,16 +24,16 @@
 from nautilus_trader.config import ActorFactory
 from nautilus_trader.config import BacktestDataConfig
 from nautilus_trader.config import BacktestRunConfig
 from nautilus_trader.config import BacktestVenueConfig
 from nautilus_trader.core.correctness import PyCondition
 from nautilus_trader.core.inspect import is_nautilus_class
 from nautilus_trader.model.currency import Currency
-from nautilus_trader.model.data.base import DataType
-from nautilus_trader.model.data.base import GenericData
+from nautilus_trader.model.data import DataType
+from nautilus_trader.model.data import GenericData
 from nautilus_trader.model.enums import AccountType
 from nautilus_trader.model.enums import OmsType
 from nautilus_trader.model.enums import book_type_from_str
 from nautilus_trader.model.identifiers import ClientId
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.identifiers import Venue
 from nautilus_trader.model.objects import Money
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/backtest/results.py` & `nautilus_trader-1.175.0/nautilus_trader/backtest/results.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/cache/__init__.pxd` & `nautilus_trader-1.175.0/nautilus_trader/cache/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/cache/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/cache/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/cache/base.pxd` & `nautilus_trader-1.175.0/nautilus_trader/cache/base.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/cache/base.pyx` & `nautilus_trader-1.175.0/nautilus_trader/cache/base.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/cache/cache.pxd` & `nautilus_trader-1.175.0/nautilus_trader/cache/cache.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/cache/cache.pyx` & `nautilus_trader-1.175.0/nautilus_trader/cache/cache.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -35,14 +35,15 @@
 from nautilus_trader.core.rust.core cimport unix_timestamp_us
 from nautilus_trader.execution.messages cimport SubmitOrder
 from nautilus_trader.model.currency cimport Currency
 from nautilus_trader.model.data.bar cimport Bar
 from nautilus_trader.model.data.bar cimport BarType
 from nautilus_trader.model.data.tick cimport QuoteTick
 from nautilus_trader.model.data.tick cimport TradeTick
+from nautilus_trader.model.enums_c cimport ContingencyType
 from nautilus_trader.model.enums_c cimport OmsType
 from nautilus_trader.model.enums_c cimport OrderSide
 from nautilus_trader.model.enums_c cimport PositionSide
 from nautilus_trader.model.enums_c cimport PriceType
 from nautilus_trader.model.enums_c cimport TriggerType
 from nautilus_trader.model.identifiers cimport AccountId
 from nautilus_trader.model.identifiers cimport ClientOrderId
@@ -177,15 +178,15 @@
         self._log.debug(f"Loading currencies from database...")
 
         if self._database is not None:
             self._currencies = self._database.load_currencies()
         else:
             self._currencies = {}
 
-        # Register currencies in internal `_CURRENCY_MAP`.
+        # Register currencies with internal `CURRENCY_MAP`
         cdef Currency currency
         for currency in self._currencies.values():
             Currency.register_c(currency, overwrite=False)
 
         cdef int count = len(self._currencies)
         self._log.info(
             f"Cached {count} currenc{'y' if count == 1 else 'ies'} from database.",
@@ -235,14 +236,30 @@
         self._log.debug(f"Loading orders from database...")
 
         if self._database is not None:
             self._orders = self._database.load_orders()
         else:
             self._orders = {}
 
+        # Assign position IDs to contingent orders
+        cdef Order order
+        cdef Order contingent_order
+        cdef ClientOrderId client_order_id
+        for order in self._orders.values():
+            if order.contingency_type == ContingencyType.OTO:
+                for client_order_id in order.linked_order_ids or []:
+                    contingent_order = self._orders.get(client_order_id)
+                    if contingent_order is None:
+                        self._log.error(f"Contingency order {client_order_id!r} not found.")
+                        continue
+                    # Assign the parents position ID
+                    if contingent_order.position_id is None:
+                        self._log.info(f"Assigned {order.position_id!r} to {client_order_id!r}.")
+                        contingent_order.position_id = order.position_id
+
         cdef int count = len(self._orders)
         self._log.info(
             f"Cached {count} order{'' if count == 1 else 's'} from database.",
             color=LogColor.BLUE if self._orders else LogColor.NORMAL,
         )
 
     cpdef void cache_order_lists(self):
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/cache/database.pxd` & `nautilus_trader-1.175.0/nautilus_trader/cache/database.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/cache/database.pyx` & `nautilus_trader-1.175.0/nautilus_trader/cache/database.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/common/__init__.pxd` & `nautilus_trader-1.175.0/nautilus_trader/common/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/common/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/common/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/common/actor.pxd` & `nautilus_trader-1.175.0/nautilus_trader/common/actor.pxd`

 * *Files 0% similar despite different names*

```diff
@@ -26,14 +26,15 @@
 from nautilus_trader.core.uuid cimport UUID4
 from nautilus_trader.data.messages cimport DataCommand
 from nautilus_trader.data.messages cimport DataRequest
 from nautilus_trader.data.messages cimport DataResponse
 from nautilus_trader.model.data.bar cimport Bar
 from nautilus_trader.model.data.bar cimport BarType
 from nautilus_trader.model.data.base cimport DataType
+from nautilus_trader.model.data.book cimport OrderBookDeltas
 from nautilus_trader.model.data.tick cimport QuoteTick
 from nautilus_trader.model.data.tick cimport TradeTick
 from nautilus_trader.model.data.ticker cimport Ticker
 from nautilus_trader.model.data.venue cimport InstrumentClose
 from nautilus_trader.model.data.venue cimport InstrumentStatusUpdate
 from nautilus_trader.model.data.venue cimport VenueStatusUpdate
 from nautilus_trader.model.enums_c cimport BookType
@@ -71,15 +72,15 @@
     cpdef void on_dispose(self)
     cpdef void on_degrade(self)
     cpdef void on_fault(self)
     cpdef void on_venue_status_update(self, VenueStatusUpdate update)
     cpdef void on_instrument_status_update(self, InstrumentStatusUpdate update)
     cpdef void on_instrument_close(self, InstrumentClose update)
     cpdef void on_instrument(self, Instrument instrument)
-    cpdef void on_order_book_delta(self, Data data)
+    cpdef void on_order_book_deltas(self, OrderBookDeltas deltas)
     cpdef void on_order_book(self, OrderBook order_book)
     cpdef void on_ticker(self, Ticker ticker)
     cpdef void on_quote_tick(self, QuoteTick tick)
     cpdef void on_trade_tick(self, TradeTick tick)
     cpdef void on_bar(self, Bar bar)
     cpdef void on_data(self, Data data)
     cpdef void on_historical_data(self, Data data)
@@ -177,15 +178,15 @@
     )
 
 # -- HANDLERS -------------------------------------------------------------------------------------
 
     cpdef void handle_instrument(self, Instrument instrument)
     cpdef void handle_instruments(self, list instruments)
     cpdef void handle_order_book(self, OrderBook order_book)
-    cpdef void handle_order_book_delta(self, Data data)
+    cpdef void handle_order_book_deltas(self, OrderBookDeltas deltas)
     cpdef void handle_ticker(self, Ticker ticker)
     cpdef void handle_quote_tick(self, QuoteTick tick)
     cpdef void handle_quote_ticks(self, list ticks)
     cpdef void handle_trade_tick(self, TradeTick tick)
     cpdef void handle_trade_ticks(self, list ticks)
     cpdef void handle_bar(self, Bar bar)
     cpdef void handle_bars(self, list bars)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/common/actor.pyx` & `nautilus_trader-1.175.0/nautilus_trader/common/actor.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -53,15 +53,15 @@
 from nautilus_trader.data.messages cimport DataResponse
 from nautilus_trader.data.messages cimport Subscribe
 from nautilus_trader.data.messages cimport Unsubscribe
 from nautilus_trader.model.data.bar cimport Bar
 from nautilus_trader.model.data.bar cimport BarType
 from nautilus_trader.model.data.base cimport DataType
 from nautilus_trader.model.data.book cimport OrderBookDelta
-from nautilus_trader.model.data.book cimport OrderBookSnapshot
+from nautilus_trader.model.data.book cimport OrderBookDeltas
 from nautilus_trader.model.data.tick cimport QuoteTick
 from nautilus_trader.model.data.tick cimport TradeTick
 from nautilus_trader.model.data.ticker cimport Ticker
 from nautilus_trader.model.data.venue cimport InstrumentClose
 from nautilus_trader.model.data.venue cimport InstrumentStatusUpdate
 from nautilus_trader.model.data.venue cimport VenueStatusUpdate
 from nautilus_trader.model.enums_c cimport BookType
@@ -352,36 +352,36 @@
         System method (not intended to be called by user code).
 
         """
         # Optionally override in subclass
 
     cpdef void on_order_book(self, OrderBook order_book):
         """
-        Actions to be performed when running and receives an order book snapshot.
+        Actions to be performed when running and receives an order book.
 
         Parameters
         ----------
         order_book : OrderBook
             The order book received.
 
         Warnings
         --------
         System method (not intended to be called by user code).
 
         """
         # Optionally override in subclass
 
-    cpdef void on_order_book_delta(self, Data data):
+    cpdef void on_order_book_deltas(self, OrderBookDeltas deltas):
         """
-        Actions to be performed when running and receives order book data.
+        Actions to be performed when running and receives order book deltas.
 
         Parameters
         ----------
-        delta : OrderBookDelta, OrderBookDeltas, OrderBookSnapshot
-            The order book data received.
+        deltas : OrderBookDeltas
+            The order book deltas received.
 
         Warnings
         --------
         System method (not intended to be called by user code).
 
         """
         # Optionally override in subclass
@@ -804,15 +804,15 @@
         Condition.not_none(instrument_id, "instrument_id")
         Condition.true(self.trader_id is not None, "The actor has not been registered")
 
         self._msgbus.subscribe(
             topic=f"data.book.deltas"
                   f".{instrument_id.venue}"
                   f".{instrument_id.symbol}",
-            handler=self.handle_order_book_delta,
+            handler=self.handle_order_book_deltas,
         )
 
         cdef Subscribe command = Subscribe(
             client_id=client_id,
             venue=instrument_id.venue,
             data_type=DataType(OrderBookDelta, metadata={
                 "instrument_id": instrument_id,
@@ -832,15 +832,15 @@
         BookType book_type=BookType.L2_MBP,
         int depth = 0,
         int interval_ms = 1000,
         dict kwargs = None,
         ClientId client_id = None,
     ):
         """
-        Subscribe to `OrderBook` snapshots for the given instrument ID.
+        Subscribe to `OrderBook` snapshots at a specified interval, for the given instrument ID.
 
         The `DataEngine` will only maintain one order book for each instrument.
         Because of this - the level, depth and kwargs for the stream will be set
         as per the last subscription request (this will also affect all subscribers).
 
         Parameters
         ----------
@@ -885,15 +885,15 @@
                   f".{interval_ms}",
             handler=self.handle_order_book,
         )
 
         cdef Subscribe command = Subscribe(
             client_id=client_id,
             venue=instrument_id.venue,
-            data_type=DataType(OrderBookSnapshot, metadata={
+            data_type=DataType(OrderBook, metadata={
                 "instrument_id": instrument_id,
                 "book_type": book_type,
                 "depth": depth,
                 "interval_ms": interval_ms,
                 "kwargs": kwargs,
             }),
             command_id=UUID4(),
@@ -1076,15 +1076,15 @@
             If ``None`` then will be inferred from the venue in the instrument ID.
 
         """
         Condition.not_none(instrument_id, "instrument_id")
         Condition.true(self.trader_id is not None, "The actor has not been registered")
 
         self._msgbus.subscribe(
-            topic=f"data.status.{instrument_id.venue.to_str()}.{instrument_id.symbol}",
+            topic=f"data.status.{instrument_id.venue}.{instrument_id.symbol}",
             handler=self.handle_instrument_status_update,
         )
 
         cdef Subscribe command = Subscribe(
             client_id=client_id,
             venue=instrument_id.venue,
             data_type=DataType(InstrumentStatusUpdate, metadata={"instrument_id": instrument_id}),
@@ -1240,15 +1240,15 @@
         Condition.not_none(instrument_id, "instrument_id")
         Condition.true(self.trader_id is not None, "The actor has not been registered")
 
         self._msgbus.unsubscribe(
             topic=f"data.book.deltas"
                   f".{instrument_id.venue}"
                   f".{instrument_id.symbol}",
-            handler=self.handle_order_book_delta,
+            handler=self.handle_order_book_deltas,
         )
 
         cdef Unsubscribe command = Unsubscribe(
             client_id=client_id,
             venue=instrument_id.venue,
             data_type=DataType(OrderBookDelta, metadata={"instrument_id": instrument_id}),
             command_id=UUID4(),
@@ -1260,15 +1260,15 @@
     cpdef void unsubscribe_order_book_snapshots(
         self,
         InstrumentId instrument_id,
         int interval_ms = 1000,
         ClientId client_id = None,
     ):
         """
-        Unsubscribe from order book snapshots for the given instrument ID.
+        Unsubscribe from `OrderBook` snapshots, for the given instrument ID.
 
         The interval must match the previously subscribed interval.
 
         Parameters
         ----------
         instrument_id : InstrumentId
             The order book instrument to subscribe to.
@@ -1289,15 +1289,15 @@
                   f".{interval_ms}",
             handler=self.handle_order_book,
         )
 
         cdef Unsubscribe command = Unsubscribe(
             client_id=client_id,
             venue=instrument_id.venue,
-            data_type=DataType(OrderBookSnapshot, metadata={
+            data_type=DataType(OrderBook, metadata={
                 "instrument_id": instrument_id,
                 "interval_ms": interval_ms,
             }),
             command_id=UUID4(),
             ts_init=self._clock.timestamp_ns(),
         )
 
@@ -1478,15 +1478,15 @@
             If ``None`` then will be inferred from the venue.
 
         """
         Condition.not_none(instrument_id, "instrument_id")
         Condition.true(self.trader_id is not None, "The actor has not been registered")
 
         self._msgbus.unsubscribe(
-            topic=f"data.status.{instrument_id.venue.to_str()}.{instrument_id.symbol}",
+            topic=f"data.status.{instrument_id.venue}.{instrument_id.symbol}",
             handler=self.handle_venue_status_update,
         )
         cdef Unsubscribe command = Unsubscribe(
             client_id=client_id,
             venue=instrument_id.venue,
             data_type=DataType(InstrumentStatusUpdate),
             command_id=UUID4(),
@@ -1862,42 +1862,42 @@
         else:
             self._log.warning("Received <Instrument[]> data with no instruments.")
 
         cdef int i
         for i in range(length):
             self.handle_instrument(instruments[i])
 
-    cpdef void handle_order_book_delta(self, Data data):
+    cpdef void handle_order_book_deltas(self, OrderBookDeltas deltas):
         """
-        Handle the given order book data.
+        Handle the given order book deltas.
 
         Passes to `on_order_book_delta` if state is ``RUNNING``.
 
         Parameters
         ----------
-        delta : OrderBookDelta, OrderBookDeltas, OrderBookSnapshot
-            The order book delta received.
+        deltas : OrderBookDeltas
+            The order book deltas received.
 
         Warnings
         --------
         System method (not intended to be called by user code).
 
         """
-        Condition.not_none(data, "data")
+        Condition.not_none(deltas, "deltas")
 
         if self._fsm.state == ComponentState.RUNNING:
             try:
-                self.on_order_book_delta(data)
+                self.on_order_book_deltas(deltas)
             except Exception as e:
-                self._log.exception(f"Error on handling {repr(data)}", e)
+                self._log.exception(f"Error on handling {repr(deltas)}", e)
                 raise
 
     cpdef void handle_order_book(self, OrderBook order_book):
         """
-        Handle the given order book snapshot.
+        Handle the given order book.
 
         Passes to `on_order_book` if state is ``RUNNING``.
 
         Parameters
         ----------
         order_book : OrderBook
             The order book received.
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/common/clock.pxd` & `nautilus_trader-1.175.0/nautilus_trader/common/clock.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/common/clock.pyx` & `nautilus_trader-1.175.0/nautilus_trader/common/clock.pyx`

 * *Files 0% similar despite different names*

```diff
@@ -15,14 +15,15 @@
 
 import asyncio
 from typing import Callable, Optional
 
 import cython
 import numpy as np
 import pandas as pd
+import pytz
 
 from cpython.datetime cimport datetime
 from cpython.datetime cimport timedelta
 from cpython.datetime cimport tzinfo
 from cpython.object cimport PyCallable_Check
 from cpython.object cimport PyObject
 from libc.stdint cimport uint64_t
@@ -156,15 +157,15 @@
 
         Returns
         -------
         datetime
             The current tz-aware UTC time of the clock.
 
         """
-        return pd.Timestamp(self.timestamp_ns(), tz="UTC")
+        return pd.Timestamp(self.timestamp_ns(), tz=pytz.utc)
 
     cpdef datetime local_now(self, tzinfo tz = None):
         """
         Return the current datetime of the clock in the given local timezone.
 
         Parameters
         ----------
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/common/component.pxd` & `nautilus_trader-1.175.0/nautilus_trader/common/component.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/common/component.pyx` & `nautilus_trader-1.175.0/nautilus_trader/common/component.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -349,16 +349,16 @@
             self._log.exception(f"{repr(self)}: Error on initialize", e)
             raise
 
     cpdef void start(self):
         """
         Start the component.
 
-        While executing `on_start()`, any exception will be logged and reraised.
-        The component will remain in a ``STARTING`` state.
+        While executing `on_start()` any exception will be logged and reraised, then the component
+        will remain in a ``STARTING`` state.
 
         Warnings
         --------
         Do not override.
 
         If the component is not in a valid state from which to execute this method,
         then the component state will not change, and an error will be logged.
@@ -380,16 +380,16 @@
             action=None,
         )
 
     cpdef void stop(self):
         """
         Stop the component.
 
-        While executing `on_stop()`, any exception will be logged and reraised.
-        The component will remain in a ``STOPPING`` state.
+        While executing `on_stop()` any exception will be logged and reraised, then the component
+        will remain in a ``STOPPING`` state.
 
         Warnings
         --------
         Do not override.
 
         If the component is not in a valid state from which to execute this method,
         then the component state will not change, and an error will be logged.
@@ -411,16 +411,16 @@
             action=None,
         )
 
     cpdef void resume(self):
         """
         Resume the component.
 
-        While executing `on_resume()`, any exception will be logged and reraised.
-        The component will remain in a ``RESUMING`` state.
+        While executing `on_resume()` any exception will be logged and reraised, then the component
+        will remain in a ``RESUMING`` state.
 
         Warnings
         --------
         Do not override.
 
         If the component is not in a valid state from which to execute this method,
         then the component state will not change, and an error will be logged.
@@ -444,16 +444,16 @@
 
     cpdef void reset(self):
         """
         Reset the component.
 
         All stateful fields are reset to their initial value.
 
-        While executing `on_reset()`, any exception will be logged and reraised.
-        The component will remain in a ``RESETTING`` state.
+        While executing `on_reset()` any exception will be logged and reraised, then the component
+        will remain in a ``RESETTING`` state.
 
         Warnings
         --------
         Do not override.
 
         If the component is not in a valid state from which to execute this method,
         then the component state will not change, and an error will be logged.
@@ -475,16 +475,16 @@
             action=None,
         )
 
     cpdef void dispose(self):
         """
         Dispose of the component.
 
-        While executing `on_dispose()`, any exception will be logged and reraised.
-        The component will remain in a ``DISPOSING`` state.
+        While executing `on_dispose()` any exception will be logged and reraised, then the component
+        will remain in a ``DISPOSING`` state.
 
         Warnings
         --------
         Do not override.
 
         If the component is not in a valid state from which to execute this method,
         then the component state will not change, and an error will be logged.
@@ -506,16 +506,16 @@
             action=None,
         )
 
     cpdef void degrade(self):
         """
         Degrade the component.
 
-        While executing `on_degrade()`, any exception will be logged and reraised.
-        The component will remain in a ``DEGRADING`` state.
+        While executing `on_degrade()` any exception will be logged and reraised, then the component
+        will remain in a ``DEGRADING`` state.
 
         Warnings
         --------
         Do not override.
 
         If the component is not in a valid state from which to execute this method,
         then the component state will not change, and an error will be logged.
@@ -537,19 +537,19 @@
             action=None,
         )
 
     cpdef void fault(self):
         """
         Fault the component.
 
-        This method is idempotent and irreversible. No other methods should be
-        called after faulting.
+        Calling this method multiple times has the same effect as calling it once (it is idempotent).
+        Once called, it cannot be reversed, and no other methods should be called on this instance.
 
-        While executing `on_fault()`, any exception will be logged and reraised.
-        The component will remain in a ``FAULTING`` state.
+        While executing `on_fault()` any exception will be logged and reraised, then the component
+        will remain in a ``FAULTING`` state.
 
         Warnings
         --------
         Do not override.
 
         If the component is not in a valid state from which to execute this method,
         then the component state will not change, and an error will be logged.
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/common/enums.pyx` & `nautilus_trader-1.175.0/nautilus_trader/common/enums.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/common/enums_c.pxd` & `nautilus_trader-1.175.0/nautilus_trader/common/enums_c.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/common/enums_c.pyx` & `nautilus_trader-1.175.0/nautilus_trader/common/enums_c.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/common/factories.pxd` & `nautilus_trader-1.175.0/nautilus_trader/common/factories.pxd`

 * *Files 14% similar despite different names*

```diff
@@ -67,14 +67,15 @@
     cpdef MarketOrder market(
         self,
         InstrumentId instrument_id,
         OrderSide order_side,
         Quantity quantity,
         TimeInForce time_in_force=*,
         bint reduce_only=*,
+        bint quote_quantity=*,
         ExecAlgorithmId exec_algorithm_id=*,
         dict exec_algorithm_params=*,
         str tags=*,
     )
 
     cpdef LimitOrder limit(
         self,
@@ -82,16 +83,18 @@
         OrderSide order_side,
         Quantity quantity,
         Price price,
         TimeInForce time_in_force=*,
         datetime expire_time=*,
         bint post_only=*,
         bint reduce_only=*,
+        bint quote_quantity=*,
         Quantity display_qty=*,
         TriggerType emulation_trigger=*,
+        InstrumentId trigger_instrument_id=*,
         ExecAlgorithmId exec_algorithm_id=*,
         dict exec_algorithm_params=*,
         str tags=*,
     )
 
     cpdef StopMarketOrder stop_market(
         self,
@@ -99,15 +102,17 @@
         OrderSide order_side,
         Quantity quantity,
         Price trigger_price,
         TriggerType trigger_type=*,
         TimeInForce time_in_force=*,
         datetime expire_time=*,
         bint reduce_only=*,
+        bint quote_quantity=*,
         TriggerType emulation_trigger=*,
+        InstrumentId trigger_instrument_id=*,
         ExecAlgorithmId exec_algorithm_id=*,
         dict exec_algorithm_params=*,
         str tags=*,
     )
 
     cpdef StopLimitOrder stop_limit(
         self,
@@ -117,29 +122,32 @@
         Price price,
         Price trigger_price,
         TriggerType trigger_type=*,
         TimeInForce time_in_force=*,
         datetime expire_time=*,
         bint post_only=*,
         bint reduce_only=*,
+        bint quote_quantity=*,
         Quantity display_qty=*,
         TriggerType emulation_trigger=*,
+        InstrumentId trigger_instrument_id=*,
         ExecAlgorithmId exec_algorithm_id=*,
         dict exec_algorithm_params=*,
         str tags=*,
     )
 
     cpdef MarketToLimitOrder market_to_limit(
         self,
         InstrumentId instrument_id,
         OrderSide order_side,
         Quantity quantity,
         TimeInForce time_in_force=*,
         datetime expire_time=*,
         bint reduce_only=*,
+        bint quote_quantity=*,
         Quantity display_qty=*,
         ExecAlgorithmId exec_algorithm_id=*,
         dict exec_algorithm_params=*,
         str tags=*,
     )
 
     cpdef MarketIfTouchedOrder market_if_touched(
@@ -148,15 +156,17 @@
         OrderSide order_side,
         Quantity quantity,
         Price trigger_price,
         TriggerType trigger_type=*,
         TimeInForce time_in_force=*,
         datetime expire_time=*,
         bint reduce_only=*,
+        bint quote_quantity=*,
         TriggerType emulation_trigger=*,
+        InstrumentId trigger_instrument_id=*,
         ExecAlgorithmId exec_algorithm_id=*,
         dict exec_algorithm_params=*,
         str tags=*,
     )
 
     cpdef LimitIfTouchedOrder limit_if_touched(
         self,
@@ -166,16 +176,18 @@
         Price price,
         Price trigger_price,
         TriggerType trigger_type=*,
         TimeInForce time_in_force=*,
         datetime expire_time=*,
         bint post_only=*,
         bint reduce_only=*,
+        bint quote_quantity=*,
         Quantity display_qty=*,
         TriggerType emulation_trigger=*,
+        InstrumentId trigger_instrument_id=*,
         ExecAlgorithmId exec_algorithm_id=*,
         dict exec_algorithm_params=*,
         str tags=*,
     )
 
     cpdef TrailingStopMarketOrder trailing_stop_market(
         self,
@@ -185,15 +197,17 @@
         trailing_offset: Decimal,
         Price trigger_price=*,
         TriggerType trigger_type=*,
         TrailingOffsetType trailing_offset_type=*,
         TimeInForce time_in_force=*,
         datetime expire_time=*,
         bint reduce_only=*,
+        bint quote_quantity=*,
         TriggerType emulation_trigger=*,
+        InstrumentId trigger_instrument_id=*,
         ExecAlgorithmId exec_algorithm_id=*,
         dict exec_algorithm_params=*,
         str tags=*,
     )
 
     cpdef TrailingStopLimitOrder trailing_stop_limit(
         self,
@@ -206,16 +220,18 @@
         Price trigger_price=*,
         TriggerType trigger_type=*,
         TrailingOffsetType trailing_offset_type=*,
         TimeInForce time_in_force=*,
         datetime expire_time=*,
         bint post_only=*,
         bint reduce_only=*,
+        bint quote_quantity=*,
         Quantity display_qty=*,
         TriggerType emulation_trigger=*,
+        InstrumentId trigger_instrument_id=*,
         ExecAlgorithmId exec_algorithm_id=*,
         dict exec_algorithm_params=*,
         str tags=*,
     )
 
     cpdef OrderList bracket(
         self,
@@ -229,15 +245,17 @@
         Price tp_price=*,
         OrderType entry_order_type=*,
         OrderType tp_order_type=*,
         TimeInForce time_in_force=*,
         datetime expire_time=*,
         bint entry_post_only=*,
         bint tp_post_only=*,
+        bint quote_quantity=*,
         TriggerType emulation_trigger=*,
+        InstrumentId trigger_instrument_id=*,
         ContingencyType contingency_type=*,
         ExecAlgorithmId entry_exec_algorithm_id=*,
         ExecAlgorithmId sl_exec_algorithm_id=*,
         ExecAlgorithmId tp_exec_algorithm_id=*,
         dict entry_exec_algorithm_params=*,
         dict tp_exec_algorithm_params=*,
         dict sl_exec_algorithm_params=*,
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/common/factories.pyx` & `nautilus_trader-1.175.0/nautilus_trader/common/factories.pyx`

 * *Files 24% similar despite different names*

```diff
@@ -198,14 +198,15 @@
     cpdef MarketOrder market(
         self,
         InstrumentId instrument_id,
         OrderSide order_side,
         Quantity quantity,
         TimeInForce time_in_force = TimeInForce.GTC,
         bint reduce_only = False,
+        bint quote_quantity = False,
         ExecAlgorithmId exec_algorithm_id = None,
         dict exec_algorithm_params = None,
         str tags = None,
     ):
         """
         Create a new ``MARKET`` order.
 
@@ -217,14 +218,16 @@
             The orders side.
         quantity : Quantity
             The orders quantity (> 0).
         time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``DAY``, ``AT_THE_OPEN``, ``AT_THE_CLOSE``}, default ``GTC``
             The orders time in force. Often not applicable for market orders.
         reduce_only : bool, default False
             If the order carries the 'reduce-only' execution instruction.
+        quote_quantity : bool
+            If the order quantity is denominated in the quote currency.
         exec_algorithm_id : ExecAlgorithmId, optional
             The execution algorithm ID for the order.
         exec_algorithm_params : dict[str, Any], optional
             The execution algorithm parameters for the order.
         tags : str, optional
             The custom user tags for the order. These are optional and can
             contain any arbitrary delimiter if required.
@@ -246,14 +249,15 @@
             strategy_id=self.strategy_id,
             instrument_id=instrument_id,
             client_order_id=self._order_id_generator.generate(),
             order_side=order_side,
             quantity=quantity,
             time_in_force=time_in_force,
             reduce_only=reduce_only,
+            quote_quantity=quote_quantity,
             init_id=UUID4(),
             ts_init=self._clock.timestamp_ns(),
             contingency_type=ContingencyType.NO_CONTINGENCY,
             order_list_id=None,
             linked_order_ids=None,
             parent_order_id=None,
             exec_algorithm_id=exec_algorithm_id,
@@ -267,16 +271,18 @@
         OrderSide order_side,
         Quantity quantity,
         Price price,
         TimeInForce time_in_force = TimeInForce.GTC,
         datetime expire_time = None,
         bint post_only = False,
         bint reduce_only = False,
+        bint quote_quantity = False,
         Quantity display_qty = None,
         TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
+        InstrumentId trigger_instrument_id = None,
         ExecAlgorithmId exec_algorithm_id = None,
         dict exec_algorithm_params = None,
         str tags = None,
     ):
         """
         Create a new ``LIMIT`` order.
 
@@ -294,18 +300,22 @@
             The orders time in force.
         expire_time : datetime, optional
             The order expiration (for ``GTD`` orders).
         post_only : bool, default False
             If the order will only provide liquidity (make a market).
         reduce_only : bool, default False
             If the order carries the 'reduce-only' execution instruction.
+        quote_quantity : bool
+            If the order quantity is denominated in the quote currency.
         display_qty : Quantity, optional
             The quantity of the order to display on the public book (iceberg).
         emulation_trigger : TriggerType, default ``NO_TRIGGER``
             The orders emulation trigger.
+        trigger_instrument_id : InstrumentId, optional
+            The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
         exec_algorithm_id : ExecAlgorithmId, optional
             The execution algorithm ID for the order.
         exec_algorithm_params : dict[str, Any], optional
             The execution algorithm parameters for the order.
         tags : str, optional
             The custom user tags for the order. These are optional and can
             contain any arbitrary delimiter if required.
@@ -334,16 +344,18 @@
             price=price,
             init_id=UUID4(),
             ts_init=self._clock.timestamp_ns(),
             time_in_force=time_in_force,
             expire_time_ns=0 if expire_time is None else dt_to_unix_nanos(expire_time),
             post_only=post_only,
             reduce_only=reduce_only,
+            quote_quantity=quote_quantity,
             display_qty=display_qty,
             emulation_trigger=emulation_trigger,
+            trigger_instrument_id=trigger_instrument_id,
             contingency_type=ContingencyType.NO_CONTINGENCY,
             order_list_id=None,
             linked_order_ids=None,
             parent_order_id=None,
             exec_algorithm_id=exec_algorithm_id,
             exec_algorithm_params=exec_algorithm_params,
             tags=tags,
@@ -355,15 +367,17 @@
         OrderSide order_side,
         Quantity quantity,
         Price trigger_price,
         TriggerType trigger_type = TriggerType.DEFAULT,
         TimeInForce time_in_force = TimeInForce.GTC,
         datetime expire_time = None,
         bint reduce_only = False,
+        bint quote_quantity = False,
         TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
+        InstrumentId trigger_instrument_id = None,
         ExecAlgorithmId exec_algorithm_id = None,
         dict exec_algorithm_params = None,
         str tags = None,
     ):
         """
         Create a new ``STOP_MARKET`` conditional order.
 
@@ -381,16 +395,20 @@
             The order trigger type.
         time_in_force : TimeInForce  {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``}, default ``GTC``
             The orders time in force.
         expire_time : datetime, optional
             The order expiration (for ``GTD`` orders).
         reduce_only : bool, default False
             If the order carries the 'reduce-only' execution instruction.
+        quote_quantity : bool
+            If the order quantity is denominated in the quote currency.
         emulation_trigger : TriggerType, default ``NO_TRIGGER``
             The orders emulation trigger.
+        trigger_instrument_id : InstrumentId, optional
+            The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
         exec_algorithm_id : ExecAlgorithmId, optional
             The execution algorithm ID for the order.
         exec_algorithm_params : dict[str, Any], optional
             The execution algorithm parameters for the order.
         tags : str, optional
             The custom user tags for the order. These are optional and can
             contain any arbitrary delimiter if required.
@@ -421,15 +439,17 @@
             trigger_price=trigger_price,
             trigger_type=trigger_type,
             init_id=UUID4(),
             ts_init=self._clock.timestamp_ns(),
             time_in_force=time_in_force,
             expire_time_ns=0 if expire_time is None else dt_to_unix_nanos(expire_time),
             reduce_only=reduce_only,
+            quote_quantity=quote_quantity,
             emulation_trigger=emulation_trigger,
+            trigger_instrument_id=trigger_instrument_id,
             contingency_type=ContingencyType.NO_CONTINGENCY,
             order_list_id=None,
             linked_order_ids=None,
             parent_order_id=None,
             exec_algorithm_id=exec_algorithm_id,
             exec_algorithm_params=exec_algorithm_params,
             tags=tags,
@@ -443,16 +463,18 @@
         Price price,
         Price trigger_price,
         TriggerType trigger_type = TriggerType.DEFAULT,
         TimeInForce time_in_force = TimeInForce.GTC,
         datetime expire_time = None,
         bint post_only = False,
         bint reduce_only = False,
+        bint quote_quantity = False,
         Quantity display_qty = None,
         TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
+        InstrumentId trigger_instrument_id = None,
         ExecAlgorithmId exec_algorithm_id = None,
         dict exec_algorithm_params = None,
         str tags = None,
     ):
         """
         Create a new ``STOP_LIMIT`` conditional order.
 
@@ -474,18 +496,22 @@
             The orders time in force.
         expire_time : datetime, optional
             The order expiration (for ``GTD`` orders).
         post_only : bool, default False
             If the order will only provide liquidity (make a market).
         reduce_only : bool, default False
             If the order carries the 'reduce-only' execution instruction.
+        quote_quantity : bool
+            If the order quantity is denominated in the quote currency.
         display_qty : Quantity, optional
             The quantity of the order to display on the public book (iceberg).
         emulation_trigger : TriggerType, default ``NO_TRIGGER``
             The orders emulation trigger.
+        trigger_instrument_id : InstrumentId, optional
+            The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
         exec_algorithm_id : ExecAlgorithmId, optional
             The execution algorithm ID for the order.
         exec_algorithm_params : dict[str, Any], optional
             The execution algorithm parameters for the order.
         tags : str, optional
             The custom user tags for the order. These are optional and can
             contain any arbitrary delimiter if required.
@@ -520,16 +546,18 @@
             trigger_type=trigger_type,
             init_id=UUID4(),
             ts_init=self._clock.timestamp_ns(),
             time_in_force=time_in_force,
             expire_time_ns=0 if expire_time is None else dt_to_unix_nanos(expire_time),
             post_only=post_only,
             reduce_only=reduce_only,
+            quote_quantity=quote_quantity,
             display_qty=display_qty,
             emulation_trigger=emulation_trigger,
+            trigger_instrument_id=trigger_instrument_id,
             contingency_type=ContingencyType.NO_CONTINGENCY,
             order_list_id=None,
             linked_order_ids=None,
             parent_order_id=None,
             exec_algorithm_id=exec_algorithm_id,
             exec_algorithm_params=exec_algorithm_params,
             tags=tags,
@@ -539,14 +567,15 @@
         self,
         InstrumentId instrument_id,
         OrderSide order_side,
         Quantity quantity,
         TimeInForce time_in_force = TimeInForce.GTC,
         datetime expire_time = None,
         bint reduce_only = False,
+        bint quote_quantity = False,
         Quantity display_qty = None,
         ExecAlgorithmId exec_algorithm_id = None,
         dict exec_algorithm_params = None,
         str tags = None,
     ):
         """
         Create a new ``MARKET`` order.
@@ -561,14 +590,16 @@
             The orders quantity (> 0).
         time_in_force : TimeInForce {``GTC``, ``GTD``, ``IOC``, ``FOK``}, default ``GTC``
             The orders time in force.
         expire_time : datetime, optional
             The order expiration (for ``GTD`` orders).
         reduce_only : bool, default False
             If the order carries the 'reduce-only' execution instruction.
+        quote_quantity : bool
+            If the order quantity is denominated in the quote currency.
         display_qty : Quantity, optional
             The quantity of the limit order to display on the public book (iceberg).
         exec_algorithm_id : ExecAlgorithmId, optional
             The execution algorithm ID for the order.
         exec_algorithm_params : dict[str, Any], optional
             The execution algorithm parameters for the order.
         tags : str, optional
@@ -615,15 +646,17 @@
         OrderSide order_side,
         Quantity quantity,
         Price trigger_price,
         TriggerType trigger_type = TriggerType.DEFAULT,
         TimeInForce time_in_force = TimeInForce.GTC,
         datetime expire_time = None,
         bint reduce_only = False,
+        bint quote_quantity = False,
         TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
+        InstrumentId trigger_instrument_id = None,
         ExecAlgorithmId exec_algorithm_id = None,
         dict exec_algorithm_params = None,
         str tags = None,
     ):
         """
         Create a new ``MARKET_IF_TOUCHED`` (MIT) conditional order.
 
@@ -641,16 +674,20 @@
             The order trigger type.
         time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``}, default ``GTC``
             The orders time in force.
         expire_time : datetime, optional
             The order expiration (for ``GTD`` orders).
         reduce_only : bool, default False
             If the order carries the 'reduce-only' execution instruction.
+        quote_quantity : bool
+            If the order quantity is denominated in the quote currency.
         emulation_trigger : TriggerType, default ``NO_TRIGGER``
             The orders emulation trigger.
+        trigger_instrument_id : InstrumentId, optional
+            The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
         exec_algorithm_id : ExecAlgorithmId, optional
             The execution algorithm ID for the order.
         exec_algorithm_params : dict[str, Any], optional
             The execution algorithm parameters for the order.
         tags : str, optional
             The custom user tags for the order. These are optional and can
             contain any arbitrary delimiter if required.
@@ -681,15 +718,17 @@
             trigger_price=trigger_price,
             trigger_type=trigger_type,
             init_id=UUID4(),
             ts_init=self._clock.timestamp_ns(),
             time_in_force=time_in_force,
             expire_time_ns=0 if expire_time is None else dt_to_unix_nanos(expire_time),
             reduce_only=reduce_only,
+            quote_quantity=quote_quantity,
             emulation_trigger=emulation_trigger,
+            trigger_instrument_id=trigger_instrument_id,
             contingency_type=ContingencyType.NO_CONTINGENCY,
             order_list_id=None,
             linked_order_ids=None,
             parent_order_id=None,
             exec_algorithm_id=exec_algorithm_id,
             exec_algorithm_params=exec_algorithm_params,
             tags=tags,
@@ -703,16 +742,18 @@
         Price price,
         Price trigger_price,
         TriggerType trigger_type = TriggerType.DEFAULT,
         TimeInForce time_in_force = TimeInForce.GTC,
         datetime expire_time = None,
         bint post_only = False,
         bint reduce_only = False,
+        bint quote_quantity = False,
         Quantity display_qty = None,
         TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
+        InstrumentId trigger_instrument_id = None,
         ExecAlgorithmId exec_algorithm_id = None,
         dict exec_algorithm_params = None,
         str tags = None,
     ):
         """
         Create a new ``LIMIT_IF_TOUCHED`` (LIT) conditional order.
 
@@ -734,18 +775,22 @@
             The orders time in force.
         expire_time : datetime, optional
             The order expiration (for ``GTD`` orders).
         post_only : bool, default False
             If the order will only provide liquidity (make a market).
         reduce_only : bool, default False
             If the order carries the 'reduce-only' execution instruction.
+        quote_quantity : bool
+            If the order quantity is denominated in the quote currency.
         display_qty : Quantity, optional
             The quantity of the order to display on the public book (iceberg).
         emulation_trigger : TriggerType, default ``NO_TRIGGER``
             The orders emulation trigger.
+        trigger_instrument_id : InstrumentId, optional
+            The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
         exec_algorithm_id : ExecAlgorithmId, optional
             The execution algorithm ID for the order.
         exec_algorithm_params : dict[str, Any], optional
             The execution algorithm parameters for the order.
         tags : str, optional
             The custom user tags for the order. These are optional and can
             contain any arbitrary delimiter if required.
@@ -780,16 +825,18 @@
             trigger_type=trigger_type,
             init_id=UUID4(),
             ts_init=self._clock.timestamp_ns(),
             time_in_force=time_in_force,
             expire_time_ns=0 if expire_time is None else dt_to_unix_nanos(expire_time),
             post_only=post_only,
             reduce_only=reduce_only,
+            quote_quantity=quote_quantity,
             display_qty=display_qty,
             emulation_trigger=emulation_trigger,
+            trigger_instrument_id=trigger_instrument_id,
             contingency_type=ContingencyType.NO_CONTINGENCY,
             order_list_id=None,
             linked_order_ids=None,
             parent_order_id=None,
             exec_algorithm_id=exec_algorithm_id,
             exec_algorithm_params=exec_algorithm_params,
             tags=tags,
@@ -803,15 +850,17 @@
         trailing_offset: Decimal,
         Price trigger_price = None,
         TriggerType trigger_type = TriggerType.DEFAULT,
         TrailingOffsetType trailing_offset_type = TrailingOffsetType.PRICE,
         TimeInForce time_in_force = TimeInForce.GTC,
         datetime expire_time = None,
         bint reduce_only = False,
+        bint quote_quantity = False,
         TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
+        InstrumentId trigger_instrument_id = None,
         ExecAlgorithmId exec_algorithm_id = None,
         dict exec_algorithm_params = None,
         str tags = None,
     ):
         """
         Create a new ``TRAILING_STOP_MARKET`` conditional order.
 
@@ -834,14 +883,16 @@
             The order trailing offset type.
         time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``}, default ``GTC``
             The orders time in force.
         expire_time : datetime, optional
             The order expiration (for ``GTD`` orders).
         reduce_only : bool, default False
             If the order carries the 'reduce-only' execution instruction.
+        quote_quantity : bool
+            If the order quantity is denominated in the quote currency.
         emulation_trigger : TriggerType, default ``NO_TRIGGER``
             The orders emulation trigger.
         exec_algorithm_id : ExecAlgorithmId, optional
             The execution algorithm ID for the order.
         exec_algorithm_params : dict[str, Any], optional
             The execution algorithm parameters for the order.
         tags : str, optional
@@ -878,15 +929,17 @@
             trailing_offset=trailing_offset,
             trailing_offset_type=trailing_offset_type,
             init_id=UUID4(),
             ts_init=self._clock.timestamp_ns(),
             time_in_force=time_in_force,
             expire_time_ns=0 if expire_time is None else dt_to_unix_nanos(expire_time),
             reduce_only=reduce_only,
+            quote_quantity=quote_quantity,
             emulation_trigger=emulation_trigger,
+            trigger_instrument_id=trigger_instrument_id,
             contingency_type=ContingencyType.NO_CONTINGENCY,
             order_list_id=None,
             linked_order_ids=None,
             parent_order_id=None,
             exec_algorithm_id=exec_algorithm_id,
             exec_algorithm_params=exec_algorithm_params,
             tags=tags,
@@ -903,16 +956,18 @@
         Price trigger_price = None,
         TriggerType trigger_type = TriggerType.DEFAULT,
         TrailingOffsetType trailing_offset_type = TrailingOffsetType.PRICE,
         TimeInForce time_in_force = TimeInForce.GTC,
         datetime expire_time = None,
         bint post_only = False,
         bint reduce_only = False,
+        bint quote_quantity = False,
         Quantity display_qty = None,
         TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
+        InstrumentId trigger_instrument_id = None,
         ExecAlgorithmId exec_algorithm_id = None,
         dict exec_algorithm_params = None,
         str tags = None,
     ):
         """
         Create a new ``TRAILING_STOP_LIMIT`` conditional order.
 
@@ -942,18 +997,22 @@
             The orders time in force.
         expire_time : datetime, optional
             The order expiration (for ``GTD`` orders).
         post_only : bool, default False
             If the order will only provide liquidity (make a market).
         reduce_only : bool, default False
             If the order carries the 'reduce-only' execution instruction.
+        quote_quantity : bool
+            If the order quantity is denominated in the quote currency.
         display_qty : Quantity, optional
             The quantity of the order to display on the public book (iceberg).
         emulation_trigger : TriggerType, default ``NO_TRIGGER``
             The orders emulation trigger.
+        trigger_instrument_id : InstrumentId, optional
+            The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
         exec_algorithm_id : ExecAlgorithmId, optional
             The execution algorithm ID for the order.
         exec_algorithm_params : dict[str, Any], optional
             The execution algorithm parameters for the order.
         tags : str, optional
             The custom user tags for the order. These are optional and can
             contain any arbitrary delimiter if required.
@@ -993,16 +1052,18 @@
             trailing_offset_type=trailing_offset_type,
             init_id=UUID4(),
             ts_init=self._clock.timestamp_ns(),
             time_in_force=time_in_force,
             expire_time_ns=0 if expire_time is None else dt_to_unix_nanos(expire_time),
             post_only=post_only,
             reduce_only=reduce_only,
+            quote_quantity=quote_quantity,
             display_qty=display_qty,
             emulation_trigger=emulation_trigger,
+            trigger_instrument_id=trigger_instrument_id,
             contingency_type=ContingencyType.NO_CONTINGENCY,
             order_list_id=None,
             linked_order_ids=None,
             parent_order_id=None,
             exec_algorithm_id=exec_algorithm_id,
             exec_algorithm_params=exec_algorithm_params,
             tags=tags,
@@ -1020,15 +1081,17 @@
         Price tp_price = None,
         OrderType entry_order_type = OrderType.MARKET,
         OrderType tp_order_type = OrderType.LIMIT,
         TimeInForce time_in_force = TimeInForce.GTC,
         datetime expire_time = None,
         bint entry_post_only = False,
         bint tp_post_only = True,
+        bint quote_quantity = False,
         TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
+        InstrumentId trigger_instrument_id = None,
         ContingencyType contingency_type = ContingencyType.OUO,
         ExecAlgorithmId entry_exec_algorithm_id = None,
         ExecAlgorithmId sl_exec_algorithm_id = None,
         ExecAlgorithmId tp_exec_algorithm_id = None,
         dict entry_exec_algorithm_params = None,
         dict tp_exec_algorithm_params = None,
         dict sl_exec_algorithm_params = None,
@@ -1066,16 +1129,20 @@
             The entry orders time in force.
         expire_time : datetime, optional
             The order expiration (for ``GTD`` orders).
         entry_post_only : bool, default False
             If the entry order will only provide liquidity (make a market).
         tp_post_only : bool, default False
             If the take-profit order will only provide liquidity (make a market).
+        quote_quantity : bool
+            If order quantity is denominated in the quote currency.
         emulation_trigger : TriggerType, default ``NO_TRIGGER``
             The emulation trigger type for the entry, as well as the TP and SL bracket orders.
+        trigger_instrument_id : InstrumentId, optional
+            The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
         contingency_type : ContingencyType, default ``OUO``
             The contingency type for the TP and SL bracket orders.
         entry_exec_algorithm_id : ExecAlgorithmId, optional
             The entry order execution algorithm ID.
         sl_exec_algorithm_id : ExecAlgorithmId, optional
             The stop-loss order execution algorithm ID.
         tp_exec_algorithm_id : ExecAlgorithmId, optional
@@ -1107,14 +1174,15 @@
                 instrument_id=instrument_id,
                 client_order_id=entry_client_order_id,
                 order_side=order_side,
                 quantity=quantity,
                 init_id=UUID4(),
                 ts_init=self._clock.timestamp_ns(),
                 time_in_force=TimeInForce.GTC,
+                quote_quantity=quote_quantity,
                 contingency_type=ContingencyType.OTO,
                 order_list_id=order_list_id,
                 linked_order_ids=[sl_client_order_id, tp_client_order_id],
                 parent_order_id=None,
                 exec_algorithm_id=entry_exec_algorithm_id,
                 exec_algorithm_params=entry_exec_algorithm_params,
                 tags="ENTRY",
@@ -1129,15 +1197,17 @@
                 quantity=quantity,
                 price=entry_price,
                 init_id=UUID4(),
                 ts_init=self._clock.timestamp_ns(),
                 time_in_force=time_in_force,
                 expire_time_ns=0 if expire_time is None else dt_to_unix_nanos(expire_time),
                 post_only=entry_post_only,
+                quote_quantity=quote_quantity,
                 emulation_trigger=emulation_trigger,
+                trigger_instrument_id=trigger_instrument_id,
                 contingency_type=ContingencyType.OTO,
                 order_list_id=order_list_id,
                 linked_order_ids=[sl_client_order_id, tp_client_order_id],
                 parent_order_id=None,
                 exec_algorithm_id=entry_exec_algorithm_id,
                 exec_algorithm_params=entry_exec_algorithm_params,
                 tags="ENTRY",
@@ -1152,15 +1222,17 @@
                 quantity=quantity,
                 trigger_price=entry_trigger_price,
                 trigger_type=TriggerType.DEFAULT,
                 init_id=UUID4(),
                 ts_init=self._clock.timestamp_ns(),
                 time_in_force=time_in_force,
                 expire_time_ns=0 if expire_time is None else dt_to_unix_nanos(expire_time),
+                quote_quantity=quote_quantity,
                 emulation_trigger=emulation_trigger,
+                trigger_instrument_id=trigger_instrument_id,
                 contingency_type=ContingencyType.OTO,
                 order_list_id=order_list_id,
                 linked_order_ids=[sl_client_order_id, tp_client_order_id],
                 parent_order_id=None,
                 exec_algorithm_id=entry_exec_algorithm_id,
                 exec_algorithm_params=entry_exec_algorithm_params,
                 tags="ENTRY",
@@ -1177,15 +1249,17 @@
                 trigger_price=entry_trigger_price,
                 trigger_type=TriggerType.DEFAULT,
                 init_id=UUID4(),
                 ts_init=self._clock.timestamp_ns(),
                 time_in_force=time_in_force,
                 expire_time_ns=0 if expire_time is None else dt_to_unix_nanos(expire_time),
                 post_only=entry_post_only,
+                quote_quantity=quote_quantity,
                 emulation_trigger=emulation_trigger,
+                trigger_instrument_id=trigger_instrument_id,
                 contingency_type=ContingencyType.OTO,
                 order_list_id=order_list_id,
                 linked_order_ids=[sl_client_order_id, tp_client_order_id],
                 parent_order_id=None,
                 exec_algorithm_id=entry_exec_algorithm_id,
                 exec_algorithm_params=entry_exec_algorithm_params,
                 tags="ENTRY",
@@ -1206,16 +1280,18 @@
                 quantity=quantity,
                 price=tp_price,
                 init_id=UUID4(),
                 ts_init=self._clock.timestamp_ns(),
                 time_in_force=TimeInForce.GTC,
                 post_only=tp_post_only,
                 reduce_only=True,
+                quote_quantity=quote_quantity,
                 display_qty=None,
                 emulation_trigger=emulation_trigger,
+                trigger_instrument_id=trigger_instrument_id,
                 contingency_type=contingency_type,
                 order_list_id=order_list_id,
                 linked_order_ids=[sl_client_order_id],
                 parent_order_id=entry_client_order_id,
                 exec_algorithm_id=tp_exec_algorithm_id,
                 exec_algorithm_params=tp_exec_algorithm_params,
                 tags="TAKE_PROFIT",
@@ -1232,16 +1308,18 @@
                 trigger_price=tp_trigger_price,
                 trigger_type=TriggerType.DEFAULT,
                 init_id=UUID4(),
                 ts_init=self._clock.timestamp_ns(),
                 time_in_force=TimeInForce.GTC,
                 post_only=tp_post_only,
                 reduce_only=True,
+                quote_quantity=quote_quantity,
                 display_qty=None,
                 emulation_trigger=emulation_trigger,
+                trigger_instrument_id=trigger_instrument_id,
                 contingency_type=contingency_type,
                 order_list_id=order_list_id,
                 linked_order_ids=[sl_client_order_id],
                 parent_order_id=entry_client_order_id,
                 exec_algorithm_id=tp_exec_algorithm_id,
                 exec_algorithm_params=tp_exec_algorithm_params,
                 tags="TAKE_PROFIT",
@@ -1256,15 +1334,17 @@
                 quantity=quantity,
                 trigger_price=tp_trigger_price,
                 trigger_type=TriggerType.DEFAULT,
                 init_id=UUID4(),
                 ts_init=self._clock.timestamp_ns(),
                 time_in_force=TimeInForce.GTC,
                 reduce_only=True,
+                quote_quantity=quote_quantity,
                 emulation_trigger=emulation_trigger,
+                trigger_instrument_id=trigger_instrument_id,
                 contingency_type=contingency_type,
                 order_list_id=order_list_id,
                 linked_order_ids=[sl_client_order_id],
                 parent_order_id=entry_client_order_id,
                 exec_algorithm_id=tp_exec_algorithm_id,
                 exec_algorithm_params=tp_exec_algorithm_params,
                 tags="TAKE_PROFIT",
@@ -1284,15 +1364,17 @@
             quantity=quantity,
             trigger_price=sl_trigger_price,
             trigger_type=TriggerType.DEFAULT,
             init_id=UUID4(),
             ts_init=self._clock.timestamp_ns(),
             time_in_force=TimeInForce.GTC,
             reduce_only=True,
+            quote_quantity=quote_quantity,
             emulation_trigger=emulation_trigger,
+            trigger_instrument_id=trigger_instrument_id,
             contingency_type=contingency_type,
             order_list_id=order_list_id,
             linked_order_ids=[tp_client_order_id],
             parent_order_id=entry_client_order_id,
             exec_algorithm_id=sl_exec_algorithm_id,
             exec_algorithm_params=sl_exec_algorithm_params,
             tags="STOP_LOSS",
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/common/functions.py` & `nautilus_trader-1.175.0/nautilus_trader/common/functions.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/common/generators.pxd` & `nautilus_trader-1.175.0/nautilus_trader/common/generators.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/common/generators.pyx` & `nautilus_trader-1.175.0/nautilus_trader/common/generators.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/common/logging.pxd` & `nautilus_trader-1.175.0/nautilus_trader/common/logging.pxd`

 * *Files 10% similar despite different names*

```diff
@@ -15,63 +15,63 @@
 
 from typing import Callable
 
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.common.clock cimport Clock
 from nautilus_trader.common.logging cimport Logger
-from nautilus_trader.core.rust.common cimport CLogger
 from nautilus_trader.core.rust.common cimport LogColor
+from nautilus_trader.core.rust.common cimport Logger_API
 from nautilus_trader.core.rust.common cimport LogLevel
 
 
 cdef str RECV
 cdef str SENT
 cdef str CMD
 cdef str EVT
 cdef str DOC
 cdef str RPT
 cdef str REQ
 cdef str RES
 
 
 cdef class Logger:
-    cdef CLogger _mem
+    cdef Logger_API _mem
     cdef Clock _clock
 
     cpdef void change_clock(self, Clock clock)
     cdef void log(
         self,
-        uint64_t timestamp_ns,
+        uint64_t timestamp,
         LogLevel level,
         LogColor color,
         str component,
-        str msg,
+        str message,
         dict annotations=*,
     )
     cdef void _log(
         self,
-        uint64_t timestamp_ns,
+        uint64_t timestamp,
         LogLevel level,
         LogColor color,
         str component,
-        str msg,
+        str message,
         dict annotations,
     )
 
 
 cdef class LoggerAdapter:
     cdef Logger _logger
     cdef str _component
     cdef bint _is_bypassed
 
     cpdef Logger get_logger(self)
-    cpdef void debug(self, str msg, LogColor color=*, dict annotations=*)
-    cpdef void info(self, str msg, LogColor color=*, dict annotations=*)
-    cpdef void warning(self, str msg, LogColor color=*, dict annotations=*)
-    cpdef void error(self, str msg, LogColor color=*, dict annotations=*)
-    cpdef void critical(self, str msg, LogColor color=*, dict annotations=*)
-    cpdef void exception(self, str msg, ex, dict annotations=*)
+    cpdef void debug(self, str message, LogColor color=*, dict annotations=*)
+    cpdef void info(self, str message, LogColor color=*, dict annotations=*)
+    cpdef void warning(self, str message, LogColor color=*, dict annotations=*)
+    cpdef void error(self, str message, LogColor color=*, dict annotations=*)
+    cpdef void critical(self, str message, LogColor color=*, dict annotations=*)
+    cpdef void exception(self, str message, ex, dict annotations=*)
 
 
 cpdef void nautilus_header(LoggerAdapter logger)
 cpdef void log_memory(LoggerAdapter logger)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/common/logging.pyx` & `nautilus_trader-1.175.0/nautilus_trader/common/logging.pyx`

 * *Files 4% similar despite different names*

```diff
@@ -200,46 +200,46 @@
         """
         Condition.not_none(clock, "clock")
 
         self._clock = clock
 
     cdef void log(
         self,
-        uint64_t timestamp_ns,
+        uint64_t timestamp,
         LogLevel level,
         LogColor color,
         str component,
-        str msg,
+        str message,
         dict annotations = None,
     ):
         self._log(
-            timestamp_ns,
+            timestamp,
             level,
             color,
             component,
-            msg,
+            message,
             annotations,
         )
 
     cdef void _log(
         self,
-        uint64_t timestamp_ns,
+        uint64_t timestamp,
         LogLevel level,
         LogColor color,
         str component,
-        str msg,
+        str message,
         dict annotations,
     ):
         logger_log(
             &self._mem,
-            timestamp_ns,
+            timestamp,
             level,
             color,
             pystr_to_cstr(component),
-            pystr_to_cstr(msg),
+            pystr_to_cstr(message),
         )
 
 
 cdef class LoggerAdapter:
     """
     Provides an adapter for a components logger.
 
@@ -331,189 +331,189 @@
         Logger
 
         """
         return self._logger
 
     cpdef void debug(
         self,
-        str msg,
+        str message,
         LogColor color = LogColor.NORMAL,
         dict annotations = None,
     ):
         """
         Log the given debug message with the logger.
 
         Parameters
         ----------
-        msg : str
-            The message to log.
+        message : str
+            The log message content.
         color : LogColor, optional
-            The color for the log record.
+            The log message color.
         annotations : dict[str, object], optional
             The annotations for the log record.
 
         """
-        Condition.not_none(msg, "message")
+        Condition.not_none(message, "message")
 
         if self.is_bypassed:
             return
 
         self._logger.log(
             self._logger._clock.timestamp_ns(),
             LogLevel.DEBUG,
             color,
             self.component,
-            msg,
+            message,
             annotations,
         )
 
     cpdef void info(
-        self, str msg,
+        self, str message,
         LogColor color = LogColor.NORMAL,
         dict annotations = None,
     ):
         """
         Log the given information message with the logger.
 
         Parameters
         ----------
-        msg : str
-            The message to log.
+        message : str
+            The log message content.
         color : LogColor, optional
-            The color for the log record.
+            The log message color.
         annotations : dict[str, object], optional
             The annotations for the log record.
 
         """
-        Condition.not_none(msg, "msg")
+        Condition.not_none(message, "message")
 
         if self.is_bypassed:
             return
 
         self._logger.log(
             self._logger._clock.timestamp_ns(),
             LogLevel.INFO,
             color,
             self.component,
-            msg,
+            message,
             annotations,
         )
 
     cpdef void warning(
         self,
-        str msg,
+        str message,
         LogColor color = LogColor.YELLOW,
         dict annotations = None,
     ):
         """
         Log the given warning message with the logger.
 
         Parameters
         ----------
-        msg : str
-            The message to log.
+        message : str
+            The log message content.
         color : LogColor, optional
-            The color for the log record.
+            The log message color.
         annotations : dict[str, object], optional
             The annotations for the log record.
 
         """
-        Condition.not_none(msg, "msg")
+        Condition.not_none(message, "message")
 
         if self.is_bypassed:
             return
 
         self._logger.log(
             self._logger._clock.timestamp_ns(),
             LogLevel.WARNING,
             color,
             self.component,
-            msg,
+            message,
             annotations,
         )
 
     cpdef void error(
         self,
-        str msg,
+        str message,
         LogColor color = LogColor.RED,
         dict annotations = None,
     ):
         """
         Log the given error message with the logger.
 
         Parameters
         ----------
-        msg : str
-            The message to log.
+        message : str
+            The log message content.
         color : LogColor, optional
-            The color for the log record.
+            The log message color.
         annotations : dict[str, object], optional
             The annotations for the log record.
 
         """
-        Condition.not_none(msg, "msg")
+        Condition.not_none(message, "message")
 
         if self.is_bypassed:
             return
 
         self._logger.log(
             self._logger._clock.timestamp_ns(),
             LogLevel.ERROR,
             color,
             self.component,
-            msg,
+            message,
             annotations,
         )
 
     cpdef void critical(
         self,
-        str msg,
+        str message,
         LogColor color = LogColor.RED,
         dict annotations = None,
     ):
         """
         Log the given critical message with the logger.
 
         Parameters
         ----------
-        msg : str
-            The message to log.
+        message : str
+            The log message content.
         color : LogColor, optional
-            The color for the log record.
+            The log message color.
         annotations : dict[str, object], optional
             The annotations for the log record.
 
         """
-        Condition.not_none(msg, "msg")
+        Condition.not_none(message, "message")
 
         if self.is_bypassed:
             return
 
         self._logger.log(
             self._logger._clock.timestamp_ns(),
             LogLevel.CRITICAL,
             color,
             self.component,
-            msg,
+            message,
             annotations,
         )
 
     cpdef void exception(
         self,
-        str msg,
+        str message,
         ex,
         dict annotations = None,
     ):
         """
         Log the given exception including stack trace information.
 
         Parameters
         ----------
-        msg : str
-            The message to log.
+        message : str
+            The log message content.
         ex : Exception
             The exception to log.
         annotations : dict[str, object], optional
             The annotations for the log record.
 
         """
         Condition.not_none(ex, "ex")
@@ -523,15 +523,15 @@
         stack_trace = traceback.format_exception(ex_type, ex_value, ex_traceback)
 
         cdef str stack_trace_lines = ""
         cdef str line
         for line in stack_trace[:len(stack_trace) - 1]:
             stack_trace_lines += line
 
-        self.error(f"{msg}\n{ex_string}\n{stack_trace_lines}", annotations=annotations)
+        self.error(f"{message}\n{ex_string}\n{stack_trace_lines}", annotations=annotations)
 
 
 cpdef void nautilus_header(LoggerAdapter logger):
     Condition.not_none(logger, "logger")
     print("")  # New line to begin
     logger.info("\033[36m=================================================================")
     logger.info(f"\033[36m NAUTILUS TRADER - Automated Algorithmic Trading Platform")
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/common/messages.pxd` & `nautilus_trader-1.175.0/nautilus_trader/common/messages.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/common/messages.pyx` & `nautilus_trader-1.175.0/nautilus_trader/common/messages.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/common/providers.py` & `nautilus_trader-1.175.0/nautilus_trader/common/providers.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/common/queue.pxd` & `nautilus_trader-1.175.0/nautilus_trader/common/queue.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/common/queue.pyx` & `nautilus_trader-1.175.0/nautilus_trader/common/queue.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/common/throttler.pxd` & `nautilus_trader-1.175.0/nautilus_trader/common/throttler.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/common/throttler.pyx` & `nautilus_trader-1.175.0/nautilus_trader/common/throttler.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/common/timer.pxd` & `nautilus_trader-1.175.0/nautilus_trader/common/timer.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/common/timer.pyx` & `nautilus_trader-1.175.0/nautilus_trader/common/timer.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/config/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/config/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/config/backtest.py` & `nautilus_trader-1.175.0/nautilus_trader/config/backtest.py`

 * *Files 1% similar despite different names*

```diff
@@ -26,15 +26,15 @@
 from nautilus_trader.config.common import DataEngineConfig
 from nautilus_trader.config.common import ExecEngineConfig
 from nautilus_trader.config.common import ImportableConfig
 from nautilus_trader.config.common import NautilusConfig
 from nautilus_trader.config.common import NautilusKernelConfig
 from nautilus_trader.config.common import RiskEngineConfig
 from nautilus_trader.core.datetime import maybe_dt_to_unix_nanos
-from nautilus_trader.model.data.bar import Bar
+from nautilus_trader.model.data import Bar
 from nautilus_trader.model.identifiers import ClientId
 
 
 class BacktestVenueConfig(NautilusConfig, frozen=True):
     """
     Represents a venue configuration for one specific backtest engine.
     """
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/config/common.py` & `nautilus_trader-1.175.0/nautilus_trader/config/common.py`

 * *Files 8% similar despite different names*

```diff
@@ -17,14 +17,15 @@
 import importlib.util
 from typing import Any, Optional
 
 import fsspec
 import msgspec
 
 from nautilus_trader.common import Environment
+from nautilus_trader.config.validation import PositiveFloat
 from nautilus_trader.config.validation import PositiveInt
 from nautilus_trader.core.correctness import PyCondition
 from nautilus_trader.persistence.catalog.parquet import ParquetDataCatalog
 
 
 def resolve_path(path: str):
     module, cls = path.rsplit(":", maxsplit=1)
@@ -245,20 +246,23 @@
 
     Parameters
     ----------
     load_cache : bool, default True
         If the cache should be loaded on initialization.
     allow_cash_positions : bool, default True
         If unleveraged spot/cash assets should generate positions.
+    filter_unclaimed_external_orders : bool, default False
+        If unclaimed order events with an EXTERNAL strategy ID should be filtered/dropped.
     debug : bool, default False
         If debug mode is active (will provide extra debug logging).
     """
 
     load_cache: bool = True
     allow_cash_positions: bool = True
+    filter_unclaimed_external_orders: bool = False
     debug: bool = False
 
 
 class OrderEmulatorConfig(NautilusConfig, frozen=True):
     """
     Configuration for ``OrderEmulator`` instances.
     """
@@ -591,14 +595,24 @@
         The strategy configurations for the kernel.
     load_state : bool, default True
         If trading strategy state should be loaded from the database on start.
     save_state : bool, default True
         If trading strategy state should be saved to the database on stop.
     loop_debug : bool, default False
         If the asyncio event loop should be in debug mode.
+    timeout_connection : PositiveFloat (seconds)
+        The timeout for all clients to connect and initialize.
+    timeout_reconciliation : PositiveFloat (seconds)
+        The timeout for execution state to reconcile.
+    timeout_portfolio : PositiveFloat (seconds)
+        The timeout for portfolio to initialize margins and unrealized PnLs.
+    timeout_disconnection : PositiveFloat (seconds)
+        The timeout for all engine clients to disconnect.
+    timeout_post_stop : PositiveFloat (seconds)
+        The timeout after stopping the node to await residual events before final shutdown.
     """
 
     environment: Environment
     trader_id: str
     instance_id: Optional[str] = None
     cache: Optional[CacheConfig] = None
     cache_database: Optional[CacheDatabaseConfig] = None
@@ -610,14 +624,19 @@
     actors: list[ImportableActorConfig] = []
     strategies: list[ImportableStrategyConfig] = []
     exec_algorithms: list[ImportableExecAlgorithmConfig] = []
     load_state: bool = False
     save_state: bool = False
     loop_debug: bool = False
     logging: Optional[LoggingConfig] = None
+    timeout_connection: PositiveFloat = 10.0
+    timeout_reconciliation: PositiveFloat = 10.0
+    timeout_portfolio: PositiveFloat = 10.0
+    timeout_disconnection: PositiveFloat = 10.0
+    timeout_post_stop: PositiveFloat = 10.0
 
 
 class ImportableFactoryConfig(NautilusConfig, frozen=True):
     """
     Represents an importable (JSON) factory config.
     """
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/config/error.py` & `nautilus_trader-1.175.0/nautilus_trader/config/error.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/config/live.py` & `nautilus_trader-1.175.0/nautilus_trader/config/live.py`

 * *Files 26% similar despite different names*

```diff
@@ -19,15 +19,14 @@
 from nautilus_trader.config.common import DataEngineConfig
 from nautilus_trader.config.common import ExecEngineConfig
 from nautilus_trader.config.common import InstrumentProviderConfig
 from nautilus_trader.config.common import NautilusConfig
 from nautilus_trader.config.common import NautilusKernelConfig
 from nautilus_trader.config.common import RiskEngineConfig
 from nautilus_trader.config.validation import NonNegativeInt
-from nautilus_trader.config.validation import PositiveFloat
 from nautilus_trader.config.validation import PositiveInt
 
 
 class LiveDataEngineConfig(DataEngineConfig, frozen=True):
     """
     Configuration for ``LiveDataEngine`` instances.
 
@@ -160,31 +159,16 @@
         The live execution engine configuration.
     streaming : StreamingConfig, optional
         The configuration for streaming to feather files.
     data_clients : dict[str, ImportableConfig | LiveDataClientConfig], optional
         The data client configurations.
     exec_clients : dict[str, ImportableConfig | LiveExecClientConfig], optional
         The execution client configurations.
-    timeout_connection : PositiveFloat (seconds)
-        The timeout for all clients to connect and initialize.
-    timeout_reconciliation : PositiveFloat (seconds)
-        The timeout for execution state to reconcile.
-    timeout_portfolio : PositiveFloat (seconds)
-        The timeout for portfolio to initialize margins and unrealized PnLs.
-    timeout_disconnection : PositiveFloat (seconds)
-        The timeout for all engine clients to disconnect.
-    timeout_post_stop : PositiveFloat (seconds)
-        The timeout after stopping the node to await residual events before final shutdown.
     """
 
     environment: Environment = Environment.LIVE
     trader_id: str = "TRADER-001"
     data_engine: LiveDataEngineConfig = LiveDataEngineConfig()
     risk_engine: LiveRiskEngineConfig = LiveRiskEngineConfig()
     exec_engine: LiveExecEngineConfig = LiveExecEngineConfig()
     data_clients: dict[str, LiveDataClientConfig] = {}
     exec_clients: dict[str, LiveExecClientConfig] = {}
-    timeout_connection: PositiveFloat = 10.0
-    timeout_reconciliation: PositiveFloat = 10.0
-    timeout_portfolio: PositiveFloat = 10.0
-    timeout_disconnection: PositiveFloat = 10.0
-    timeout_post_stop: PositiveFloat = 10.0
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/config/validation.py` & `nautilus_trader-1.175.0/nautilus_trader/config/validation.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/core/__init__.pxd` & `nautilus_trader-1.175.0/nautilus_trader/core/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/core/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/core/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/core/asynchronous.py` & `nautilus_trader-1.175.0/nautilus_trader/core/asynchronous.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/core/correctness.pxd` & `nautilus_trader-1.175.0/nautilus_trader/core/correctness.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/core/correctness.pyx` & `nautilus_trader-1.175.0/nautilus_trader/core/correctness.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/core/data.pxd` & `nautilus_trader-1.175.0/nautilus_trader/adapters/interactive_brokers/client/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -9,15 +9,11 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from libc.stdint cimport uint64_t
+from .client import InteractiveBrokersClient
 
 
-cdef class Data:
-    cdef readonly uint64_t ts_event
-    """The UNIX timestamp (nanoseconds) when the data event occurred.\n\n:returns: `uint64_t`"""
-    cdef readonly uint64_t ts_init
-    """The UNIX timestamp (nanoseconds) when the object was initialized.\n\n:returns: `uint64_t`"""
+__all__ = ("InteractiveBrokersClient",)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/core/datetime.pxd` & `nautilus_trader-1.175.0/nautilus_trader/core/datetime.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/core/datetime.pyx` & `nautilus_trader-1.175.0/nautilus_trader/core/datetime.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -18,15 +18,15 @@
 
 Functions include awareness/tz checks and conversions, as well as ISO 8601 conversion.
 """
 
 import pandas as pd
 import pytz
 
-from cpython.datetime cimport datetime
+cimport cpython.datetime
 from cpython.datetime cimport datetime_tzinfo
 from cpython.unicode cimport PyUnicode_Contains
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.core.correctness cimport Condition
 from nautilus_trader.core.rust.core cimport micros_to_nanos as rust_micros_to_nanos
 from nautilus_trader.core.rust.core cimport millis_to_nanos as rust_millis_to_nanos
@@ -35,15 +35,15 @@
 from nautilus_trader.core.rust.core cimport nanos_to_secs as rust_nanos_to_secs
 from nautilus_trader.core.rust.core cimport secs_to_millis as rust_secs_to_millis
 from nautilus_trader.core.rust.core cimport secs_to_nanos as rust_secs_to_nanos
 
 
 # UNIX epoch is the UTC time at 00:00:00 on 1/1/1970
 # https://en.wikipedia.org/wiki/Unix_time
-cdef datetime UNIX_EPOCH = pd.Timestamp("1970-01-01", tz="UTC")
+cdef datetime UNIX_EPOCH = pd.Timestamp("1970-01-01", tz=pytz.utc)
 
 
 cpdef uint64_t secs_to_nanos(double secs):
     """
     Return round nanoseconds (ns) converted from the given seconds.
 
     Parameters
@@ -171,15 +171,15 @@
         The UNIX time (nanoseconds) to convert.
 
     Returns
     -------
     pd.Timestamp
 
     """
-    return pd.Timestamp(nanos, unit="ns", tz="UTC")
+    return pd.Timestamp(nanos, unit="ns", tz=pytz.utc)
 
 
 cpdef dt_to_unix_nanos(dt: pd.Timestamp):
     """
     Return the UNIX time (nanoseconds) from the given datetime (UTC).
 
     Parameters
@@ -220,15 +220,15 @@
     -------
     pd.Timestamp or ``None``
 
     """
     if nanos is None:
         return None
     else:
-        return pd.Timestamp(nanos, unit="ns", tz="UTC")
+        return pd.Timestamp(nanos, unit="ns", tz=pytz.utc)
 
 
 cpdef maybe_dt_to_unix_nanos(dt: pd.Timestamp):
     """
     Return the UNIX time (nanoseconds) from the given datetime, or ``None``.
 
     If dt is ``None``, then will return None.
@@ -362,15 +362,15 @@
 
     if data.empty:
         return data
 
     if data.index.tzinfo is None:  # tz-naive
         return data.tz_localize(pytz.utc)
     elif data.index.tzinfo != pytz.utc:
-        return pytz.utc.localize(data.index)
+        return data.tz_convert(None).tz_localize(pytz.utc)
     else:
         return data  # Already UTC
 
 
 cpdef str format_iso8601(datetime dt):
     """
     Format the given datetime to a millisecond accurate ISO 8601 specification
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/core/fsm.pxd` & `nautilus_trader-1.175.0/nautilus_trader/core/fsm.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/core/fsm.pyx` & `nautilus_trader-1.175.0/nautilus_trader/core/fsm.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/core/includes/backtest.h` & `nautilus_trader-1.175.0/nautilus_trader/core/includes/backtest.h`

 * *Files 0% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-/* Generated with cbindgen:0.24.3 */
+/* Generated with cbindgen:0.24.5 */
 
 /* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */
 
 #include <stdint.h>
 #include <Python.h>
 
 /**
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/core/includes/core.h` & `nautilus_trader-1.175.0/nautilus_trader/core/includes/core.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
-/* Generated with cbindgen:0.24.3 */
+/* Generated with cbindgen:0.24.5 */
 
 /* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */
 
 #include <stdint.h>
 #include <Python.h>
 
-typedef struct Rc_String Rc_String;
+typedef struct Arc_String Arc_String;
 
 /**
  * `CVec` is a C compatible struct that stores an opaque pointer to a block of
  * memory, it's length and the capacity of the vector it was allocated from.
  *
  * NOTE: Changing the values here may lead to undefined behaviour when the
  * memory is dropped.
@@ -28,15 +28,15 @@
      * The capacity of vector from which it was allocated.
      * Used when deallocating the memory
      */
     uintptr_t cap;
 } CVec;
 
 typedef struct UUID4_t {
-    struct Rc_String *value;
+    struct Arc_String *value;
 } UUID4_t;
 
 void cvec_drop(struct CVec cvec);
 
 struct CVec cvec_new(void);
 
 /**
@@ -74,26 +74,32 @@
  */
 uint64_t nanos_to_micros(uint64_t nanos);
 
 /**
  * Return the decimal precision inferred from the given C string.
  *
  * # Safety
+ *
  * - Assumes `ptr` is a valid C string pointer.
+ *
  * # Panics
+ *
  * - If `ptr` is null.
  */
 uint8_t precision_from_cstr(const char *ptr);
 
 /**
  * Drops the C string memory at the pointer.
  *
  * # Safety
+ *
  * - Assumes `ptr` is a valid C string pointer.
+ *
  * # Panics
+ *
  * - If `ptr` is null.
  */
 void cstr_drop(const char *ptr);
 
 /**
  * Returns the current seconds since the UNIX epoch.
  */
@@ -120,16 +126,19 @@
 
 void uuid4_drop(struct UUID4_t uuid4);
 
 /**
  * Returns a [`UUID4`] from C string pointer.
  *
  * # Safety
+ *
  * - Assumes `ptr` is a valid C string pointer.
+ *
  * # Panics
+ *
  * - If `ptr` cannot be cast to a valid C string.
  */
 struct UUID4_t uuid4_from_cstr(const char *ptr);
 
 const char *uuid4_to_cstr(const struct UUID4_t *uuid);
 
 uint8_t uuid4_eq(const struct UUID4_t *lhs, const struct UUID4_t *rhs);
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/core/inspect.py` & `nautilus_trader-1.175.0/nautilus_trader/core/inspect.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/core/message.pxd` & `nautilus_trader-1.175.0/nautilus_trader/core/message.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/core/message.pyx` & `nautilus_trader-1.175.0/nautilus_trader/core/message.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/core/rust/__init__.pxd` & `nautilus_trader-1.175.0/nautilus_trader/core/rust/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/core/rust/backtest.pxd` & `nautilus_trader-1.175.0/nautilus_trader/core/rust/backtest.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/core/rust/common.pyx` & `nautilus_trader-1.175.0/nautilus_trader/core/rust/common.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/core/rust/core.pxd` & `nautilus_trader-1.175.0/nautilus_trader/core/rust/core.pxd`

 * *Files 6% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 # Warning, this file is autogenerated by cbindgen. Don't modify this manually. */
 
 from libc.stdint cimport uint8_t, uint64_t, uintptr_t
 
 cdef extern from "../includes/core.h":
 
-    cdef struct Rc_String:
+    cdef struct Arc_String:
         pass
 
     # `CVec` is a C compatible struct that stores an opaque pointer to a block of
     # memory, it's length and the capacity of the vector it was allocated from.
     #
     # NOTE: Changing the values here may lead to undefined behaviour when the
     # memory is dropped.
@@ -19,15 +19,15 @@
         # The number of elements in the block.
         uintptr_t len;
         # The capacity of vector from which it was allocated.
         # Used when deallocating the memory
         uintptr_t cap;
 
     cdef struct UUID4_t:
-        Rc_String *value;
+        Arc_String *value;
 
     void cvec_drop(CVec cvec);
 
     CVec cvec_new();
 
     # Converts seconds to nanoseconds (ns).
     uint64_t secs_to_nanos(double secs);
@@ -49,24 +49,30 @@
 
     # Converts nanoseconds (ns) to microseconds (s).
     uint64_t nanos_to_micros(uint64_t nanos);
 
     # Return the decimal precision inferred from the given C string.
     #
     # # Safety
+    #
     # - Assumes `ptr` is a valid C string pointer.
+    #
     # # Panics
+    #
     # - If `ptr` is null.
     uint8_t precision_from_cstr(const char *ptr);
 
     # Drops the C string memory at the pointer.
     #
     # # Safety
+    #
     # - Assumes `ptr` is a valid C string pointer.
+    #
     # # Panics
+    #
     # - If `ptr` is null.
     void cstr_drop(const char *ptr);
 
     # Returns the current seconds since the UNIX epoch.
     double unix_timestamp();
 
     # Returns the current milliseconds since the UNIX epoch.
@@ -83,16 +89,19 @@
     UUID4_t uuid4_clone(const UUID4_t *uuid4);
 
     void uuid4_drop(UUID4_t uuid4);
 
     # Returns a [`UUID4`] from C string pointer.
     #
     # # Safety
+    #
     # - Assumes `ptr` is a valid C string pointer.
+    #
     # # Panics
+    #
     # - If `ptr` cannot be cast to a valid C string.
     UUID4_t uuid4_from_cstr(const char *ptr);
 
     const char *uuid4_to_cstr(const UUID4_t *uuid);
 
     uint8_t uuid4_eq(const UUID4_t *lhs, const UUID4_t *rhs);
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/core/rust/model.pyx` & `nautilus_trader-1.175.0/nautilus_trader/core/rust/model.pyx`

 * *Files 0% similar despite different names*

```diff
@@ -20,15 +20,14 @@
 from nautilus_trader.core.rust.model cimport AggressorSide  # type: ignore
 from nautilus_trader.core.rust.model cimport AssetClass  # type: ignore
 from nautilus_trader.core.rust.model cimport AssetType  # type: ignore
 from nautilus_trader.core.rust.model cimport BookAction  # type: ignore
 from nautilus_trader.core.rust.model cimport BookType  # type: ignore
 from nautilus_trader.core.rust.model cimport ContingencyType  # type: ignore
 from nautilus_trader.core.rust.model cimport CurrencyType  # type: ignore
-from nautilus_trader.core.rust.model cimport DepthType  # type: ignore
 from nautilus_trader.core.rust.model cimport InstrumentCloseType  # type: ignore
 from nautilus_trader.core.rust.model cimport LiquiditySide  # type: ignore
 from nautilus_trader.core.rust.model cimport MarketStatus  # type: ignore
 from nautilus_trader.core.rust.model cimport OmsType  # type: ignore
 from nautilus_trader.core.rust.model cimport OptionKind  # type: ignore
 from nautilus_trader.core.rust.model cimport OrderSide  # type: ignore
 from nautilus_trader.core.rust.model cimport OrderStatus  # type: ignore
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/core/stats.pxd` & `nautilus_trader-1.175.0/nautilus_trader/core/stats.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/core/stats.pyx` & `nautilus_trader-1.175.0/nautilus_trader/core/stats.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/core/string.pxd` & `nautilus_trader-1.175.0/nautilus_trader/core/string.pxd`

 * *Files 9% similar despite different names*

```diff
@@ -17,14 +17,20 @@
 
 
 cdef extern from "Python.h":
     # Similar to PyUnicode_FromUnicode(), but u points to null-terminated
     # UTF-8 encoded bytes. The size is determined with strlen().
     unicode PyUnicode_FromString(const char *u)  # noqa
 
+    # Return value: New reference.
+    # Return a new string object with the value v on success, and NULL
+    # on failure. The parameter v must not be NULL; it will not be
+    # checked.
+    bytes PyBytes_FromString(char *v)
+
     # Return a pointer to the UTF-8 encoding of the Unicode object,
     # and store the size of the encoded representation (in bytes) in size.
     # The size argument can be NULL; in this case no size will be stored.
     # The returned buffer always has an extra null byte appended
     # (not included in size), regardless of whether there are any
     # other null code points.
 
@@ -56,14 +62,23 @@
 
     # Assumes `ptr` was created from Rust `CString::from_raw`,
     # otherwise will lead to undefined behaviour when passed to `cstr_drop`.
     cstr_drop(ptr)
     return obj
 
 
+cdef inline bytes cstr_to_pybytes(const char* ptr):
+    cdef bytes obj = PyBytes_FromString(ptr)
+
+    # Assumes `ptr` was created from Rust `CString::from_raw`,
+    # otherwise will lead to undefined behaviour when passed to `cstr_drop`.
+    cstr_drop(ptr)
+    return obj
+
+
 cdef inline const char* pystr_to_cstr(str value):
     return PyUnicode_AsUTF8AndSize(value, NULL)
 
 
 cdef inline const char* pybytes_to_cstr(bytes value):
     if not PyBytes_Check(value):
         raise TypeError("expected a bytes object")
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/core/uuid.pxd` & `nautilus_trader-1.175.0/nautilus_trader/core/uuid.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/core/uuid.pyx` & `nautilus_trader-1.175.0/nautilus_trader/core/uuid.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/data/__init__.pxd` & `nautilus_trader-1.175.0/nautilus_trader/data/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/data/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/data/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/data/aggregation.pxd` & `nautilus_trader-1.175.0/nautilus_trader/data/aggregation.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/data/aggregation.pyx` & `nautilus_trader-1.175.0/nautilus_trader/data/aggregation.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/data/client.pxd` & `nautilus_trader-1.175.0/nautilus_trader/data/client.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/data/client.pyx` & `nautilus_trader-1.175.0/nautilus_trader/data/client.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -445,30 +445,30 @@
             f"Cannot subscribe to `OrderBookDeltas` data for {instrument_id}: not implemented. "  # pragma: no cover
             f"You can implement by overriding the `subscribe_order_book_deltas` method for this client.",  # pragma: no cover
         )
         raise NotImplementedError("method must be implemented in the subclass")
 
     cpdef void subscribe_order_book_snapshots(self, InstrumentId instrument_id, BookType book_type, int depth = 0, dict kwargs = None):
         """
-        Subscribe to `OrderBookSnapshot` data for the given instrument ID.
+        Subscribe to `OrderBook` snapshots data for the given instrument ID.
 
         Parameters
         ----------
         instrument_id : InstrumentId
             The order book instrument to subscribe to.
         book_type : BookType {``L1_TBBO``, ``L2_MBP``, ``L3_MBO``}
             The order book level.
         depth : int, optional
             The maximum depth for the order book. A depth of 0 is maximum depth.
         kwargs : dict, optional
             The keyword arguments for exchange specific parameters.
 
         """
         self._log.error(  # pragma: no cover
-            f"Cannot subscribe to `OrderBookSnapshot` data for {instrument_id}: not implemented. "  # pragma: no cover
+            f"Cannot subscribe to `OrderBook` snapshots data for {instrument_id}: not implemented. "  # pragma: no cover
             f"You can implement by overriding the `subscribe_order_book_snapshots` method for this client.",  # pragma: no cover
         )
         raise NotImplementedError("method must be implemented in the subclass")
 
     cpdef void subscribe_ticker(self, InstrumentId instrument_id):
         """
         Subscribe to `Ticker` data for the given instrument ID.
@@ -637,24 +637,24 @@
             f"Cannot unsubscribe from `OrderBookDeltas` data for {instrument_id}: not implemented. "  # pragma: no cover
             f"You can implement by overriding the `unsubscribe_order_book_deltas` method for this client.",  # pragma: no cover
         )
         raise NotImplementedError("method must be implemented in the subclass")
 
     cpdef void unsubscribe_order_book_snapshots(self, InstrumentId instrument_id):
         """
-        Unsubscribe from `OrderBookSnapshot` data for the given instrument ID.
+        Unsubscribe from `OrderBook` snapshots data for the given instrument ID.
 
         Parameters
         ----------
         instrument_id : InstrumentId
             The order book instrument to unsubscribe from.
 
         """
         self._log.error(  # pragma: no cover
-            f"Cannot unsubscribe from `OrderBookSnapshot` data for {instrument_id}: not implemented. "  # pragma: no cover
+            f"Cannot unsubscribe from `OrderBook` snapshot data for {instrument_id}: not implemented. "  # pragma: no cover
             f"You can implement by overriding the `unsubscribe_order_book_snapshots` method for this client.",  # pragma: no cover
         )
         raise NotImplementedError("method must be implemented in the subclass")
 
     cpdef void unsubscribe_ticker(self, InstrumentId instrument_id):
         """
         Unsubscribe from `Ticker` data for the given instrument ID.
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/data/engine.pxd` & `nautilus_trader-1.175.0/nautilus_trader/data/engine.pxd`

 * *Files 2% similar despite different names*

```diff
@@ -25,14 +25,15 @@
 from nautilus_trader.data.messages cimport Subscribe
 from nautilus_trader.data.messages cimport Unsubscribe
 from nautilus_trader.model.data.bar cimport Bar
 from nautilus_trader.model.data.bar cimport BarType
 from nautilus_trader.model.data.base cimport DataType
 from nautilus_trader.model.data.base cimport GenericData
 from nautilus_trader.model.data.book cimport OrderBookDelta
+from nautilus_trader.model.data.book cimport OrderBookDeltas
 from nautilus_trader.model.data.tick cimport QuoteTick
 from nautilus_trader.model.data.tick cimport TradeTick
 from nautilus_trader.model.data.ticker cimport Ticker
 from nautilus_trader.model.data.venue cimport InstrumentClose
 from nautilus_trader.model.data.venue cimport InstrumentStatusUpdate
 from nautilus_trader.model.data.venue cimport VenueStatusUpdate
 from nautilus_trader.model.identifiers cimport InstrumentId
@@ -128,15 +129,16 @@
     cpdef void _handle_request(self, DataRequest request)
     cpdef void _query_data_catalog(self, DataRequest request)
 
 # -- DATA HANDLERS --------------------------------------------------------------------------------
 
     cpdef void _handle_data(self, Data data)
     cpdef void _handle_instrument(self, Instrument instrument)
-    cpdef void _handle_order_book_data(self, Data data)
+    cpdef void _handle_order_book_delta(self, OrderBookDelta delta)
+    cpdef void _handle_order_book_deltas(self, OrderBookDeltas deltas)
     cpdef void _handle_ticker(self, Ticker ticker)
     cpdef void _handle_quote_tick(self, QuoteTick tick)
     cpdef void _handle_trade_tick(self, TradeTick tick)
     cpdef void _handle_bar(self, Bar bar)
     cpdef void _handle_generic_data(self, GenericData data)
     cpdef void _handle_venue_status_update(self, VenueStatusUpdate data)
     cpdef void _handle_instrument_status_update(self, InstrumentStatusUpdate data)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/data/engine.pyx` & `nautilus_trader-1.175.0/nautilus_trader/data/engine.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -63,18 +63,16 @@
 from nautilus_trader.data.messages cimport DataRequest
 from nautilus_trader.data.messages cimport DataResponse
 from nautilus_trader.data.messages cimport Subscribe
 from nautilus_trader.data.messages cimport Unsubscribe
 from nautilus_trader.model.data.bar cimport Bar
 from nautilus_trader.model.data.bar cimport BarType
 from nautilus_trader.model.data.base cimport DataType
-from nautilus_trader.model.data.book cimport ORDER_BOOK_DATA
 from nautilus_trader.model.data.book cimport OrderBookDelta
 from nautilus_trader.model.data.book cimport OrderBookDeltas
-from nautilus_trader.model.data.book cimport OrderBookSnapshot
 from nautilus_trader.model.data.tick cimport QuoteTick
 from nautilus_trader.model.data.tick cimport TradeTick
 from nautilus_trader.model.data.venue cimport InstrumentClose
 from nautilus_trader.model.data.venue cimport InstrumentStatusUpdate
 from nautilus_trader.model.data.venue cimport VenueStatusUpdate
 from nautilus_trader.model.enums_c cimport BarAggregation
 from nautilus_trader.model.enums_c cimport PriceType
@@ -172,14 +170,30 @@
         Returns
         -------
         Optional[ClientId]
 
         """
         return self._default_client.id if self._default_client is not None else None
 
+    def connect(self) -> None:
+        """
+        Connect the engine by calling connect on all registered clients.
+        """
+        self._log.info("Connecting all clients...")
+        # Implement actual client connections for a live/sandbox context
+
+    def disconnect(self) -> None:
+        """
+        Disconnect the engine by calling disconnect on all registered clients.
+        """
+        self._log.info("Disconnecting all clients...")
+        # Implement actual client connections for a live/sandbox context
+
+# --REGISTRATION ----------------------------------------------------------------------------------
+
     def register_catalog(self, catalog: ParquetDataCatalog, bint use_rust=False) -> None:
         """
         Register the given data catalog with the engine.
 
         Parameters
         ----------
         catalog : ParquetDataCatalog
@@ -187,16 +201,14 @@
 
         """
         Condition.not_none(catalog, "catalog")
 
         self._catalog = catalog
         self._use_rust = use_rust
 
-# --REGISTRATION ----------------------------------------------------------------------------------
-
     cpdef void register_client(self, DataClient client):
         """
         Register the given data client with the data engine.
 
         Parameters
         ----------
         client : DataClient
@@ -601,15 +613,15 @@
 
     cpdef void _handle_subscribe(self, DataClient client, Subscribe command):
         if command.data_type.type == Instrument:
             self._handle_subscribe_instrument(
                 client,
                 command.data_type.metadata.get("instrument_id"),
             )
-        elif command.data_type.type == OrderBookSnapshot:
+        elif command.data_type.type == OrderBook:
             self._handle_subscribe_order_book_snapshots(
                 client,
                 command.data_type.metadata.get("instrument_id"),
                 command.data_type.metadata,
             )
         elif command.data_type.type == OrderBookDelta:
             self._handle_subscribe_order_book_deltas(
@@ -657,15 +669,15 @@
 
     cpdef void _handle_unsubscribe(self, DataClient client, Unsubscribe command):
         if command.data_type.type == Instrument:
             self._handle_unsubscribe_instrument(
                 client,
                 command.data_type.metadata.get("instrument_id"),
             )
-        elif command.data_type.type == OrderBookSnapshot:
+        elif command.data_type.type == OrderBook:
             self._handle_unsubscribe_order_book_snapshots(
                 client,
                 command.data_type.metadata.get("instrument_id"),
                 command.data_type.metadata,
             )
         elif command.data_type.type == OrderBookDelta:
             self._handle_unsubscribe_order_book_deltas(
@@ -739,15 +751,15 @@
 
         cdef int interval_ms = metadata["interval_ms"]
         key = (instrument_id, interval_ms)
         if key not in self._order_book_intervals:
             self._order_book_intervals[key] = []
             now = self._clock.utc_now()
             start_time = now - timedelta(milliseconds=int((now.second * 1000) % interval_ms), microseconds=now.microsecond)
-            timer_name = f"OrderBookSnapshot_{instrument_id}_{interval_ms}"
+            timer_name = f"OrderBook_{instrument_id}_{interval_ms}"
             self._clock.set_timer(
                 name=timer_name,
                 interval=timedelta(milliseconds=interval_ms),
                 start_time=start_time,
                 stop_time=None,
                 callback=self._snapshot_order_book,
             )
@@ -776,16 +788,16 @@
             instrument = self._cache.instrument(instrument_id)
             if instrument is None:
                 self._log.error(
                     f"Cannot subscribe to {instrument_id} <OrderBook> data: "
                     f"no instrument found in the cache.",
                 )
                 return
-            order_book = OrderBook.create(
-                instrument=instrument,
+            order_book = OrderBook(
+                instrument_id=instrument.id,
                 book_type=metadata["book_type"],
             )
 
             self._cache.add_order_book(order_book)
             self._log.debug(f"Created {type(order_book).__name__}.")
 
         # Always re-subscribe to override previous settings
@@ -1216,16 +1228,18 @@
         self._handle_response(response)
 
 # -- DATA HANDLERS --------------------------------------------------------------------------------
 
     cpdef void _handle_data(self, Data data):
         self.data_count += 1
 
-        if isinstance(data, ORDER_BOOK_DATA):
-            self._handle_order_book_data(data)
+        if isinstance(data, OrderBookDelta):
+            self._handle_order_book_delta(data)
+        elif isinstance(data, OrderBookDeltas):
+            self._handle_order_book_deltas(data)
         elif isinstance(data, Ticker):
             self._handle_ticker(data)
         elif isinstance(data, QuoteTick):
             self._handle_quote_tick(data)
         elif isinstance(data, TradeTick):
             self._handle_trade_tick(data)
         elif isinstance(data, Bar):
@@ -1248,20 +1262,32 @@
         self._msgbus.publish_c(
             topic=f"data.instrument"
                   f".{instrument.id.venue}"
                   f".{instrument.id.symbol}",
             msg=instrument,
         )
 
-    cpdef void _handle_order_book_data(self, Data data):
+    cpdef void _handle_order_book_delta(self, OrderBookDelta delta):
+        cdef OrderBookDeltas deltas = OrderBookDeltas(
+            instrument_id=delta.instrument_id,
+            deltas=[delta]
+        )
+        self._msgbus.publish_c(
+            topic=f"data.book.deltas"
+                  f".{deltas.instrument_id.venue}"
+                  f".{deltas.instrument_id.symbol}",
+            msg=deltas,
+        )
+
+    cpdef void _handle_order_book_deltas(self, OrderBookDeltas deltas):
         self._msgbus.publish_c(
             topic=f"data.book.deltas"
-                  f".{data.instrument_id.venue}"
-                  f".{data.instrument_id.symbol}",
-            msg=data,
+                  f".{deltas.instrument_id.venue}"
+                  f".{deltas.instrument_id.symbol}",
+            msg=deltas,
         )
 
     cpdef void _handle_ticker(self, Ticker ticker):
         self._cache.add_ticker(ticker)
         self._msgbus.publish_c(
             topic=f"data.tickers"
                   f".{ticker.instrument_id.venue}"
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/data/messages.pxd` & `nautilus_trader-1.175.0/nautilus_trader/data/messages.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/data/messages.pyx` & `nautilus_trader-1.175.0/nautilus_trader/data/messages.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/examples/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/examples/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/examples/algorithms/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/examples/algorithms/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/examples/algorithms/blank.py` & `nautilus_trader-1.175.0/nautilus_trader/examples/algorithms/blank.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/examples/algorithms/twap.py` & `nautilus_trader-1.175.0/nautilus_trader/examples/algorithms/twap.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/examples/strategies/__init__.pxd` & `nautilus_trader-1.175.0/nautilus_trader/examples/strategies/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/examples/strategies/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/examples/strategies/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/examples/strategies/blank.py` & `nautilus_trader-1.175.0/nautilus_trader/examples/strategies/blank.py`

 * *Files 1% similar despite different names*

```diff
@@ -12,17 +12,17 @@
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from nautilus_trader.config import StrategyConfig
 from nautilus_trader.core.data import Data
 from nautilus_trader.core.message import Event
-from nautilus_trader.model.data.bar import Bar
-from nautilus_trader.model.data.tick import QuoteTick
-from nautilus_trader.model.data.tick import TradeTick
+from nautilus_trader.model.data import Bar
+from nautilus_trader.model.data import QuoteTick
+from nautilus_trader.model.data import TradeTick
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.instruments import Instrument
 from nautilus_trader.trading.strategy import Strategy
 
 
 class MyStrategyConfig(StrategyConfig, frozen=True):
     """
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/examples/strategies/ema_cross.py` & `nautilus_trader-1.175.0/nautilus_trader/examples/strategies/ema_cross.py`

 * *Files 3% similar despite different names*

```diff
@@ -10,30 +10,27 @@
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from decimal import Decimal
-from typing import Union
 
 from nautilus_trader.common.enums import LogColor
 from nautilus_trader.config import StrategyConfig
 from nautilus_trader.core.correctness import PyCondition
 from nautilus_trader.core.data import Data
 from nautilus_trader.core.message import Event
 from nautilus_trader.indicators.average.ema import ExponentialMovingAverage
-from nautilus_trader.model.data.bar import Bar
-from nautilus_trader.model.data.bar import BarType
-from nautilus_trader.model.data.book import OrderBookDelta
-from nautilus_trader.model.data.book import OrderBookDeltas
-from nautilus_trader.model.data.book import OrderBookSnapshot
-from nautilus_trader.model.data.tick import QuoteTick
-from nautilus_trader.model.data.tick import TradeTick
-from nautilus_trader.model.data.ticker import Ticker
+from nautilus_trader.model.data import Bar
+from nautilus_trader.model.data import BarType
+from nautilus_trader.model.data import OrderBookDeltas
+from nautilus_trader.model.data import QuoteTick
+from nautilus_trader.model.data import Ticker
+from nautilus_trader.model.data import TradeTick
 from nautilus_trader.model.enums import OrderSide
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.instruments import Instrument
 from nautilus_trader.model.orderbook import OrderBook
 from nautilus_trader.model.orders import MarketOrder
 from nautilus_trader.trading.strategy import Strategy
 
@@ -150,29 +147,26 @@
         instrument : Instrument
             The instrument received.
 
         """
         # For debugging (must add a subscription)
         # self.log.info(repr(instrument), LogColor.CYAN)
 
-    def on_order_book_delta(
-        self,
-        data: Union[OrderBookDelta, OrderBookDeltas, OrderBookSnapshot],
-    ) -> None:
+    def on_order_book_deltas(self, deltas: OrderBookDeltas) -> None:
         """
-        Actions to be performed when the strategy is running and receives order data.
+        Actions to be performed when the strategy is running and receives order book deltas.
 
         Parameters
         ----------
-        data : OrderBookDelta, OrderBookDeltas, OrderBookSnapshot
-            The order book data received.
+        deltas : OrderBookDeltas
+            The order book deltas received.
 
         """
         # For debugging (must add a subscription)
-        # self.log.info(repr(data), LogColor.CYAN)
+        # self.log.info(repr(deltas), LogColor.CYAN)
 
     def on_order_book(self, order_book: OrderBook) -> None:
         """
         Actions to be performed when the strategy is running and receives an order book.
 
         Parameters
         ----------
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/examples/strategies/ema_cross_bracket.py` & `nautilus_trader-1.175.0/nautilus_trader/examples/strategies/ema_cross_bracket.py`

 * *Files 2% similar despite different names*

```diff
@@ -20,17 +20,17 @@
 from nautilus_trader.common.enums import LogColor
 from nautilus_trader.config import StrategyConfig
 from nautilus_trader.core.correctness import PyCondition
 from nautilus_trader.core.data import Data
 from nautilus_trader.core.message import Event
 from nautilus_trader.indicators.atr import AverageTrueRange
 from nautilus_trader.indicators.average.ema import ExponentialMovingAverage
-from nautilus_trader.model.data.bar import Bar
-from nautilus_trader.model.data.bar import BarType
-from nautilus_trader.model.data.tick import QuoteTick
+from nautilus_trader.model.data import Bar
+from nautilus_trader.model.data import BarType
+from nautilus_trader.model.data import QuoteTick
 from nautilus_trader.model.enums import OrderSide
 from nautilus_trader.model.enums import OrderType
 from nautilus_trader.model.enums import TimeInForce
 from nautilus_trader.model.enums import TriggerType
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.instruments import Instrument
 from nautilus_trader.model.orders.list import OrderList
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/examples/strategies/ema_cross_bracket_algo.py` & `nautilus_trader-1.175.0/nautilus_trader/examples/strategies/ema_cross_bracket_algo.py`

 * *Files 1% similar despite different names*

```diff
@@ -20,17 +20,17 @@
 from nautilus_trader.common.enums import LogColor
 from nautilus_trader.config import StrategyConfig
 from nautilus_trader.core.correctness import PyCondition
 from nautilus_trader.core.data import Data
 from nautilus_trader.core.message import Event
 from nautilus_trader.indicators.atr import AverageTrueRange
 from nautilus_trader.indicators.average.ema import ExponentialMovingAverage
-from nautilus_trader.model.data.bar import Bar
-from nautilus_trader.model.data.bar import BarType
-from nautilus_trader.model.data.tick import QuoteTick
+from nautilus_trader.model.data import Bar
+from nautilus_trader.model.data import BarType
+from nautilus_trader.model.data import QuoteTick
 from nautilus_trader.model.enums import OrderSide
 from nautilus_trader.model.enums import OrderType
 from nautilus_trader.model.enums import TimeInForce
 from nautilus_trader.model.enums import TriggerType
 from nautilus_trader.model.identifiers import ExecAlgorithmId
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.instruments import Instrument
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/examples/strategies/ema_cross_cython.pyx` & `nautilus_trader-1.175.0/nautilus_trader/examples/strategies/ema_cross_cython.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/examples/strategies/ema_cross_stop_entry.py` & `nautilus_trader-1.175.0/nautilus_trader/examples/strategies/ema_cross_stop_entry.py`

 * *Files 2% similar despite different names*

```diff
@@ -19,23 +19,23 @@
 from nautilus_trader.common.enums import LogColor
 from nautilus_trader.config import StrategyConfig
 from nautilus_trader.core.correctness import PyCondition
 from nautilus_trader.core.data import Data
 from nautilus_trader.core.message import Event
 from nautilus_trader.indicators.atr import AverageTrueRange
 from nautilus_trader.indicators.average.ema import ExponentialMovingAverage
-from nautilus_trader.model.data.bar import Bar
-from nautilus_trader.model.data.bar import BarType
-from nautilus_trader.model.data.tick import QuoteTick
-from nautilus_trader.model.data.tick import TradeTick
+from nautilus_trader.model.data import Bar
+from nautilus_trader.model.data import BarType
+from nautilus_trader.model.data import QuoteTick
+from nautilus_trader.model.data import TradeTick
 from nautilus_trader.model.enums import OrderSide
 from nautilus_trader.model.enums import TimeInForce
 from nautilus_trader.model.enums import TrailingOffsetType
 from nautilus_trader.model.enums import TriggerType
-from nautilus_trader.model.events.order import OrderFilled
+from nautilus_trader.model.events import OrderFilled
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.instruments import Instrument
 from nautilus_trader.model.orderbook import OrderBook
 from nautilus_trader.model.orders import MarketIfTouchedOrder
 from nautilus_trader.model.orders import TrailingStopMarketOrder
 from nautilus_trader.trading.strategy import Strategy
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/examples/strategies/ema_cross_trailing_stop.py` & `nautilus_trader-1.175.0/nautilus_trader/examples/strategies/ema_cross_trailing_stop.py`

 * *Files 3% similar despite different names*

```diff
@@ -19,25 +19,25 @@
 from nautilus_trader.common.enums import LogColor
 from nautilus_trader.config import StrategyConfig
 from nautilus_trader.core.correctness import PyCondition
 from nautilus_trader.core.data import Data
 from nautilus_trader.core.message import Event
 from nautilus_trader.indicators.atr import AverageTrueRange
 from nautilus_trader.indicators.average.ema import ExponentialMovingAverage
-from nautilus_trader.model.data.bar import Bar
-from nautilus_trader.model.data.bar import BarType
-from nautilus_trader.model.data.tick import QuoteTick
-from nautilus_trader.model.data.tick import TradeTick
+from nautilus_trader.model.data import Bar
+from nautilus_trader.model.data import BarType
+from nautilus_trader.model.data import QuoteTick
+from nautilus_trader.model.data import TradeTick
 from nautilus_trader.model.enums import OrderSide
 from nautilus_trader.model.enums import TrailingOffsetType
 from nautilus_trader.model.enums import TriggerType
-from nautilus_trader.model.events.order import OrderFilled
-from nautilus_trader.model.events.position import PositionChanged
-from nautilus_trader.model.events.position import PositionClosed
-from nautilus_trader.model.events.position import PositionOpened
+from nautilus_trader.model.events import OrderFilled
+from nautilus_trader.model.events import PositionChanged
+from nautilus_trader.model.events import PositionClosed
+from nautilus_trader.model.events import PositionOpened
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.instruments import Instrument
 from nautilus_trader.model.orderbook import OrderBook
 from nautilus_trader.model.orders import MarketOrder
 from nautilus_trader.model.orders import TrailingStopMarketOrder
 from nautilus_trader.trading.strategy import Strategy
 
@@ -241,15 +241,15 @@
 
         Parameters
         ----------
         bar : Bar
             The bar received.
 
         """
-        self.log.info(f"Received {bar!r}")
+        # self.log.info(f"Received {bar!r}")
 
         # Check if indicators ready
         if not self.indicators_initialized():
             self.log.info(
                 f"Waiting for indicators to warm up " f"[{self.cache.bar_count(self.bar_type)}]...",
                 color=LogColor.BLUE,
             )
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/examples/strategies/ema_cross_twap.py` & `nautilus_trader-1.175.0/nautilus_trader/examples/strategies/ema_cross_twap.py`

 * *Files 6% similar despite different names*

```diff
@@ -10,31 +10,29 @@
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from decimal import Decimal
-from typing import Any, Union
+from typing import Any
 
 from nautilus_trader.common.enums import LogColor
 from nautilus_trader.config import StrategyConfig
 from nautilus_trader.config.validation import PositiveFloat
 from nautilus_trader.core.correctness import PyCondition
 from nautilus_trader.core.data import Data
 from nautilus_trader.core.message import Event
 from nautilus_trader.indicators.average.ema import ExponentialMovingAverage
-from nautilus_trader.model.data.bar import Bar
-from nautilus_trader.model.data.bar import BarType
-from nautilus_trader.model.data.book import OrderBookDelta
-from nautilus_trader.model.data.book import OrderBookDeltas
-from nautilus_trader.model.data.book import OrderBookSnapshot
-from nautilus_trader.model.data.tick import QuoteTick
-from nautilus_trader.model.data.tick import TradeTick
-from nautilus_trader.model.data.ticker import Ticker
+from nautilus_trader.model.data import Bar
+from nautilus_trader.model.data import BarType
+from nautilus_trader.model.data import OrderBookDeltas
+from nautilus_trader.model.data import QuoteTick
+from nautilus_trader.model.data import Ticker
+from nautilus_trader.model.data import TradeTick
 from nautilus_trader.model.enums import OrderSide
 from nautilus_trader.model.enums import TimeInForce
 from nautilus_trader.model.identifiers import ExecAlgorithmId
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.instruments import Instrument
 from nautilus_trader.model.orderbook import OrderBook
 from nautilus_trader.model.orders import MarketOrder
@@ -166,29 +164,26 @@
         instrument : Instrument
             The instrument received.
 
         """
         # For debugging (must add a subscription)
         # self.log.info(repr(instrument), LogColor.CYAN)
 
-    def on_order_book_delta(
-        self,
-        data: Union[OrderBookDelta, OrderBookDeltas, OrderBookSnapshot],
-    ) -> None:
+    def on_order_book_deltas(self, deltas: OrderBookDeltas) -> None:
         """
-        Actions to be performed when the strategy is running and receives order data.
+        Actions to be performed when the strategy is running and receives order book deltas.
 
         Parameters
         ----------
-        data : OrderBookDelta, OrderBookDeltas, OrderBookSnapshot
-            The order book data received.
+        deltas : OrderBookDeltas
+            The order book deltas received.
 
         """
         # For debugging (must add a subscription)
-        # self.log.info(repr(data), LogColor.CYAN)
+        # self.log.info(repr(deltas), LogColor.CYAN)
 
     def on_order_book(self, order_book: OrderBook) -> None:
         """
         Actions to be performed when the strategy is running and receives an order book.
 
         Parameters
         ----------
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/examples/strategies/market_maker.py` & `nautilus_trader-1.175.0/nautilus_trader/examples/strategies/market_maker.py`

 * *Files 3% similar despite different names*

```diff
@@ -10,26 +10,24 @@
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from decimal import Decimal
-from typing import Optional, Union
+from typing import Optional
 
 from nautilus_trader.core.message import Event
-from nautilus_trader.model.data.book import OrderBookDelta
-from nautilus_trader.model.data.book import OrderBookDeltas
-from nautilus_trader.model.data.book import OrderBookSnapshot
+from nautilus_trader.model.data import OrderBookDeltas
 from nautilus_trader.model.enums import BookType
 from nautilus_trader.model.enums import OrderSide
 from nautilus_trader.model.enums import PositionSide
-from nautilus_trader.model.events.position import PositionChanged
-from nautilus_trader.model.events.position import PositionClosed
-from nautilus_trader.model.events.position import PositionOpened
+from nautilus_trader.model.events import PositionChanged
+from nautilus_trader.model.events import PositionClosed
+from nautilus_trader.model.events import PositionOpened
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.instruments import Instrument
 from nautilus_trader.model.objects import Price
 from nautilus_trader.model.orderbook import OrderBook
 from nautilus_trader.trading.strategy import Strategy
 
 
@@ -69,28 +67,28 @@
         self.instrument = self.cache.instrument(self.instrument_id)
         if self.instrument is None:
             self.log.error(f"Could not find instrument for {self.instrument_id}")
             self.stop()
             return
 
         # Create orderbook
-        self._book = OrderBook.create(instrument=self.instrument, book_type=BookType.L2_MBP)
+        self._book = OrderBook(
+            instrument_id=self.instrument.id,
+            book_type=BookType.L2_MBP,
+        )
 
         # Subscribe to live data
         self.subscribe_order_book_deltas(self.instrument_id)
 
-    def on_order_book_delta(
-        self,
-        delta: Union[OrderBookDelta, OrderBookDeltas, OrderBookSnapshot],
-    ) -> None:
+    def on_order_book_deltas(self, deltas: OrderBookDeltas) -> None:
         if not self._book:
             self.log.error("No book being maintained.")
             return
 
-        self._book.apply(delta)
+        self._book.apply_deltas(deltas)
         bid_price = self._book.best_bid_price()
         ask_price = self._book.best_ask_price()
         if bid_price and ask_price:
             mid = (bid_price + ask_price) / 2
             if mid != self._mid:
                 self.cancel_all_orders(self.instrument_id)
                 self._mid = Decimal(mid)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/examples/strategies/orderbook_imbalance.py` & `nautilus_trader-1.175.0/nautilus_trader/examples/strategies/orderbook_imbalance.py`

 * *Files 6% similar despite different names*

```diff
@@ -10,22 +10,20 @@
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from decimal import Decimal
-from typing import Optional, Union
+from typing import Optional
 
 from nautilus_trader.config import StrategyConfig
-from nautilus_trader.model.data.book import BookOrder
-from nautilus_trader.model.data.book import OrderBookDelta
-from nautilus_trader.model.data.book import OrderBookDeltas
-from nautilus_trader.model.data.book import OrderBookSnapshot
-from nautilus_trader.model.data.tick import QuoteTick
+from nautilus_trader.model.data import BookOrder
+from nautilus_trader.model.data import OrderBookDeltas
+from nautilus_trader.model.data import QuoteTick
 from nautilus_trader.model.enums import BookType
 from nautilus_trader.model.enums import OrderSide
 from nautilus_trader.model.enums import TimeInForce
 from nautilus_trader.model.enums import book_type_from_str
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.instruments import Instrument
 from nautilus_trader.model.orderbook import OrderBook
@@ -110,26 +108,26 @@
             book_type = BookType.L1_TBBO
             self.subscribe_quote_ticks(self.instrument.id)
         else:
             book_type = book_type_from_str(self.config.book_type)
             self.subscribe_order_book_deltas(self.instrument.id, book_type)
         if self.config.subscribe_ticker:
             self.subscribe_ticker(self.instrument.id)
-        self._book = OrderBook.create(instrument=self.instrument, book_type=book_type)
+        self._book = OrderBook(
+            instrument_id=self.instrument.id,
+            book_type=book_type,
+        )
 
-    def on_order_book_delta(
-        self,
-        data: Union[OrderBookDelta, OrderBookDeltas, OrderBookSnapshot],
-    ) -> None:
-        """Actions to be performed when a delta is received."""
+    def on_order_book_deltas(self, deltas: OrderBookDeltas) -> None:
+        """Actions to be performed when order book deltas are received."""
         if not self._book:
             self.log.error("No book being maintained.")
             return
 
-        self._book.apply(data)
+        self._book.apply_deltas(deltas)
         if self._book.spread():
             self.check_trigger()
 
     def on_quote_tick(self, tick: QuoteTick) -> None:
         """Actions to be performed when a delta is received."""
         bid = BookOrder(
             price=tick.bid.as_double(),
@@ -160,16 +158,16 @@
             self.log.error("No book being maintained.")
             return
 
         if not self.instrument:
             self.log.error("No instrument loaded.")
             return
 
-        bid_size = self._book.best_bid_qty()
-        ask_size = self._book.best_ask_qty()
+        bid_size = self._book.best_bid_size()
+        ask_size = self._book.best_ask_size()
         if not (bid_size and ask_size):
             return
 
         smaller = min(bid_size, ask_size)
         larger = max(bid_size, ask_size)
         ratio = smaller / larger
         self.log.info(
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/examples/strategies/signal_strategy.py` & `nautilus_trader-1.175.0/nautilus_trader/examples/strategies/signal_strategy.py`

 * *Files 1% similar despite different names*

```diff
@@ -12,16 +12,16 @@
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from typing import Optional
 
 from nautilus_trader.config import StrategyConfig
-from nautilus_trader.model.data.tick import QuoteTick
-from nautilus_trader.model.data.tick import TradeTick
+from nautilus_trader.model.data import QuoteTick
+from nautilus_trader.model.data import TradeTick
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.instruments import Instrument
 from nautilus_trader.trading.strategy import Strategy
 
 
 # *** THIS IS A TEST STRATEGY ***
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/examples/strategies/subscribe.py` & `nautilus_trader-1.175.0/nautilus_trader/examples/strategies/subscribe.py`

 * *Files 4% similar despite different names*

```diff
@@ -12,20 +12,20 @@
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from typing import Optional
 
 from nautilus_trader.config import StrategyConfig
-from nautilus_trader.core.data import Data
-from nautilus_trader.model.data.bar import Bar
-from nautilus_trader.model.data.bar import BarSpecification
-from nautilus_trader.model.data.bar import BarType
-from nautilus_trader.model.data.tick import QuoteTick
-from nautilus_trader.model.data.tick import TradeTick
+from nautilus_trader.model.data import Bar
+from nautilus_trader.model.data import BarSpecification
+from nautilus_trader.model.data import BarType
+from nautilus_trader.model.data import OrderBookDeltas
+from nautilus_trader.model.data import QuoteTick
+from nautilus_trader.model.data import TradeTick
 from nautilus_trader.model.enums import AggregationSource
 from nautilus_trader.model.enums import BarAggregation
 from nautilus_trader.model.enums import BookType
 from nautilus_trader.model.enums import PriceType
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.orderbook import OrderBook
 from nautilus_trader.trading.strategy import Strategy
@@ -67,16 +67,16 @@
         self.instrument = self.cache.instrument(self.instrument_id)
         if self.instrument is None:
             self.log.error(f"Could not find instrument for {self.instrument_id}")
             self.stop()
             return
 
         if self.config.book_type:
-            self.book = OrderBook.create(
-                instrument=self.instrument,
+            self.book = OrderBook(
+                instrument_id=self.instrument.id,
                 book_type=self.config.book_type,
             )
             if self.config.snapshots:
                 self.subscribe_order_book_snapshots(
                     instrument_id=self.instrument_id,
                     book_type=self.config.book_type,
                 )
@@ -98,20 +98,20 @@
                     aggregation=BarAggregation.SECOND,
                     price_type=PriceType.LAST,
                 ),
                 aggregation_source=AggregationSource.EXTERNAL,
             )
             self.subscribe_bars(bar_type)
 
-    def on_order_book_delta(self, data: Data) -> None:
+    def on_order_book_deltas(self, deltas: OrderBookDeltas) -> None:
         if not self.book:
             self.log.error("No book being maintained.")
             return
 
-        self.book.apply(data)
+        self.book.apply_deltas(deltas)
         self.log.info(str(self.book))
 
     def on_order_book(self, order_book: OrderBook) -> None:
         self.book = order_book
         self.log.info(str(self.book))
 
     def on_trade_tick(self, tick: TradeTick) -> None:
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/examples/strategies/volatility_market_maker.py` & `nautilus_trader-1.175.0/nautilus_trader/examples/strategies/volatility_market_maker.py`

 * *Files 2% similar despite different names*

```diff
@@ -17,24 +17,24 @@
 from typing import Optional, Union
 
 from nautilus_trader.common.enums import LogColor
 from nautilus_trader.config import StrategyConfig
 from nautilus_trader.core.data import Data
 from nautilus_trader.core.message import Event
 from nautilus_trader.indicators.atr import AverageTrueRange
-from nautilus_trader.model.data.bar import Bar
-from nautilus_trader.model.data.bar import BarType
-from nautilus_trader.model.data.book import OrderBookDelta
-from nautilus_trader.model.data.tick import QuoteTick
-from nautilus_trader.model.data.tick import TradeTick
-from nautilus_trader.model.data.ticker import Ticker
+from nautilus_trader.model.data import Bar
+from nautilus_trader.model.data import BarType
+from nautilus_trader.model.data import OrderBookDeltas
+from nautilus_trader.model.data import QuoteTick
+from nautilus_trader.model.data import Ticker
+from nautilus_trader.model.data import TradeTick
 from nautilus_trader.model.enums import OrderSide
 from nautilus_trader.model.enums import TimeInForce
 from nautilus_trader.model.enums import TriggerType
-from nautilus_trader.model.events.order import OrderFilled
+from nautilus_trader.model.events import OrderFilled
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.instruments import Instrument
 from nautilus_trader.model.orderbook import OrderBook
 from nautilus_trader.model.orders import LimitOrder
 from nautilus_trader.trading.strategy import Strategy
 
 
@@ -132,15 +132,16 @@
         # self.subscribe_order_book_snapshots(
         #     self.instrument_id,
         #     depth=20,
         #     interval_ms=1000,
         # )  # For debugging
         # self.subscribe_data(
         #     data_type=DataType(
-        #         BinanceFuturesMarkPriceUpdate, metadata={"instrument_id": self.instrument.id}
+        #         BinanceFuturesMarkPriceUpdate,
+        #         metadata={"instrument_id": self.instrument.id},
         #     ),
         #     client_id=ClientId("BINANCE"),
         # )
 
     def on_data(self, data: Data) -> None:
         """
         Actions to be performed when the strategy is running and receives generic
@@ -176,28 +177,28 @@
         Parameters
         ----------
         order_book : OrderBook
             The order book received.
 
         """
         # For debugging (must add a subscription)
-        # self.log.info(repr(order_book), LogColor.CYAN)
+        self.log.info(repr(order_book), LogColor.CYAN)
 
-    def on_order_book_delta(self, delta: OrderBookDelta) -> None:
+    def on_order_book_deltas(self, deltas: OrderBookDeltas) -> None:
         """
-        Actions to be performed when the strategy is running and receives an order book delta.
+        Actions to be performed when the strategy is running and receives order book deltas.
 
         Parameters
         ----------
-        delta : OrderBookDelta
-            The order book delta received.
+        deltas : OrderBookDeltas
+            The order book deltas received.
 
         """
         # For debugging (must add a subscription)
-        # self.log.info(repr(delta), LogColor.CYAN)
+        self.log.info(repr(deltas), LogColor.CYAN)
 
     def on_ticker(self, ticker: Ticker) -> None:
         """
         Actions to be performed when the strategy is running and receives a ticker.
 
         Parameters
         ----------
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/execution/__init__.pxd` & `nautilus_trader-1.175.0/nautilus_trader/execution/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/execution/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/execution/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/execution/algorithm.pxd` & `nautilus_trader-1.175.0/nautilus_trader/execution/algorithm.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/execution/algorithm.pyx` & `nautilus_trader-1.175.0/nautilus_trader/execution/algorithm.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/execution/client.pxd` & `nautilus_trader-1.175.0/nautilus_trader/execution/client.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/execution/client.pyx` & `nautilus_trader-1.175.0/nautilus_trader/execution/client.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/execution/emulator.pxd` & `nautilus_trader-1.175.0/nautilus_trader/execution/emulator.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/execution/emulator.pyx` & `nautilus_trader-1.175.0/nautilus_trader/execution/emulator.pyx`

 * *Files 8% similar despite different names*

```diff
@@ -298,20 +298,21 @@
             self._log.error(
                 f"Cannot emulate order: `TriggerType` {trigger_type_to_str(emulation_trigger)} "
                 f"not supported.",
             )
             self._cancel_order(matching_core=None, order=order)
             return
 
-        cdef MatchingCore matching_core = self._matching_cores.get(command.instrument_id)
+        cdef InstrumentId trigger_instrument_id = order.instrument_id if order.trigger_instrument_id is None else order.trigger_instrument_id
+        cdef MatchingCore matching_core = self._matching_cores.get(trigger_instrument_id)
         if matching_core is None:
-            instrument = self.cache.instrument(command.instrument_id)
+            instrument = self.cache.instrument(trigger_instrument_id)
             if instrument is None:
                 self._log.error(
-                    f"Cannot emulate order: no instrument for {command.instrument_id}.",
+                    f"Cannot emulate order: no trigger instrument for {trigger_instrument_id}.",
                 )
                 self._cancel_order(matching_core=None, order=order)
                 return
             matching_core = self.create_matching_core(instrument)
 
         # Update trailing stop
         if order.order_type == OrderType.TRAILING_STOP_MARKET or order.order_type == OrderType.TRAILING_STOP_LIMIT:
@@ -327,21 +328,21 @@
         self._commands_submit_order[order.client_order_id] = command
 
         # Check if immediately marketable (initial match)
         matching_core.match_order(order, initial=True)
 
         # Check data subscription
         if emulation_trigger == TriggerType.DEFAULT or emulation_trigger == TriggerType.BID_ASK:
-            if command.instrument_id not in self._subscribed_quotes:
-                self.subscribe_quote_ticks(command.instrument_id)
-                self._subscribed_quotes.add(command.instrument_id)
+            if trigger_instrument_id not in self._subscribed_quotes:
+                self.subscribe_quote_ticks(trigger_instrument_id)
+                self._subscribed_quotes.add(trigger_instrument_id)
         elif emulation_trigger == TriggerType.LAST_TRADE:
-            if command.instrument_id not in self._subscribed_trades:
-                self.subscribe_trade_ticks(command.instrument_id)
-                self._subscribed_trades.add(command.instrument_id)
+            if trigger_instrument_id not in self._subscribed_trades:
+                self.subscribe_trade_ticks(trigger_instrument_id)
+                self._subscribed_trades.add(trigger_instrument_id)
         else:
             raise ValueError(  # pragma: no cover (design-time error)
                 f"invalid `TriggerType`, was {emulation_trigger}",  # pragma: no cover (design-time error)
             )
 
         if order.client_order_id not in self._commands_submit_order:
             return  # Already released
@@ -411,32 +412,39 @@
             trigger_price=trigger_price,
             event_id=UUID4(),
             ts_event=ts_now,
             ts_init=ts_now,
         )
         self.msgbus.send(endpoint="ExecEngine.process", msg=event)
 
-        cdef MatchingCore matching_core = self._matching_cores.get(command.instrument_id)
+        cdef InstrumentId trigger_instrument_id = order.instrument_id if order.trigger_instrument_id is None else order.trigger_instrument_id
+        cdef MatchingCore matching_core = self._matching_cores.get(trigger_instrument_id)
         if matching_core is None:
-            raise RuntimeError(f"Cannot handle `ModifyOrder`: no matching core for {command.instrument_id}.")  # pragma: no cover (design-time error)
+            raise RuntimeError(f"Cannot handle `ModifyOrder`: no matching core for trigger instrument {trigger_instrument_id}.")  # pragma: no cover (design-time error)
 
         matching_core.match_order(order)
         if order.side == OrderSide.BUY:
             matching_core.sort_bid_orders()
         elif order.side == OrderSide.SELL:
             matching_core.sort_ask_orders()
 
     cdef void _handle_cancel_order(self, CancelOrder command):
-        cdef MatchingCore matching_core = self._matching_cores.get(command.instrument_id)
-        if matching_core is None:
-            raise RuntimeError(f"Cannot handle `CancelOrder`: no matching core for {command.instrument_id}.")  # pragma: no cover (design-time error)
-
         cdef Order order = self.cache.order(command.client_order_id)
+        if order is None:
+            self._log.error(
+                f"Cannot cancel order: {repr(command.client_order_id)} not found.",
+            )
+            return
 
-        if not matching_core.order_exists(command.client_order_id):
+        cdef InstrumentId trigger_instrument_id = order.instrument_id if order.trigger_instrument_id is None else order.trigger_instrument_id
+        cdef MatchingCore matching_core = self._matching_cores.get(trigger_instrument_id)
+        if matching_core is None:
+            raise RuntimeError(f"Cannot handle `CancelOrder`: no matching core for trigger instrument {trigger_instrument_id}.")  # pragma: no cover (design-time error)
+
+        if not matching_core.order_exists(order.client_order_id):
             # Order not held in the emulator
             self._send_exec_command(command)
         else:
             self._cancel_order(matching_core, order)
 
     cdef void _handle_cancel_all_orders(self, CancelAllOrders command):
         cdef MatchingCore matching_core = self._matching_cores.get(command.instrument_id)
@@ -496,16 +504,17 @@
             return
 
         self._log.debug(f"Cancelling order {order}.")
 
         # Remove emulation trigger
         order.emulation_trigger = TriggerType.NO_TRIGGER
 
+        cdef InstrumentId trigger_instrument_id = order.instrument_id if order.trigger_instrument_id is None else order.trigger_instrument_id
         if matching_core is None:
-            matching_core = self._matching_cores.get(order.instrument_id)
+            matching_core = self._matching_cores.get(trigger_instrument_id)
         if matching_core is not None:
             matching_core.delete_order(order)
 
         self._commands_submit_order.pop(order.client_order_id, None)
 
         # Generate event
         cdef uint64_t ts_now = self._clock.timestamp_ns()
@@ -748,17 +757,18 @@
             self._log.debug(
                 f"`SubmitOrder` command for {repr(order.client_order_id)} not found.",
             )
             return
 
         self.log.info(f"Releasing {order}...")
 
-        cdef MatchingCore matching_core = self._matching_cores.get(order.instrument_id)
+        cdef InstrumentId trigger_instrument_id = order.instrument_id if order.trigger_instrument_id is None else order.trigger_instrument_id
+        cdef MatchingCore matching_core = self._matching_cores.get(trigger_instrument_id)
         if matching_core is None:
-            raise RuntimeError(f"No matching core for {order.instrument_id}")
+            raise RuntimeError(f"No matching core for trigger instrument {trigger_instrument_id}")
 
         matching_core.delete_order(order)
 
         cdef MarketOrder transformed = MarketOrder.transform(order, self.clock.timestamp_ns())
 
         # Cast to writable cache
         cdef Cache cache = <Cache>self.cache
@@ -789,17 +799,18 @@
             self._log.debug(
                 f"`SubmitOrder` command for {repr(order.client_order_id)} not found.",
             )
             return
 
         self.log.info(f"Releasing {order}...")
 
-        cdef MatchingCore matching_core = self._matching_cores.get(order.instrument_id)
+        cdef InstrumentId trigger_instrument_id = order.instrument_id if order.trigger_instrument_id is None else order.trigger_instrument_id
+        cdef MatchingCore matching_core = self._matching_cores.get(trigger_instrument_id)
         if matching_core is None:
-            raise RuntimeError(f"No matching core for {order.instrument_id}")
+            raise RuntimeError(f"No matching core for trigger instrument {trigger_instrument_id}")
 
         matching_core.delete_order(order)
 
         cdef LimitOrder transformed = LimitOrder.transform(order, self.clock.timestamp_ns())
 
         # Cast to writable cache
         cdef Cache cache = <Cache>self.cache
@@ -821,29 +832,29 @@
 
     cpdef void on_quote_tick(self, QuoteTick tick):
         if not self._log.is_bypassed:
             self._log.debug(f"Processing {repr(tick)}...", LogColor.CYAN)
 
         cdef MatchingCore matching_core = self._matching_cores.get(tick.instrument_id)
         if matching_core is None:
-            self._log.error(f"Cannot handle `QuoteTick`: no matching core for {tick.instrument_id}.")
+            self._log.error(f"Cannot handle `QuoteTick`: no matching core for instrument {tick.instrument_id}.")
             return
 
         matching_core.set_bid_raw(tick._mem.bid.raw)
         matching_core.set_ask_raw(tick._mem.ask.raw)
 
         self._iterate_orders(matching_core)
 
     cpdef void on_trade_tick(self, TradeTick tick):
         if not self._log.is_bypassed:
             self._log.debug(f"Processing {repr(tick)}...", LogColor.CYAN)
 
         cdef MatchingCore matching_core = self._matching_cores.get(tick.instrument_id)
         if matching_core is None:
-            self._log.error(f"Cannot handle `TradeTick`: no matching core for {tick.instrument_id}.")
+            self._log.error(f"Cannot handle `TradeTick`: no matching core for instrument {tick.instrument_id}.")
             return
 
         matching_core.set_last_raw(tick._mem.price.raw)
         if tick.instrument_id not in self._subscribed_quotes:
             matching_core.set_bid_raw(tick._mem.price.raw)
             matching_core.set_ask_raw(tick._mem.price.raw)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/execution/engine.pxd` & `nautilus_trader-1.175.0/nautilus_trader/execution/engine.pxd`

 * *Files 7% similar despite different names*

```diff
@@ -22,20 +22,23 @@
 from nautilus_trader.execution.messages cimport CancelOrder
 from nautilus_trader.execution.messages cimport ModifyOrder
 from nautilus_trader.execution.messages cimport QueryOrder
 from nautilus_trader.execution.messages cimport SubmitOrder
 from nautilus_trader.execution.messages cimport SubmitOrderList
 from nautilus_trader.execution.messages cimport TradingCommand
 from nautilus_trader.model.enums_c cimport OmsType
+from nautilus_trader.model.enums_c cimport OrderSide
 from nautilus_trader.model.events.order cimport OrderEvent
 from nautilus_trader.model.events.order cimport OrderFilled
 from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.identifiers cimport StrategyId
 from nautilus_trader.model.identifiers cimport Venue
 from nautilus_trader.model.instruments.base cimport Instrument
+from nautilus_trader.model.objects cimport Price
+from nautilus_trader.model.objects cimport Quantity
 from nautilus_trader.model.orders.base cimport Order
 from nautilus_trader.model.position cimport Position
 from nautilus_trader.trading.strategy cimport Strategy
 
 
 cdef class ExecutionEngine(Component):
     cdef readonly Cache _cache
@@ -46,14 +49,16 @@
     cdef readonly dict _oms_overrides
     cdef readonly dict _external_order_claims
 
     cdef readonly bint debug
     """If debug mode is active (will provide extra debug logging).\n\n:returns: `bool`"""
     cdef readonly bint allow_cash_positions
     """If unleveraged spot/cash assets should generate positions.\n\n:returns: `bool`"""
+    cdef readonly bint filter_unclaimed_external_orders
+    """If unclaimed order events with an EXTERNAL strategy ID should be filtered/dropped.\n\n:returns `bool`"""
     cdef readonly int command_count
     """The total count of commands received by the engine.\n\n:returns: `int`"""
     cdef readonly int event_count
     """The total count of events received by the engine.\n\n:returns: `int`"""
     cdef public int report_count
     """The total count of reports received by the engine.\n\n:returns: `int`"""
 
@@ -77,14 +82,17 @@
 
     cpdef void _on_start(self)
     cpdef void _on_stop(self)
 
 # -- INTERNAL -------------------------------------------------------------------------------------
 
     cpdef void _set_position_id_counts(self)
+    cpdef Price _last_px_for_conversion(self, InstrumentId instrument_id, OrderSide order_side)
+    cpdef void _set_order_base_qty(self, Order order, Quantity base_qty)
+    cpdef void _deny_order(self, Order order, str reason)
 
 # -- COMMANDS -------------------------------------------------------------------------------------
 
     cpdef void load_cache(self)
     cpdef void execute(self, TradingCommand command)
     cpdef void process(self, OrderEvent event)
     cpdef void flush_db(self)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/execution/engine.pyx` & `nautilus_trader-1.175.0/nautilus_trader/execution/engine.pyx`

 * *Files 12% similar despite different names*

```diff
@@ -55,17 +55,26 @@
 from nautilus_trader.execution.client cimport ExecutionClient
 from nautilus_trader.execution.messages cimport CancelAllOrders
 from nautilus_trader.execution.messages cimport CancelOrder
 from nautilus_trader.execution.messages cimport ModifyOrder
 from nautilus_trader.execution.messages cimport SubmitOrder
 from nautilus_trader.execution.messages cimport SubmitOrderList
 from nautilus_trader.execution.messages cimport TradingCommand
+from nautilus_trader.execution.reports cimport ExecutionMassStatus
+from nautilus_trader.execution.reports cimport ExecutionReport
+from nautilus_trader.execution.reports cimport OrderStatusReport
+from nautilus_trader.execution.reports cimport PositionStatusReport
+from nautilus_trader.execution.reports cimport TradeReport
+from nautilus_trader.model.data.tick cimport QuoteTick
+from nautilus_trader.model.data.tick cimport TradeTick
+from nautilus_trader.model.enums_c cimport ContingencyType
 from nautilus_trader.model.enums_c cimport OmsType
 from nautilus_trader.model.enums_c cimport PositionSide
 from nautilus_trader.model.enums_c cimport oms_type_to_str
+from nautilus_trader.model.events.order cimport OrderDenied
 from nautilus_trader.model.events.order cimport OrderEvent
 from nautilus_trader.model.events.order cimport OrderFilled
 from nautilus_trader.model.events.position cimport PositionChanged
 from nautilus_trader.model.events.position cimport PositionClosed
 from nautilus_trader.model.events.position cimport PositionEvent
 from nautilus_trader.model.events.position cimport PositionOpened
 from nautilus_trader.model.identifiers cimport ClientId
@@ -74,14 +83,15 @@
 from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.identifiers cimport PositionId
 from nautilus_trader.model.identifiers cimport StrategyId
 from nautilus_trader.model.identifiers cimport Venue
 from nautilus_trader.model.instruments.base cimport Instrument
 from nautilus_trader.model.instruments.currency_pair cimport CurrencyPair
 from nautilus_trader.model.objects cimport Money
+from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.objects cimport Quantity
 from nautilus_trader.model.orders.base cimport Order
 from nautilus_trader.msgbus.bus cimport MessageBus
 
 
 cdef class ExecutionEngine(Component):
     """
@@ -139,48 +149,76 @@
             trader_id=msgbus.trader_id,
             clock=clock,
         )
 
         # Settings
         self.debug: bool = config.debug
         self.allow_cash_positions: bool = config.allow_cash_positions
+        self.filter_unclaimed_external_orders: bool = config.filter_unclaimed_external_orders
 
         # Counters
         self.command_count: int = 0
         self.event_count: int = 0
         self.report_count: int = 0
 
         # Register endpoints
         self._msgbus.register(endpoint="ExecEngine.execute", handler=self.execute)
         self._msgbus.register(endpoint="ExecEngine.process", handler=self.process)
 
     @property
-    def registered_clients(self):
+    def reconciliation(self) -> bool:
+        """
+        Return whether the reconciliation process will be run on start.
+
+        Returns
+        -------
+        bool
+
+        """
+        # Temporary to push down common logic, the `LiveExecutionEngine` will override this
+        return False
+
+    @property
+    def registered_clients(self) -> list[ClientId]:
         """
         Return the execution clients registered with the engine.
 
         Returns
         -------
         list[ClientId]
 
         """
         return sorted(list(self._clients.keys()))
 
     @property
-    def default_client(self):
+    def default_client(self) -> Optional[ClientId]:
         """
         Return the default execution client registered with the engine.
 
         Returns
         -------
-        Optional[ClientId]
+        ClientId or ``None``
 
         """
         return self._default_client.id if self._default_client is not None else None
 
+    def connect(self) -> None:
+        """
+        Connect the engine by calling connect on all registered clients.
+        """
+        self._log.info("Connecting all clients...")
+        # Implement actual client connections for a live/sandbox context
+
+    def disconnect(self) -> None:
+        """
+        Disconnect the engine by calling disconnect on all registered clients.
+        """
+        self._log.info("Disconnecting all clients...")
+        # Implement actual client connections for a live/sandbox context
+
     cpdef int position_id_count(self, StrategyId strategy_id):
         """
         The position ID count for the given strategy ID.
 
         Parameters
         ----------
         strategy_id : StrategyId
@@ -424,14 +462,67 @@
             if self._default_client == client:
                 self._default_client = None
         else:
             del self._routing_map[client.venue]
 
         self._log.info(f"Deregistered {client}.")
 
+    # -- RECONCILIATION -------------------------------------------------------------------------------
+
+    async def reconcile_state(self, timeout_secs: float = 10.0) -> bool:
+        """
+        Reconcile the internal execution state with all execution clients (external state).
+
+        Parameters
+        ----------
+        timeout_secs : double, default 10.0
+            The timeout (seconds) for reconciliation to complete.
+
+        Returns
+        -------
+        bool
+            True if states reconcile within timeout, else False.
+
+        Raises
+        ------
+        ValueError
+            If `timeout_secs` is not positive (> 0).
+
+        """
+        return True  # Should be overridden for live execution engines
+
+    def reconcile_report(self, report: ExecutionReport) -> bool:
+        """
+        Check the given execution report.
+
+        Parameters
+        ----------
+        report : ExecutionReport
+            The execution report to check.
+
+        Returns
+        -------
+        bool
+            True if reconciliation successful, else False.
+
+        """
+        return True  # Should be overridden for live execution engines
+
+    def reconcile_mass_status(self, report: ExecutionMassStatus) -> None:
+        """
+        Reconcile the given execution mass status report.
+
+        Parameters
+        ----------
+        report : ExecutionMassStatus
+            The execution mass status report to reconcile.
+
+        """
+        # Should be overridden for live execution enginesj
+
 # -- ABSTRACT METHODS -----------------------------------------------------------------------------
 
     cpdef void _on_start(self):
         pass  # Optionally override in subclass
 
     cpdef void _on_stop(self):
         pass  # Optionally override in subclass
@@ -552,14 +643,81 @@
 
         # Set counts
         cdef StrategyId strategy_id
         for strategy_id, count in counts.items():
             self._pos_id_generator.set_count(strategy_id, count)
             self._log.info(f"Set PositionId count for {repr(strategy_id)} to {count}.")
 
+    cpdef Price _last_px_for_conversion(self, InstrumentId instrument_id, OrderSide order_side):
+        cdef Price last_px = None
+        cdef QuoteTick last_quote = self._cache.quote_tick(instrument_id)
+        cdef TradeTick last_trade = self._cache.trade_tick(instrument_id)
+        if last_quote is not None:
+            last_px = last_quote.ask if order_side == OrderSide.BUY else last_quote.bid
+        else:
+            if last_trade is not None:
+                last_px = last_trade.price
+
+        return last_px
+
+    cpdef void _set_order_base_qty(self, Order order, Quantity base_qty):
+        self._log.info(
+            f"Setting {order.instrument_id} order quote quantity {order.quantity} to base quantity {base_qty}.",
+        )
+        cdef Quantity original_qty = order.quantity
+        order.quantity = base_qty
+        order.leaves_qty = base_qty
+        order.is_quote_quantity = False
+
+        if order.contingency_type != ContingencyType.OTO:
+            return
+
+        # Set base quantity for all OTO contingent orders
+        cdef ClientOrderId client_order_id
+        cdef Order contingent_order
+        for client_order_id in order.linked_order_ids or []:
+            contingent_order = self._cache.order(client_order_id)
+            if contingent_order is None:
+                self._log.error(f"Contingency order {client_order_id!r} not found.")
+                continue
+            if not contingent_order.is_quote_quantity:
+                continue  # Already base quantity
+            if contingent_order.quantity != original_qty:
+                self._log.warning(
+                    f"Contingent order quantity {contingent_order.quantity} "
+                    f"was not equal to the OTO parent original quantity {original_qty} "
+                    f"when setting to base quantity of {base_qty}."
+                )
+            self._log.info(
+                f"Setting {contingent_order.instrument_id} order quote quantity "
+                f"{contingent_order.quantity} to base quantity {base_qty}.",
+            )
+            contingent_order.quantity = base_qty
+            contingent_order.leaves_qty = base_qty
+            contingent_order.is_quote_quantity = False
+
+    cpdef void _deny_order(self, Order order, str reason):
+        # Generate event
+        cdef OrderDenied denied = OrderDenied(
+            trader_id=order.trader_id,
+            strategy_id=order.strategy_id,
+            instrument_id=order.instrument_id,
+            client_order_id=order.client_order_id,
+            reason=reason,
+            event_id=UUID4(),
+            ts_init=self._clock.timestamp_ns(),
+        )
+        order.apply(denied)
+
+        self._cache.update_order(order)
+        self._msgbus.publish_c(
+            topic=f"events.order.{order.strategy_id.to_str()}",
+            msg=denied,
+        )
+
 # -- COMMAND HANDLERS -----------------------------------------------------------------------------
 
     cpdef void _execute_command(self, TradingCommand command):
         if self.debug:
             self._log.debug(f"{RECV}{CMD} {command}.", LogColor.MAGENTA)
         self.command_count += 1
 
@@ -591,28 +749,74 @@
             self._handle_query_order(client, command)
         else:
             self._log.error(  # pragma: no cover (design-time error)
                 f"Cannot handle command: unrecognized {command}.",  # pragma: no cover (design-time error)
             )
 
     cpdef void _handle_submit_order(self, ExecutionClient client, SubmitOrder command):
-        if not self._cache.order_exists(command.order.client_order_id):
+        cdef Order order = command.order
+        if not self._cache.order_exists(order.client_order_id):
             # Cache order
-            self._cache.add_order(command.order, command.position_id)
+            self._cache.add_order(order, command.position_id)
+
+        cdef Instrument instrument = self._cache.instrument(order.instrument_id)
+        if instrument is None:
+            self._log.error(
+                f"Cannot handle submit order: "
+                f"no instrument found for {order.instrument_id}, {command}."
+            )
+            return
+
+        # Check if converting quote quantity
+        cdef Price last_px = None
+        cdef Quantity base_qty = None
+        if not instrument.is_inverse and order.is_quote_quantity:
+            last_px = self._last_px_for_conversion(order.instrument_id, order.side)
+            if last_px is None:
+                self._deny_order(order, f"no-price-to-convert-quote-qty {order.instrument_id}")
+                return  # Denied
+            base_qty = instrument.calculate_base_quantity(order.quantity, last_px)
+            self._set_order_base_qty(order, base_qty)
 
         # Send to execution client
         client.submit_order(command)
 
     cpdef void _handle_submit_order_list(self, ExecutionClient client, SubmitOrderList command):
         cdef Order order
         for order in command.order_list.orders:
             if not self._cache.order_exists(order.client_order_id):
                 # Cache order
                 self._cache.add_order(order, position_id=None)
 
+        cdef Instrument instrument = self._cache.instrument(command.instrument_id)
+        if instrument is None:
+            self._log.error(
+                f"Cannot handle submit order list: "
+                f"no instrument found for {command.instrument_id}, {command}."
+            )
+            return
+
+        # Check if converting quote quantity
+        cdef Price last_px = None
+        cdef Quantity quote_qty = None
+        cdef Quantity base_qty = None
+        if not instrument.is_inverse and command.order_list.first.is_quote_quantity:
+            for order in command.order_list.orders:
+                if order.is_quote_quantity == False:
+                    continue  # Base quantity already set
+                if order.quantity != quote_qty:
+                    last_px = self._last_px_for_conversion(order.instrument_id, order.side)
+                    quote_qty = order.quantity
+                if last_px is None:
+                    for order in command.order_list.orders:
+                        self._deny_order(order, f"no-price-to-convert-quote-qty {order.instrument_id}")
+                    return  # Denied
+                base_qty = instrument.calculate_base_quantity(quote_qty, last_px)
+                self._set_order_base_qty(order, base_qty)
+
         # Send to execution client
         client.submit_order_list(command)
 
     cpdef void _handle_modify_order(self, ExecutionClient client, ModifyOrder command):
         client.modify_order(command)
 
     cpdef void _handle_cancel_order(self, ExecutionClient client, CancelOrder command):
@@ -879,14 +1083,22 @@
                 ts_event=fill.ts_event,
                 ts_init=fill.ts_init,
             )
 
             # Close original position
             self._update_position(instrument, position, fill_split1, oms_type)
 
+        # Guard against flipping a position with a zero fill size
+        if difference._mem.raw == 0:
+            self._log.warning(
+                "Zero fill size during position flip calculation, this could be caused by"
+                "a mismatch between instrument `size_precision` and a quantity `size_precision`."
+            )
+            return
+
         cdef PositionId position_id_flip = fill.position_id
         if oms_type == OmsType.HEDGING and fill.position_id.is_virtual_c():
             # Generate new position ID for flipped virtual position
             position_id_flip = self._pos_id_generator.generate(
                 strategy_id=fill.strategy_id,
                 flipped=True,
             )
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/execution/matching_core.pxd` & `nautilus_trader-1.175.0/nautilus_trader/execution/matching_core.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/execution/matching_core.pyx` & `nautilus_trader-1.175.0/nautilus_trader/execution/matching_core.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/execution/messages.pxd` & `nautilus_trader-1.175.0/nautilus_trader/execution/messages.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/execution/messages.pyx` & `nautilus_trader-1.175.0/nautilus_trader/execution/messages.pyx`

 * *Files 0% similar despite different names*

```diff
@@ -541,15 +541,15 @@
         ClientOrderId client_order_id not None,
         VenueOrderId venue_order_id: Optional[VenueOrderId],
         UUID4 command_id not None,
         uint64_t ts_init,
         ClientId client_id = None,
     ):
         if client_id is None:
-            client_id = ClientId(instrument_id.venue.to_str())
+            client_id = ClientId(instrument_id.venue.value)
         super().__init__(
             client_id=client_id,
             trader_id=trader_id,
             strategy_id=strategy_id,
             instrument_id=instrument_id,
             command_id=command_id,
             ts_init=ts_init,
@@ -792,15 +792,15 @@
         ClientOrderId client_order_id not None,
         VenueOrderId venue_order_id: Optional[VenueOrderId],
         UUID4 command_id not None,
         uint64_t ts_init,
         ClientId client_id = None,
     ):
         if client_id is None:
-            client_id = ClientId(instrument_id.venue.to_str())
+            client_id = ClientId(instrument_id.venue.value)
         super().__init__(
             client_id=client_id,
             trader_id=trader_id,
             strategy_id=strategy_id,
             instrument_id=instrument_id,
             command_id=command_id,
             ts_init=ts_init,
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/execution/reports.pxd` & `nautilus_trader-1.175.0/nautilus_trader/execution/reports.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/execution/reports.pyx` & `nautilus_trader-1.175.0/nautilus_trader/execution/reports.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/execution/trailing.pxd` & `nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/betting.pxd`

 * *Files 22% similar despite different names*

```diff
@@ -9,43 +9,31 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from nautilus_trader.accounting.accounts.cash cimport CashAccount
 from nautilus_trader.model.enums_c cimport OrderSide
-from nautilus_trader.model.enums_c cimport TrailingOffsetType
 from nautilus_trader.model.instruments.base cimport Instrument
+from nautilus_trader.model.objects cimport Money
 from nautilus_trader.model.objects cimport Price
-from nautilus_trader.model.orders.base cimport Order
+from nautilus_trader.model.objects cimport Quantity
 
 
-cdef class TrailingStopCalculator:
-
-    @staticmethod
-    cdef tuple calculate(
-        Instrument instrument,
-        Order order,
-        Price bid,
-        Price ask,
-        Price last,
-    )
-
-    @staticmethod
-    cdef Price calculate_with_last(
+cdef class BettingAccount(CashAccount):
+    cpdef Money calculate_balance_locked(
+        self,
         Instrument instrument,
-        TrailingOffsetType trailing_offset_type,
         OrderSide side,
-        double offset,
-        Price last,
+        Quantity quantity,
+        Price price,
+        bint use_quote_for_inverse=*,
     )
 
-    @staticmethod
-    cdef Price calculate_with_bid_ask(
-        Instrument instrument,
-        TrailingOffsetType trailing_offset_type,
-        OrderSide side,
-        double offset,
-        Price bid,
-        Price ask,
-    )
+
+cpdef stake(Quantity quantity, Price price)
+cpdef liability(Quantity quantity, Price price, OrderSide side)
+cpdef win_payoff(Quantity quantity, Price price, OrderSide side)
+cpdef lose_payoff(Quantity quantity, OrderSide side)
+cpdef exposure(Quantity quantity, Price price, OrderSide side)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/execution/trailing.pyx` & `nautilus_trader-1.175.0/nautilus_trader/execution/trailing.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/__init__.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/indicators/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/amat.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/amat.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/amat.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/amat.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/aroon.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/aroon.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/aroon.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/aroon.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/atr.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/atr.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/atr.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/atr.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/average/__init__.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/average/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/average/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/indicators/average/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/average/ama.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/average/ama.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/average/ama.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/average/ama.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/average/dema.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/average/dema.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/average/dema.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/average/dema.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/average/ema.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/average/ema.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/average/ema.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/average/ema.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/average/hma.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/average/hma.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/average/hma.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/average/hma.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/average/ma_factory.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/average/ma_factory.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/average/moving_average.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/average/moving_average.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/average/moving_average.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/average/moving_average.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/average/rma.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/average/rma.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/average/rma.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/average/rma.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/average/sma.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/average/sma.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/average/sma.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/average/sma.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/average/vidya.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/average/vidya.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/average/vidya.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/average/vidya.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/average/wma.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/average/wma.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/average/wma.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/average/wma.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/base/__init__.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/base/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/base/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/indicators/base/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/base/indicator.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/base/indicator.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/base/indicator.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/base/indicator.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/bias.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/keltner_channel.pxd`

 * *Files 13% similar despite different names*

```diff
@@ -9,21 +9,30 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from nautilus_trader.indicators.atr cimport AverageTrueRange
 from nautilus_trader.indicators.average.moving_average cimport MovingAverage
 from nautilus_trader.indicators.base.indicator cimport Indicator
+from nautilus_trader.model.data.bar cimport Bar
 
 
-cdef class Bias(Indicator):
+cdef class KeltnerChannel(Indicator):
     cdef MovingAverage _ma
+    cdef AverageTrueRange _atr
 
     cdef readonly int period
     """The window period.\n\n:returns: `int`"""
-    cdef readonly double value
-    """The current value.\n\n:returns: `double`"""
+    cdef readonly double k_multiplier
+    """The k multiplier.\n\n:returns: `double`"""
+    cdef readonly double upper
+    """The current value of the upper channel.\n\n:returns: `double`"""
+    cdef readonly double middle
+    """The current value of the middle channel.\n\n:returns: `double`"""
+    cdef readonly double lower
+    """The current value of the lower channel.\n\n:returns: `double`"""
 
-    cpdef void update_raw(self, double close)
-    cdef void _check_initialized(self)
+    cpdef void handle_bar(self, Bar bar)
+    cpdef void update_raw(self, double high, double low, double close)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/bias.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/bias.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/bollinger_bands.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/bollinger_bands.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/bollinger_bands.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/bollinger_bands.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/cci.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/cci.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/cci.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/cci.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/cmo.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/cmo.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/cmo.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/cmo.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/dm.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/dm.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/dm.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/dm.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/donchian_channel.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/donchian_channel.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/donchian_channel.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/donchian_channel.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/efficiency_ratio.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/efficiency_ratio.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/efficiency_ratio.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/efficiency_ratio.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/fuzzy_candlesticks.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_candlesticks.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/fuzzy_candlesticks.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_candlesticks.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/fuzzy_enum.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enum.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/fuzzy_enums/__init__.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/fuzzy_enums/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/fuzzy_enums/candle_body.pxd` & `nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/serializer.pxd`

 * *Files 10% similar despite different names*

```diff
@@ -10,13 +10,9 @@
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 
-cpdef enum CandleBodySize:
-    NONE = 0  # Doji
-    SMALL = 1
-    MEDIUM = 2
-    LARGE = 3
-    TREND = 4
+cdef class ParquetSerializer:
+    pass
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/fuzzy_enums/candle_body.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_body.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/fuzzy_enums/candle_direction.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/orderbook/error.py`

 * *Files 12% similar despite different names*

```diff
@@ -10,11 +10,11 @@
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 
-cpdef enum CandleDirection:
-    BULL = 1
-    NONE = 0  # Doji
-    BEAR = -1
+class BookIntegrityError(Exception):
+    """
+    Represents an error condition where the order books integrity has been lost.
+    """
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/fuzzy_enums/candle_direction.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_direction.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/fuzzy_enums/candle_size.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_size.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/fuzzy_enums/candle_size.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_size.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/fuzzy_enums/candle_wick.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_wick.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/fuzzy_enums/candle_wick.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/fuzzy_enums/candle_wick.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/keltner_channel.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/keltner_position.pxd`

 * *Files 12% similar despite different names*

```diff
@@ -9,30 +9,22 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.indicators.atr cimport AverageTrueRange
-from nautilus_trader.indicators.average.moving_average cimport MovingAverage
 from nautilus_trader.indicators.base.indicator cimport Indicator
-from nautilus_trader.model.data.bar cimport Bar
+from nautilus_trader.indicators.keltner_channel cimport KeltnerChannel
 
 
-cdef class KeltnerChannel(Indicator):
-    cdef MovingAverage _ma
-    cdef AverageTrueRange _atr
+cdef class KeltnerPosition(Indicator):
+    cdef KeltnerChannel _kc
 
     cdef readonly int period
     """The window period.\n\n:returns: `int`"""
     cdef readonly double k_multiplier
-    """The k multiplier.\n\n:returns: `double`"""
-    cdef readonly double upper
-    """The current value of the upper channel.\n\n:returns: `double`"""
-    cdef readonly double middle
-    """The current value of the middle channel.\n\n:returns: `double`"""
-    cdef readonly double lower
-    """The current value of the lower channel.\n\n:returns: `double`"""
+    """The K multiplier.\n\n:returns: `double`"""
+    cdef readonly double value
+    """The current value.\n\n:returns: `double`"""
 
-    cpdef void handle_bar(self, Bar bar)
     cpdef void update_raw(self, double high, double low, double close)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/keltner_channel.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/keltner_channel.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/keltner_position.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/volatility_ratio.pxd`

 * *Files 13% similar despite different names*

```diff
@@ -9,22 +9,24 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from nautilus_trader.indicators.atr cimport AverageTrueRange
 from nautilus_trader.indicators.base.indicator cimport Indicator
-from nautilus_trader.indicators.keltner_channel cimport KeltnerChannel
 
 
-cdef class KeltnerPosition(Indicator):
-    cdef KeltnerChannel _kc
+cdef class VolatilityRatio(Indicator):
+    cdef AverageTrueRange _atr_fast
+    cdef AverageTrueRange _atr_slow
 
-    cdef readonly int period
-    """The window period.\n\n:returns: `int`"""
-    cdef readonly double k_multiplier
-    """The K multiplier.\n\n:returns: `double`"""
+    cdef readonly int fast_period
+    """The period of the fast ATR.\n\n:returns: `int`"""
+    cdef readonly int slow_period
+    """The period of the slow ATR.\n\n:returns: `int`"""
     cdef readonly double value
     """The current value.\n\n:returns: `double`"""
 
     cpdef void update_raw(self, double high, double low, double close)
+    cdef void _check_initialized(self)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/keltner_position.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/keltner_position.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/kvo.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/kvo.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/kvo.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/kvo.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/linear_regression.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/linear_regression.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/linear_regression.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/linear_regression.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/macd.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/macd.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/macd.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/macd.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/obv.pxd` & `nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -9,19 +9,8 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.indicators.base.indicator cimport Indicator
-
-
-cdef class OnBalanceVolume(Indicator):
-    cdef object _obv
-
-    cdef readonly int period
-    """The window period.\n\n:returns: `int`"""
-    cdef readonly double value
-    """The current value.\n\n:returns: `double`"""
-
-    cpdef void update_raw(self, double open, double close, double volume)
+from nautilus_trader.serialization.arrow import implementations  # noqa: F401
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/obv.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/obv.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/pressure.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/pressure.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/pressure.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/pressure.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/psl.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/psl.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/psl.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/psl.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/roc.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -9,20 +9,14 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.indicators.base.indicator cimport Indicator
+"""
+The `model` subpackage defines a rich trading domain model.
 
-
-cdef class RateOfChange(Indicator):
-    cdef bint _use_log
-    cdef object _prices
-
-    cdef readonly int period
-    """The window period.\n\n:returns: `int`"""
-    cdef readonly double value
-    """The current value.\n\n:returns: `double`"""
-
-    cpdef void update_raw(self, double price)
+The domain model is agnostic of any system design, seeking to represent the logic
+and state transitions of trading in a generic way. Many system implementations could
+be built around this domain model.
+"""
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/roc.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/roc.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/rsi.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/rsi.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/rsi.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/rsi.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/rvi.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/rvi.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/rvi.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/rvi.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/spread_analyzer.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/spread_analyzer.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/spread_analyzer.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/spread_analyzer.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/stochastics.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/stochastics.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/stochastics.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/stochastics.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/swings.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/swings.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/swings.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/swings.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/vhf.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/vhf.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/vhf.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/vhf.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/volatility_ratio.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/implementations/fixed.pxd`

 * *Files 20% similar despite different names*

```diff
@@ -9,24 +9,21 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.indicators.atr cimport AverageTrueRange
-from nautilus_trader.indicators.base.indicator cimport Indicator
+from nautilus_trader.model.objects cimport Price
+from nautilus_trader.model.tick_scheme.base cimport TickScheme
 
 
-cdef class VolatilityRatio(Indicator):
-    cdef AverageTrueRange _atr_fast
-    cdef AverageTrueRange _atr_slow
+cdef class FixedTickScheme(TickScheme):
+    cdef double _increment
 
-    cdef readonly int fast_period
-    """The period of the fast ATR.\n\n:returns: `int`"""
-    cdef readonly int slow_period
-    """The period of the slow ATR.\n\n:returns: `int`"""
-    cdef readonly double value
-    """The current value.\n\n:returns: `double`"""
+    cdef readonly int price_precision
+    """The tick scheme price precision.\n\n:returns: `int`"""
+    cdef readonly Price increment
+    """The tick scheme price increment.\n\n:returns: `Price`"""
 
-    cpdef void update_raw(self, double high, double low, double close)
-    cdef void _check_initialized(self)
+    cpdef Price next_ask_price(self, double value, int n=*)
+    cpdef Price next_bid_price(self, double value, int n=*)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/volatility_ratio.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/volatility_ratio.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/vwap.pxd` & `nautilus_trader-1.175.0/nautilus_trader/indicators/vwap.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/indicators/vwap.pyx` & `nautilus_trader-1.175.0/nautilus_trader/indicators/vwap.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/infrastructure/__init__.pxd` & `nautilus_trader-1.175.0/nautilus_trader/infrastructure/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/infrastructure/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/infrastructure/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/infrastructure/cache.pxd` & `nautilus_trader-1.175.0/nautilus_trader/infrastructure/cache.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/infrastructure/cache.pyx` & `nautilus_trader-1.175.0/nautilus_trader/infrastructure/cache.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/live/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/live/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/live/__main__.py` & `nautilus_trader-1.175.0/nautilus_trader/live/__main__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/live/data_client.py` & `nautilus_trader-1.175.0/nautilus_trader/live/data_client.py`

 * *Files 0% similar despite different names*

```diff
@@ -32,16 +32,16 @@
 from nautilus_trader.common.enums import LogColor
 from nautilus_trader.common.logging import Logger
 from nautilus_trader.common.providers import InstrumentProvider
 from nautilus_trader.core.correctness import PyCondition
 from nautilus_trader.core.uuid import UUID4
 from nautilus_trader.data.client import DataClient
 from nautilus_trader.data.client import MarketDataClient
-from nautilus_trader.model.data.bar import BarType
-from nautilus_trader.model.data.base import DataType
+from nautilus_trader.model.data import BarType
+from nautilus_trader.model.data import DataType
 from nautilus_trader.model.enums import BookType
 from nautilus_trader.model.identifiers import ClientId
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.identifiers import Venue
 from nautilus_trader.msgbus.bus import MessageBus
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/live/data_engine.py` & `nautilus_trader-1.175.0/nautilus_trader/live/data_engine.py`

 * *Files 2% similar despite different names*

```diff
@@ -200,27 +200,27 @@
         """
         self._log.warning("Killing engine...")
         self._kill = True
         self.stop()
         if self._cmd_queue_task:
             self._log.debug(f"Canceling {self._cmd_queue_task.get_name()}...")
             self._cmd_queue_task.cancel()
-            self._cmd_queue_task.done()
+            self._cmd_queue_task = None
         if self._req_queue_task:
             self._log.debug(f"Canceling {self._req_queue_task.get_name()}...")
             self._req_queue_task.cancel()
-            self._req_queue_task.done()
+            self._req_queue_task = None
         if self._res_queue_task:
             self._log.debug(f"Canceling {self._res_queue_task.get_name()}...")
             self._res_queue_task.cancel()
-            self._res_queue_task.done()
+            self._res_queue_task = None
         if self._data_queue_task:
             self._log.debug(f"Canceling {self._data_queue_task.get_name()}...")
             self._data_queue_task.cancel()
-            self._data_queue_task.done()
+            self._data_queue_task = None
 
     def execute(self, command: DataCommand) -> None:
         """
         Execute the given data command.
 
         If the internal queue is already full then will log a warning and block
         until queue size reduces.
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/live/execution_client.py` & `nautilus_trader-1.175.0/nautilus_trader/msgbus/bus.pyx`

 * *Files 25% similar despite different names*

```diff
@@ -9,486 +9,535 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-"""
-The `LiveExecutionClient` class is responsible for interfacing with a particular
-API which may be presented directly by an exchange, or broker intermediary.
-"""
-
-import asyncio
-import functools
-from asyncio import Task
-from collections.abc import Coroutine
-from datetime import timedelta
-from typing import Any, Callable, Optional
-
-import pandas as pd
-
-from nautilus_trader.cache.cache import Cache
-from nautilus_trader.common.clock import LiveClock
-from nautilus_trader.common.enums import LogColor
-from nautilus_trader.common.logging import Logger
-from nautilus_trader.common.providers import InstrumentProvider
-from nautilus_trader.core.correctness import PyCondition
-from nautilus_trader.core.uuid import UUID4
-from nautilus_trader.execution.client import ExecutionClient
-from nautilus_trader.execution.messages import CancelAllOrders
-from nautilus_trader.execution.messages import CancelOrder
-from nautilus_trader.execution.messages import ModifyOrder
-from nautilus_trader.execution.messages import QueryOrder
-from nautilus_trader.execution.messages import SubmitOrder
-from nautilus_trader.execution.messages import SubmitOrderList
-from nautilus_trader.execution.reports import ExecutionMassStatus
-from nautilus_trader.execution.reports import OrderStatusReport
-from nautilus_trader.execution.reports import PositionStatusReport
-from nautilus_trader.execution.reports import TradeReport
-from nautilus_trader.model.currency import Currency
-from nautilus_trader.model.enums import AccountType
-from nautilus_trader.model.enums import OmsType
-from nautilus_trader.model.identifiers import ClientId
-from nautilus_trader.model.identifiers import ClientOrderId
-from nautilus_trader.model.identifiers import InstrumentId
-from nautilus_trader.model.identifiers import Venue
-from nautilus_trader.model.identifiers import VenueOrderId
-from nautilus_trader.msgbus.bus import MessageBus
+from typing import Any, Callable
 
+import cython
+import numpy as np
 
-class LiveExecutionClient(ExecutionClient):
+cimport numpy as np
+
+from nautilus_trader.common.clock cimport Clock
+from nautilus_trader.common.logging cimport Logger
+from nautilus_trader.core.correctness cimport Condition
+from nautilus_trader.core.uuid cimport UUID4
+from nautilus_trader.model.identifiers cimport TraderId
+
+
+cdef class MessageBus:
     """
-    The base class for all live execution clients.
+    Provides a generic message bus to facilitate various messaging patterns.
+
+    The bus provides both a producer and consumer API for Pub/Sub, Req/Rep, as
+    well as direct point-to-point messaging to registered endpoints.
+
+    Pub/Sub wildcard patterns for hierarchical topics are possible:
+     - `*` asterisk represents one or more characters in a pattern.
+     - `?` question mark represents a single character in a pattern.
+
+    Given a topic and pattern potentially containing wildcard characters, i.e.
+    `*` and `?`, where `?` can match any single character in the topic, and `*`
+    can match any number of characters including zero characters.
+
+    The asterisk in a wildcard matches any character zero or more times. For
+    example, `comp*` matches anything beginning with `comp` which means `comp`,
+    `complete`, and `computer` are all matched.
+
+    A question mark matches a single character once. For example, `c?mp` matches
+    `camp` and `comp`. The question mark can also be used more than once.
+    For example, `c??p` would match both of the above examples and `coop`.
 
     Parameters
     ----------
-    loop : asyncio.AbstractEventLoop
-        The event loop for the client.
-    client_id : ClientId
-        The client ID.
-    venue : Venue, optional with no default so ``None`` must be passed explicitly
-        The client venue. If multi-venue then can be ``None``.
-    instrument_provider : InstrumentProvider
-        The instrument provider for the client.
-    account_type : AccountType
-        The account type for the client.
-    base_currency : Currency, optional
-        The account base currency for the client. Use ``None`` for multi-currency accounts.
-    msgbus : MessageBus
-        The message bus for the client.
-    cache : Cache
-        The cache for the client.
-    clock : LiveClock
-        The clock for the client.
+    trader_id : TraderId
+        The trader ID associated with the message bus.
+    clock : Clock
+        The clock for the message bus.
     logger : Logger
-        The logger for the client.
-    config : dict[str, object], optional
-        The configuration for the instance.
+        The logger for the message bus.
+    name : str, optional
+        The custom name for the message bus.
 
     Raises
     ------
     ValueError
-        If `oms_type` is ``UNSPECIFIED`` (must be specified).
+        If `name` is not ``None`` and not a valid string.
 
     Warnings
     --------
-    This class should not be used directly, but through a concrete subclass.
+    This message bus is not thread-safe and must be called from the same thread
+    as the event loop.
     """
 
     def __init__(
         self,
-        loop: asyncio.AbstractEventLoop,
-        client_id: ClientId,
-        venue: Optional[Venue],
-        oms_type: OmsType,
-        account_type: AccountType,
-        base_currency: Optional[Currency],
-        instrument_provider: InstrumentProvider,
-        msgbus: MessageBus,
-        cache: Cache,
-        clock: LiveClock,
-        logger: Logger,
-        config: Optional[dict[str, Any]] = None,
-    ) -> None:
-        PyCondition.type(instrument_provider, InstrumentProvider, "instrument_provider")
-
-        super().__init__(
-            client_id=client_id,
-            venue=venue,
-            oms_type=oms_type,
-            account_type=account_type,
-            base_currency=base_currency,
-            msgbus=msgbus,
-            cache=cache,
-            clock=clock,
-            logger=logger,
-            config=config,
-        )
+        TraderId trader_id not None,
+        Clock clock not None,
+        Logger logger not None,
+        str name = None,
+    ):
+        if name is None:
+            name = type(self).__name__
+        Condition.valid_string(name, "name")
+
+        self.trader_id = trader_id
+
+        self._clock = clock
+        self._log = LoggerAdapter(component_name=name, logger=logger)
+
+        self._endpoints: dict[str, Callable[[Any], None]] = {}
+        self._patterns: dict[str, Subscription[:]] = {}
+        self._subscriptions: dict[Subscription, list[str]] = {}
+        self._correlation_index: dict[UUID4, Callable[[Any], None]] = {}
+
+        # Counters
+        self.sent_count = 0
+        self.req_count = 0
+        self.res_count = 0
+        self.pub_count = 0
 
-        self._loop = loop
-        self._instrument_provider = instrument_provider
+    cpdef list endpoints(self):
+        """
+        Return all endpoint addresses registered with the message bus.
 
-        self.reconciliation_active = False
+        Returns
+        -------
+        list[str]
 
-    async def run_after_delay(
-        self,
-        delay: float,
-        coro: Coroutine,
-    ) -> None:
         """
-        Run the given coroutine after a delay.
+        return list(self._endpoints.keys())
 
-        Parameters
-        ----------
-        delay : float
-            The delay (seconds) before running the coroutine.
-        coro : Coroutine
-            The coroutine to run after the initial delay.
+    cpdef list topics(self):
+        """
+        Return all topics with active subscribers.
+
+        Returns
+        -------
+        list[str]
 
         """
-        await asyncio.sleep(delay)
-        return await coro
+        return sorted(set([s.topic for s in self._subscriptions.keys()]))
 
-    def create_task(
-        self,
-        coro: Coroutine,
-        log_msg: Optional[str] = None,
-        actions: Optional[Callable] = None,
-        success: Optional[str] = None,
-    ) -> asyncio.Task:
-        """
-        Run the given coroutine with error handling and optional callback
-        actions when done.
+    cpdef list subscriptions(self, str pattern = None):
+        """
+        Return all subscriptions matching the given topic `pattern`.
 
         Parameters
         ----------
-        coro : Coroutine
-            The coroutine to run.
-        log_msg : str, optional
-            The log message for the task.
-        actions : Callable, optional
-            The actions callback to run when the coroutine is done.
-        success : str, optional
-            The log message to write on actions success.
+        pattern : str, optional
+            The topic pattern filter. May include wildcard characters `*` and `?`.
+            If ``None`` then query is for **all** topics.
 
         Returns
         -------
-        asyncio.Task
+        list[Subscription]
 
         """
-        log_msg = log_msg or coro.__name__
-        self._log.debug(f"Creating task {log_msg}.")
-        task = self._loop.create_task(
-            coro,
-            name=coro.__name__,
-        )
-        task.add_done_callback(
-            functools.partial(
-                self._on_task_completed,
-                actions,
-                success,
-            ),
-        )
-        return task
+        if pattern is None:
+            pattern = "*"  # Wildcard
+        Condition.valid_string(pattern, "pattern")
 
-    def _on_task_completed(
-        self,
-        actions: Optional[Callable],
-        success: Optional[str],
-        task: Task,
-    ) -> None:
-        if task.exception():
-            self._log.error(
-                f"Error on `{task.get_name()}`: " f"{task.exception()!r}",
-            )
-        else:
-            if actions:
-                try:
-                    actions()
-                except Exception as e:
-                    self._log.error(
-                        f"Failed triggering action {actions.__name__} on `{task.get_name()}`: "
-                        f"{e!r}",
-                    )
-            if success:
-                self._log.info(success, LogColor.GREEN)
-
-    def connect(self) -> None:
-        """
-        Connect the client.
-        """
-        self._log.info("Connecting...")
-        self.create_task(
-            self._connect(),
-            actions=lambda: self._set_connected(True),
-            success="Connected",
-        )
+        return [s for s in self._subscriptions if is_matching(s.topic, pattern)]
 
-    def disconnect(self) -> None:
+    cpdef bint has_subscribers(self, str pattern = None):
         """
-        Disconnect the client.
+        If the message bus has subscribers for the give topic `pattern`.
+
+        Parameters
+        ----------
+        pattern : str, optional
+            The topic filter. May include wildcard characters `*` and `?`.
+            If ``None`` then query is for **all** topics.
+
+        Returns
+        -------
+        bool
+
         """
-        self._log.info("Disconnecting...")
-        self.create_task(
-            self._disconnect(),
-            actions=lambda: self._set_connected(False),
-            success="Disconnected",
-        )
+        return len(self.subscriptions(pattern)) > 0
 
-    def submit_order(self, command: SubmitOrder) -> None:
-        self.create_task(
-            self._submit_order(command),
-            log_msg=f"submit_order: {command}",
-        )
+    cpdef bint is_subscribed(self, str topic, handler: Callable[[Any], None]):
+        """
+        Return if topic and handler is subscribed to the message bus.
 
-    def submit_order_list(self, command: SubmitOrderList) -> None:
-        self.create_task(
-            self._submit_order_list(command),
-            log_msg=f"submit_order_list: {command}",
-        )
+        Does not consider any previous `priority`.
 
-    def modify_order(self, command: ModifyOrder) -> None:
-        self.create_task(
-            self._modify_order(command),
-            log_msg=f"modify_order: {command}",
-        )
+        Parameters
+        ----------
+        topic : str
+            The topic of the subscription.
+        handler : Callable[[Any], None]
+            The handler of the subscription.
 
-    def cancel_order(self, command: CancelOrder) -> None:
-        self.create_task(
-            self._cancel_order(command),
-            log_msg=f"cancel_order: {command}",
-        )
+        Returns
+        -------
+        bool
 
-    def cancel_all_orders(self, command: CancelAllOrders) -> None:
-        self.create_task(
-            self._cancel_all_orders(command),
-            log_msg=f"cancel_all_orders: {command}",
-        )
+        """
+        Condition.valid_string(topic, "topic")
+        Condition.callable(handler, "handler")
 
-    def query_order(self, command: QueryOrder) -> None:
-        self.create_task(
-            self._query_order(command),
-            log_msg=f"query_order: {command}",
+        # Create subscription
+        cdef Subscription sub = Subscription(
+            topic=topic,
+            handler=handler,
         )
 
-    async def generate_order_status_report(
-        self,
-        instrument_id: InstrumentId,
-        client_order_id: Optional[ClientOrderId] = None,
-        venue_order_id: Optional[VenueOrderId] = None,
-    ) -> Optional[OrderStatusReport]:
-        """
-        Generate an `OrderStatusReport` for the given order identifier parameter(s).
+        return sub in self._subscriptions
 
-        If the order is not found, or an error occurs, then logs and returns ``None``.
+    cpdef void register(self, str endpoint, handler: Callable[[Any], None]):
+        """
+        Register the given `handler` to receive messages at the `endpoint` address.
 
         Parameters
         ----------
-        instrument_id : InstrumentId
-            The instrument ID for the report.
-        client_order_id : ClientOrderId, optional
-            The client order ID for the report.
-        venue_order_id : VenueOrderId, optional
-            The venue order ID for the report.
-
-        Returns
-        -------
-        OrderStatusReport or ``None``
+        endpoint : str
+            The endpoint address to register.
+        handler : Callable[[Any], None]
+            The handler for the registration.
 
         Raises
         ------
         ValueError
-            If both the `client_order_id` and `venue_order_id` are ``None``.
+            If `endpoint` is not a valid string.
+        ValueError
+            If `handler` is not of type `Callable`.
+        KeyError
+            If `endpoint` already registered.
 
         """
-        raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
+        Condition.valid_string(endpoint, "endpoint")
+        Condition.callable(handler, "handler")
+        Condition.not_in(endpoint, self._endpoints, "endpoint", "_endpoints")
 
-    async def generate_order_status_reports(
-        self,
-        instrument_id: Optional[InstrumentId] = None,
-        start: Optional[pd.Timestamp] = None,
-        end: Optional[pd.Timestamp] = None,
-        open_only: bool = False,
-    ) -> list[OrderStatusReport]:
-        """
-        Generate a list of `OrderStatusReport`s with optional query filters.
-
-        The returned list may be empty if no orders match the given parameters.
+        self._endpoints[endpoint] = handler
+
+        self._log.debug(f"Added endpoint '{endpoint}' {handler}.")
+
+    cpdef void deregister(self, str endpoint, handler: Callable[[Any], None]):
+        """
+        Deregister the given `handler` from the `endpoint` address.
 
         Parameters
         ----------
-        instrument_id : InstrumentId, optional
-            The instrument ID query filter.
-        start : pd.Timestamp, optional
-            The start datetime query filter.
-        end : pd.Timestamp, optional
-            The end datetime query filter.
-        open_only : bool, default False
-            If the query is for open orders only.
+        endpoint : str
+            The endpoint address to deregister.
+        handler : Callable[[Any], None]
+            The handler to deregister.
 
-        Returns
-        -------
-        list[OrderStatusReport]
+        Raises
+        ------
+        ValueError
+            If `endpoint` is not a valid string.
+        ValueError
+            If `handler` is not of type `Callable`.
+        KeyError
+            If `endpoint` is not registered.
+        ValueError
+            If `handler` is not registered at the endpoint.
 
         """
-        raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
+        Condition.valid_string(endpoint, "endpoint")
+        Condition.callable(handler, "handler")
+        Condition.is_in(endpoint, self._endpoints, "endpoint", "self._endpoints")
+        Condition.equal(handler, self._endpoints[endpoint], "handler", "self._endpoints[endpoint]")
 
-    async def generate_trade_reports(
-        self,
-        instrument_id: Optional[InstrumentId] = None,
-        venue_order_id: Optional[VenueOrderId] = None,
-        start: Optional[pd.Timestamp] = None,
-        end: Optional[pd.Timestamp] = None,
-    ) -> list[TradeReport]:
-        """
-        Generate a list of `TradeReport`s with optional query filters.
-
-        The returned list may be empty if no trades match the given parameters.
+        del self._endpoints[endpoint]
+
+        self._log.debug(f"Removed endpoint '{endpoint}' {handler}.")
+
+    cpdef void send(self, str endpoint, msg: Any):
+        """
+        Send the given message to the given `endpoint` address.
 
         Parameters
         ----------
-        instrument_id : InstrumentId, optional
-            The instrument ID query filter.
-        venue_order_id : VenueOrderId, optional
-            The venue order ID (assigned by the venue) query filter.
-        start : pd.Timestamp, optional
-            The start datetime query filter.
-        end : pd.Timestamp, optional
-            The end datetime query filter.
-
-        Returns
-        -------
-        list[TradeReport]
+        endpoint : str
+            The endpoint address to send the message to.
+        msg : object
+            The message to send.
 
         """
-        raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
+        Condition.not_none(endpoint, "endpoint")
+        Condition.not_none(msg, "msg")
 
-    async def generate_position_status_reports(
-        self,
-        instrument_id: Optional[InstrumentId] = None,
-        start: Optional[pd.Timestamp] = None,
-        end: Optional[pd.Timestamp] = None,
-    ) -> list[PositionStatusReport]:
+        handler = self._endpoints.get(endpoint)
+        if handler is None:
+            self._log.error(
+                f"Cannot send message: no endpoint registered at '{endpoint}'.",
+            )
+            return  # Cannot send
+
+        handler(msg)
+        self.sent_count += 1
+
+    cpdef void request(self, str endpoint, Request request):
         """
-        Generate a list of `PositionStatusReport`s with optional query filters.
+        Handle the given `request`.
 
-        The returned list may be empty if no positions match the given parameters.
+        Will log an error if the correlation ID already exists.
 
         Parameters
         ----------
-        instrument_id : InstrumentId, optional
-            The instrument ID query filter.
-        start : pd.Timestamp, optional
-            The start datetime query filter.
-        end : pd.Timestamp, optional
-            The end datetime query filter.
+        endpoint : str
+            The endpoint address to send the request to.
+        request : Request
+            The request to handle.
 
-        Returns
-        -------
-        list[PositionStatusReport]
+        """
+        Condition.not_none(endpoint, "endpoint")
+        Condition.not_none(request, "request")
+
+        if request.id in self._correlation_index:
+            self._log.error(
+                f"Cannot handle request: "
+                f"duplicate ID {request.id} found in correlation index.",
+            )
+            return  # Do not handle duplicates
+
+        self._correlation_index[request.id] = request.callback
+
+        handler = self._endpoints.get(endpoint)
+        if handler is None:
+            self._log.error(
+                f"Cannot handle request: no endpoint registered at '{endpoint}'.",
+            )
+            return  # Cannot handle
+
+        handler(request)
+        self.req_count += 1
+
+    cpdef void response(self, Response response):
+        """
+        Handle the given `response`.
+
+        Will log an error if the correlation ID is not found.
+
+        Parameters
+        ----------
+        response : Response
+            The response to handle
 
         """
-        raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
+        Condition.not_none(response, "response")
+
+        callback = self._correlation_index.pop(response.correlation_id, None)
+        if callback is None:
+            self._log.error(
+                f"Cannot handle response: "
+                f"callback not found for correlation_id {response.correlation_id}.",
+            )
+            return  # Cannot handle
 
-    async def generate_mass_status(
+        callback(response)
+        self.res_count += 1
+
+    cpdef void subscribe(
         self,
-        lookback_mins: Optional[int] = None,
-    ) -> ExecutionMassStatus:
+        str topic,
+        handler: Callable[[Any], None],
+        int priority = 0,
+    ):
         """
-        Generate an `ExecutionMassStatus` report.
+        Subscribe to the given message `topic` with the given callback `handler`.
 
         Parameters
         ----------
-        lookback_mins : int, optional
-            The maximum lookback for querying closed orders, trades and positions.
+        topic : str
+            The topic for the subscription. May include wildcard characters
+            `*` and `?`.
+        handler : Callable[[Any], None]
+            The handler for the subscription.
+        priority : int, optional
+            The priority for the subscription. Determines the ordering of
+            handlers receiving messages being processed, higher priority
+            handlers will receive messages prior to lower priority handlers.
 
-        Returns
-        -------
-        ExecutionMassStatus
+        Raises
+        ------
+        ValueError
+            If `topic` is not a valid string.
+        ValueError
+            If `handler` is not of type `Callable`.
 
-        """
-        self._log.info(f"Generating ExecutionMassStatus for {self.id}...")
+        Warnings
+        --------
+        Assigning priority handling is an advanced feature which *shouldn't
+        normally be needed by most users*. **Only assign a higher priority to the
+        subscription if you are certain of what you're doing**. If an inappropriate
+        priority is assigned then the handler may receive messages before core
+        system components have been able to process necessary calculations and
+        produce potential side effects for logically sound behaviour.
+
+        """
+        Condition.valid_string(topic, "topic")
+        Condition.callable(handler, "handler")
+
+        # Create subscription
+        cdef Subscription sub = Subscription(
+            topic=topic,
+            handler=handler,
+            priority=priority,
+        )
+
+        # Check if already exists
+        if sub in self._subscriptions:
+            self._log.debug(f"{sub} already exists.")
+            return
 
-        self.reconciliation_active = True
+        cdef list matches = []
+        cdef list patterns = list(self._patterns.keys())
 
-        mass_status = ExecutionMassStatus(
-            client_id=self.id,
-            account_id=self.account_id,
-            venue=self.venue,
-            report_id=UUID4(),
-            ts_init=self._clock.timestamp_ns(),
-        )
+        cdef str pattern
+        cdef list subs
+        for pattern in patterns:
+            if is_matching(topic, pattern):
+                subs = list(self._patterns[pattern])
+                subs.append(sub)
+                subs = sorted(subs, reverse=True)
+                self._patterns[pattern] = np.ascontiguousarray(subs, dtype=Subscription)
+                matches.append(pattern)
 
-        since: Optional[pd.Timestamp] = None
-        if lookback_mins is not None:
-            since = self._clock.utc_now() - timedelta(minutes=lookback_mins)
-
-        try:
-            reports = await asyncio.gather(
-                self.generate_order_status_reports(start=since),
-                self.generate_trade_reports(start=since),
-                self.generate_position_status_reports(start=since),
-            )
+        self._subscriptions[sub] = sorted(matches)
 
-            mass_status.add_order_reports(reports=reports[0])
-            mass_status.add_trade_reports(reports=reports[1])
-            mass_status.add_position_reports(reports=reports[2])
-
-            self.reconciliation_active = False
-
-            return mass_status
-        except Exception as e:
-            self._log.exception("Cannot reconcile execution state", e)
-
-    async def _query_order(self, command: QueryOrder) -> None:
-        self._log.debug(f"Synchronizing order status {command}.")
-
-        report: OrderStatusReport = await self.generate_order_status_report(
-            instrument_id=command.instrument_id,
-            client_order_id=command.client_order_id,
-            venue_order_id=command.venue_order_id,
-        )
+        self._log.debug(f"Added {sub}.")
 
-        if report is None:
-            self._log.warning("Did not received `OrderStatusReport` from request.")
-            return
+    cpdef void unsubscribe(self, str topic, handler: Callable[[Any], None]):
+        """
+        Unsubscribe the given callback `handler` from the given message `topic`.
 
-        self._send_order_status_report(report)
+        Parameters
+        ----------
+        topic : str, optional
+            The topic to unsubscribe from. May include wildcard characters `*`
+            and `?`.
+        handler : Callable[[Any], None]
+            The handler for the subscription.
 
-    ############################################################################
-    # Coroutines to implement
-    ############################################################################
-    async def _connect(self) -> None:
-        raise NotImplementedError(  # pragma: no cover
-            "implement the `_connect` coroutine",  # pragma: no cover
-        )
+        Raises
+        ------
+        ValueError
+            If `topic` is not a valid string.
+        ValueError
+            If `handler` is not of type `Callable`.
 
-    async def _disconnect(self) -> None:
-        raise NotImplementedError(  # pragma: no cover
-            "implement the `_disconnect` coroutine",  # pragma: no cover
-        )
+        """
+        Condition.valid_string(topic, "topic")
+        Condition.callable(handler, "handler")
 
-    async def _submit_order(self, command: SubmitOrder) -> None:
-        raise NotImplementedError(  # pragma: no cover
-            "implement the `_submit_order` coroutine",  # pragma: no cover
-        )
+        cdef Subscription sub = Subscription(topic=topic, handler=handler)
 
-    async def _submit_order_list(self, command: SubmitOrderList) -> None:
-        raise NotImplementedError(  # pragma: no cover
-            "implement the `_submit_order_list` coroutine",  # pragma: no cover
-        )
+        cdef list patterns = self._subscriptions.get(sub)
 
-    async def _modify_order(self, command: ModifyOrder) -> None:
-        raise NotImplementedError(  # pragma: no cover
-            "implement the `_modify_order` coroutine",  # pragma: no cover
-        )
+        # Check if exists
+        if patterns is None:
+            self._log.warning(f"{sub} not found.")
+            return
 
-    async def _cancel_order(self, command: CancelOrder) -> None:
-        raise NotImplementedError(  # pragma: no cover
-            "implement the `_cancel_order` coroutine",  # pragma: no cover
-        )
+        cdef str pattern
+        for pattern in patterns:
+            subs = list(self._patterns[pattern])
+            subs.remove(sub)
+            subs = sorted(subs, reverse=True)
+            self._patterns[pattern] = np.ascontiguousarray(subs, dtype=Subscription)
 
-    async def _cancel_all_orders(self, command: CancelAllOrders) -> None:
-        raise NotImplementedError(  # pragma: no cover
-            "implement the `_cancel_all_orders` coroutine",  # pragma: no cover
-        )
+        del self._subscriptions[sub]
+
+        self._log.debug(f"Removed {sub}.")
+
+    cpdef void publish(self, str topic, msg: Any):
+        """
+        Publish the given message for the given `topic`.
+
+        Subscription handlers will receive the message in priority order
+        (highest first).
+
+        Parameters
+        ----------
+        topic : str
+            The topic to publish on.
+        msg : object
+            The message to publish.
+
+        """
+        self.publish_c(topic, msg)
+
+    @cython.boundscheck(False)
+    @cython.wraparound(False)
+    cdef void publish_c(self, str topic, msg: Any):
+        Condition.not_none(topic, "topic")
+        Condition.not_none(msg, "msg")
+
+        # Get all subscriptions matching topic pattern
+        cdef Subscription[:] subs = self._patterns.get(topic)
+        if subs is None:
+            # Add the topic pattern and get matching subscribers
+            subs = self._resolve_subscriptions(topic)
+
+        # Send message to all matched subscribers
+        cdef:
+            int i
+            Subscription sub
+        for i in range(len(subs)):
+            sub = subs[i]
+            sub.handler(msg)
+
+        self.pub_count += 1
+
+    cdef Subscription[:] _resolve_subscriptions(self, str topic):
+        cdef list subs_list = []
+        cdef Subscription existing_sub
+        for existing_sub in self._subscriptions:
+            if is_matching(topic, existing_sub.topic):
+                subs_list.append(existing_sub)
+
+        subs_list = sorted(subs_list, reverse=True)
+        cdef Subscription[:] subs_array = np.ascontiguousarray(subs_list, dtype=Subscription)
+        self._patterns[topic] = subs_array
+
+        cdef list matches
+        for sub in subs_array:
+            matches = self._subscriptions.get(sub, [])
+            if topic not in matches:
+                matches.append(topic)
+            self._subscriptions[sub] = sorted(matches)
+
+        return subs_array
+
+
+cdef inline bint is_matching(str topic, str pattern):
+    # Get length of string and wildcard pattern
+    cdef int n = len(topic)
+    cdef int m = len(pattern)
+
+    # Create a DP lookup table
+    cdef np.ndarray[np.int8_t, ndim=2] t = np.empty((n + 1, m + 1), dtype=np.int8)
+    t.fill(False)
+
+    # If both pattern and string are empty: match
+    t[0, 0] = True
+
+    # Handle empty string case (i == 0)
+    cdef int j
+    for j in range(1, m + 1):
+        if pattern[j - 1] == '*':
+            t[0, j] = t[0, j - 1]
+
+    # Build a matrix in a bottom-up manner
+    cdef int i
+    for i in range(1, n + 1):
+        for j in range(1, m + 1):
+            if pattern[j - 1] == '*':
+                t[i, j] = t[i - 1, j] or t[i, j - 1]
+            elif pattern[j - 1] == '?' or topic[i - 1] == pattern[j - 1]:
+                t[i, j] = t[i - 1, j - 1]
+
+    return t[n, m]
+
+
+# Python wrapper for test access
+def is_matching_py(str topic, str pattern) -> bool:
+    return is_matching(topic, pattern)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/live/execution_engine.py` & `nautilus_trader-1.175.0/nautilus_trader/live/execution_engine.py`

 * *Files 2% similar despite different names*

```diff
@@ -39,23 +39,23 @@
 from nautilus_trader.execution.reports import TradeReport
 from nautilus_trader.model.enums import LiquiditySide
 from nautilus_trader.model.enums import OrderStatus
 from nautilus_trader.model.enums import OrderType
 from nautilus_trader.model.enums import TriggerType
 from nautilus_trader.model.enums import trailing_offset_type_to_str
 from nautilus_trader.model.enums import trigger_type_to_str
-from nautilus_trader.model.events.order import OrderAccepted
-from nautilus_trader.model.events.order import OrderCanceled
-from nautilus_trader.model.events.order import OrderEvent
-from nautilus_trader.model.events.order import OrderExpired
-from nautilus_trader.model.events.order import OrderFilled
-from nautilus_trader.model.events.order import OrderInitialized
-from nautilus_trader.model.events.order import OrderRejected
-from nautilus_trader.model.events.order import OrderTriggered
-from nautilus_trader.model.events.order import OrderUpdated
+from nautilus_trader.model.events import OrderAccepted
+from nautilus_trader.model.events import OrderCanceled
+from nautilus_trader.model.events import OrderEvent
+from nautilus_trader.model.events import OrderExpired
+from nautilus_trader.model.events import OrderFilled
+from nautilus_trader.model.events import OrderInitialized
+from nautilus_trader.model.events import OrderRejected
+from nautilus_trader.model.events import OrderTriggered
+from nautilus_trader.model.events import OrderUpdated
 from nautilus_trader.model.identifiers import ClientOrderId
 from nautilus_trader.model.identifiers import PositionId
 from nautilus_trader.model.identifiers import StrategyId
 from nautilus_trader.model.identifiers import TradeId
 from nautilus_trader.model.instruments import Instrument
 from nautilus_trader.model.objects import Money
 from nautilus_trader.model.objects import Price
@@ -114,15 +114,15 @@
         )
 
         self._loop: asyncio.AbstractEventLoop = loop
         self._cmd_queue: Queue = Queue(maxsize=config.qsize)
         self._evt_queue: Queue = Queue(maxsize=config.qsize)
 
         # Settings
-        self.reconciliation: bool = config.reconciliation
+        self._reconciliation: bool = config.reconciliation
         self.reconciliation_lookback_mins: int = config.reconciliation_lookback_mins or 0
         self.inflight_check_interval_ms: int = config.inflight_check_interval_ms
         self.inflight_check_threshold_ms: int = config.inflight_check_threshold_ms
         self._inflight_check_threshold_ns: int = millis_to_nanos(self.inflight_check_threshold_ms)
 
         # Async tasks
         self._cmd_queue_task: Optional[asyncio.Task] = None
@@ -133,14 +133,26 @@
         # Register endpoints
         self._msgbus.register(endpoint="ExecEngine.reconcile_report", handler=self.reconcile_report)
         self._msgbus.register(
             endpoint="ExecEngine.reconcile_mass_status",
             handler=self.reconcile_mass_status,
         )
 
+    @property
+    def reconciliation(self) -> bool:
+        """
+        Return whether the reconciliation process will be run on start.
+
+        Returns
+        -------
+        bool
+
+        """
+        return self._reconciliation
+
     def connect(self) -> None:
         """
         Connect the engine by calling connect on all registered clients.
         """
         self._log.info("Connecting all clients...")
         for client in self._clients.values():
             client.connect()
@@ -216,19 +228,19 @@
         """
         self._log.warning("Killing engine...")
         self._kill = True
         self.stop()
         if self._cmd_queue_task:
             self._log.debug(f"Canceling {self._cmd_queue_task.get_name()}...")
             self._cmd_queue_task.cancel()
-            self._cmd_queue_task.done()
+            self._cmd_queue_task = None
         if self._evt_queue_task:
             self._log.debug(f"Canceling {self._evt_queue_task.get_name()}...")
             self._evt_queue_task.cancel()
-            self._evt_queue_task.done()
+            self._evt_queue_task = None
 
     def execute(self, command: TradingCommand) -> None:
         """
         Execute the given command.
 
         If the internal queue is already full then will log a warning and block
         until queue size reduces.
@@ -528,14 +540,17 @@
                 client_order_id = self._generate_client_order_id()
             # Assign to report
             report.client_order_id = client_order_id
 
         order: Order = self._cache.order(client_order_id)
         if order is None:
             order = self._generate_external_order(report)
+            if order is None:
+                # External order dropped
+                return True  # No further reconciliation
             # Add to cache without determining any position ID initially
             self._cache.add_order(order, position_id=None)
 
         if report.order_status == OrderStatus.REJECTED:
             if order.status != OrderStatus.REJECTED:
                 self._generate_order_rejected(order, report)
             return True  # Reconciled
@@ -745,15 +760,15 @@
             ts_init=self._clock.timestamp_ns(),
             reconciliation=True,
         )
 
         self._log.warning(f"Generated inferred {filled}.")
         return filled
 
-    def _generate_external_order(self, report: OrderStatusReport) -> Order:
+    def _generate_external_order(self, report: OrderStatusReport) -> Optional[Order]:
         self._log.info(
             f"Generating external order {report.client_order_id!r}",
             color=LogColor.BLUE,
         )
 
         # Prepare order options
         options: dict[str, Any] = {}
@@ -782,27 +797,38 @@
         strategy_id = self.get_external_order_claim(report.instrument_id)
         if strategy_id is None:
             strategy_id = StrategyId("EXTERNAL")
             tags = "EXTERNAL"
         else:
             tags = None
 
+        # Check if filtering
+        if self.filter_unclaimed_external_orders:
+            if strategy_id.value == "EXTERNAL":
+                # Experimental: will call this out with a warning log for now
+                self._log.warning(
+                    f"Filtering report for unclaimed EXTERNAL order, {report}.",
+                )
+                return None  # No further reconciliation
+
         initialized = OrderInitialized(
             trader_id=self.trader_id,
             strategy_id=strategy_id,
             instrument_id=report.instrument_id,
             client_order_id=report.client_order_id,
             order_side=report.order_side,
             order_type=report.order_type,
             quantity=report.quantity,
             time_in_force=report.time_in_force,
             post_only=report.post_only,
             reduce_only=report.reduce_only,
+            quote_quantity=False,
             options=options,
             emulation_trigger=TriggerType.NO_TRIGGER,
+            trigger_instrument_id=None,
             contingency_type=report.contingency_type,
             order_list_id=report.order_list_id,
             linked_order_ids=None,
             parent_order_id=None,
             exec_algorithm_id=None,
             exec_algorithm_params=None,
             exec_spawn_id=None,
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/live/factories.py` & `nautilus_trader-1.175.0/nautilus_trader/live/factories.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/live/node.py` & `nautilus_trader-1.175.0/nautilus_trader/live/node.py`

 * *Files 10% similar despite different names*

```diff
@@ -38,40 +38,46 @@
     """
     Provides an asynchronous network node for live trading.
 
     Parameters
     ----------
     config : TradingNodeConfig, optional
         The configuration for the instance.
+    loop : asyncio.AbstractEventLoop, optional
+        The event loop for the node.
+        If ``None`` then will get the running event loop internally.
     """
 
-    def __init__(self, config: Optional[TradingNodeConfig] = None) -> None:
+    def __init__(
+        self,
+        config: Optional[TradingNodeConfig] = None,
+        loop: Optional[asyncio.AbstractEventLoop] = None,
+    ) -> None:
         if config is None:
             config = TradingNodeConfig()
         PyCondition.not_none(config, "config")
         PyCondition.type(config, TradingNodeConfig, "config")
 
-        # Configuration
         self._config: TradingNodeConfig = config
 
-        # Setup loop
-        loop = asyncio.get_event_loop()
+        # Determine loop
+        loop = loop or asyncio.get_event_loop()
 
-        # Build core system kernel
         self.kernel = NautilusKernel(
             name=type(self).__name__,
             config=config,
             loop=loop,
             loop_sig_callback=self._loop_sig_handler,
         )
 
         self._builder = TradingNodeBuilder(
             loop=loop,
             data_engine=self.kernel.data_engine,
             exec_engine=self.kernel.exec_engine,
+            portfolio=self.kernel.portfolio,
             msgbus=self.kernel.msgbus,
             cache=self.kernel.cache,
             clock=self.kernel.clock,
             logger=self.kernel.logger,
             log=self.kernel.log,
         )
 
@@ -373,81 +379,16 @@
         try:
             if not self._is_built:
                 raise RuntimeError(
                     "The trading nodes clients have not been built. "
                     "Run `node.build()` prior to start.",
                 )
 
-            self.kernel.log.info("STARTING...")
             self._is_running = True
-
-            # Start system
-            self.kernel.data_engine.start()
-            self.kernel.risk_engine.start()
-            self.kernel.exec_engine.start()
-
-            # Connect all clients
-            self.kernel.data_engine.connect()
-            self.kernel.exec_engine.connect()
-
-            # Await engine connection and initialization
-            self.kernel.log.info(
-                f"Awaiting engine connections and initializations "
-                f"({self._config.timeout_connection}s timeout)...",
-                color=LogColor.BLUE,
-            )
-            if not await self._await_engines_connected():
-                self.kernel.log.warning(
-                    f"Timed out ({self._config.timeout_connection}s) waiting for engines to connect and initialize."
-                    f"\nStatus"
-                    f"\n------"
-                    f"\nDataEngine.check_connected() == {self.kernel.data_engine.check_connected()}"
-                    f"\nExecEngine.check_connected() == {self.kernel.exec_engine.check_connected()}",
-                )
-                return
-
-            # Await execution state reconciliation
-            self.kernel.log.info(
-                f"Awaiting execution state reconciliation "
-                f"({self._config.timeout_reconciliation}s timeout)...",
-                color=LogColor.BLUE,
-            )
-            if not await self.kernel.exec_engine.reconcile_state(
-                timeout_secs=self._config.timeout_reconciliation,
-            ):
-                self.kernel.log.error("Execution state could not be reconciled.")
-                return
-
-            if self.kernel.exec_engine.reconciliation:
-                self.kernel.log.info("State reconciled.", color=LogColor.GREEN)
-
-            self.kernel.emulator.start()
-
-            # Initialize portfolio
-            self.kernel.portfolio.initialize_orders()
-            self.kernel.portfolio.initialize_positions()
-
-            # Await portfolio initialization
-            self.kernel.log.info(
-                "Awaiting portfolio initialization "
-                f"({self._config.timeout_portfolio}s timeout)...",
-                color=LogColor.BLUE,
-            )
-            if not await self._await_portfolio_initialized():
-                self.kernel.log.warning(
-                    f"Timed out ({self._config.timeout_portfolio}s) waiting for portfolio to initialize."
-                    f"\nStatus"
-                    f"\n------"
-                    f"\nPortfolio.initialized == {self.kernel.portfolio.initialized}",
-                )
-                return
-            self.kernel.log.info("Portfolio initialized.", color=LogColor.GREEN)
-
-            # Start trader and strategies
-            self.kernel.trader.start()
+            await self.kernel.start()
 
             if self.kernel.loop.is_running():
                 self.kernel.log.info("RUNNING.")
             else:
                 self.kernel.log.warning("Event loop is not running.")
 
             # Continue to run while engines are running...
@@ -461,51 +402,14 @@
                 self.kernel.exec_engine.get_cmd_queue_task(),
                 self.kernel.exec_engine.get_evt_queue_task(),
             ]
             await asyncio.gather(*tasks)
         except asyncio.CancelledError as e:
             self.kernel.log.error(str(e))
 
-    async def _await_engines_connected(self) -> bool:
-        # - The data engine clients will be set connected when all
-        # instruments are received and updated with the data engine.
-        # - The execution engine clients will be set connected when all
-        # accounts are updated and the current order and position status is
-        # reconciled.
-        # Thus any delay here will be due to blocking network I/O.
-        seconds = self._config.timeout_connection
-        timeout: timedelta = self.kernel.clock.utc_now() + timedelta(seconds=seconds)
-        while True:
-            await asyncio.sleep(0)
-            if self.kernel.clock.utc_now() >= timeout:
-                return False
-            if not self.kernel.data_engine.check_connected():
-                continue
-            if not self.kernel.exec_engine.check_connected():
-                continue
-            break
-
-        return True  # Engines connected
-
-    async def _await_portfolio_initialized(self) -> bool:
-        # - The portfolio will be set initialized when all margin and unrealized
-        # PnL calculations are completed (maybe waiting on first quotes).
-        # Thus any delay here will be due to blocking network I/O.
-        seconds = self._config.timeout_portfolio
-        timeout: timedelta = self.kernel.clock.utc_now() + timedelta(seconds=seconds)
-        while True:
-            await asyncio.sleep(0)
-            if self.kernel.clock.utc_now() >= timeout:
-                return False
-            if not self.kernel.portfolio.initialized:
-                continue
-            break
-
-        return True  # Portfolio initialized
-
     async def stop_async(self) -> None:
         """
         Stop the trading node gracefully, asynchronously.
 
         After a specified delay the internal `Trader` residual state will be checked.
 
         If save strategy is configured, then strategy states will be saved.
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/live/node_builder.py` & `nautilus_trader-1.175.0/nautilus_trader/live/node_builder.py`

 * *Files 2% similar despite different names*

```diff
@@ -25,28 +25,31 @@
 from nautilus_trader.core.correctness import PyCondition
 from nautilus_trader.live.data_engine import LiveDataEngine
 from nautilus_trader.live.execution_engine import LiveExecutionEngine
 from nautilus_trader.live.factories import LiveDataClientFactory
 from nautilus_trader.live.factories import LiveExecClientFactory
 from nautilus_trader.model.identifiers import Venue
 from nautilus_trader.msgbus.bus import MessageBus
+from nautilus_trader.portfolio.portfolio import Portfolio
 
 
 class TradingNodeBuilder:
     """
     Provides building services for a trading node.
 
     Parameters
     ----------
     loop : asyncio.AbstractEventLoop
         The event loop for the clients.
     data_engine : LiveDataEngine
         The data engine for the trading node.
     exec_engine : LiveExecutionEngine
         The execution engine for the trading node.
+    portfolio : Portfolio
+        The portfolio for the trading node.
     msgbus : MessageBus
         The message bus for the trading node.
     cache : Cache
         The cache for building clients.
     clock : LiveClock
         The clock for building clients.
     logger : Logger
@@ -56,14 +59,15 @@
     """
 
     def __init__(
         self,
         loop: asyncio.AbstractEventLoop,
         data_engine: LiveDataEngine,
         exec_engine: LiveExecutionEngine,
+        portfolio: Portfolio,
         msgbus: MessageBus,
         cache: Cache,
         clock: LiveClock,
         logger: Logger,
         log: LoggerAdapter,
     ) -> None:
         self._msgbus = msgbus
@@ -71,14 +75,15 @@
         self._clock = clock
         self._logger = logger
         self._log = log
 
         self._loop = loop
         self._data_engine = data_engine
         self._exec_engine = exec_engine
+        self._portfolio = portfolio
 
         self._data_factories: dict[str, type[LiveDataClientFactory]] = {}
         self._exec_factories: dict[str, type[LiveExecClientFactory]] = {}
 
     def add_data_client_factory(self, name: str, factory: type[LiveDataClientFactory]) -> None:
         """
         Add the given data client factory to the builder.
@@ -184,14 +189,18 @@
             # Venue routing config
             venues: frozenset[str] = client_config.routing.venues or frozenset()
             for venue in venues:
                 if not isinstance(venue, Venue):
                     venue = Venue(venue)
                 self._data_engine.register_venue_routing(client, venue)
 
+            # Temporary handling for setting specific 'venue' for portfolio
+            if name == "InteractiveBrokers":
+                self._portfolio.set_specific_venue(Venue("InteractiveBrokers"))
+
     def build_exec_clients(
         self,
         config: dict[str, LiveExecClientConfig],
     ) -> None:
         """
         Build the execution clients with the given configuration.
 
@@ -234,7 +243,11 @@
 
             # Venue routing config
             venues: frozenset[str] = client_config.routing.venues or frozenset()
             for venue in venues:
                 if not isinstance(venue, Venue):
                     venue = Venue(venue)
                 self._exec_engine.register_venue_routing(client, venue)
+
+            # Temporary handling for setting specific 'venue' for portfolio
+            if name == "InteractiveBrokers":
+                self._portfolio.set_specific_venue(Venue("InteractiveBrokers"))
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/live/risk_engine.py` & `nautilus_trader-1.175.0/nautilus_trader/live/risk_engine.py`

 * *Files 0% similar despite different names*

```diff
@@ -141,19 +141,19 @@
         """
         self._log.warning("Killing engine...")
         self._kill = True
         self.stop()
         if self._cmd_queue_task:
             self._log.debug(f"Canceling {self._cmd_queue_task.get_name()}...")
             self._cmd_queue_task.cancel()
-            self._cmd_queue_task.done()
+            self._cmd_queue_task = None
         if self._evt_queue_task:
             self._log.debug(f"Canceling {self._evt_queue_task.get_name()}...")
             self._evt_queue_task.cancel()
-            self._evt_queue_task.done()
+            self._evt_queue_task = None
 
     def execute(self, command: Command) -> None:
         """
         Execute the given command.
 
         If the internal queue is already full then will log a warning and block
         until queue size reduces.
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/__init__.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/__init__.pxd`

 * *Files 0% similar despite different names*

```diff
@@ -18,15 +18,14 @@
 from nautilus_trader.core.rust.model cimport AggressorSide
 from nautilus_trader.core.rust.model cimport AssetClass
 from nautilus_trader.core.rust.model cimport AssetType
 from nautilus_trader.core.rust.model cimport BookAction
 from nautilus_trader.core.rust.model cimport BookType
 from nautilus_trader.core.rust.model cimport ContingencyType
 from nautilus_trader.core.rust.model cimport CurrencyType
-from nautilus_trader.core.rust.model cimport DepthType
 from nautilus_trader.core.rust.model cimport InstrumentCloseType
 from nautilus_trader.core.rust.model cimport LiquiditySide
 from nautilus_trader.core.rust.model cimport MarketStatus
 from nautilus_trader.core.rust.model cimport OmsType
 from nautilus_trader.core.rust.model cimport OptionKind
 from nautilus_trader.core.rust.model cimport OrderSide
 from nautilus_trader.core.rust.model cimport OrderStatus
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/instruments.py`

 * *Files 16% similar despite different names*

```diff
@@ -9,14 +9,13 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-"""
-The `model` subpackage defines a rich trading domain model.
+from nautilus_trader.model.instruments import Instrument
+from nautilus_trader.serialization.arrow.serializer import register_parquet
 
-The domain model is agnostic of any system design, seeking to represent the logic
-and state transitions of trading in a generic way. Many system implementations could
-be built around this domain model.
-"""
+
+for cls in Instrument.__subclasses__():
+    register_parquet(cls, partition_keys=())
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/currencies.pxd` & `nautilus_trader-1.175.0/nautilus_trader/portfolio/__init__.py`

 * *Files 9% similar despite different names*

```diff
@@ -9,8 +9,8 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-cdef dict _CURRENCY_MAP
+"""The `portfolio` subpackage provides portfolio management functionality."""
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/currency.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/currency.pxd`

 * *Files 12% similar despite different names*

```diff
@@ -23,14 +23,17 @@
 
     cdef uint8_t get_precision(self)
 
     @staticmethod
     cdef void register_c(Currency currency, bint overwrite=*)
 
     @staticmethod
+    cdef Currency from_internal_map_c(str code)
+
+    @staticmethod
     cdef Currency from_str_c(str code, bint strict=*)
 
     @staticmethod
     cdef bint is_fiat_c(str code)
 
     @staticmethod
     cdef bint is_crypto_c(str code)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/currency.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/currency.pyx`

 * *Files 16% similar despite different names*

```diff
@@ -13,39 +13,42 @@
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from libc.stdint cimport uint8_t
 from libc.stdint cimport uint16_t
 
 from nautilus_trader.core.correctness cimport Condition
+from nautilus_trader.core.rust.model cimport currency_clone
 from nautilus_trader.core.rust.model cimport currency_code_to_cstr
 from nautilus_trader.core.rust.model cimport currency_drop
 from nautilus_trader.core.rust.model cimport currency_eq
+from nautilus_trader.core.rust.model cimport currency_exists
+from nautilus_trader.core.rust.model cimport currency_from_cstr
 from nautilus_trader.core.rust.model cimport currency_from_py
 from nautilus_trader.core.rust.model cimport currency_hash
 from nautilus_trader.core.rust.model cimport currency_name_to_cstr
+from nautilus_trader.core.rust.model cimport currency_register
 from nautilus_trader.core.rust.model cimport currency_to_cstr
 from nautilus_trader.core.string cimport cstr_to_pystr
 from nautilus_trader.core.string cimport pystr_to_cstr
-from nautilus_trader.model.currencies cimport _CURRENCY_MAP
 from nautilus_trader.model.enums_c cimport CurrencyType
 
 
 cdef class Currency:
     """
     Represents a medium of exchange in a specified denomination with a fixed
     decimal precision.
 
     Handles up to 9 decimals of precision.
 
     Parameters
     ----------
     code : str
         The currency code.
-    precision : uint8
+    precision : uint8_t
         The currency decimal precision.
     iso4217 : uint16
         The currency ISO 4217 code.
     name : str
         The currency name.
     currency_type : CurrencyType
         The currency type.
@@ -177,36 +180,64 @@
         return <CurrencyType>self._mem.currency_type
 
     cdef uint8_t get_precision(self):
         return self._mem.precision
 
     @staticmethod
     cdef void register_c(Currency currency, bint overwrite=False):
-        if not overwrite and currency.code in _CURRENCY_MAP:
-            return
-        _CURRENCY_MAP[currency.code] = currency
+        cdef Currency existing = Currency.from_internal_map_c(currency.code)
+        if existing is not None and not overwrite:
+            return  # Already exists in internal map
+        currency_register(currency_clone(&currency._mem))
+
+    @staticmethod
+    cdef Currency from_internal_map_c(str code):
+        cdef const char* code_ptr = pystr_to_cstr(code)
+        if not currency_exists(code_ptr):
+            return None
+        cdef Currency currency = Currency.__new__(Currency)
+        currency._mem = currency_from_cstr(code_ptr)
+        return currency
 
     @staticmethod
     cdef Currency from_str_c(str code, bint strict=False):
-        cdef Currency currency = _CURRENCY_MAP.get(code)
-        if strict or currency is not None:
+        cdef Currency currency = Currency.from_internal_map_c(code)
+        if currency is not None:
             return currency
+        if strict:
+            return None
 
         # Strict mode false with no currency found (very likely a crypto)
         currency = Currency(
             code=code,
             precision=8,
             iso4217=0,
             name=code,
             currency_type=CurrencyType.CRYPTO,
         )
         print(f"Currency '{code}' not found, created {repr(currency)}")
         return currency
 
     @staticmethod
+    cdef bint is_fiat_c(str code):
+        cdef Currency currency = Currency.from_internal_map_c(code)
+        if currency is None:
+            return False
+
+        return <CurrencyType>currency._mem.currency_type == CurrencyType.FIAT
+
+    @staticmethod
+    cdef bint is_crypto_c(str code):
+        cdef Currency currency = Currency.from_internal_map_c(code)
+        if currency is None:
+            return False
+
+        return <CurrencyType>currency._mem.currency_type == CurrencyType.CRYPTO
+
+    @staticmethod
     def register(Currency currency, bint overwrite=False):
         """
         Register the given `currency`.
 
         Will override the internal currency map.
 
         Parameters
@@ -218,52 +249,54 @@
 
         """
         Condition.not_none(currency, "currency")
 
         return Currency.register_c(currency, overwrite)
 
     @staticmethod
+    def from_internal_map(str code):
+        """
+        Return the currency with the given `code` from the built-in internal map (if found).
+
+        Parameters
+        ----------
+        code : str
+            The code of the currency.
+
+        Returns
+        -------
+        Currency or ``None``
+
+        """
+        Condition.not_none(code, "code")
+
+        return Currency.from_internal_map_c(code)
+
+    @staticmethod
     def from_str(str code, bint strict=False):
         """
         Parse a currency from the given string (if found).
 
         Parameters
         ----------
         code : str
             The code of the currency.
         strict : bool, default False
             If not `strict` mode then an unknown currency will very likely
             be a Cryptocurrency, so for robustness will then return a new
-            `Currency` object using the given `code` with a default `precision`
-            of 8.
+            `Currency` object using the given `code` with a default `precision` of 8.
 
         Returns
         -------
         Currency or ``None``
 
         """
         return Currency.from_str_c(code, strict)
 
     @staticmethod
-    cdef bint is_fiat_c(str code):
-        cdef Currency currency = _CURRENCY_MAP.get(code)
-        if currency is None:
-            return False
-
-        return <CurrencyType>currency._mem.currency_type == CurrencyType.FIAT
-
-    @staticmethod
-    cdef bint is_crypto_c(str code):
-        cdef Currency currency = _CURRENCY_MAP.get(code)
-        if currency is None:
-            return False
-
-        return <CurrencyType>currency._mem.currency_type == CurrencyType.CRYPTO
-
-    @staticmethod
     def is_fiat(str code):
         """
         Return whether a currency with the given code is ``FIAT``.
 
         Parameters
         ----------
         code : str
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/data/__init__.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/data/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/data/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/persistence/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -9,8 +9,8 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-"""Defines the fundamental data types represented within the trading domain."""
+"""The `persistence` subpackage handles data storage and retrieval, mainly to support backtesting."""
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/data/bar.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/data/bar.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/data/bar.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/data/bar.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -696,15 +696,14 @@
         bint is_revision = False,
     ):
         Condition.true(high._mem.raw >= open._mem.raw, "high was < open")
         Condition.true(high._mem.raw >= low._mem.raw, "high was < low")
         Condition.true(high._mem.raw >= close._mem.raw, "high was < close")
         Condition.true(low._mem.raw <= close._mem.raw, "low was > close")
         Condition.true(low._mem.raw <= open._mem.raw, "low was > open")
-        super().__init__(ts_event, ts_init)
 
         self._mem = bar_new(
             bar_type_clone(&bar_type._mem),
             open._mem,
             high._mem,
             low._mem,
             close._mem,
@@ -751,16 +750,14 @@
             state[8],
             state[9],
             state[10],
             state[11],
             state[12],
             state[13],
         )
-        self.ts_event = state[12]
-        self.ts_init = state[13]
 
     def __del__(self) -> None:
         if self._mem.bar_type.instrument_id.symbol.value != NULL:
             bar_drop(self._mem)  # `self._mem` moved to Rust (then dropped)
 
     def __eq__(self, Bar other) -> bool:
         return bar_eq(&self._mem, &other._mem)
@@ -874,14 +871,38 @@
         Returns
         -------
         Quantity
 
         """
         return Quantity.from_raw_c(self._mem.volume.raw, self._mem.volume.precision)
 
+    @property
+    def ts_event(self) -> int:
+        """
+        The UNIX timestamp (nanoseconds) when the data event occurred.
+
+        Returns
+        -------
+        int
+
+        """
+        return self._mem.ts_event
+
+    @property
+    def ts_init(self) -> int:
+        """
+        The UNIX timestamp (nanoseconds) when the object was initialized.
+
+        Returns
+        -------
+        int
+
+        """
+        return self._mem.ts_init
+
     @staticmethod
     def from_dict(dict values) -> Bar:
         """
         Return a bar parsed from the given values.
 
         Parameters
         ----------
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/data/bar_aggregation.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/data/bar_aggregation.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/data/bar_aggregation.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/data/bar_aggregation.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/data/base.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/data/base.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/data/base.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/data/base.pyx`

 * *Files 13% similar despite different names*

```diff
@@ -91,13 +91,36 @@
     """
 
     def __init__(
         self,
         DataType data_type not None,
         Data data not None,
     ):
-        super().__init__(data.ts_event, data.ts_init)
         self.data_type = data_type
         self.data = data
 
     def __repr__(self) -> str:
         return f"{type(self).__name__}(data_type={self.data_type}, data={self.data})"
+
+    @property
+    def ts_event(self) -> int:
+        """
+        The UNIX timestamp (nanoseconds) when the data event occurred.
+
+        Returns
+        -------
+        int
+
+        """
+        return self.data.ts_event
+
+    @property
+    def ts_init(self) -> int:
+        """
+        The UNIX timestamp (nanoseconds) when the object was initialized.
+
+        Returns
+        -------
+        int
+
+        """
+        return self.data.ts_init
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/data/bet.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/orderbook/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -9,29 +9,23 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.model.enums_c cimport OrderSide
-from nautilus_trader.model.objects cimport Price
-from nautilus_trader.model.objects cimport Quantity
-
-
-cdef class Bet:
-    cdef Price price
-    cdef Quantity quantity
-    cdef OrderSide side
-
-    cpdef stake(self)
-    cpdef liability(self)
-    cpdef cost(self)
-    cpdef win_payoff(self)
-    cpdef lose_payoff(self)
-    cpdef exposure(self)
-
-    @staticmethod
-    cdef Bet from_dict_c(dict values)
-
-    @staticmethod
-    cdef dict to_dict_c(Bet obj)
+"""
+Defines real-time and simulated order book components and data.
+"""
+
+from nautilus_trader.model.data.book import BookOrder
+from nautilus_trader.model.data.book import OrderBookDelta
+from nautilus_trader.model.data.book import OrderBookDeltas
+from nautilus_trader.model.orderbook.book import OrderBook
+
+
+__all__ = [
+    "BookOrder",
+    "OrderBookDelta",
+    "OrderBookDeltas",
+    "OrderBook",
+]
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/data/book.pxd` & `nautilus_trader-1.175.0/nautilus_trader/accounting/accounts/betting.pyx`

 * *Files 27% similar despite different names*

```diff
@@ -9,93 +9,92 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from libc.stdint cimport uint64_t
+from decimal import Decimal
 
-from nautilus_trader.core.data cimport Data
-from nautilus_trader.model.data.book cimport OrderBookDelta
-from nautilus_trader.model.data.book cimport OrderBookDeltas
-from nautilus_trader.model.data.book cimport OrderBookSnapshot
-from nautilus_trader.model.enums_c cimport BookAction
-from nautilus_trader.model.enums_c cimport BookType
+from nautilus_trader.accounting.accounts.cash cimport CashAccount
+from nautilus_trader.core.correctness cimport Condition
+from nautilus_trader.model.enums_c cimport AccountType
 from nautilus_trader.model.enums_c cimport OrderSide
-from nautilus_trader.model.enums_c cimport TimeInForce
-from nautilus_trader.model.identifiers cimport InstrumentId
+from nautilus_trader.model.instruments.base cimport Instrument
+from nautilus_trader.model.objects cimport Money
+from nautilus_trader.model.objects cimport Price
+from nautilus_trader.model.objects cimport Quantity
+
+
+cdef class BettingAccount(CashAccount):
+    """
+    Provides a betting account.
+    """
+    ACCOUNT_TYPE = AccountType.BETTING
+
+# -- CALCULATIONS ---------------------------------------------------------------------------------
+
+    cpdef Money calculate_balance_locked(
+        self,
+        Instrument instrument,
+        OrderSide side,
+        Quantity quantity,
+        Price price,
+        bint use_quote_for_inverse=False,
+    ):
+        """
+        Calculate the locked balance.
+
+        Parameters
+        ----------
+        instrument : Instrument
+            The instrument for the calculation.
+        side : OrderSide {``BUY``, ``SELL``}
+            The order side.
+        quantity : Quantity
+            The order quantity.
+        price : Price
+            The order price.
+        use_quote_for_inverse : bool
+            Not applicable for betting accounts.
+
+        Returns
+        -------
+        Money
+
+        """
+        Condition.not_none(instrument, "instrument")
+        Condition.not_none(quantity, "quantity")
+        Condition.not_none(price, "price")
+        Condition.not_equal(use_quote_for_inverse, True, "use_quote_for_inverse", "True")
+
+        locked: Decimal = liability(quantity, price, side)
+        return Money(locked, instrument.quote_currency)
+
+
+cpdef stake(Quantity quantity, Price price):
+    return quantity * (price - 1)
+
+
+cpdef liability(Quantity quantity, Price price, OrderSide side):
+    if side == OrderSide.BUY:
+        return quantity
+    elif side == OrderSide.SELL:
+        return stake(quantity, price)
+
+
+cpdef win_payoff(Quantity quantity, Price price, OrderSide side):
+    if side == OrderSide.BUY:
+        return stake(quantity, price)
+    elif side == OrderSide.SELL:
+        return -stake(quantity, price)
+
+
+cpdef lose_payoff(Quantity quantity, OrderSide side):
+    if side == OrderSide.BUY:
+        return -quantity
+    elif side == OrderSide.SELL:
+        return quantity
 
 
-cdef tuple ORDER_BOOK_DATA
-
-
-cdef class BookOrder:
-    cdef readonly double price
-    """The orders price.\n\n:returns: `double`"""
-    cdef readonly double size
-    """The orders size.\n\n:returns: `double`"""
-    cdef readonly OrderSide side
-    """The orders side.\n\n:returns: `OrderSide`"""
-    cdef readonly str order_id
-    """The orders ID.\n\n:returns: `str`"""
-
-    cpdef void update_price(self, double price)
-    cpdef void update_size(self, double size)
-    cpdef void update_order_id(self, str value)
-    cpdef double exposure(self)
-    cpdef double signed_size(self)
-
-    @staticmethod
-    cdef BookOrder from_dict_c(dict values)
-
-    @staticmethod
-    cdef dict to_dict_c(BookOrder obj)
-
-
-cdef class OrderBookDelta(Data):
-    cdef readonly InstrumentId instrument_id
-    """The instrument ID for the order book.\n\n:returns: `InstrumentId`"""
-    cdef readonly BookAction action
-    """The order book delta action {``ADD``, ``UPDATED``, ``DELETE``, ``CLEAR``}.\n\n:returns: `BookAction`"""
-    cdef readonly BookOrder order
-    """The order to apply.\n\n:returns: `Order`"""
-    cdef readonly uint64_t sequence
-    """The unique sequence number.\n\n:returns: `uint64`"""
-
-    @staticmethod
-    cdef OrderBookDelta from_dict_c(dict values)
-
-    @staticmethod
-    cdef dict to_dict_c(OrderBookDelta obj)
-
-
-cdef class OrderBookDeltas(Data):
-    cdef readonly InstrumentId instrument_id
-    """The instrument ID for the order book.\n\n:returns: `InstrumentId`"""
-    cdef readonly uint64_t sequence
-    """The unique sequence number.\n\n:returns: `uint64`"""
-    cdef readonly list deltas
-    """The order book deltas.\n\n:returns: `list[OrderBookDelta]`"""
-
-    @staticmethod
-    cdef OrderBookDeltas from_dict_c(dict values)
-
-    @staticmethod
-    cdef dict to_dict_c(OrderBookDeltas obj)
-
-
-cdef class OrderBookSnapshot(Data):
-    cdef readonly InstrumentId instrument_id
-    """The instrument ID for the order book.\n\n:returns: `InstrumentId`"""
-    cdef readonly uint64_t sequence
-    """The unique sequence number.\n\n:returns: `uint64`"""
-    cdef readonly list bids
-    """The snapshot bids.\n\n:returns: `list`"""
-    cdef readonly list asks
-    """The snapshot asks.\n\n:returns: `list`"""
-
-    @staticmethod
-    cdef OrderBookSnapshot from_dict_c(dict values)
-
-    @staticmethod
-    cdef dict to_dict_c(OrderBookSnapshot obj)
+cpdef exposure(Quantity quantity, Price price, OrderSide side):
+    return win_payoff(quantity, price, side) - lose_payoff(quantity, side)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/data/book.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/data/book.pyx`

 * *Files 13% similar despite different names*

```diff
@@ -9,153 +9,185 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from libc.stdint cimport uint8_t
 from libc.stdint cimport uint64_t
 
 import uuid
 
 import msgspec
 
 from nautilus_trader.core.correctness cimport Condition
 from nautilus_trader.core.data cimport Data
+from nautilus_trader.core.rust.model cimport book_order_debug_to_cstr
+from nautilus_trader.core.rust.model cimport book_order_eq
+from nautilus_trader.core.rust.model cimport book_order_exposure
+from nautilus_trader.core.rust.model cimport book_order_from_raw
+from nautilus_trader.core.rust.model cimport book_order_hash
+from nautilus_trader.core.rust.model cimport book_order_signed_size
+from nautilus_trader.core.rust.model cimport instrument_id_clone
+from nautilus_trader.core.rust.model cimport orderbook_delta_clone
+from nautilus_trader.core.rust.model cimport orderbook_delta_drop
+from nautilus_trader.core.rust.model cimport orderbook_delta_eq
+from nautilus_trader.core.rust.model cimport orderbook_delta_hash
+from nautilus_trader.core.rust.model cimport orderbook_delta_new
+from nautilus_trader.core.string cimport cstr_to_pystr
 from nautilus_trader.model.enums_c cimport BookAction
 from nautilus_trader.model.enums_c cimport BookType
 from nautilus_trader.model.enums_c cimport OrderSide
 from nautilus_trader.model.enums_c cimport book_action_from_str
 from nautilus_trader.model.enums_c cimport book_action_to_str
 from nautilus_trader.model.enums_c cimport book_type_from_str
 from nautilus_trader.model.enums_c cimport book_type_to_str
 from nautilus_trader.model.enums_c cimport order_side_from_str
 from nautilus_trader.model.enums_c cimport order_side_to_str
-
-
-ORDER_BOOK_DATA = (OrderBookSnapshot, OrderBookDeltas, OrderBookDelta)
+from nautilus_trader.model.objects cimport Price
+from nautilus_trader.model.objects cimport Quantity
 
 
 cdef class BookOrder:
     """
     Represents an order in a book.
 
     Parameters
     ----------
-    price : double
-        The order price.
-    size : double
-        The order size.
     side : OrderSide {``BUY``, ``SELL``}
         The order side.
-    id : str
+    price : Price
+        The order price.
+    size : Quantity
+        The order size.
+    order_id : uint64_t
         The order ID.
     """
 
     def __init__(
         self,
-        double price,
-        double size,
         OrderSide side,
-        str order_id = None,
+        Price price,
+        Quantity size,
+        uint64_t order_id,
     ):
-        self.price = price
-        self.size = size
-        self.side = side
-        self.order_id = order_id or str(uuid.uuid4())
+        self._mem = book_order_from_raw(
+            side,
+            price._mem.raw,
+            price._mem.precision,
+            size._mem.raw,
+            size._mem.precision,
+            order_id,
+        )
 
     def __eq__(self, BookOrder other) -> bool:
-        return self.order_id == other.order_id
+        return book_order_eq(&self._mem, &other._mem)
 
     def __hash__(self) -> int:
-        return hash(frozenset(BookOrder.to_dict_c(self)))
+        return book_order_hash(&self._mem)
 
     def __repr__(self) -> str:
-        return f"{BookOrder.__name__}({self.price}, {self.size}, {order_side_to_str(self.side)}, {self.order_id})"
+        return cstr_to_pystr(book_order_debug_to_cstr(&self._mem))
 
-    cpdef void update_price(self, double price):
+    @staticmethod
+    cdef BookOrder from_mem_c(BookOrder_t mem):
+        cdef BookOrder order = BookOrder.__new__(BookOrder)
+        order._mem = mem
+        return order
+
+    @property
+    def price(self) -> Price:
         """
-        Update the orders price.
+        Return the book orders price.
 
-        Parameters
-        ----------
-        price : double
-            The updated price.
+        Returns
+        -------
+        Price
 
         """
-        self.price = price
+        return Price.from_raw_c(self._mem.price.raw, self._mem.price.precision)
 
-    cpdef void update_size(self, double size):
+    @property
+    def size(self) -> Price:
         """
-        Update the orders size.
+        Return the book orders size.
 
-        Parameters
-        ----------
-        size : double
-            The updated size.
+        Returns
+        -------
+        Quantity
 
         """
-        self.size = size
+        return Quantity.from_raw_c(self._mem.size.raw, self._mem.size.precision)
 
-    cpdef void update_order_id(self, str value):
+    @property
+    def side(self) -> OrderSide:
         """
-        Update the orders ID.
+        Return the book orders side.
 
-        Parameters
-        ----------
-        value : str
-            The updated order ID.
+        Returns
+        -------
+        OrderSide
+
+        """
+        return <OrderSide>self._mem.side
+
+    @property
+    def order_id(self) -> uint64_t:
+        """
+        Return the book orders side.
+
+        Returns
+        -------
+        uint64_t
 
         """
-        self.order_id = value
+        return self._mem.order_id
 
     cpdef double exposure(self):
         """
         Return the total exposure for this order (price * size).
 
         Returns
         -------
         double
 
         """
-        return self.price * self.size
+        return book_order_exposure(&self._mem)
 
     cpdef double signed_size(self):
         """
         Return the signed size of the order (negative for ``SELL``).
 
         Returns
         -------
         double
 
         """
-        if self.side == OrderSide.BUY:
-            return self.size * 1.0
-        else:
-            return self.size * -1.0
+        return book_order_signed_size(&self._mem)
 
     @staticmethod
     cdef BookOrder from_dict_c(dict values):
         Condition.not_none(values, "values")
         return BookOrder(
-            price=values["price"],
-            size=values["size"],
             side=order_side_from_str(values["side"]),
+            price=Price.from_str(values["price"]),
+            size=Quantity.from_str(values["size"]),
             order_id=values["order_id"],
         )
 
     @staticmethod
     cdef dict to_dict_c(BookOrder obj):
         Condition.not_none(obj, "obj")
         return {
             "type": "BookOrder",
-            "price": obj.price,
-            "size": obj.size,
             "side": order_side_to_str(obj.side),
-            "order_id": str(obj.order_id),
+            "price": str(obj.price),
+            "size": str(obj.size),
+            "order_id": obj.order_id,
         }
 
     @staticmethod
     def from_dict(dict values) -> BookOrder:
         """
         Return an order from the given dict values.
 
@@ -188,95 +220,265 @@
     """
     Represents a single difference on an `OrderBook`.
 
     Parameters
     ----------
     instrument_id : InstrumentId
         The instrument ID for the book.
-    action : BookAction {``ADD``, ``UPDATED``, ``DELETE``, ``CLEAR``}
+    action : BookAction {``ADD``, ``UPDATE``, ``DELETE``, ``CLEAR``}
         The order book delta action.
     order : Order
         The order to apply.
     ts_event : uint64_t
         The UNIX timestamp (nanoseconds) when the data event occurred.
     ts_init : uint64_t
         The UNIX timestamp (nanoseconds) when the data object was initialized.
-    sequence : uint64, default 0
+    sequence : uint64_t, default 0
+        The unique sequence number for the update. If default 0 then will increment the `sequence`.
+    flags : uint8_t, default 0
         The unique sequence number for the update. If default 0 then will increment the `sequence`.
     """
 
     def __init__(
         self,
         InstrumentId instrument_id not None,
         BookAction action,
         BookOrder order,
         uint64_t ts_event,
         uint64_t ts_init,
         uint64_t sequence=0,
+        uint8_t flags=0,
     ):
-        super().__init__(ts_event, ts_init)
+        # Placeholder for now
+        cdef BookOrder_t book_order = order._mem if order is not None else book_order_from_raw(
+            OrderSide.NO_ORDER_SIDE,
+            0,
+            0,
+            0,
+            0,
+            0,
+        )
+        self._mem = orderbook_delta_new(
+            instrument_id_clone(&instrument_id._mem),
+            action,
+            book_order,
+            flags,
+            sequence,
+            ts_event,
+            ts_init,
+        )
 
-        self.instrument_id = instrument_id
-        self.action = action
-        self.order = order
-        self.sequence = sequence
+    def __del__(self) -> None:
+        if self._mem.instrument_id.symbol.value != NULL:
+            orderbook_delta_drop(self._mem)  # `self._mem` moved to Rust (then dropped)
 
     def __eq__(self, OrderBookDelta other) -> bool:
-        return OrderBookDelta.to_dict_c(self) == OrderBookDelta.to_dict_c(other)
+        return orderbook_delta_eq(&self._mem, &other._mem)
 
     def __hash__(self) -> int:
-        return hash(frozenset(OrderBookDelta.to_dict_c(self)))
+        return orderbook_delta_hash(&self._mem)
 
     def __repr__(self) -> str:
         return (
             f"{type(self).__name__}("
             f"instrument_id={self.instrument_id}, "
             f"action={book_action_to_str(self.action)}, "
             f"order={self.order}, "
-            f"sequence={self.sequence}, "
             f"ts_event={self.ts_event}, "
-            f"ts_init={self.ts_init})"
+            f"ts_init={self.ts_init}, "
+            f"sequence={self.sequence}, "
+            f"flags={self.flags})"
         )
 
+    @property
+    def instrument_id(self) -> InstrumentId:
+        """
+        Return the deltas book instrument ID.
+
+        Returns
+        -------
+        InstrumentId
+
+        """
+        return InstrumentId.from_mem_c(self._mem.instrument_id)
+
+    @property
+    def action(self) -> BookAction:
+        """
+        Return the deltas book action {``ADD``, ``UPDATE``, ``DELETE``, ``CLEAR``}
+
+        Returns
+        -------
+        BookAction
+
+        """
+        return <BookAction>self._mem.action
+
+    @property
+    def is_add(self) -> BookAction:
+        """
+        If the deltas book action is an ``ADD``.
+
+        Returns
+        -------
+        bool
+
+        """
+        return <BookAction>self._mem.action == BookAction.ADD
+
+    @property
+    def is_update(self) -> BookAction:
+        """
+        If the deltas book action is an ``UPDATE``.
+
+        Returns
+        -------
+        bool
+
+        """
+        return <BookAction>self._mem.action == BookAction.UPDATE
+
+    @property
+    def is_delete(self) -> BookAction:
+        """
+        If the deltas book action is a ``DELETE``.
+
+        Returns
+        -------
+        bool
+
+        """
+        return <BookAction>self._mem.action == BookAction.DELETE
+
+    @property
+    def is_clear(self) -> BookAction:
+        """
+        If the deltas book action is a ``CLEAR``.
+
+        Returns
+        -------
+        bool
+
+        """
+        return <BookAction>self._mem.action == BookAction.CLEAR
+
+    @property
+    def order(self) -> BookOrder:
+        """
+        Return the deltas book order for the action.
+
+        Returns
+        -------
+        BookOrder
+
+        """
+        return BookOrder.from_mem_c(self._mem.order)
+
+    @property
+    def flags(self) -> uint8_t:
+        """
+        Return the flags for the delta.
+
+        Returns
+        -------
+        uint8_t
+
+        """
+        return self._mem.flags
+
+    @property
+    def sequence(self) -> uint64_t:
+        """
+        Return the sequence number for the delta.
+
+        Returns
+        -------
+        uint64_t
+
+        """
+        return self._mem.sequence
+
+    @property
+    def ts_event(self) -> int:
+        """
+        The UNIX timestamp (nanoseconds) when the data event occurred.
+
+        Returns
+        -------
+        int
+
+        """
+        return self._mem.ts_event
+
+    @property
+    def ts_init(self) -> int:
+        """
+        The UNIX timestamp (nanoseconds) when the object was initialized.
+
+        Returns
+        -------
+        int
+
+        """
+        return self._mem.ts_init
+
+    @staticmethod
+    cdef OrderBookDelta from_mem_c(OrderBookDelta_t mem):
+        cdef OrderBookDelta delta = OrderBookDelta.__new__(OrderBookDelta)
+        delta._mem = orderbook_delta_clone(&mem)
+        return delta
+
     @staticmethod
     cdef OrderBookDelta from_dict_c(dict values):
         Condition.not_none(values, "values")
         cdef BookAction action = book_action_from_str(values["action"])
         cdef BookOrder order = BookOrder.from_dict_c({
+            "side": values["side"],
             "price": values["price"],
             "size": values["size"],
-            "side": values["side"],
             "order_id": values["order_id"],
-        }) if values['action'] != "CLEAR" else None
+        }) if values["action"] != "CLEAR" else None
         return OrderBookDelta(
             instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
             action=action,
             order=order,
-            sequence=values.get("update_id", 0),
+            flags=values["flags"],
+            sequence=values["sequence"],
             ts_event=values["ts_event"],
             ts_init=values["ts_init"],
         )
 
     @staticmethod
     cdef dict to_dict_c(OrderBookDelta obj):
         Condition.not_none(obj, "obj")
+        cdef BookOrder order = obj.order
         return {
             "type": "OrderBookDelta",
-            "instrument_id": obj.instrument_id.to_str(),
-            "action": book_action_to_str(obj.action),
-            "price": obj.order.price if obj.order else None,
-            "size": obj.order.size if obj.order else None,
-            "side": order_side_to_str(obj.order.side) if obj.order else None,
-            "order_id": obj.order.order_id if obj.order else None,
-            "sequence": obj.sequence,
-            "ts_event": obj.ts_event,
-            "ts_init": obj.ts_init,
+            "instrument_id": obj.instrument_id.value,
+            "action": book_action_to_str(obj._mem.action),
+            "side": order_side_to_str(order.side) if order else None,
+            "price": str(obj.order.price) if order else None,
+            "size": str(obj.order.size) if order else None,
+            "order_id": order._mem.order_id if order else None,
+            "flags": obj._mem.flags,
+            "sequence": obj._mem.sequence,
+            "ts_event": obj._mem.ts_event,
+            "ts_init": obj._mem.ts_init,
         }
 
     @staticmethod
+    cdef OrderBookDelta clear_c(
+        InstrumentId instrument_id,
+        uint64_t ts_event,
+        uint64_t ts_init,
+        uint64_t sequence=0,
+    ):
+        return OrderBookDelta(instrument_id, BookAction.CLEAR, None, ts_event, ts_init, sequence)
+
+    @staticmethod
     def from_dict(dict values) -> OrderBookDelta:
         """
         Return an order book delta from the given dict values.
 
         Parameters
         ----------
         values : dict[str, object]
@@ -297,82 +499,89 @@
         Returns
         -------
         dict[str, object]
 
         """
         return OrderBookDelta.to_dict_c(obj)
 
+    @staticmethod
+    def clear(InstrumentId instrument_id, uint64_t ts_event, uint64_t ts_init, uint64_t sequence=0):
+        """
+        Return an order book delta which acts as an initial ``CLEAR``.
+
+        Returns
+        -------
+        OrderBookDelta
+
+        """
+        return OrderBookDelta.clear_c(instrument_id, ts_event, ts_init, sequence)
+
 
 cdef class OrderBookDeltas(Data):
     """
     Represents bulk `OrderBookDelta` updates for an `OrderBook`.
 
     Parameters
     ----------
     instrument_id : InstrumentId
         The instrument ID for the book.
     deltas : list[OrderBookDelta]
         The list of order book changes.
-    ts_event : uint64_t
-        The UNIX timestamp (nanoseconds) when the data event occurred.
-    ts_init : uint64_t
-        The UNIX timestamp (nanoseconds) when the data object was initialized.
+
+    Raises
+    ------
+    ValueError
+        If `deltas` is an empty list.
     """
 
     def __init__(
         self,
         InstrumentId instrument_id not None,
         list deltas not None,
-        uint64_t ts_event,
-        uint64_t ts_init,
-        uint64_t sequence=0,
     ):
-        super().__init__(ts_event, ts_init)
+        Condition.not_empty(deltas, "deltas")
 
         self.instrument_id = instrument_id
         self.deltas = deltas
-        self.sequence = sequence
+        self.is_snapshot = deltas[0].is_clear
+        self.ts_event = deltas[-1].ts_event
+        self.ts_init = deltas[-1].ts_init
 
     def __eq__(self, OrderBookDeltas other) -> bool:
         return OrderBookDeltas.to_dict_c(self) == OrderBookDeltas.to_dict_c(other)
 
     def __hash__(self) -> int:
         return hash(frozenset(OrderBookDeltas.to_dict_c(self)))
 
     def __repr__(self) -> str:
         return (
             f"{type(self).__name__}("
             f"instrument_id={self.instrument_id}, "
             f"{self.deltas}, "
             f"sequence={self.sequence}, "
+            f"is_snapshot={self.is_snapshot}, "
             f"ts_event={self.ts_event}, "
             f"ts_init={self.ts_init})"
         )
 
     @staticmethod
     cdef OrderBookDeltas from_dict_c(dict values):
         Condition.not_none(values, "values")
         return OrderBookDeltas(
             instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
             deltas=[OrderBookDelta.from_dict_c(d) for d in msgspec.json.decode(values["deltas"])],
-            ts_event=values["ts_event"],
-            ts_init=values["ts_init"],
-            sequence=values.get("update_id", 0),
         )
 
     @staticmethod
     cdef dict to_dict_c(OrderBookDeltas obj):
         Condition.not_none(obj, "obj")
         return {
             "type": "OrderBookDeltas",
             "instrument_id": obj.instrument_id.to_str(),
             "deltas": msgspec.json.encode([OrderBookDelta.to_dict_c(d) for d in obj.deltas]),
-            "sequence": obj.sequence,
-            "ts_event": obj.ts_event,
-            "ts_init": obj.ts_init,
         }
 
     @staticmethod
     def from_dict(dict values) -> OrderBookDeltas:
         """
         Return order book deltas from the given dict values.
 
@@ -395,115 +604,7 @@
 
         Returns
         -------
         dict[str, object]
 
         """
         return OrderBookDeltas.to_dict_c(obj)
-
-
-cdef class OrderBookSnapshot(Data):
-    """
-    Represents a snapshot in time for an `OrderBook`.
-
-    Parameters
-    ----------
-    instrument_id : InstrumentId
-        The instrument ID for the book.
-    bids : list
-        The bids for the snapshot.
-    asks : list
-        The asks for the snapshot.
-    ts_event : uint64_t
-        The UNIX timestamp (nanoseconds) when the data event occurred.
-    ts_init : uint64_t
-        The UNIX timestamp (nanoseconds) when the data object was initialized.
-    sequence : uint64, default 0
-        The unique sequence number for the update. If default 0 then will increment the `sequence`.
-    """
-
-    def __init__(
-        self,
-        InstrumentId instrument_id not None,
-        list bids not None,
-        list asks not None,
-        uint64_t ts_event,
-        uint64_t ts_init,
-        uint64_t sequence=0,
-    ):
-        super().__init__(ts_event, ts_init)
-
-        self.instrument_id = instrument_id
-        self.bids = bids
-        self.asks = asks
-        self.sequence = sequence
-
-    def __eq__(self, OrderBookSnapshot other) -> bool:
-        return OrderBookSnapshot.to_dict_c(self) == OrderBookSnapshot.to_dict_c(other)
-
-    def __hash__(self) -> int:
-        return hash(frozenset(OrderBookSnapshot.to_dict_c(self)))
-
-    def __repr__(self) -> str:
-        return (
-            f"{type(self).__name__}("
-            f"instrument_id={self.instrument_id}, "
-            f"bids={self.bids}, "
-            f"asks={self.asks}, "
-            f"sequence={self.sequence}, "
-            f"ts_event={self.ts_event}, "
-            f"ts_init={self.ts_init})"
-        )
-
-    @staticmethod
-    cdef OrderBookSnapshot from_dict_c(dict values):
-        Condition.not_none(values, "values")
-        return OrderBookSnapshot(
-            instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
-            bids=msgspec.json.decode(values["bids"]),
-            asks=msgspec.json.decode(values["asks"]),
-            ts_event=values["ts_event"],
-            ts_init=values["ts_init"],
-            sequence=values.get("sequence", 0),
-        )
-
-    @staticmethod
-    cdef dict to_dict_c(OrderBookSnapshot obj):
-        Condition.not_none(obj, "obj")
-        return {
-            "type": "OrderBookSnapshot",
-            "instrument_id": obj.instrument_id.to_str(),
-            "sequence": obj.sequence,
-            "bids": msgspec.json.encode(obj.bids),
-            "asks": msgspec.json.encode(obj.asks),
-            "ts_event": obj.ts_event,
-            "ts_init": obj.ts_init,
-        }
-
-    @staticmethod
-    def from_dict(dict values) -> OrderBookSnapshot:
-        """
-        Return an order book snapshot from the given dict values.
-
-        Parameters
-        ----------
-        values : dict[str, object]
-            The values for initialization.
-
-        Returns
-        -------
-        OrderBookSnapshot
-
-        """
-        return OrderBookSnapshot.from_dict_c(values)
-
-    @staticmethod
-    def to_dict(OrderBookSnapshot obj):
-        """
-        Return a dictionary representation of this object.
-
-        Returns
-        -------
-        dict[str, object]
-
-        """
-        return OrderBookSnapshot.to_dict_c(obj)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/data/tick.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/data/tick.pxd`

 * *Files 20% similar despite different names*

```diff
@@ -9,29 +9,41 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from cpython.mem cimport PyMem_Free
+from cpython.mem cimport PyMem_Malloc
+from cpython.pycapsule cimport PyCapsule_Destructor
+from cpython.pycapsule cimport PyCapsule_GetPointer
+from cpython.pycapsule cimport PyCapsule_New
 from libc.stdint cimport int64_t
 from libc.stdint cimport uint8_t
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.core.data cimport Data
+from nautilus_trader.core.rust.core cimport CVec
 from nautilus_trader.core.rust.model cimport QuoteTick_t
 from nautilus_trader.core.rust.model cimport TradeTick_t
 from nautilus_trader.model.enums_c cimport AggressorSide
 from nautilus_trader.model.enums_c cimport PriceType
 from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.identifiers cimport TradeId
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.objects cimport Quantity
 
 
+cdef inline void capsule_destructor(object capsule):
+    cdef CVec* cvec = <CVec*>PyCapsule_GetPointer(capsule, NULL)
+    PyMem_Free(cvec[0].ptr) # de-allocate buffer
+    PyMem_Free(cvec) # de-allocate cvec
+
+
 cdef class QuoteTick(Data):
     cdef QuoteTick_t _mem
 
     cdef str to_str(self)
 
     @staticmethod
     cdef QuoteTick from_raw_c(
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/data/tick.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/data/tick.pyx`

 * *Files 4% similar despite different names*

```diff
@@ -9,56 +9,45 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from cpython.mem cimport PyMem_Free
-from cpython.mem cimport PyMem_Malloc
-from cpython.pycapsule cimport PyCapsule_Destructor
-from cpython.pycapsule cimport PyCapsule_GetPointer
-from cpython.pycapsule cimport PyCapsule_New
 from libc.stdint cimport int64_t
 from libc.stdint cimport uint8_t
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.core.correctness cimport Condition
 from nautilus_trader.core.data cimport Data
 from nautilus_trader.core.rust.core cimport CVec
 from nautilus_trader.core.rust.model cimport instrument_id_clone
 from nautilus_trader.core.rust.model cimport instrument_id_new_from_cstr
 from nautilus_trader.core.rust.model cimport quote_tick_clone
 from nautilus_trader.core.rust.model cimport quote_tick_drop
-from nautilus_trader.core.rust.model cimport quote_tick_from_raw
+from nautilus_trader.core.rust.model cimport quote_tick_new
 from nautilus_trader.core.rust.model cimport quote_tick_to_cstr
 from nautilus_trader.core.rust.model cimport trade_id_clone
 from nautilus_trader.core.rust.model cimport trade_id_new
 from nautilus_trader.core.rust.model cimport trade_tick_clone
 from nautilus_trader.core.rust.model cimport trade_tick_drop
-from nautilus_trader.core.rust.model cimport trade_tick_from_raw
+from nautilus_trader.core.rust.model cimport trade_tick_new
 from nautilus_trader.core.rust.model cimport trade_tick_to_cstr
 from nautilus_trader.core.string cimport cstr_to_pystr
 from nautilus_trader.core.string cimport pystr_to_cstr
 from nautilus_trader.model.enums_c cimport AggressorSide
 from nautilus_trader.model.enums_c cimport PriceType
 from nautilus_trader.model.enums_c cimport aggressor_side_from_str
 from nautilus_trader.model.enums_c cimport aggressor_side_to_str
 from nautilus_trader.model.enums_c cimport price_type_to_str
 from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.objects cimport Quantity
 
 
-cdef void capsule_destructor(object capsule):
-    cdef CVec* cvec = <CVec*>PyCapsule_GetPointer(capsule, NULL)
-    PyMem_Free(cvec[0].ptr) # de-allocate buffer
-    PyMem_Free(cvec) # de-allocate cvec
-
-
 cdef class QuoteTick(Data):
     """
     Represents a single quote tick in a financial market.
 
     Contains information about the best top of book bid and ask.
 
     Parameters
@@ -94,17 +83,16 @@
         Quantity bid_size not None,
         Quantity ask_size not None,
         uint64_t ts_event,
         uint64_t ts_init,
     ):
         Condition.equal(bid._mem.precision, ask._mem.precision, "bid.precision", "ask.precision")
         Condition.equal(bid_size._mem.precision, ask_size._mem.precision, "bid_size.precision", "ask_size.precision")
-        super().__init__(ts_event, ts_init)
 
-        self._mem = quote_tick_from_raw(
+        self._mem = quote_tick_new(
             instrument_id_clone(&instrument_id._mem),
             bid._mem.raw,
             ask._mem.raw,
             bid._mem.precision,
             ask._mem.precision,
             bid_size._mem.raw,
             ask_size._mem.raw,
@@ -130,17 +118,15 @@
             self._mem.bid_size.precision,
             self._mem.ask_size.precision,
             self.ts_event,
             self.ts_init,
         )
 
     def __setstate__(self, state):
-        self.ts_event = state[9]
-        self.ts_init = state[10]
-        self._mem = quote_tick_from_raw(
+        self._mem = quote_tick_new(
             instrument_id_new_from_cstr(
                 pystr_to_cstr(state[0]),
             ),
             state[1],
             state[2],
             state[3],
             state[4],
@@ -170,15 +156,15 @@
     @property
     def instrument_id(self) -> InstrumentId:
         """
         Return the tick instrument ID.
 
         Returns
         -------
-        Price
+        InstrumentId
 
         """
         return InstrumentId.from_mem_c(self._mem.instrument_id)
 
     @property
     def bid(self) -> Price:
         """
@@ -223,14 +209,38 @@
         Returns
         -------
         Quantity
 
         """
         return Quantity.from_raw_c(self._mem.ask_size.raw, self._mem.ask_size.precision)
 
+    @property
+    def ts_event(self) -> int:
+        """
+        The UNIX timestamp (nanoseconds) when the data event occurred.
+
+        Returns
+        -------
+        int
+
+        """
+        return self._mem.ts_event
+
+    @property
+    def ts_init(self) -> int:
+        """
+        The UNIX timestamp (nanoseconds) when the object was initialized.
+
+        Returns
+        -------
+        int
+
+        """
+        return self._mem.ts_init
+
     @staticmethod
     cdef QuoteTick from_dict_c(dict values):
         Condition.not_none(values, "values")
         return QuoteTick(
             instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
             bid=Price.from_str_c(values["bid"]),
             ask=Price.from_str_c(values["ask"]),
@@ -265,39 +275,33 @@
         uint64_t raw_ask_size,
         uint8_t bid_size_prec,
         uint8_t ask_size_prec,
         uint64_t ts_event,
         uint64_t ts_init,
     ):
         cdef QuoteTick tick = QuoteTick.__new__(QuoteTick)
-        tick.ts_event = ts_event
-        tick.ts_init = ts_init
-        tick._mem = quote_tick_from_raw(
+        tick._mem = quote_tick_new(
             instrument_id_clone(&instrument_id._mem),
             raw_bid,
             raw_ask,
             bid_price_prec,
             ask_price_prec,
             raw_bid_size,
             raw_ask_size,
             bid_size_prec,
             ask_size_prec,
             ts_event,
             ts_init,
         )
-
         return tick
 
     @staticmethod
     cdef QuoteTick from_mem_c(QuoteTick_t mem):
         cdef QuoteTick quote_tick = QuoteTick.__new__(QuoteTick)
         quote_tick._mem = quote_tick_clone(&mem)
-        quote_tick.ts_event = mem.ts_event
-        quote_tick.ts_init = mem.ts_init
-
         return quote_tick
 
     # Safety: Do NOT deallocate the capsule here
     # It is supposed to be deallocated by the creator
     @staticmethod
     cdef inline list capsule_to_quote_tick_list(object capsule):
         cdef CVec* data = <CVec*>PyCapsule_GetPointer(capsule, NULL)
@@ -522,17 +526,15 @@
         Price price not None,
         Quantity size not None,
         AggressorSide aggressor_side,
         TradeId trade_id not None,
         uint64_t ts_event,
         uint64_t ts_init,
     ):
-        super().__init__(ts_event, ts_init)
-
-        self._mem = trade_tick_from_raw(
+        self._mem = trade_tick_new(
             instrument_id_clone(&instrument_id._mem),
             price._mem.raw,
             price._mem.precision,
             size._mem.raw,
             size._mem.precision,
             aggressor_side,
             trade_id_clone(&trade_id._mem),
@@ -554,17 +556,15 @@
             self._mem.aggressor_side,
             self.trade_id.value,
             self.ts_event,
             self.ts_init,
         )
 
     def __setstate__(self, state):
-        self.ts_event = state[7]
-        self.ts_init = state[8]
-        self._mem = trade_tick_from_raw(
+        self._mem = trade_tick_new(
             instrument_id_new_from_cstr(
                 pystr_to_cstr(state[0]),
             ),
             state[1],
             state[2],
             state[3],
             state[4],
@@ -592,15 +592,15 @@
     @property
     def instrument_id(self) -> InstrumentId:
         """
         Return the ticks instrument ID.
 
         Returns
         -------
-        Price
+        InstrumentId
 
         """
         return InstrumentId.from_mem_c(self._mem.instrument_id)
 
     @property
     def trade_id(self) -> InstrumentId:
         """
@@ -645,51 +645,68 @@
         Returns
         -------
         AggressorSide
 
         """
         return <AggressorSide>self._mem.aggressor_side
 
+    @property
+    def ts_event(self) -> int:
+        """
+        The UNIX timestamp (nanoseconds) when the data event occurred.
+
+        Returns
+        -------
+        int
+
+        """
+        return self._mem.ts_event
+
+    @property
+    def ts_init(self) -> int:
+        """
+        The UNIX timestamp (nanoseconds) when the object was initialized.
+
+        Returns
+        -------
+        int
+
+        """
+        return self._mem.ts_init
+
     @staticmethod
     cdef TradeTick from_raw_c(
         InstrumentId instrument_id,
         int64_t raw_price,
         uint8_t price_prec,
         uint64_t raw_size,
         uint8_t size_prec,
         AggressorSide aggressor_side,
         TradeId trade_id,
         uint64_t ts_event,
         uint64_t ts_init,
     ):
         cdef TradeTick tick = TradeTick.__new__(TradeTick)
-        tick._mem = trade_tick_from_raw(
+        tick._mem = trade_tick_new(
             instrument_id_clone(&instrument_id._mem),
             raw_price,
             price_prec,
             raw_size,
             size_prec,
             aggressor_side,
             trade_id_clone(&trade_id._mem),
             ts_event,
             ts_init,
         )
-        tick.ts_event = ts_event
-        tick.ts_init = ts_init
-
         return tick
 
     @staticmethod
     cdef TradeTick from_mem_c(TradeTick_t mem):
         cdef TradeTick trade_tick = TradeTick.__new__(TradeTick)
         trade_tick._mem = trade_tick_clone(&mem)
-
-        trade_tick.ts_event = mem.ts_event
-        trade_tick.ts_init = mem.ts_init
-
         return trade_tick
 
     # Safety: Do NOT deallocate the capsule here
     # It is supposed to be deallocated by the creator
     @staticmethod
     cdef inline list capsule_to_trade_tick_list(object capsule):
         cdef CVec* data = <CVec *>PyCapsule_GetPointer(capsule, NULL)
@@ -701,30 +718,30 @@
             ticks.append(TradeTick.from_mem_c(ptr[i]))
 
         return ticks
 
     @staticmethod
     cdef inline trade_tick_list_to_capsule(list items):
 
-        # create a C struct buffer
+        # Create a C struct buffer
         cdef uint64_t len_ = len(items)
         cdef TradeTick_t * data = <TradeTick_t *> PyMem_Malloc(len_ * sizeof(TradeTick_t))
         cdef uint64_t i
         for i in range(len_):
             data[i] = (<TradeTick> items[i])._mem
         if not data:
             raise MemoryError()
 
-        # create CVec
+        # Create CVec
         cdef CVec* cvec = <CVec *> PyMem_Malloc(1 * sizeof(CVec))
         cvec.ptr = data
         cvec.len = len_
         cvec.cap = len_
 
-        # create PyCapsule
+        # Create PyCapsule
         return PyCapsule_New(cvec, NULL, <PyCapsule_Destructor>capsule_destructor)
 
     @staticmethod
     def list_from_capsule(capsule) -> list[TradeTick]:
         return TradeTick.capsule_to_trade_tick_list(capsule)
 
     @staticmethod
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/data/ticker.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/data/ticker.pxd`

 * *Files 12% similar despite different names*

```diff
@@ -9,20 +9,27 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from libc.stdint cimport uint64_t
+
 from nautilus_trader.core.data cimport Data
 from nautilus_trader.model.identifiers cimport InstrumentId
 
 
 cdef class Ticker(Data):
     cdef readonly InstrumentId instrument_id
     """The ticker instrument ID.\n\n:returns: `InstrumentId`"""
+    cdef readonly uint64_t ts_event
+    """The UNIX timestamp (nanoseconds) when the data event occurred.\n\n:returns: `uint64_t`"""
+    cdef readonly uint64_t ts_init
+    """The UNIX timestamp (nanoseconds) when the object was initialized.\n\n:returns: `uint64_t`"""
+
 
     @staticmethod
     cdef Ticker from_dict_c(dict values)
 
     @staticmethod
     cdef dict to_dict_c(Ticker obj)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/data/ticker.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/data/ticker.pyx`

 * *Files 5% similar despite different names*

```diff
@@ -40,17 +40,17 @@
 
     def __init__(
         self,
         InstrumentId instrument_id not None,
         uint64_t ts_event,
         uint64_t ts_init,
     ):
-        super().__init__(ts_event, ts_init)
-
         self.instrument_id = instrument_id
+        self.ts_event = ts_event
+        self.ts_init = ts_init
 
     def __eq__(self, Ticker other) -> bool:
         return self.instrument_id == other.instrument_id
 
     def __hash__(self) -> int:
         return hash(self.instrument_id)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/data/venue.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/data/venue.pxd`

 * *Files 26% similar despite different names*

```diff
@@ -9,14 +9,16 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from libc.stdint cimport uint64_t
+
 from nautilus_trader.core.data cimport Data
 from nautilus_trader.model.enums_c cimport InstrumentCloseType
 from nautilus_trader.model.enums_c cimport MarketStatus
 from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.identifiers cimport Venue
 from nautilus_trader.model.objects cimport Price
 
@@ -26,27 +28,35 @@
 
 
 cdef class VenueStatusUpdate(StatusUpdate):
     cdef readonly Venue venue
     """The venue.\n\n:returns: `Venue`"""
     cdef readonly MarketStatus status
     """The venue market status.\n\n:returns: `MarketStatus`"""
+    cdef readonly uint64_t ts_event
+    """The UNIX timestamp (nanoseconds) when the data event occurred.\n\n:returns: `uint64_t`"""
+    cdef readonly uint64_t ts_init
+    """The UNIX timestamp (nanoseconds) when the object was initialized.\n\n:returns: `uint64_t`"""
 
     @staticmethod
     cdef VenueStatusUpdate from_dict_c(dict values)
 
     @staticmethod
     cdef dict to_dict_c(VenueStatusUpdate obj)
 
 
 cdef class InstrumentStatusUpdate(StatusUpdate):
     cdef readonly InstrumentId instrument_id
     """The instrument ID.\n\n:returns: `InstrumentId`"""
     cdef readonly MarketStatus status
     """The instrument market status.\n\n:returns: `MarketStatus`"""
+    cdef readonly uint64_t ts_event
+    """The UNIX timestamp (nanoseconds) when the data event occurred.\n\n:returns: `uint64_t`"""
+    cdef readonly uint64_t ts_init
+    """The UNIX timestamp (nanoseconds) when the object was initialized.\n\n:returns: `uint64_t`"""
 
     @staticmethod
     cdef InstrumentStatusUpdate from_dict_c(dict values)
 
     @staticmethod
     cdef dict to_dict_c(InstrumentStatusUpdate obj)
 
@@ -54,13 +64,17 @@
 cdef class InstrumentClose(Data):
     cdef readonly InstrumentId instrument_id
     """The event instrument ID.\n\n:returns: `InstrumentId`"""
     cdef readonly Price close_price
     """The instrument close price.\n\n:returns: `Price`"""
     cdef readonly InstrumentCloseType close_type
     """The instrument close type.\n\n:returns: `InstrumentCloseType`"""
+    cdef readonly uint64_t ts_event
+    """The UNIX timestamp (nanoseconds) when the data event occurred.\n\n:returns: `uint64_t`"""
+    cdef readonly uint64_t ts_init
+    """The UNIX timestamp (nanoseconds) when the object was initialized.\n\n:returns: `uint64_t`"""
 
     @staticmethod
     cdef InstrumentClose from_dict_c(dict values)
 
     @staticmethod
     cdef dict to_dict_c(InstrumentClose obj)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/data/venue.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/data/venue.pyx`

 * *Files 3% similar despite different names*

```diff
@@ -28,33 +28,19 @@
 from nautilus_trader.model.objects cimport Price
 
 
 cdef class StatusUpdate(Data):
     """
     The base class for all status updates.
 
-    Parameters
-    ----------
-    ts_event : uint64_t
-        The UNIX timestamp (nanoseconds) when the status update event occurred.
-    ts_init : uint64_t
-        The UNIX timestamp (nanoseconds) when the object was initialized.
-
     Warnings
     --------
     This class should not be used directly, but through a concrete subclass.
     """
 
-    def __init__(
-        self,
-        uint64_t ts_event,
-        uint64_t ts_init,
-    ):
-        super().__init__(ts_event, ts_init)
-
 
 cdef class VenueStatusUpdate(StatusUpdate):
     """
     Represents an update that indicates a change in a Venue status.
 
     Parameters
     ----------
@@ -71,17 +57,18 @@
     def __init__(
         self,
         Venue venue,
         MarketStatus status,
         uint64_t ts_event,
         uint64_t ts_init,
     ):
-        super().__init__(ts_event, ts_init)
         self.venue = venue
         self.status = status
+        self.ts_event = ts_event
+        self.ts_init = ts_init
 
     def __eq__(self, VenueStatusUpdate other) -> bool:
         return VenueStatusUpdate.to_dict_c(self) == VenueStatusUpdate.to_dict_c(other)
 
     def __hash__(self) -> int:
         return hash(frozenset(VenueStatusUpdate.to_dict_c(self)))
 
@@ -162,17 +149,18 @@
     def __init__(
         self,
         InstrumentId instrument_id,
         MarketStatus status,
         uint64_t ts_event,
         uint64_t ts_init,
     ):
-        super().__init__(ts_event, ts_init,)
         self.instrument_id = instrument_id
         self.status = status
+        self.ts_event = ts_event
+        self.ts_init = ts_init
 
     def __eq__(self, InstrumentStatusUpdate other) -> bool:
         return InstrumentStatusUpdate.to_dict_c(self) == InstrumentStatusUpdate.to_dict_c(other)
 
     def __hash__(self) -> int:
         return hash(frozenset(InstrumentStatusUpdate.to_dict_c(self)))
 
@@ -256,18 +244,19 @@
         self,
         InstrumentId instrument_id not None,
         Price close_price not None,
         InstrumentCloseType close_type,
         uint64_t ts_event,
         uint64_t ts_init,
     ):
-        super().__init__(ts_event, ts_init,)
         self.instrument_id = instrument_id
         self.close_price = close_price
         self.close_type = close_type
+        self.ts_event = ts_event
+        self.ts_init = ts_init
 
     def __eq__(self, InstrumentClose other) -> bool:
         return InstrumentClose.to_dict_c(self) == InstrumentClose.to_dict_c(other)
 
     def __hash__(self) -> int:
         return hash(frozenset(InstrumentClose.to_dict_c(self)))
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/enums.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/enums.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -20,15 +20,14 @@
 from nautilus_trader.core.rust.model import AggressorSide
 from nautilus_trader.core.rust.model import AssetClass
 from nautilus_trader.core.rust.model import AssetType
 from nautilus_trader.core.rust.model import BookAction
 from nautilus_trader.core.rust.model import BookType
 from nautilus_trader.core.rust.model import ContingencyType
 from nautilus_trader.core.rust.model import CurrencyType
-from nautilus_trader.core.rust.model import DepthType
 from nautilus_trader.core.rust.model import InstrumentCloseType
 from nautilus_trader.core.rust.model import LiquiditySide
 from nautilus_trader.core.rust.model import MarketStatus
 from nautilus_trader.core.rust.model import OmsType
 from nautilus_trader.core.rust.model import OptionKind
 from nautilus_trader.core.rust.model import OrderSide
 from nautilus_trader.core.rust.model import OrderStatus
@@ -56,16 +55,14 @@
 from nautilus_trader.model.enums_c import book_action_to_str
 from nautilus_trader.model.enums_c import book_type_from_str
 from nautilus_trader.model.enums_c import book_type_to_str
 from nautilus_trader.model.enums_c import contingency_type_from_str
 from nautilus_trader.model.enums_c import contingency_type_to_str
 from nautilus_trader.model.enums_c import currency_type_from_str
 from nautilus_trader.model.enums_c import currency_type_to_str
-from nautilus_trader.model.enums_c import depth_type_from_str
-from nautilus_trader.model.enums_c import depth_type_to_str
 from nautilus_trader.model.enums_c import instrument_close_type_from_str
 from nautilus_trader.model.enums_c import instrument_close_type_to_str
 from nautilus_trader.model.enums_c import liquidity_side_from_str
 from nautilus_trader.model.enums_c import liquidity_side_to_str
 from nautilus_trader.model.enums_c import market_status_from_str
 from nautilus_trader.model.enums_c import market_status_to_str
 from nautilus_trader.model.enums_c import oms_type_from_str
@@ -99,15 +96,14 @@
     "AssetClass",
     "AssetType",
     "BarAggregation",
     "BookAction",
     "BookType",
     "ContingencyType",
     "CurrencyType",
-    "DepthType",
     "InstrumentCloseType",
     "LiquiditySide",
     "MarketStatus",
     "OmsType",
     "OptionKind",
     "OrderSide",
     "OrderStatus",
@@ -134,16 +130,14 @@
     "book_action_from_str",
     "book_type_to_str",
     "book_type_from_str",
     "contingency_type_to_str",
     "contingency_type_from_str",
     "currency_type_to_str",
     "currency_type_from_str",
-    "depth_type_to_str",
-    "depth_type_from_str",
     "instrument_close_type_to_str",
     "instrument_close_type_from_str",
     "liquidity_side_to_str",
     "liquidity_side_from_str",
     "market_status_to_str",
     "market_status_from_str",
     "oms_type_to_str",
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/enums_c.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/enums_c.pxd`

 * *Files 2% similar despite different names*

```diff
@@ -18,15 +18,14 @@
 from nautilus_trader.core.rust.model cimport AggressorSide
 from nautilus_trader.core.rust.model cimport AssetClass
 from nautilus_trader.core.rust.model cimport AssetType
 from nautilus_trader.core.rust.model cimport BookAction
 from nautilus_trader.core.rust.model cimport BookType
 from nautilus_trader.core.rust.model cimport ContingencyType
 from nautilus_trader.core.rust.model cimport CurrencyType
-from nautilus_trader.core.rust.model cimport DepthType
 from nautilus_trader.core.rust.model cimport InstrumentCloseType
 from nautilus_trader.core.rust.model cimport LiquiditySide
 from nautilus_trader.core.rust.model cimport MarketStatus
 from nautilus_trader.core.rust.model cimport OmsType
 from nautilus_trader.core.rust.model cimport OptionKind
 from nautilus_trader.core.rust.model cimport OrderSide
 from nautilus_trader.core.rust.model cimport OrderStatus
@@ -66,17 +65,14 @@
 
 cpdef ContingencyType contingency_type_from_str(str value)
 cpdef str contingency_type_to_str(ContingencyType value)
 
 cpdef CurrencyType currency_type_from_str(str value)
 cpdef str currency_type_to_str(CurrencyType value)
 
-cpdef DepthType depth_type_from_str(str value)
-cpdef str depth_type_to_str(DepthType value)
-
 cpdef InstrumentCloseType instrument_close_type_from_str(str value)
 cpdef str instrument_close_type_to_str(InstrumentCloseType value)
 
 cpdef LiquiditySide liquidity_side_from_str(str value)
 cpdef str liquidity_side_to_str(LiquiditySide value)
 
 cpdef MarketStatus market_status_from_str(str value)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/enums_c.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/enums_c.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -20,15 +20,14 @@
 from nautilus_trader.core.rust.model cimport AggressorSide
 from nautilus_trader.core.rust.model cimport AssetClass
 from nautilus_trader.core.rust.model cimport AssetType
 from nautilus_trader.core.rust.model cimport BookAction
 from nautilus_trader.core.rust.model cimport BookType
 from nautilus_trader.core.rust.model cimport ContingencyType
 from nautilus_trader.core.rust.model cimport CurrencyType
-from nautilus_trader.core.rust.model cimport DepthType
 from nautilus_trader.core.rust.model cimport InstrumentCloseType
 from nautilus_trader.core.rust.model cimport LiquiditySide
 from nautilus_trader.core.rust.model cimport MarketStatus
 from nautilus_trader.core.rust.model cimport OmsType
 from nautilus_trader.core.rust.model cimport OptionKind
 from nautilus_trader.core.rust.model cimport OrderSide
 from nautilus_trader.core.rust.model cimport OrderStatus
@@ -55,16 +54,14 @@
 from nautilus_trader.core.rust.model cimport book_action_to_cstr
 from nautilus_trader.core.rust.model cimport book_type_from_cstr
 from nautilus_trader.core.rust.model cimport book_type_to_cstr
 from nautilus_trader.core.rust.model cimport contingency_type_from_cstr
 from nautilus_trader.core.rust.model cimport contingency_type_to_cstr
 from nautilus_trader.core.rust.model cimport currency_type_from_cstr
 from nautilus_trader.core.rust.model cimport currency_type_to_cstr
-from nautilus_trader.core.rust.model cimport depth_type_from_cstr
-from nautilus_trader.core.rust.model cimport depth_type_to_cstr
 from nautilus_trader.core.rust.model cimport instrument_close_type_from_cstr
 from nautilus_trader.core.rust.model cimport instrument_close_type_to_cstr
 from nautilus_trader.core.rust.model cimport liquidity_side_from_cstr
 from nautilus_trader.core.rust.model cimport liquidity_side_to_cstr
 from nautilus_trader.core.rust.model cimport market_status_from_cstr
 from nautilus_trader.core.rust.model cimport market_status_to_cstr
 from nautilus_trader.core.rust.model cimport oms_type_from_cstr
@@ -170,22 +167,14 @@
     return currency_type_from_cstr(pystr_to_cstr(value))
 
 
 cpdef str currency_type_to_str(CurrencyType value):
     return cstr_to_pystr(currency_type_to_cstr(value))
 
 
-cpdef DepthType depth_type_from_str(str value):
-    return depth_type_from_cstr(pystr_to_cstr(value))
-
-
-cpdef str depth_type_to_str(DepthType value):
-    return cstr_to_pystr(depth_type_to_cstr(value))
-
-
 cpdef InstrumentCloseType instrument_close_type_from_str(str value):
     return instrument_close_type_from_cstr(pystr_to_cstr(value))
 
 
 cpdef str instrument_close_type_to_str(InstrumentCloseType value):
     return cstr_to_pystr(instrument_close_type_to_cstr(value))
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/events/__init__.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/events/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/events/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/core/data.pxd`

 * *Files 6% similar despite different names*

```diff
@@ -9,8 +9,10 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-"""Defines the fundamental event types represented within the trading domain."""
+
+cdef class Data:
+    pass
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/events/account.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/events/account.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/events/account.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/events/account.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/events/order.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/events/order.pxd`

 * *Files 8% similar despite different names*

```diff
@@ -10,14 +10,15 @@
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from nautilus_trader.core.message cimport Event
+from nautilus_trader.core.rust.model cimport OrderDenied_t
 from nautilus_trader.model.currency cimport Currency
 from nautilus_trader.model.enums_c cimport ContingencyType
 from nautilus_trader.model.enums_c cimport LiquiditySide
 from nautilus_trader.model.enums_c cimport OrderSide
 from nautilus_trader.model.enums_c cimport OrderType
 from nautilus_trader.model.enums_c cimport TimeInForce
 from nautilus_trader.model.enums_c cimport TriggerType
@@ -62,18 +63,22 @@
     """The order quantity.\n\n:returns: `Quantity`"""
     cdef readonly TimeInForce time_in_force
     """The order time in force.\n\n:returns: `TimeInForce`"""
     cdef readonly bint post_only
     """If the order will only provide liquidity (make a market).\n\n:returns: `bool`"""
     cdef readonly bint reduce_only
     """If the order carries the 'reduce-only' execution instruction.\n\n:returns: `bool`"""
+    cdef readonly bint quote_quantity
+    """If the order quantity is denominated in the quote currency.\n\n:returns: `bool`"""
     cdef readonly dict options
     """The order initialization options.\n\n:returns: `dict`"""
     cdef readonly TriggerType emulation_trigger
     """The order emulation trigger type.\n\n:returns: `TriggerType`"""
+    cdef readonly InstrumentId trigger_instrument_id
+    """The order emulation trigger instrument ID (will be `instrument_id` if ``None``).\n\n:returns: `InstrumentId` or ``None``"""
     cdef readonly ContingencyType contingency_type
     """The orders contingency type.\n\n:returns: `ContingencyType`"""
     cdef readonly OrderListId order_list_id
     """The order list ID associated with the order.\n\n:returns: `OrderListId` or ``None``"""
     cdef readonly list linked_order_ids
     """The orders linked client order ID(s).\n\n:returns: `list[ClientOrderId]` or ``None``"""
     cdef readonly ClientOrderId parent_order_id
@@ -91,24 +96,24 @@
     cdef OrderInitialized from_dict_c(dict values)
 
     @staticmethod
     cdef dict to_dict_c(OrderInitialized obj)
 
 
 cdef class OrderDenied(OrderEvent):
-    cdef readonly str reason
-    """The reason the order was denied.\n\n:returns: `str`"""
+    cdef OrderDenied_t _mem
 
     @staticmethod
     cdef OrderDenied from_dict_c(dict values)
 
     @staticmethod
     cdef dict to_dict_c(OrderDenied obj)
 
 
+
 cdef class OrderSubmitted(OrderEvent):
 
     @staticmethod
     cdef OrderSubmitted from_dict_c(dict values)
 
     @staticmethod
     cdef dict to_dict_c(OrderSubmitted obj)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/events/order.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/events/order.pyx`

 * *Files 4% similar despite different names*

```diff
@@ -18,14 +18,26 @@
 
 import msgspec
 
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.core.correctness cimport Condition
 from nautilus_trader.core.message cimport Event
+from nautilus_trader.core.rust.core cimport uuid4_clone
+from nautilus_trader.core.rust.model cimport client_order_id_clone
+from nautilus_trader.core.rust.model cimport component_id_to_cstr
+from nautilus_trader.core.rust.model cimport instrument_id_clone
+from nautilus_trader.core.rust.model cimport order_denied_new
+from nautilus_trader.core.rust.model cimport order_denied_reason_to_cstr
+from nautilus_trader.core.rust.model cimport strategy_id_new
+from nautilus_trader.core.rust.model cimport trade_id_clone
+from nautilus_trader.core.rust.model cimport trader_id_new
+from nautilus_trader.core.string cimport cstr_to_pybytes
+from nautilus_trader.core.string cimport cstr_to_pystr
+from nautilus_trader.core.string cimport pystr_to_cstr
 from nautilus_trader.core.uuid cimport UUID4
 from nautilus_trader.model.currency cimport Currency
 from nautilus_trader.model.enums_c cimport ContingencyType
 from nautilus_trader.model.enums_c cimport LiquiditySide
 from nautilus_trader.model.enums_c cimport OrderSide
 from nautilus_trader.model.enums_c cimport OrderType
 from nautilus_trader.model.enums_c cimport TimeInForce
@@ -135,19 +147,23 @@
         The order quantity.
     time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``, ``AT_THE_OPEN``, ``AT_THE_CLOSE``}
         The order time in force.
     post_only : bool
         If the order will only provide liquidity (make a market).
     reduce_only : bool
         If the order carries the 'reduce-only' execution instruction.
+    quote_quantity : bool
+        If the order quantity is denominated in the quote currency.
     options : dict[str, str]
         The order initialization options. Contains mappings for specific
         order parameters.
     emulation_trigger : EmulationTrigger
         The emulation trigger for the order.
+    trigger_instrument_id : InstrumentId, optional with no default so ``None`` must be passed explicitly
+        The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
     contingency_type : ContingencyType
         The order contingency type.
     order_list_id : OrderListId, optional with no default so ``None`` must be passed explicitly
         The order list ID associated with the order.
     linked_order_ids : list[ClientOrderId], optional with no default so ``None`` must be passed explicitly
         The order linked client order ID(s).
     parent_order_id : ClientOrderId, optional with no default so ``None`` must be passed explicitly
@@ -182,16 +198,18 @@
         ClientOrderId client_order_id not None,
         OrderSide order_side,
         OrderType order_type,
         Quantity quantity not None,
         TimeInForce time_in_force,
         bint post_only,
         bint reduce_only,
+        bint quote_quantity,
         dict options not None,
         TriggerType emulation_trigger,
+        InstrumentId trigger_instrument_id: Optional[InstrumentId],
         ContingencyType contingency_type,
         OrderListId order_list_id: Optional[OrderListId],
         list linked_order_ids: Optional[list[ClientOrderId]],
         ClientOrderId parent_order_id: Optional[ClientOrderId],
         ExecAlgorithmId exec_algorithm_id: Optional[ExecAlgorithmId],
         dict exec_algorithm_params: Optional[dict[str, Any]],
         ClientOrderId exec_spawn_id: Optional[ClientOrderId],
@@ -217,16 +235,18 @@
 
         self.side = order_side
         self.order_type = order_type
         self.quantity = quantity
         self.time_in_force = time_in_force
         self.post_only = post_only
         self.reduce_only = reduce_only
+        self.quote_quantity = quote_quantity
         self.options = options
         self.emulation_trigger = emulation_trigger
+        self.trigger_instrument_id = trigger_instrument_id
         self.contingency_type = contingency_type
         self.order_list_id = order_list_id
         self.linked_order_ids = linked_order_ids
         self.parent_order_id = parent_order_id
         self.exec_algorithm_id = exec_algorithm_id
         self.exec_algorithm_params = exec_algorithm_params
         self.exec_spawn_id = exec_spawn_id
@@ -243,16 +263,18 @@
             f"client_order_id={self.client_order_id}, "
             f"side={order_side_to_str(self.side)}, "
             f"type={order_type_to_str(self.order_type)}, "
             f"quantity={self.quantity.to_str()}, "
             f"time_in_force={time_in_force_to_str(self.time_in_force)}, "
             f"post_only={self.post_only}, "
             f"reduce_only={self.reduce_only}, "
+            f"quote_quantity={self.quote_quantity}, "
             f"options={self.options}, "
             f"emulation_trigger={trigger_type_to_str(self.emulation_trigger)}, "
+            f"trigger_instrument_id={self.trigger_instrument_id}, "  # Can be None
             f"contingency_type={contingency_type_to_str(self.contingency_type)}, "
             f"order_list_id={self.order_list_id}, "  # Can be None
             f"linked_order_ids={linked_order_ids}, "
             f"parent_order_id={self.parent_order_id}, "  # Can be None
             f"exec_algorithm_id={self.exec_algorithm_id}, "  # Can be None
             f"exec_algorithm_params={self.exec_algorithm_params}, "  # Can be None
             f"exec_spawn_id={self.exec_spawn_id}, "  # Can be None
@@ -272,16 +294,18 @@
             f"client_order_id={self.client_order_id.to_str()}, "
             f"side={order_side_to_str(self.side)}, "
             f"type={order_type_to_str(self.order_type)}, "
             f"quantity={self.quantity.to_str()}, "
             f"time_in_force={time_in_force_to_str(self.time_in_force)}, "
             f"post_only={self.post_only}, "
             f"reduce_only={self.reduce_only}, "
+            f"quote_quantity={self.quote_quantity}, "
             f"options={self.options}, "
             f"emulation_trigger={trigger_type_to_str(self.emulation_trigger)}, "
+            f"trigger_instrument_id={self.trigger_instrument_id}, "  # Can be None
             f"contingency_type={contingency_type_to_str(self.contingency_type)}, "
             f"order_list_id={self.order_list_id}, "  # Can be None
             f"linked_order_ids={linked_order_ids}, "
             f"parent_order_id={self.parent_order_id}, "  # Can be None
             f"exec_algorithm_id={self.exec_algorithm_id}, "  # Can be None
             f"exec_algorithm_params={self.exec_algorithm_params}, "  # Can be None
             f"exec_spawn_id={self.exec_spawn_id}, "  # Can be None
@@ -289,14 +313,15 @@
             f"event_id={self.id.to_str()}, "
             f"ts_init={self.ts_init})"
         )
 
     @staticmethod
     cdef OrderInitialized from_dict_c(dict values):
         Condition.not_none(values, "values")
+        cdef str trigger_instrument_id = values["trigger_instrument_id"]
         cdef str order_list_id_str = values["order_list_id"]
         cdef str linked_order_ids_str = values["linked_order_ids"]
         cdef str parent_order_id_str = values["parent_order_id"]
         cdef str exec_algorithm_id_str = values["exec_algorithm_id"]
         cdef str exec_spawn_id_str = values["exec_spawn_id"]
         return OrderInitialized(
             trader_id=TraderId(values["trader_id"]),
@@ -305,16 +330,18 @@
             client_order_id=ClientOrderId(values["client_order_id"]),
             order_side=order_side_from_str(values["order_side"]),
             order_type=order_type_from_str(values["order_type"]),
             quantity=Quantity.from_str_c(values["quantity"]),
             time_in_force=time_in_force_from_str(values["time_in_force"]),
             post_only=values["post_only"],
             reduce_only=values["reduce_only"],
+            quote_quantity=values["quote_quantity"],
             options=json.loads(values["options"]),  # Using vanilla json due mixed schema types
             emulation_trigger=trigger_type_from_str(values["emulation_trigger"]),
+            trigger_instrument_id=InstrumentId.from_str_c(trigger_instrument_id) if trigger_instrument_id is not None else None,
             contingency_type=contingency_type_from_str(values["contingency_type"]),
             order_list_id=OrderListId(order_list_id_str) if order_list_id_str is not None else None,
             linked_order_ids=[ClientOrderId(o_str) for o_str in linked_order_ids_str.split(",")] if linked_order_ids_str is not None else None,
             parent_order_id=ClientOrderId(parent_order_id_str) if parent_order_id_str is not None else None,
             exec_algorithm_id=ExecAlgorithmId(exec_algorithm_id_str) if exec_algorithm_id_str is not None else None,
             exec_algorithm_params=json.loads(values["exec_algorithm_params"]),  # Using vanilla json due mixed schema types
             exec_spawn_id=ClientOrderId(exec_spawn_id_str) if exec_spawn_id_str is not None else None,
@@ -336,16 +363,18 @@
             "client_order_id": obj.client_order_id.to_str(),
             "order_side": order_side_to_str(obj.side),
             "order_type": order_type_to_str(obj.order_type),
             "quantity": str(obj.quantity),
             "time_in_force": time_in_force_to_str(obj.time_in_force),
             "post_only": obj.post_only,
             "reduce_only": obj.reduce_only,
+            "quote_quantity": obj.quote_quantity,
             "options": json.dumps(obj.options),  # Using vanilla json due mixed schema types
             "emulation_trigger": trigger_type_to_str(obj.emulation_trigger),
+            "trigger_instrument_id": obj.trigger_instrument_id.to_str() if obj.trigger_instrument_id is not None else None,
             "contingency_type": contingency_type_to_str(obj.contingency_type),
             "order_list_id": obj.order_list_id.to_str() if obj.order_list_id is not None else None,
             "linked_order_ids": ",".join([o.to_str() for o in obj.linked_order_ids]) if obj.linked_order_ids is not None else None,  # noqa
             "parent_order_id": obj.parent_order_id.to_str() if obj.parent_order_id is not None else None,
             "exec_algorithm_id": obj.exec_algorithm_id.to_str() if obj.exec_algorithm_id is not None else None,
             "exec_algorithm_params": json.dumps(obj.exec_algorithm_params),  # Using vanilla json due mixed schema types
             "exec_spawn_id": obj.exec_spawn_id.to_str() if obj.exec_spawn_id is not None else None,
@@ -435,15 +464,24 @@
             None,  # Never assigned
             event_id,
             ts_init,  # Timestamp identical to ts_init
             ts_init,
             reconciliation=False,  # Internal system event
         )
 
-        self.reason = reason
+        self._mem = order_denied_new(
+            trader_id_new(component_id_to_cstr(&trader_id._mem)),
+            strategy_id_new(component_id_to_cstr(&strategy_id._mem)),
+            instrument_id_clone(&instrument_id._mem),
+            client_order_id_clone(&client_order_id._mem),
+            pystr_to_cstr(reason),
+            uuid4_clone(&event_id._mem),
+            ts_init,
+            ts_init,
+        )
 
     def __str__(self) -> str:
         return (
             f"{type(self).__name__}("
             f"instrument_id={self.instrument_id.to_str()}, "
             f"client_order_id={self.client_order_id.to_str()}, "
             f"reason={self.reason})"
@@ -457,14 +495,26 @@
             f"instrument_id={self.instrument_id.to_str()}, "
             f"client_order_id={self.client_order_id.to_str()}, "
             f"reason={self.reason}, "
             f"event_id={self.id.to_str()}, "
             f"ts_init={self.ts_init})"
         )
 
+    @property
+    def reason(self) -> str:
+        """
+        Return the reason the order was denied.
+
+        Returns
+        -------
+        str
+
+        """
+        return cstr_to_pystr(order_denied_reason_to_cstr(&self._mem))
+
     @staticmethod
     cdef OrderDenied from_dict_c(dict values):
         Condition.not_none(values, "values")
         return OrderDenied(
             trader_id=TraderId(values["trader_id"]),
             strategy_id=StrategyId(values["strategy_id"]),
             instrument_id=InstrumentId.from_str_c(values["instrument_id"]),
@@ -481,14 +531,15 @@
             "type": "OrderDenied",
             "trader_id": obj.trader_id.to_str(),
             "strategy_id": obj.strategy_id.to_str(),
             "instrument_id": obj.instrument_id.to_str(),
             "client_order_id": obj.client_order_id.to_str(),
             "reason": obj.reason,
             "event_id": obj.id.to_str(),
+            "ts_event": obj.ts_init,
             "ts_init": obj.ts_init,
         }
 
     @staticmethod
     def from_dict(dict values) -> OrderDenied:
         """
         Return an order denied event from the given dict values.
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/events/position.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/events/position.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/events/position.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/events/position.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/identifiers.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/identifiers.pxd`

 * *Files 10% similar despite different names*

```diff
@@ -28,27 +28,28 @@
 cdef class Identifier:
     cdef str to_str(self)
 
 
 cdef class Symbol(Identifier):
     cdef Symbol_t _mem
 
+    @staticmethod
+    cdef Symbol from_mem_c(Symbol_t* mem)
+
 
 cdef class Venue(Identifier):
     cdef Venue_t _mem
 
+    @staticmethod
+    cdef Venue from_mem_c(Venue_t* mem)
+
 
 cdef class InstrumentId(Identifier):
     cdef InstrumentId_t _mem
 
-    cdef readonly Symbol symbol
-    """The instrument ticker symbol.\n\n:returns: `Symbol`"""
-    cdef readonly Venue venue
-    """The instrument trading venue.\n\n:returns: `Venue`"""
-
     @staticmethod
     cdef InstrumentId from_mem_c(InstrumentId_t mem)
 
     @staticmethod
     cdef InstrumentId from_str_c(str value)
 
 
@@ -63,14 +64,15 @@
 cdef class TraderId(ComponentId):
     cpdef str get_tag(self)
 
 
 cdef class StrategyId(ComponentId):
     cpdef str get_tag(self)
     cpdef bint is_external(self)
+
     @staticmethod
     cdef StrategyId external_c()
 
 
 cdef class ExecAlgorithmId(ComponentId):
     pass
 
@@ -81,14 +83,16 @@
     cpdef str get_issuer(self)
     cpdef str get_id(self)
 
 
 cdef class ClientOrderId(Identifier):
     cdef ClientOrderId_t _mem
 
+    cpdef bint is_this_trader(self, TraderId trader_id)
+
 
 cdef class VenueOrderId(Identifier):
     cdef VenueOrderId_t _mem
 
 
 cdef class OrderListId(Identifier):
     cdef OrderListId_t _mem
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/identifiers.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/identifiers.pyx`

 * *Files 6% similar despite different names*

```diff
@@ -9,14 +9,15 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from nautilus_trader.core.correctness cimport Condition
 from nautilus_trader.core.rust.model cimport account_id_drop
 from nautilus_trader.core.rust.model cimport account_id_eq
 from nautilus_trader.core.rust.model cimport account_id_hash
 from nautilus_trader.core.rust.model cimport account_id_new
 from nautilus_trader.core.rust.model cimport account_id_to_cstr
 from nautilus_trader.core.rust.model cimport client_order_id_drop
 from nautilus_trader.core.rust.model cimport client_order_id_eq
@@ -70,15 +71,15 @@
 from nautilus_trader.core.rust.model cimport venue_to_cstr
 from nautilus_trader.core.string cimport cstr_to_pystr
 from nautilus_trader.core.string cimport pystr_to_cstr
 
 
 cdef class Identifier:
     """
-    The base class for all identifiers.
+    The abstract base class for all identifiers.
     """
 
     def __getstate__(self):
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
 
     def __setstate__(self, state):
         raise NotImplementedError("method must be implemented in the subclass")  # pragma: no cover
@@ -115,33 +116,37 @@
 
         """
         return self.to_str()
 
 
 cdef class Symbol(Identifier):
     """
-    Represents a valid ticker symbol ID for a tradable financial market
-    instrument.
+    Represents a valid ticker symbol ID for a tradable financial market instrument.
 
     Parameters
     ----------
     value : str
         The ticker symbol ID value.
 
+    Raises
+    ------
+    ValueError
+        If `value` is not a valid string.
+
     Warnings
     --------
-    - The ID value must be unique for a trading venue.
-    - Panics at runtime if `value` is not a valid string.
+    The ID value must be unique for a trading venue.
 
     References
     ----------
     https://en.wikipedia.org/wiki/Ticker_symbol
     """
 
     def __init__(self, str value not None):
+        Condition.valid_string(value, "value")
         self._mem = symbol_new(pystr_to_cstr(value))
 
     def __del__(self) -> None:
         if self._mem.value != NULL:
             symbol_drop(self._mem)  # `self._mem` moved to Rust (then dropped)
 
     def __getstate__(self):
@@ -154,33 +159,41 @@
         if other is None:
             raise RuntimeError("other was None in __eq__")
         return symbol_eq(&self._mem, &other._mem)
 
     def __hash__ (self) -> int:
         return symbol_hash(&self._mem)
 
+    @staticmethod
+    cdef Symbol from_mem_c(Symbol_t* mem):
+        cdef Symbol symbol = Symbol.__new__(Symbol)
+        symbol._mem = symbol_clone(mem)
+        return symbol
+
     cdef str to_str(self):
         return cstr_to_pystr(symbol_to_cstr(&self._mem))
 
 
 cdef class Venue(Identifier):
     """
     Represents a valid trading venue ID.
 
     Parameters
     ----------
     name : str
         The venue ID value.
 
-    Warnings
-    --------
-    - Panics at runtime if `value` is not a valid string.
+    Raises
+    ------
+    ValueError
+        If `name` is not a valid string.
     """
 
     def __init__(self, str name not None):
+        Condition.valid_string(name, "name")
         self._mem = venue_new(pystr_to_cstr(name))
 
     def __del__(self) -> None:
         if self._mem.value != NULL:
             venue_drop(self._mem)  # `self._mem` moved to Rust (then dropped)
 
     def __getstate__(self):
@@ -193,14 +206,20 @@
         if other is None:
             raise RuntimeError("other was None in __eq__")
         return venue_eq(&self._mem, &other._mem)
 
     def __hash__ (self) -> int:
         return venue_hash(&self._mem)
 
+    @staticmethod
+    cdef Venue from_mem_c(Venue_t* mem):
+        cdef Venue venue = Venue.__new__(Venue)
+        venue._mem = venue_clone(mem)
+        return venue
+
     cdef str to_str(self):
         return cstr_to_pystr(venue_to_cstr(&self._mem))
 
 
 cdef class InstrumentId(Identifier):
     """
     Represents a valid instrument ID.
@@ -216,68 +235,72 @@
     """
 
     def __init__(self, Symbol symbol not None, Venue venue not None):
         self._mem = instrument_id_new(
             <Symbol_t *>&symbol._mem,
             <Venue_t *>&venue._mem,
         )
-        self.symbol = symbol
-        self.venue = venue
+
+    @property
+    def symbol(self) -> Symbol:
+        """
+        Returns the instrument ticker symbol.
+
+        Returns
+        -------
+        Symbol
+
+        """
+        return Symbol.from_mem_c(&self._mem.symbol)
+
+    @property
+    def venue(self) -> Venue:
+        """
+        Returns the instrument trading venue.
+
+        Returns
+        -------
+        Venue
+
+        """
+        return Venue.from_mem_c(&self._mem.venue)
 
     def __del__(self) -> None:
         if self._mem.symbol.value != NULL:
             instrument_id_drop(self._mem)  # `self._mem` moved to Rust (then dropped)
 
     def __getstate__(self):
         return self.to_str()
 
     def __setstate__(self, state):
-        cdef list pieces = state.rsplit('.', maxsplit=1)
-
         self._mem = instrument_id_new_from_cstr(
             pystr_to_cstr(state),
         )
-        self.symbol = Symbol(pieces[0])
-        self.venue = Venue(pieces[1])
 
     def __eq__(self, InstrumentId other) -> bool:
         if other is None:
             raise RuntimeError("other was None in __eq__")
         return instrument_id_eq(&self._mem, &other._mem)
 
     def __hash__ (self) -> int:
         return instrument_id_hash(&self._mem)
 
     cdef str to_str(self):
         return cstr_to_pystr(instrument_id_to_cstr(&self._mem))
 
     @staticmethod
     cdef InstrumentId from_mem_c(InstrumentId_t mem):
-        cdef Symbol symbol = Symbol.__new__(Symbol)
-        symbol._mem = symbol_clone(&mem.symbol)
-
-        cdef Venue venue = Venue.__new__(Venue)
-        venue._mem = venue_clone(&mem.venue)
-
         cdef InstrumentId instrument_id = InstrumentId.__new__(InstrumentId)
         instrument_id._mem = instrument_id_clone(&mem)
-        instrument_id.symbol = symbol
-        instrument_id.venue = venue
-
         return instrument_id
 
     @staticmethod
     cdef InstrumentId from_str_c(str value):
-        cdef list pieces = value.rsplit('.', maxsplit=1)
-
         cdef InstrumentId instrument_id = InstrumentId.__new__(InstrumentId)
         instrument_id._mem = instrument_id_new_from_cstr(pystr_to_cstr(value))
-        instrument_id.symbol = Symbol(pieces[0])
-        instrument_id.venue = Venue(pieces[1])
-
         return instrument_id
 
     @staticmethod
     def from_str(value: str) -> InstrumentId:
         """
         Return an instrument ID parsed from the given string value.
         Must be correctly formatted including characters either side of a single
@@ -310,19 +333,19 @@
     Raises
     ------
     ValueError
         If `value` is not a valid string.
 
     Warnings
     --------
-    - The ID value must be unique at the trader level.
-    - Panics at runtime if `value` is not a valid string.
+    The ID value must be unique at the trader level.
     """
 
     def __init__(self, str value not None):
+        Condition.valid_string(value, "value")
         self._mem = component_id_new(pystr_to_cstr(value))
 
     def __del__(self) -> None:
         if self._mem.value != NULL:
             component_id_drop(self._mem)  # `self._mem` moved to Rust (then dropped)
 
     def __getstate__(self):
@@ -355,44 +378,53 @@
     Raises
     ------
     ValueError
         If `value` is not a valid string.
 
     Warnings
     --------
-    - The ID value must be unique at the trader level.
-    - Panics at runtime if `value` is not a valid string.
+    The ID value must be unique at the trader level.
     """
 
     def __init__(self, str value not None):
+        Condition.valid_string(value, "value")
         super().__init__(value)
 
 
 cdef class TraderId(ComponentId):
     """
     Represents a valid trader ID.
 
     Must be correctly formatted with two valid strings either side of a hyphen.
     It is expected a trader ID is the abbreviated name of the trader
     with an order ID tag number separated by a hyphen.
 
     Example: "TESTER-001".
 
+    The reason for the numerical component of the ID is so that order and position IDs
+    do not collide with those from another node instance.
+
     Parameters
     ----------
     value : str
         The trader ID value.
 
+    Raises
+    ------
+    ValueError
+        If `value` is not a valid string containing a hyphen.
+
     Warnings
     --------
-    - The name and tag combination ID value must be unique at the firm level.
-    - Panics at runtime if `value` is not a valid string containing a hyphen.
+    The name and tag combination ID value must be unique at the firm level.
     """
 
     def __init__(self, str value not None):
+        Condition.valid_string(value, "value")
+        Condition.true("-" in value, "value was malformed: did not contain a hyphen '-'")
         super().__init__(value)
 
     cpdef str get_tag(self):
         """
         Return the order ID tag value for this ID.
 
         Returns
@@ -400,39 +432,48 @@
         str
 
         """
         return self.to_str().split("-")[-1]
 
 
 # External strategy ID constant
-cdef StrategyId EXTERNAL_STRATEGY = StrategyId("EXTERNAL")
+cdef StrategyId EXTERNAL_STRATEGY_ID = StrategyId("EXTERNAL")
 
 
 cdef class StrategyId(ComponentId):
     """
     Represents a valid strategy ID.
 
     Must be correctly formatted with two valid strings either side of a hyphen.
     It is expected a strategy ID is the class name of the strategy,
     with an order ID tag number separated by a hyphen.
 
     Example: "EMACross-001".
 
+    The reason for the numerical component of the ID is so that order and position IDs
+    do not collide with those from another strategy within the node instance.
+
     Parameters
     ----------
     value : str
         The strategy ID value.
 
+    Raises
+    ------
+    ValueError
+        If `value` is not a valid string containing a hyphen.
+
     Warnings
     --------
-    - The name and tag combination must be unique at the trader level.
-    - Panics at runtime if `value` is not a valid string containing a hyphen.
+    The name and tag combination must be unique at the trader level.
     """
 
     def __init__(self, str value):
+        Condition.valid_string(value, "value")
+        Condition.true(value == "EXTERNAL" or "-" in value, "value was malformed: did not contain a hyphen '-'")
         super().__init__(value)
 
     cpdef str get_tag(self):
         """
         Return the order ID tag value for this ID.
 
         Returns
@@ -449,40 +490,38 @@
         which did not originate from any strategy being managed by the system.
 
         Returns
         -------
         bool
 
         """
-        return self == EXTERNAL_STRATEGY
+        return self == EXTERNAL_STRATEGY_ID
 
     @staticmethod
     cdef StrategyId external_c():
-        return EXTERNAL_STRATEGY
+        return EXTERNAL_STRATEGY_ID
 
 
 cdef class ExecAlgorithmId(ComponentId):
     """
     Represents a valid execution algorithm ID.
 
     Parameters
     ----------
     value : str
         The execution algorithm ID value.
 
-    Warnings
-    --------
-    - Panics at runtime if `value` is not a valid string.
-
-    References
-    ----------
-    https://www.onixs.biz/fix-dictionary/5.0/tagnum_1003.html
+    Raises
+    ------
+    ValueError
+        If `value` is not a valid string.
     """
 
     def __init__(self, str value not None):
+        Condition.valid_string(value, "value")
         super().__init__(value)
 
 
 
 cdef class AccountId(Identifier):
     """
     Represents a valid account ID.
@@ -494,21 +533,27 @@
     Example: "IB-D02851908".
 
     Parameters
     ----------
     value : str
         The account ID value.
 
+    Raises
+    ------
+    ValueError
+        If `value` is not a valid string containing a hyphen.
+
     Warnings
     --------
-    - The issuer and number ID combination must be unique at the firm level.
-    - Panics at runtime if `value` is not a valid string containing a hyphen.
+    The issuer and number ID combination must be unique at the firm level.
     """
 
     def __init__(self, str value not None):
+        Condition.valid_string(value, "value")
+        Condition.true("-" in value, "value was malformed: did not contain a hyphen '-'")
         self._mem = account_id_new(pystr_to_cstr(value))
 
     def __del__(self) -> None:
         if self._mem.value != NULL:
             account_id_drop(self._mem)  # `self._mem` moved to Rust (then dropped)
 
     def __getstate__(self):
@@ -556,21 +601,26 @@
     Represents a valid client order ID (assigned by the Nautilus system).
 
     Parameters
     ----------
     value : str
         The client order ID value.
 
+    Raises
+    ------
+    ValueError
+        If `value` is not a valid string.
+
     Warnings
     --------
-    - The ID value must be unique at the firm level.
-    - Panics at runtime if `value` is not a valid string.
+    The ID value must be unique at the firm level.
     """
 
     def __init__(self, str value not None):
+        Condition.valid_string(value, "value")
         self._mem = client_order_id_new(pystr_to_cstr(value))
 
     def __del__(self) -> None:
         if self._mem.value != NULL:
             client_order_id_drop(self._mem)  # `self._mem` moved to Rust (then dropped)
 
     def __getstate__(self):
@@ -586,30 +636,54 @@
 
     def __hash__ (self) -> int:
         return client_order_id_hash(&self._mem)
 
     cdef str to_str(self):
         return cstr_to_pystr(client_order_id_to_cstr(&self._mem))
 
+    cpdef bint is_this_trader(self, TraderId trader_id):
+        """
+        Return whether this client order ID is for the given trader ID instance.
+
+        Will compare the given `trader_id.get_tag()` with this identifier.
+
+        Parameters
+        ----------
+        trader_id : TraderId
+            The trader ID to compare with.
+
+        Returns
+        -------
+        bool
+            True if for this instance, else false.
+
+        """
+        cdef list parts = self.to_str().split("-", maxsplit=4)
+        if len(parts) < 4:
+            return False
+        return parts[3] == trader_id.get_tag()
+
 
 cdef class VenueOrderId(Identifier):
     """
     Represents a valid venue order ID (assigned by a trading venue).
 
     Parameters
     ----------
     value : str
         The venue assigned order ID value.
 
-    Warnings
-    --------
-    - Panics at runtime if `value` is not a valid string.
+    Raises
+    ------
+    ValueError
+        If `value` is not a valid string.
     """
 
     def __init__(self, str value not None):
+        Condition.valid_string(value, "value")
         self._mem = venue_order_id_new(pystr_to_cstr(value))
 
     def __del__(self) -> None:
         if self._mem.value != NULL:
             venue_order_id_drop(self._mem)  # `self._mem` moved to Rust (then dropped)
 
     def __getstate__(self):
@@ -635,20 +709,22 @@
     Represents a valid order list ID (assigned by the Nautilus system).
 
     Parameters
     ----------
     value : str
         The order list ID value.
 
-    Warnings
-    --------
-    - Panics at runtime if `value` is not a valid string.
+    Raises
+    ------
+    ValueError
+        If `value` is not a valid string.
     """
 
     def __init__(self, str value not None):
+        Condition.valid_string(value, "value")
         self._mem = order_list_id_new(pystr_to_cstr(value))
 
     def __del__(self) -> None:
         if self._mem.value != NULL:
             order_list_id_drop(self._mem)  # `self._mem` moved to Rust (then dropped)
 
     def __getstate__(self):
@@ -674,20 +750,22 @@
     Represents a valid position ID.
 
     Parameters
     ----------
     value : str
         The position ID value.
 
-    Warnings
-    --------
-    - Panics at runtime if `value` is not a valid string.
+    Raises
+    ------
+    ValueError
+        If `value` is not a valid string containing a hyphen.
     """
 
     def __init__(self, str value not None):
+        Condition.valid_string(value, "value")
         self._mem = position_id_new(pystr_to_cstr(value))
 
     def __del__(self) -> None:
         if self._mem.value != NULL:
             position_id_drop(self._mem)  # `self._mem` moved to Rust (then dropped)
 
     def __getstate__(self):
@@ -727,24 +805,26 @@
     the exchange or central counterparty.
 
     Parameters
     ----------
     value : str
         The trade match ID value.
 
-    Warnings
-    --------
-    - Panics at runtime if `value` is not a valid string.
+    Raises
+    ------
+    ValueError
+        If `value` is not a valid string.
 
     References
     ----------
     https://www.onixs.biz/fix-dictionary/5.0/tagnum_1003.html
     """
 
     def __init__(self, str value not None):
+        Condition.valid_string(value, "value")
         self._mem = trade_id_new(pystr_to_cstr(value))
 
     def __del__(self) -> None:
         if self._mem.value != NULL:
             trade_id_drop(self._mem)  # `self._mem` moved to Rust (then dropped)
 
     def __getstate__(self):
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/instruments/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/model/instruments/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/instruments/base.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/instruments/base.pxd`

 * *Files 6% similar despite different names*

```diff
@@ -9,14 +9,16 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+from libc.stdint cimport uint64_t
+
 from nautilus_trader.core.data cimport Data
 from nautilus_trader.model.currency cimport Currency
 from nautilus_trader.model.enums_c cimport AssetClass
 from nautilus_trader.model.enums_c cimport AssetType
 from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.identifiers cimport Symbol
 from nautilus_trader.model.objects cimport Money
@@ -72,21 +74,26 @@
     """The maker fee rate for the instrument.\n\n:returns: `Decimal`"""
     cdef readonly object taker_fee
     """The taker fee rate for the instrument.\n\n:returns: `Decimal`"""
     cdef readonly str tick_scheme_name
     """The tick scheme name.\n\n:returns: `str` or ``None``"""
     cdef readonly dict info
     """The raw info for the instrument.\n\n:returns: `dict[str, object]`"""
+    cdef readonly uint64_t ts_event
+    """The UNIX timestamp (nanoseconds) when the data event occurred.\n\n:returns: `uint64_t`"""
+    cdef readonly uint64_t ts_init
+    """The UNIX timestamp (nanoseconds) when the object was initialized.\n\n:returns: `uint64_t`"""
 
     @staticmethod
     cdef Instrument base_from_dict_c(dict values)
 
     @staticmethod
     cdef dict base_to_dict_c(Instrument obj)
 
     cpdef Currency get_base_currency(self)
     cpdef Currency get_settlement_currency(self)
     cpdef Price make_price(self, value)
     cpdef Price next_bid_price(self, double value, int num_ticks=*)
     cpdef Price next_ask_price(self, double value, int num_ticks=*)
     cpdef Quantity make_qty(self, value)
-    cpdef Money notional_value(self, Quantity quantity, Price price, bint inverse_as_quote=*)
+    cpdef Money notional_value(self, Quantity quantity, Price price, bint use_quote_for_inverse=*)
+    cpdef Quantity calculate_base_quantity(self, Quantity quantity, Price last_px)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/instruments/base.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/instruments/base.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -189,16 +189,14 @@
         Condition.type(margin_init, Decimal, "margin_init")
         Condition.not_negative(margin_init, "margin_init")
         Condition.type(margin_maint, Decimal, "margin_maint")
         Condition.not_negative(margin_maint, "margin_maint")
         Condition.type(maker_fee, Decimal, "maker_fee")
         Condition.type(taker_fee, Decimal, "taker_fee")
 
-        super().__init__(ts_event, ts_init)
-
         self.id = instrument_id
         self.native_symbol = native_symbol
         self.asset_class = asset_class
         self.asset_type = asset_type
         self.quote_currency = quote_currency
         self.is_inverse = is_inverse
         self.price_precision = price_precision
@@ -215,14 +213,16 @@
         self.max_price = max_price
         self.min_price = min_price
         self.margin_init = margin_init
         self.margin_maint = margin_maint
         self.maker_fee = maker_fee
         self.taker_fee = taker_fee
         self.info = info
+        self.ts_event = ts_event
+        self.ts_init = ts_init
 
         # Assign tick scheme if named
         if self.tick_scheme_name is not None:
             self._tick_scheme = get_tick_scheme(self.tick_scheme_name)
 
     def __eq__(self, Instrument other) -> bool:
         return self.id == other.id
@@ -491,39 +491,63 @@
         """
         return Quantity(float(value), precision=self.size_precision)
 
     cpdef Money notional_value(
         self,
         Quantity quantity,
         Price price,
-        bint inverse_as_quote=False,
+        bint use_quote_for_inverse=False,
     ):
         """
         Calculate the notional value.
 
         Result will be in quote currency for standard instruments, or base
         currency for inverse instruments.
 
         Parameters
         ----------
         quantity : Quantity
             The total quantity.
         price : Price
             The price for the calculation.
-        inverse_as_quote : bool
+        use_quote_for_inverse : bool
             If inverse instrument calculations use quote currency (instead of base).
 
         Returns
         -------
         Money
 
         """
         Condition.not_none(quantity, "quantity")
         Condition.not_none(price, "price")
 
         if self.is_inverse:
-            if inverse_as_quote:
-                # Quantity is notional
+            if use_quote_for_inverse:
+                # Quantity is notional in quote currency
                 return Money(quantity, self.quote_currency)
-            return Money(quantity.as_f64_c() * float(self.multiplier) * (1 / price.as_f64_c()), self.base_currency)
+            return Money(quantity.as_f64_c() * float(self.multiplier) * (1.0 / price.as_f64_c()), self.base_currency)
         else:
             return Money(quantity.as_f64_c() * float(self.multiplier) * price.as_f64_c(), self.quote_currency)
+
+    cpdef Quantity calculate_base_quantity(
+        self,
+        Quantity quantity,
+        Price last_px,
+    ):
+        """
+        Calculate the base asset quantity from the given quote asset `quantity` and last price.
+
+        Parameters
+        ----------
+        quantity : Quantity
+            The quantity to convert from.
+        last_px : Price
+            The last price for the instrument.
+
+        Returns
+        -------
+        Quantity
+
+        """
+        Condition.not_none(quantity, "quantity")
+
+        return Quantity(quantity.as_f64_c() * (1.0 / last_px.as_f64_c()), self.size_precision)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/instruments/betting.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/instruments/betting.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/instruments/betting.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/instruments/betting.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -190,11 +190,11 @@
         Returns
         -------
         dict[str, object]
 
         """
         return BettingInstrument.to_dict_c(obj)
 
-    cpdef Money notional_value(self, Quantity quantity, Price price, bint inverse_as_quote=False):
+    cpdef Money notional_value(self, Quantity quantity, Price price, bint use_quote_for_inverse=False):
         Condition.not_none(quantity, "quantity")
         cdef double bet_price = 1.0 / price.as_f64_c()
         return Money(quantity.as_f64_c() * float(self.multiplier) * bet_price, self.quote_currency)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/instruments/crypto_future.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/instruments/crypto_future.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/instruments/crypto_future.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/instruments/crypto_future.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/instruments/crypto_perpetual.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/instruments/crypto_perpetual.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/instruments/crypto_perpetual.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/instruments/crypto_perpetual.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/instruments/currency_pair.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/instruments/currency_pair.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/instruments/currency_pair.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/instruments/currency_pair.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/instruments/equity.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/instruments/equity.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/instruments/equity.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/instruments/equity.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -59,14 +59,16 @@
         The fee rate for liquidity makers as a percentage of order value.
     taker_fee : Decimal, optional
         The fee rate for liquidity takers as a percentage of order value.
     ts_event : uint64_t
         The UNIX timestamp (nanoseconds) when the data event occurred.
     ts_init : uint64_t
         The UNIX timestamp (nanoseconds) when the data object was initialized.
+    info : dict[str, object], optional
+        The additional instrument information.
 
     Raises
     ------
     ValueError
         If `multiplier` is not positive (> 0).
     ValueError
         If `price_precision` is negative (< 0).
@@ -88,14 +90,15 @@
         uint64_t ts_event,
         uint64_t ts_init,
         str isin: Optional[str] = None,
         margin_init: Optional[Decimal] = None,
         margin_maint: Optional[Decimal] = None,
         maker_fee: Optional[Decimal] = None,
         taker_fee: Optional[Decimal] = None,
+        dict info = None,
     ):
         super().__init__(
             instrument_id=instrument_id,
             native_symbol=native_symbol,
             asset_class=AssetClass.EQUITY,
             asset_type=AssetType.SPOT,
             quote_currency=currency,
@@ -114,15 +117,15 @@
             min_price=None,
             margin_init=margin_init if margin_init else Decimal(0),
             margin_maint=margin_maint if margin_maint else Decimal(0),
             maker_fee=maker_fee if maker_fee else Decimal(0),
             taker_fee=taker_fee if taker_fee else Decimal(0),
             ts_event=ts_event,
             ts_init=ts_init,
-            info={},
+            info=info,
         )
         self.isin = isin
 
     @staticmethod
     cdef Equity from_dict_c(dict values):
         Condition.not_none(values, "values")
         return Equity(
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/instruments/futures_contract.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/instruments/futures_contract.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/instruments/futures_contract.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/instruments/futures_contract.pyx`

 * *Files 5% similar despite different names*

```diff
@@ -57,14 +57,16 @@
         The underlying asset.
     expiry_date : date
         The contract expiry date.
     ts_event : uint64_t
         The UNIX timestamp (nanoseconds) when the data event occurred.
     ts_init : uint64_t
         The UNIX timestamp (nanoseconds) when the data object was initialized.
+    info : dict[str, object], optional
+        The additional instrument information.
 
     Raises
     ------
     ValueError
         If `multiplier` is not positive (> 0).
     ValueError
         If `price_precision` is negative (< 0).
@@ -84,14 +86,15 @@
         Price price_increment not None,
         Quantity multiplier,
         Quantity lot_size not None,
         str underlying,
         date expiry_date,
         uint64_t ts_event,
         uint64_t ts_init,
+        dict info = None,
     ):
         super().__init__(
             instrument_id=instrument_id,
             native_symbol=native_symbol,
             asset_class=asset_class,
             asset_type=AssetType.FUTURE,
             quote_currency=currency,
@@ -110,15 +113,15 @@
             min_price=None,
             margin_init=Decimal(0),
             margin_maint=Decimal(0),
             maker_fee=Decimal(0),
             taker_fee=Decimal(0),
             ts_event=ts_event,
             ts_init=ts_init,
-            info={},
+            info=info,
         )
         self.underlying = underlying
         self.expiry_date = expiry_date
 
     @staticmethod
     cdef FuturesContract from_dict_c(dict values):
         Condition.not_none(values, "values")
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/instruments/options_contract.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/instruments/options_contract.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/instruments/options_contract.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/instruments/options_contract.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -62,14 +62,16 @@
         The underlying asset.
     expiry_date : date
         The option expiry date.
     ts_event : uint64_t
         The UNIX timestamp (nanoseconds) when the data event occurred.
     ts_init : uint64_t
         The UNIX timestamp (nanoseconds) when the data object was initialized.
+    info : dict[str, object], optional
+        The additional instrument information.
 
     Raises
     ------
     ValueError
         If `multiplier` is not positive (> 0).
     ValueError
         If `price_precision` is negative (< 0).
@@ -91,14 +93,15 @@
         Quantity lot_size not None,
         Price strike_price not None,
         str underlying,
         date expiry_date,
         OptionKind kind,
         uint64_t ts_event,
         uint64_t ts_init,
+        dict info = None,
     ):
         Condition.positive_int(multiplier, "multiplier")
         super().__init__(
             instrument_id=instrument_id,
             native_symbol=native_symbol,
             asset_class=asset_class,
             asset_type=AssetType.OPTION,
@@ -118,15 +121,15 @@
             min_price=None,
             margin_init=Decimal(0),
             margin_maint=Decimal(0),
             maker_fee=Decimal(0),
             taker_fee=Decimal(0),
             ts_event=ts_event,
             ts_init=ts_init,
-            info={},
+            info=info,
         )
         self.underlying = underlying
         self.expiry_date = expiry_date
         self.strike_price = strike_price
         self.kind = kind
 
     @staticmethod
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/objects.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/objects.pxd`

 * *Files 2% similar despite different names*

```diff
@@ -50,14 +50,17 @@
     @staticmethod
     cdef bint _compare(a, b, int op)
 
     @staticmethod
     cdef double raw_to_f64_c(uint64_t raw)
 
     @staticmethod
+    cdef Quantity from_mem_c(Quantity_t mem)
+
+    @staticmethod
     cdef Quantity from_raw_c(uint64_t raw, uint8_t precision)
 
     @staticmethod
     cdef Quantity zero_c(uint8_t precision)
 
     @staticmethod
     cdef Quantity from_str_c(str value)
@@ -96,14 +99,17 @@
     @staticmethod
     cdef bint _compare(a, b, int op)
 
     @staticmethod
     cdef double raw_to_f64_c(uint64_t raw)
 
     @staticmethod
+    cdef Price from_mem_c(Price_t mem)
+
+    @staticmethod
     cdef Price from_raw_c(int64_t raw, uint8_t precision)
 
     @staticmethod
     cdef Price from_str_c(str value)
 
     @staticmethod
     cdef Price from_int_c(int value)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/objects.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/objects.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -81,15 +81,15 @@
     - ``QUANTITY_MAX`` = 18_446_744_073
     - ``QUANTITY_MIN`` = 0
 
     Parameters
     ----------
     value : integer, float, string, Decimal
         The value of the quantity.
-    precision : uint8
+    precision : uint8_t
         The precision for the quantity. Use a precision of 0 for whole numbers
         (no fractional units).
 
     Raises
     ------
     ValueError
         If `value` is greater than 18_446_744_073.
@@ -229,15 +229,15 @@
     @property
     def precision(self) -> int:
         """
         Return the precision for the quantity.
 
         Returns
         -------
-        uint8
+        uint8_t
 
         """
         return self._mem.precision
 
     cdef bint eq(self, Quantity other):
         return self._mem.raw == other._mem.raw
 
@@ -292,14 +292,20 @@
         return raw / RUST_FIXED_SCALAR
 
     @staticmethod
     def raw_to_f64(raw) -> float:
         return Quantity.raw_to_f64_c(raw)
 
     @staticmethod
+    cdef Quantity from_mem_c(Quantity_t mem):
+        cdef Quantity quantity = Quantity.__new__(Quantity)
+        quantity._mem = mem
+        return quantity
+
+    @staticmethod
     cdef Quantity from_raw_c(uint64_t raw, uint8_t precision):
         cdef Quantity quantity = Quantity.__new__(Quantity)
         quantity._mem = quantity_from_raw(raw, precision)
         return quantity
 
     @staticmethod
     cdef object _extract_decimal(object obj):
@@ -340,15 +346,15 @@
         return Quantity.from_raw_c(raw, precision)
 
     @staticmethod
     def zero(uint8_t precision=0) -> Quantity:
         """
         Return a quantity with a value of zero.
 
-        precision : uint8, default 0
+        precision : uint8_t, default 0
             The precision for the quantity.
 
         Returns
         -------
         Quantity
 
         Raises
@@ -467,15 +473,15 @@
     - ``PRICE_MAX`` = 9_223_372_036
     - ``PRICE_MIN`` = -9_223_372_036
 
     Parameters
     ----------
     value : integer, float, string or Decimal
         The value of the price.
-    precision : uint8
+    precision : uint8_t
         The precision for the price. Use a precision of 0 for whole numbers
         (no fractional units).
 
     Raises
     ------
     ValueError
         If `value` is greater than 9_223_372_036.
@@ -488,15 +494,15 @@
 
     References
     ----------
     https://www.onixs.biz/fix-dictionary/5.0.SP2/index.html#Price
     """
 
     def __init__(self, double value, uint8_t precision):
-        Condition.true(precision <= 9,f"invalid `precision` greater than max 9, was {precision}")
+        Condition.true(precision <= 9, f"invalid `precision` greater than max 9, was {precision}")
         if value > PRICE_MAX:
             raise ValueError(
                 f"invalid `value` greater than `PRICE_MAX` {PRICE_MAX:_}, was {value:_}",
             )
         if value < PRICE_MIN:
             raise ValueError(
                 f"invalid `value` less than `PRICE_MIX` {PRICE_MIN:_}, was {value:_}",
@@ -615,15 +621,15 @@
     @property
     def precision(self) -> int:
         """
         Return the precision for the price.
 
         Returns
         -------
-        uint8
+        uint8_t
 
         """
         return self._mem.precision
 
     cdef bint eq(self, Price other):
         return self._mem.raw == other._mem.raw
 
@@ -660,14 +666,20 @@
     cdef void add_assign(self, Price other):
         self._mem.raw += other._mem.raw
 
     cdef void sub_assign(self, Price other):
         self._mem.raw -= other._mem.raw
 
     @staticmethod
+    cdef Price from_mem_c(Price_t mem):
+        cdef Price price = Price.__new__(Price)
+        price._mem = mem
+        return price
+
+    @staticmethod
     def from_raw(int64_t raw, uint8_t precision):
         return Price.from_raw_c(raw, precision)
 
     @staticmethod
     cdef Price from_raw_c(int64_t raw, uint8_t precision):
         cdef Price price = Price.__new__(Price)
         price._mem = price_from_raw(raw, precision)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/orderbook/__init__.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/orderbook/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/orderbook/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/model/data/__init__.py`

 * *Files 15% similar despite different names*

```diff
@@ -9,31 +9,43 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-"""
-Defines real-time and simulated order book components and data.
-"""
+"""Defines the fundamental data types represented within the trading domain."""
 
+from nautilus_trader.model.data.bar import Bar
+from nautilus_trader.model.data.bar import BarSpecification
+from nautilus_trader.model.data.bar import BarType
+from nautilus_trader.model.data.bar_aggregation import BarAggregation
+from nautilus_trader.model.data.base import DataType
+from nautilus_trader.model.data.base import GenericData
 from nautilus_trader.model.data.book import BookOrder
 from nautilus_trader.model.data.book import OrderBookDelta
 from nautilus_trader.model.data.book import OrderBookDeltas
-from nautilus_trader.model.data.book import OrderBookSnapshot
-from nautilus_trader.model.orderbook.book import L1OrderBook
-from nautilus_trader.model.orderbook.book import L2OrderBook
-from nautilus_trader.model.orderbook.book import L3OrderBook
-from nautilus_trader.model.orderbook.book import OrderBook
+from nautilus_trader.model.data.tick import QuoteTick
+from nautilus_trader.model.data.tick import TradeTick
+from nautilus_trader.model.data.ticker import Ticker
+from nautilus_trader.model.data.venue import InstrumentClose
+from nautilus_trader.model.data.venue import InstrumentStatusUpdate
+from nautilus_trader.model.data.venue import VenueStatusUpdate
 
 
 __all__ = [
+    "Bar",
+    "BarSpecification",
+    "BarType",
+    "GenericData",
+    "BarAggregation",
+    "DataType",
     "BookOrder",
     "OrderBookDelta",
     "OrderBookDeltas",
-    "OrderBookSnapshot",
-    "L1OrderBook",
-    "L2OrderBook",
-    "L3OrderBook",
-    "OrderBook",
+    "QuoteTick",
+    "Ticker",
+    "TradeTick",
+    "InstrumentClose",
+    "InstrumentStatusUpdate",
+    "VenueStatusUpdate",
 ]
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/orderbook/error.py` & `nautilus_trader-1.175.0/nautilus_trader/trading/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -9,12 +9,14 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+"""
+The `trading` subpackage groups all trading domain specific components and tooling.
 
-class BookIntegrityError(Exception):
-    """
-    Represents an error condition where the order books integrity has been lost.
-    """
+This is a top-level package where the majority of users will interface with the
+framework. Custom trading strategies can be implemented by inheriting from the
+`Strategy` base class.
+"""
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/orderbook/ladder.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/orders/limit_if_touched.pxd`

 * *Files 24% similar despite different names*

```diff
@@ -9,60 +9,34 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-import cython
+from libc.stdint cimport uint64_t
 
-from libc.stdint cimport uint8_t
+from nautilus_trader.model.enums_c cimport TriggerType
+from nautilus_trader.model.events.order cimport OrderInitialized
+from nautilus_trader.model.objects cimport Price
+from nautilus_trader.model.objects cimport Quantity
+from nautilus_trader.model.orders.base cimport Order
+
+
+cdef class LimitIfTouchedOrder(Order):
+    cdef readonly Price price
+    """The order price (LIMIT).\n\n:returns: `Price`"""
+    cdef readonly Price trigger_price
+    """The order trigger price (STOP).\n\n:returns: `Price`"""
+    cdef readonly TriggerType trigger_type
+    """The trigger type for the order.\n\n:returns: `TriggerType`"""
+    cdef readonly uint64_t expire_time_ns
+    """The order expiration (UNIX epoch nanoseconds), zero for no expiration.\n\n:returns: `uint64_t`"""
+    cdef readonly Quantity display_qty
+    """The quantity of the ``LIMIT`` order to display on the public book (iceberg).\n\n:returns: `Quantity` or ``None``"""  # noqa
+    cdef readonly bint is_triggered
+    """If the order has been triggered.\n\n:returns: `bool`"""
+    cdef readonly uint64_t ts_triggered
+    """The UNIX timestamp (nanoseconds) when the order was triggered (0 if not triggered).\n\n:returns: `uint64_t`"""
 
-from nautilus_trader.model.data.book cimport BookOrder
-from nautilus_trader.model.enums_c cimport DepthType
-from nautilus_trader.model.orderbook.level cimport Level
-
-
-cdef class Ladder:
-    cdef dict _order_id_level_index
-
-    cdef readonly list levels
-    """The ladders levels.\n\n:returns: `list[Level]`"""
-    cdef readonly bint is_reversed
-    """If the ladder is in reverse order.\n\n:returns: `bool`"""
-    cdef readonly uint8_t price_precision
-    """The ladders price precision.\n\n:returns: `uint8`"""
-    cdef readonly uint8_t size_precision
-    """The ladders size precision.\n\n:returns: `uint8`"""
-
-    cpdef void add(self, BookOrder order)
-    cpdef void update(self, BookOrder order)
-    cpdef void delete(self, BookOrder order)
-    cpdef list depth(self, int n=*)
-    cpdef list prices(self)
-    cpdef list volumes(self)
-    cpdef list exposures(self)
-    cpdef Level top(self)
-    cpdef list simulate_order_fills(self, BookOrder order, DepthType depth_type=*)
-
-
-@cython.boundscheck(False)
-@cython.wraparound(False)
-cdef inline int bisect_right(list a, double x, int lo = 0, hi = None):
-    # Return the index where to insert item x in list `a`, assuming `a` is sorted.
-    # The return value `i` is such that all e in `a[:i]` have `e` <= `x`, and all `e` in
-    # `a[i:]` have `e` > `x`.  So if `x` already appears in the list, `a.insert(i, x)` will
-    # insert just after the rightmost `x` already there.
-    # Optional args `lo` (default 0) and `hi` (default len(a)) bound the
-    # slice of `a` to be searched.
-    if hi is None:
-        hi = len(a)
-    # Note, the comparison uses "<" to match the
-    # __lt__() logic in list.sort() and in heapq.
-    cdef int mid
-    while lo < hi:
-        mid = (lo + hi) // 2
-        if x < a[mid]:
-            hi = mid
-        else:
-            lo = mid + 1
-    return lo
+    @staticmethod
+    cdef LimitIfTouchedOrder create(OrderInitialized init)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/orderbook/level.pxd` & `nautilus_trader-1.175.0/nautilus_trader/serialization/base.pxd`

 * *Files 21% similar despite different names*

```diff
@@ -9,23 +9,14 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.model.data.book cimport BookOrder
+cdef dict _OBJECT_TO_DICT_MAP
+cdef dict _OBJECT_FROM_DICT_MAP
 
 
-cdef class Level:
-    cdef readonly double price
-    """The levels price.\n\n:returns: `double`"""
-    cdef readonly list orders
-    """The orders at the level.\n\n:returns: `list[Order]`"""
-
-    cpdef void bulk_add(self, list orders)
-    cpdef void add(self, BookOrder order)
-    cpdef void update(self, BookOrder order)
-    cpdef void delete(self, BookOrder order)
-
-    cpdef double volume(self)
-    cpdef double exposure(self)
+cdef class Serializer:
+    cpdef bytes serialize(self, object obj)
+    cpdef object deserialize(self, bytes obj_bytes)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/orderbook/simulated.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/orders/market.pxd`

 * *Files 24% similar despite different names*

```diff
@@ -9,23 +9,19 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.model.orderbook.book cimport L1OrderBook
-from nautilus_trader.model.orderbook.book cimport L2OrderBook
-from nautilus_trader.model.orderbook.book cimport L3OrderBook
+from libc.stdint cimport uint64_t
 
+from nautilus_trader.model.events.order cimport OrderInitialized
+from nautilus_trader.model.orders.base cimport Order
 
-cdef class SimulatedL1OrderBook(L1OrderBook):
-    cdef void _update_bid(self, double price, double size)
-    cdef void _update_ask(self, double price, double size)
 
+cdef class MarketOrder(Order):
+    @staticmethod
+    cdef MarketOrder create(OrderInitialized init)
 
-cdef class SimulatedL2OrderBook(L2OrderBook):
-    pass
-
-
-cdef class SimulatedL3OrderBook(L3OrderBook):
-    pass
+    @staticmethod
+    cdef MarketOrder transform(Order order, uint64_t ts_init)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/orders/__init__.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/orders/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/orders/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/model/orders/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/orders/base.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/orders/base.pxd`

 * *Files 3% similar despite different names*

```diff
@@ -86,26 +86,30 @@
     """The order time in force.\n\n:returns: `TimeInForce`"""
     cdef readonly LiquiditySide liquidity_side
     """The order liquidity side.\n\n:returns: `LiquiditySide`"""
     cdef readonly bint is_post_only
     """If the order will only provide liquidity (make a market).\n\n:returns: `bool`"""
     cdef readonly bint is_reduce_only
     """If the order carries the 'reduce-only' execution instruction.\n\n:returns: `bool`"""
+    cdef readonly bint is_quote_quantity
+    """If the order quantity is denominated in the quote currency.\n\n:returns: `bool`"""
     cdef readonly Quantity quantity
     """The order quantity.\n\n:returns: `Quantity`"""
     cdef readonly Quantity filled_qty
     """The order total filled quantity.\n\n:returns: `Quantity`"""
     cdef readonly Quantity leaves_qty
     """The order total leaves quantity.\n\n:returns: `Quantity`"""
     cdef readonly double avg_px
     """The order average fill price.\n\n:returns: `double`"""
     cdef readonly double slippage
     """The order total price slippage.\n\n:returns: `double`"""
     cdef readonly TriggerType emulation_trigger
     """The order emulation trigger type.\n\n:returns: `TriggerType`"""
+    cdef readonly InstrumentId trigger_instrument_id
+    """The order emulation trigger instrument ID (will be `instrument_id` if ``None``).\n\n:returns: `InstrumentId` or ``None``"""
     cdef readonly ContingencyType contingency_type
     """The orders contingency type.\n\n:returns: `ContingencyType`"""
     cdef readonly OrderListId order_list_id
     """The order list ID associated with the order.\n\n:returns: `OrderListId` or ``None``"""
     cdef readonly list linked_order_ids
     """The orders linked client order ID(s).\n\n:returns: `list[ClientOrderId]` or ``None``"""
     cdef readonly ClientOrderId parent_order_id
@@ -144,14 +148,16 @@
     cdef bint has_price_c(self)
     cdef bint has_trigger_price_c(self)
     cdef bint is_buy_c(self)
     cdef bint is_sell_c(self)
     cdef bint is_passive_c(self)
     cdef bint is_aggressive_c(self)
     cdef bint is_emulated_c(self)
+    cdef bint is_primary_c(self)
+    cdef bint is_spawned_c(self)
     cdef bint is_contingency_c(self)
     cdef bint is_parent_order_c(self)
     cdef bint is_child_order_c(self)
     cdef bint is_open_c(self)
     cdef bint is_canceled_c(self)
     cdef bint is_closed_c(self)
     cdef bint is_inflight_c(self)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/orders/base.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/orders/base.pyx`

 * *Files 5% similar despite different names*

```diff
@@ -167,15 +167,17 @@
         self.side = init.side
         self.order_type = init.order_type
         self.quantity = init.quantity
         self.time_in_force = init.time_in_force
         self.liquidity_side = LiquiditySide.NO_LIQUIDITY_SIDE
         self.is_post_only = init.post_only
         self.is_reduce_only = init.reduce_only
+        self.is_quote_quantity = init.quote_quantity
         self.emulation_trigger = init.emulation_trigger
+        self.trigger_instrument_id = init.trigger_instrument_id
         self.contingency_type = init.contingency_type
         self.order_list_id = init.order_list_id  # Can be None
         self.linked_order_ids = init.linked_order_ids  # Can be None
         self.parent_order_id = init.parent_order_id  # Can be None
         self.exec_algorithm_id = init.exec_algorithm_id  # Can be None
         self.exec_algorithm_params = init.exec_algorithm_params  # Can be None
         self.exec_spawn_id = init.exec_spawn_id  # Can be None
@@ -300,14 +302,20 @@
 
     cdef bint is_aggressive_c(self):
         return self.order_type == OrderType.MARKET
 
     cdef bint is_emulated_c(self):
         return self.emulation_trigger != TriggerType.NO_TRIGGER
 
+    cdef bint is_primary_c(self):
+        return self.exec_algorithm_id is not None and self.exec_spawn_id is None
+
+    cdef bint is_spawned_c(self):
+        return self.exec_spawn_id is not None
+
     cdef bint is_contingency_c(self):
         return self.contingency_type != ContingencyType.NO_CONTINGENCY
 
     cdef bint is_parent_order_c(self):
         return self.contingency_type == ContingencyType.OTO
 
     cdef bint is_child_order_c(self):
@@ -552,14 +560,38 @@
         -------
         bool
 
         """
         return self.is_emulated_c()
 
     @property
+    def is_primary(self):
+        """
+        Return whether the order is the primary for an execution algorithm sequence.
+
+        Returns
+        -------
+        bool
+
+        """
+        return self.is_primary_c()
+
+    @property
+    def is_spawned(self):
+        """
+        Return whether the order was spawned as part of an execution algorithm sequence.
+
+        Returns
+        -------
+        bool
+
+        """
+        return self.is_spawned_c()
+
+    @property
     def is_contingency(self):
         """
         Return whether the order has a contingency (`contingency_type` is not ``NO_CONTINGENCY``).
 
         Returns
         -------
         bool
@@ -595,16 +627,16 @@
     def is_inflight(self):
         """
         Return whether the order is in-flight (order request sent to the trading venue).
 
         An order is considered in-flight when its status is any of;
 
         - ``SUBMITTED``
-        - ``PENDING_CANCEL``
         - ``PENDING_UPDATE``
+        - ``PENDING_CANCEL``
 
         Returns
         -------
         bool
 
         Warnings
         --------
@@ -618,16 +650,16 @@
         """
         Return whether the order is open at the trading venue.
 
         An order is considered open when its status is any of;
 
         - ``ACCEPTED``
         - ``TRIGGERED``
-        - ``PENDING_CANCEL``
         - ``PENDING_UPDATE``
+        - ``PENDING_CANCEL``
         - ``PARTIALLY_FILLED``
 
         Returns
         -------
         bool
 
         Warnings
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/orders/limit.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/orders/limit.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/orders/limit.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/orders/limit.pyx`

 * *Files 6% similar despite different names*

```diff
@@ -80,16 +80,22 @@
         The order time in force.
     expire_time_ns : uint64_t, default 0 (no expiry)
         The UNIX timestamp (nanoseconds) when the order will expire.
     post_only : bool, default False
         If the order will only provide liquidity (make a market).
     reduce_only : bool, default False
         If the order carries the 'reduce-only' execution instruction.
+    quote_quantity : bool, default False
+        If the order quantity is denominated in the quote currency.
     display_qty : Quantity, optional
         The quantity of the order to display on the public book (iceberg).
+    emulation_trigger : EmulationTrigger, default ``NO_TRIGGER``
+        The emulation trigger for the order.
+    trigger_instrument_id : InstrumentId, optional
+        The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
     contingency_type : ContingencyType, default ``NO_CONTINGENCY``
         The order contingency type.
     order_list_id : OrderListId, optional
         The order list ID associated with the order.
     linked_order_ids : list[ClientOrderId], optional
         The order linked client order ID(s).
     parent_order_id : ClientOrderId, optional
@@ -131,16 +137,18 @@
         Price price not None,
         UUID4 init_id not None,
         uint64_t ts_init,
         TimeInForce time_in_force = TimeInForce.GTC,
         uint64_t expire_time_ns = 0,
         bint post_only = False,
         bint reduce_only = False,
+        bint quote_quantity = False,
         Quantity display_qty = None,
         TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
+        InstrumentId trigger_instrument_id = None,
         ContingencyType contingency_type = ContingencyType.NO_CONTINGENCY,
         OrderListId order_list_id = None,
         list linked_order_ids = None,
         ClientOrderId parent_order_id = None,
         ExecAlgorithmId exec_algorithm_id = None,
         dict exec_algorithm_params = None,
         ClientOrderId exec_spawn_id = None,
@@ -173,16 +181,18 @@
             client_order_id=client_order_id,
             order_side=order_side,
             order_type=OrderType.LIMIT,
             quantity=quantity,
             time_in_force=time_in_force,
             post_only=post_only,
             reduce_only=reduce_only,
+            quote_quantity=quote_quantity,
             options=options,
             emulation_trigger=emulation_trigger,
+            trigger_instrument_id=trigger_instrument_id,
             contingency_type=contingency_type,
             order_list_id=order_list_id,
             linked_order_ids=linked_order_ids,
             parent_order_id=parent_order_id,
             exec_algorithm_id=exec_algorithm_id,
             exec_algorithm_params=exec_algorithm_params,
             exec_spawn_id=exec_spawn_id,
@@ -277,16 +287,18 @@
             "filled_qty": str(self.filled_qty),
             "liquidity_side": liquidity_side_to_str(self.liquidity_side),
             "avg_px": str(self.avg_px),
             "slippage": str(self.slippage),
             "status": self._fsm.state_string_c(),
             "is_post_only": self.is_post_only,
             "is_reduce_only": self.is_reduce_only,
+            "is_quote_quantity": self.is_quote_quantity,
             "display_qty": str(self.display_qty) if self.display_qty is not None else None,
             "emulation_trigger": trigger_type_to_str(self.emulation_trigger),
+            "trigger_instrument_id": self.trigger_instrument_id.to_str() if self.trigger_instrument_id is not None else None,
             "contingency_type": contingency_type_to_str(self.contingency_type),
             "order_list_id": self.order_list_id.to_str() if self.order_list_id is not None else None,
             "linked_order_ids": ",".join([o.to_str() for o in self.linked_order_ids]) if self.linked_order_ids is not None else None,  # noqa
             "parent_order_id": self.parent_order_id.to_str() if self.parent_order_id is not None else None,
             "exec_algorithm_id": self.exec_algorithm_id.to_str() if self.exec_algorithm_id is not None else None,
             "exec_algorithm_params": msgspec.json.encode(self.exec_algorithm_params) if self.exec_algorithm_params is not None else None,  # noqa
             "exec_spawn_id": self.exec_spawn_id.to_str() if self.exec_spawn_id is not None else None,
@@ -330,16 +342,18 @@
             price=Price.from_str_c(init.options["price"]),
             init_id=init.id,
             ts_init=init.ts_init,
             time_in_force=init.time_in_force,
             expire_time_ns=init.options["expire_time_ns"],
             post_only=init.post_only,
             reduce_only=init.reduce_only,
+            quote_quantity=init.quote_quantity,
             display_qty=Quantity.from_str_c(display_qty_str) if display_qty_str is not None else None,
             emulation_trigger=init.emulation_trigger,
+            trigger_instrument_id=init.trigger_instrument_id,
             contingency_type=init.contingency_type,
             order_list_id=init.order_list_id,
             linked_order_ids=init.linked_order_ids,
             parent_order_id=init.parent_order_id,
             exec_algorithm_id=init.exec_algorithm_id,
             exec_algorithm_params=init.exec_algorithm_params,
             exec_spawn_id=init.exec_spawn_id,
@@ -386,14 +400,15 @@
             price=price or order.price,
             time_in_force=order.time_in_force,
             expire_time_ns=order.expire_time_ns if hasattr(order, "expire_time_ns") else 0,
             init_id=UUID4(),
             ts_init=ts_init,
             post_only=order.is_post_only if hasattr(order, "is_post_only") else False,
             reduce_only=order.is_reduce_only,
+            quote_quantity=order.is_quote_quantity,
             display_qty=order.display_qty if hasattr(order, "display_qty") else None,
             contingency_type=order.contingency_type,
             order_list_id=order.order_list_id,
             linked_order_ids=order.linked_order_ids,
             parent_order_id=order.parent_order_id,
             exec_algorithm_id=order.exec_algorithm_id,
             exec_algorithm_params=order.exec_algorithm_params,
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/orders/limit_if_touched.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/orders/stop_limit.pxd`

 * *Files 6% similar despite different names*

```diff
@@ -18,15 +18,15 @@
 from nautilus_trader.model.enums_c cimport TriggerType
 from nautilus_trader.model.events.order cimport OrderInitialized
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.objects cimport Quantity
 from nautilus_trader.model.orders.base cimport Order
 
 
-cdef class LimitIfTouchedOrder(Order):
+cdef class StopLimitOrder(Order):
     cdef readonly Price price
     """The order price (LIMIT).\n\n:returns: `Price`"""
     cdef readonly Price trigger_price
     """The order trigger price (STOP).\n\n:returns: `Price`"""
     cdef readonly TriggerType trigger_type
     """The trigger type for the order.\n\n:returns: `TriggerType`"""
     cdef readonly uint64_t expire_time_ns
@@ -35,8 +35,8 @@
     """The quantity of the ``LIMIT`` order to display on the public book (iceberg).\n\n:returns: `Quantity` or ``None``"""  # noqa
     cdef readonly bint is_triggered
     """If the order has been triggered.\n\n:returns: `bool`"""
     cdef readonly uint64_t ts_triggered
     """The UNIX timestamp (nanoseconds) when the order was triggered (0 if not triggered).\n\n:returns: `uint64_t`"""
 
     @staticmethod
-    cdef LimitIfTouchedOrder create(OrderInitialized init)
+    cdef StopLimitOrder create(OrderInitialized init)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/orders/limit_if_touched.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/orders/limit_if_touched.pyx`

 * *Files 4% similar despite different names*

```diff
@@ -88,16 +88,22 @@
         The order time in force.
     expire_time_ns : uint64_t, default 0 (no expiry)
         The UNIX timestamp (nanoseconds) when the order will expire.
     post_only : bool, default False
         If the ``LIMIT`` order will only provide liquidity (once triggered).
     reduce_only : bool, default False
         If the ``LIMIT`` order carries the 'reduce-only' execution instruction.
+    quote_quantity : bool, default False
+        If the order quantity is denominated in the quote currency.
     display_qty : Quantity, optional
         The quantity of the ``LIMIT`` order to display on the public book (iceberg).
+    emulation_trigger : EmulationTrigger, default ``NO_TRIGGER``
+        The emulation trigger for the order.
+    trigger_instrument_id : InstrumentId, optional
+        The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
     contingency_type : ContingencyType, default ``NO_CONTINGENCY``
         The order contingency type.
     order_list_id : OrderListId, optional
         The order list ID associated with the order.
     linked_order_ids : list[ClientOrderId], optional
         The order linked client order ID(s).
     parent_order_id : ClientOrderId, optional
@@ -145,16 +151,18 @@
         TriggerType trigger_type,
         UUID4 init_id not None,
         uint64_t ts_init,
         TimeInForce time_in_force = TimeInForce.GTC,
         uint64_t expire_time_ns = 0,
         bint post_only = False,
         bint reduce_only = False,
+        bint quote_quantity = False,
         Quantity display_qty = None,
         TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
+        InstrumentId trigger_instrument_id = None,
         ContingencyType contingency_type = ContingencyType.NO_CONTINGENCY,
         OrderListId order_list_id = None,
         list linked_order_ids = None,
         ClientOrderId parent_order_id = None,
         ExecAlgorithmId exec_algorithm_id = None,
         dict exec_algorithm_params = None,
         ClientOrderId exec_spawn_id = None,
@@ -193,16 +201,18 @@
             client_order_id=client_order_id,
             order_side=order_side,
             order_type=OrderType.LIMIT_IF_TOUCHED,
             quantity=quantity,
             time_in_force=time_in_force,
             post_only=post_only,
             reduce_only=reduce_only,
+            quote_quantity=quote_quantity,
             options=options,
             emulation_trigger=emulation_trigger,
+            trigger_instrument_id=trigger_instrument_id,
             contingency_type=contingency_type,
             order_list_id=order_list_id,
             linked_order_ids=linked_order_ids,
             parent_order_id=parent_order_id,
             exec_algorithm_id=exec_algorithm_id,
             exec_algorithm_params=exec_algorithm_params,
             exec_spawn_id=exec_spawn_id,
@@ -309,16 +319,18 @@
             "filled_qty": str(self.filled_qty),
             "liquidity_side": liquidity_side_to_str(self.liquidity_side),
             "avg_px": str(self.avg_px),
             "slippage": str(self.slippage),
             "status": self._fsm.state_string_c(),
             "is_post_only": self.is_post_only,
             "is_reduce_only": self.is_reduce_only,
+            "is_quote_quantity": self.is_quote_quantity,
             "display_qty": str(self.display_qty) if self.display_qty is not None else None,
             "emulation_trigger": trigger_type_to_str(self.emulation_trigger),
+            "trigger_instrument_id": self.trigger_instrument_id.to_str() if self.trigger_instrument_id is not None else None,
             "contingency_type": contingency_type_to_str(self.contingency_type),
             "order_list_id": self.order_list_id.to_str() if self.order_list_id is not None else None,
             "linked_order_ids": ",".join([o.to_str() for o in self.linked_order_ids]) if self.linked_order_ids is not None else None,  # noqa
             "parent_order_id": self.parent_order_id.to_str() if self.parent_order_id is not None else None,
             "exec_algorithm_id": self.exec_algorithm_id.to_str() if self.exec_algorithm_id is not None else None,
             "exec_algorithm_params": msgspec.json.encode(self.exec_algorithm_params) if self.exec_algorithm_params is not None else None,  # noqa
             "exec_spawn_id": self.exec_spawn_id.to_str() if self.exec_spawn_id is not None else None,
@@ -364,16 +376,18 @@
             trigger_type=trigger_type_from_str(init.options["trigger_type"]),
             time_in_force=init.time_in_force,
             expire_time_ns=init.options["expire_time_ns"],
             init_id=init.id,
             ts_init=init.ts_init,
             post_only=init.post_only,
             reduce_only=init.reduce_only,
+            quote_quantity=init.quote_quantity,
             display_qty=Quantity.from_str_c(display_qty_str) if display_qty_str is not None else None,
             emulation_trigger=init.emulation_trigger,
+            trigger_instrument_id=init.trigger_instrument_id,
             contingency_type=init.contingency_type,
             order_list_id=init.order_list_id,
             linked_order_ids=init.linked_order_ids,
             parent_order_id=init.parent_order_id,
             exec_algorithm_id=init.exec_algorithm_id,
             exec_spawn_id=init.exec_spawn_id,
             tags=init.tags,
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/orders/list.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/orders/list.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/orders/list.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/orders/list.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/orders/market.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/orders/unpacker.pxd`

 * *Files 12% similar despite different names*

```diff
@@ -9,19 +9,18 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from libc.stdint cimport uint64_t
-
 from nautilus_trader.model.events.order cimport OrderInitialized
 from nautilus_trader.model.orders.base cimport Order
 
 
-cdef class MarketOrder(Order):
+cdef class OrderUnpacker:
+
     @staticmethod
-    cdef MarketOrder create(OrderInitialized init)
+    cdef Order unpack_c(dict values)
 
     @staticmethod
-    cdef MarketOrder transform(Order order, uint64_t ts_init)
+    cdef Order from_init_c(OrderInitialized init)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/orders/market.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/orders/market.pyx`

 * *Files 7% similar despite different names*

```diff
@@ -71,14 +71,16 @@
         The order initialization event ID.
     ts_init : uint64_t
         The UNIX timestamp (nanoseconds) when the object was initialized.
     time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``DAY``, ``AT_THE_OPEN``, ``AT_THE_CLOSE``}, default ``GTC``
         The order time in force.
     reduce_only : bool, default False
         If the order carries the 'reduce-only' execution instruction.
+    quote_quantity : bool, default False
+        If the order quantity is denominated in the quote currency.
     contingency_type : ContingencyType, default ``NO_CONTINGENCY``
         The order contingency type.
     order_list_id : OrderListId, optional
         The order list ID associated with the order.
     linked_order_ids : list[ClientOrderId], optional
         The order linked client order ID(s).
     parent_order_id : ClientOrderId, optional
@@ -115,14 +117,15 @@
         ClientOrderId client_order_id not None,
         OrderSide order_side,
         Quantity quantity not None,
         UUID4 init_id not None,
         uint64_t ts_init,
         TimeInForce time_in_force = TimeInForce.GTC,
         bint reduce_only = False,
+        bint quote_quantity = False,
         ContingencyType contingency_type = ContingencyType.NO_CONTINGENCY,
         OrderListId order_list_id = None,
         list linked_order_ids = None,
         ClientOrderId parent_order_id = None,
         ExecAlgorithmId exec_algorithm_id = None,
         dict exec_algorithm_params = None,
         ClientOrderId exec_spawn_id = None,
@@ -139,16 +142,18 @@
             client_order_id=client_order_id,
             order_side=order_side,
             order_type=OrderType.MARKET,
             quantity=quantity,
             time_in_force=time_in_force,
             post_only=False,
             reduce_only=reduce_only,
+            quote_quantity=quote_quantity,
             options={},
             emulation_trigger=TriggerType.NO_TRIGGER,
+            trigger_instrument_id=None,
             contingency_type=contingency_type,
             order_list_id=order_list_id,
             linked_order_ids=linked_order_ids,
             parent_order_id=parent_order_id,
             exec_algorithm_id=exec_algorithm_id,
             exec_algorithm_params=exec_algorithm_params,
             exec_spawn_id=exec_spawn_id,
@@ -203,15 +208,16 @@
             "position_id": self.position_id.to_str() if self.position_id is not None else None,
             "account_id": self.account_id.to_str() if self.account_id is not None else None,
             "last_trade_id": self.last_trade_id.to_str() if self.last_trade_id is not None else None,
             "type": order_type_to_str(self.order_type),
             "side": order_side_to_str(self.side),
             "quantity": str(self.quantity),
             "time_in_force": time_in_force_to_str(self.time_in_force),
-            "reduce_only": self.is_reduce_only,
+            "is_reduce_only": self.is_reduce_only,
+            "is_quote_quantity": self.is_quote_quantity,
             "filled_qty": str(self.filled_qty),
             "avg_px": str(self.avg_px),
             "slippage": str(self.slippage),
             "status": self._fsm.state_string_c(),
             "contingency_type": contingency_type_to_str(self.contingency_type),
             "order_list_id": self.order_list_id.to_str() if self.order_list_id is not None else None,
             "linked_order_ids": ",".join([o.to_str() for o in self.linked_order_ids]) if self.linked_order_ids is not None else None,  # noqa
@@ -252,14 +258,15 @@
             strategy_id=init.strategy_id,
             instrument_id=init.instrument_id,
             client_order_id=init.client_order_id,
             order_side=init.side,
             quantity=init.quantity,
             time_in_force=init.time_in_force,
             reduce_only=init.reduce_only,
+            quote_quantity=init.quote_quantity,
             init_id=init.id,
             ts_init=init.ts_init,
             contingency_type=init.contingency_type,
             order_list_id=init.order_list_id,
             linked_order_ids=init.linked_order_ids,
             parent_order_id=init.parent_order_id,
             exec_algorithm_id=init.exec_algorithm_id,
@@ -296,14 +303,15 @@
             strategy_id=order.strategy_id,
             instrument_id=order.instrument_id,
             client_order_id=order.client_order_id,
             order_side=order.side,
             quantity=order.quantity,
             time_in_force=order.time_in_force if order.time_in_force != TimeInForce.GTD else TimeInForce.GTC,
             reduce_only=order.is_reduce_only,
+            quote_quantity=order.is_quote_quantity,
             init_id=UUID4(),
             ts_init=ts_init,
             contingency_type=order.contingency_type,
             order_list_id=order.order_list_id,
             linked_order_ids=order.linked_order_ids,
             parent_order_id=order.parent_order_id,
             exec_algorithm_id=order.exec_algorithm_id,
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/orders/market_if_touched.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/orders/market_if_touched.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/orders/market_if_touched.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/orders/market_if_touched.pyx`

 * *Files 4% similar despite different names*

```diff
@@ -80,14 +80,20 @@
         The UNIX timestamp (nanoseconds) when the object was initialized.
     time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``}, default ``GTC``
         The order time in force.
     expire_time_ns : uint64_t, default 0 (no expiry)
         The UNIX timestamp (nanoseconds) when the order will expire.
     reduce_only : bool, default False
         If the order carries the 'reduce-only' execution instruction.
+    quote_quantity : bool, default False
+        If the order quantity is denominated in the quote currency.
+    emulation_trigger : EmulationTrigger, default ``NO_TRIGGER``
+        The emulation trigger for the order.
+    trigger_instrument_id : InstrumentId, optional
+        The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
     contingency_type : ContingencyType, default ``NO_CONTINGENCY``
         The order contingency type.
     order_list_id : OrderListId, optional
         The order list ID associated with the order.
     linked_order_ids : list[ClientOrderId], optional
         The order linked client order ID(s).
     parent_order_id : ClientOrderId, optional
@@ -131,15 +137,17 @@
         Price trigger_price not None,
         TriggerType trigger_type,
         UUID4 init_id not None,
         uint64_t ts_init,
         TimeInForce time_in_force = TimeInForce.GTC,
         uint64_t expire_time_ns = 0,
         bint reduce_only = False,
+        bint quote_quantity = False,
         TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
+        InstrumentId trigger_instrument_id = None,
         ContingencyType contingency_type = ContingencyType.NO_CONTINGENCY,
         OrderListId order_list_id = None,
         list linked_order_ids = None,
         ClientOrderId parent_order_id = None,
         ExecAlgorithmId exec_algorithm_id = None,
         dict exec_algorithm_params = None,
         ClientOrderId exec_spawn_id = None,
@@ -172,16 +180,18 @@
             client_order_id=client_order_id,
             order_side=order_side,
             order_type=OrderType.MARKET_IF_TOUCHED,
             quantity=quantity,
             time_in_force=time_in_force,
             post_only=False,
             reduce_only=reduce_only,
+            quote_quantity=quote_quantity,
             options=options,
             emulation_trigger=emulation_trigger,
+            trigger_instrument_id=trigger_instrument_id,
             contingency_type=contingency_type,
             order_list_id=order_list_id,
             linked_order_ids=linked_order_ids,
             parent_order_id=parent_order_id,
             exec_algorithm_id=exec_algorithm_id,
             exec_algorithm_params=exec_algorithm_params,
             exec_spawn_id=exec_spawn_id,
@@ -276,15 +286,17 @@
             "time_in_force": time_in_force_to_str(self.time_in_force),
             "filled_qty": str(self.filled_qty),
             "liquidity_side": liquidity_side_to_str(self.liquidity_side),
             "avg_px": str(self.avg_px),
             "slippage": str(self.slippage),
             "status": self._fsm.state_string_c(),
             "is_reduce_only": self.is_reduce_only,
+            "is_quote_quantity": self.is_quote_quantity,
             "emulation_trigger": trigger_type_to_str(self.emulation_trigger),
+            "trigger_instrument_id": self.trigger_instrument_id.to_str() if self.trigger_instrument_id is not None else None,
             "contingency_type": contingency_type_to_str(self.contingency_type),
             "order_list_id": self.order_list_id.to_str() if self.order_list_id is not None else None,
             "linked_order_ids": ",".join([o.to_str() for o in self.linked_order_ids]) if self.linked_order_ids is not None else None,  # noqa
             "parent_order_id": self.parent_order_id.to_str() if self.parent_order_id is not None else None,
             "exec_algorithm_id": self.exec_algorithm_id.to_str() if self.exec_algorithm_id is not None else None,
             "exec_algorithm_params": msgspec.json.encode(self.exec_algorithm_params) if self.exec_algorithm_params is not None else None,  # noqa
             "exec_spawn_id": self.exec_spawn_id.to_str() if self.exec_spawn_id is not None else None,
@@ -326,15 +338,17 @@
             trigger_price=Price.from_str_c(init.options["trigger_price"]),
             trigger_type=trigger_type_from_str(init.options["trigger_type"]),
             time_in_force=init.time_in_force,
             expire_time_ns=init.options["expire_time_ns"],
             init_id=init.id,
             ts_init=init.ts_init,
             reduce_only=init.reduce_only,
+            quote_quantity=init.quote_quantity,
             emulation_trigger=init.emulation_trigger,
+            trigger_instrument_id=init.trigger_instrument_id,
             contingency_type=init.contingency_type,
             order_list_id=init.order_list_id,
             linked_order_ids=init.linked_order_ids,
             parent_order_id=init.parent_order_id,
             exec_algorithm_id=init.exec_algorithm_id,
             exec_algorithm_params=init.exec_algorithm_params,
             exec_spawn_id=init.exec_spawn_id,
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/orders/market_to_limit.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/orders/market_to_limit.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/orders/market_to_limit.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/orders/market_to_limit.pyx`

 * *Files 3% similar despite different names*

```diff
@@ -72,14 +72,16 @@
         The UNIX timestamp (nanoseconds) when the object was initialized.
     time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``}, default ``GTC``
         The order time in force.
     expire_time_ns : uint64_t, default 0 (no expiry)
         The UNIX timestamp (nanoseconds) when the order will expire.
     reduce_only : bool, default False
         If the order carries the 'reduce-only' execution instruction.
+    quote_quantity : bool, default False
+        If the order quantity is denominated in the quote currency.
     display_qty : Quantity, optional
         The quantity of the limit order to display on the public book (iceberg).
     contingency_type : ContingencyType, default ``NO_CONTINGENCY``
         The order contingency type.
     order_list_id : OrderListId, optional
         The order list ID associated with the order.
     linked_order_ids : list[ClientOrderId], optional
@@ -119,14 +121,15 @@
         OrderSide order_side,
         Quantity quantity not None,
         UUID4 init_id not None,
         uint64_t ts_init,
         TimeInForce time_in_force = TimeInForce.GTC,
         uint64_t expire_time_ns = 0,
         bint reduce_only = False,
+        bint quote_quantity = False,
         Quantity display_qty = None,
         ContingencyType contingency_type = ContingencyType.NO_CONTINGENCY,
         OrderListId order_list_id = None,
         list linked_order_ids = None,
         ClientOrderId parent_order_id = None,
         ExecAlgorithmId exec_algorithm_id = None,
         dict exec_algorithm_params = None,
@@ -158,16 +161,18 @@
             client_order_id=client_order_id,
             order_side=order_side,
             order_type=OrderType.MARKET_TO_LIMIT,
             quantity=quantity,
             time_in_force=time_in_force,
             post_only=False,
             reduce_only=reduce_only,
+            quote_quantity=quote_quantity,
             options=options,
             emulation_trigger=TriggerType.NO_TRIGGER,
+            trigger_instrument_id=None,
             contingency_type=contingency_type,
             order_list_id=order_list_id,
             linked_order_ids=linked_order_ids,
             parent_order_id=parent_order_id,
             exec_algorithm_id=exec_algorithm_id,
             exec_algorithm_params=exec_algorithm_params,
             exec_spawn_id=exec_spawn_id,
@@ -252,15 +257,16 @@
             "last_trade_id": self.last_trade_id.to_str() if self.last_trade_id is not None else None,
             "type": order_type_to_str(self.order_type),
             "side": order_side_to_str(self.side),
             "quantity": str(self.quantity),
             "price": str(self.price),
             "time_in_force": time_in_force_to_str(self.time_in_force),
             "expire_time_ns": self.expire_time_ns,
-            "reduce_only": self.is_reduce_only,
+            "is_reduce_only": self.is_reduce_only,
+            "is_quote_quantity": self.is_quote_quantity,
             "display_qty": str(self.display_qty) if self.display_qty is not None else None,
             "filled_qty": str(self.filled_qty),
             "avg_px": str(self.avg_px),
             "slippage": str(self.slippage),
             "status": self._fsm.state_string_c(),
             "contingency_type": contingency_type_to_str(self.contingency_type),
             "order_list_id": self.order_list_id.to_str() if self.order_list_id is not None else None,
@@ -305,14 +311,15 @@
             instrument_id=init.instrument_id,
             client_order_id=init.client_order_id,
             order_side=init.side,
             quantity=init.quantity,
             time_in_force=init.time_in_force,
             expire_time_ns=init.options["expire_time_ns"],
             reduce_only=init.reduce_only,
+            quote_quantity=init.quote_quantity,
             display_qty=Quantity.from_str_c(display_qty_str) if display_qty_str is not None else None,
             init_id=init.id,
             ts_init=init.ts_init,
             order_list_id=init.order_list_id,
             contingency_type=init.contingency_type,
             linked_order_ids=init.linked_order_ids,
             parent_order_id=init.parent_order_id,
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/orders/stop_limit.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/orders/stop_market.pxd`

 * *Files 17% similar despite different names*

```diff
@@ -14,29 +14,20 @@
 # -------------------------------------------------------------------------------------------------
 
 from libc.stdint cimport uint64_t
 
 from nautilus_trader.model.enums_c cimport TriggerType
 from nautilus_trader.model.events.order cimport OrderInitialized
 from nautilus_trader.model.objects cimport Price
-from nautilus_trader.model.objects cimport Quantity
 from nautilus_trader.model.orders.base cimport Order
 
 
-cdef class StopLimitOrder(Order):
-    cdef readonly Price price
-    """The order price (LIMIT).\n\n:returns: `Price`"""
+cdef class StopMarketOrder(Order):
     cdef readonly Price trigger_price
     """The order trigger price (STOP).\n\n:returns: `Price`"""
     cdef readonly TriggerType trigger_type
     """The trigger type for the order.\n\n:returns: `TriggerType`"""
     cdef readonly uint64_t expire_time_ns
     """The order expiration (UNIX epoch nanoseconds), zero for no expiration.\n\n:returns: `uint64_t`"""
-    cdef readonly Quantity display_qty
-    """The quantity of the ``LIMIT`` order to display on the public book (iceberg).\n\n:returns: `Quantity` or ``None``"""  # noqa
-    cdef readonly bint is_triggered
-    """If the order has been triggered.\n\n:returns: `bool`"""
-    cdef readonly uint64_t ts_triggered
-    """The UNIX timestamp (nanoseconds) when the order was triggered (0 if not triggered).\n\n:returns: `uint64_t`"""
 
     @staticmethod
-    cdef StopLimitOrder create(OrderInitialized init)
+    cdef StopMarketOrder create(OrderInitialized init)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/orders/stop_limit.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/orders/stop_limit.pyx`

 * *Files 4% similar despite different names*

```diff
@@ -90,16 +90,22 @@
         The order time in force.
     expire_time_ns : uint64_t, default 0 (no expiry)
         The UNIX timestamp (nanoseconds) when the order will expire.
     post_only : bool, default False
         If the ``LIMIT`` order will only provide liquidity (once triggered).
     reduce_only : bool, default False
         If the ``LIMIT`` order carries the 'reduce-only' execution instruction.
+    quote_quantity : bool, default False
+        If the order quantity is denominated in the quote currency.
     display_qty : Quantity, optional
         The quantity of the ``LIMIT`` order to display on the public book (iceberg).
+    emulation_trigger : EmulationTrigger, default ``NO_TRIGGER``
+        The emulation trigger for the order.
+    trigger_instrument_id : InstrumentId, optional
+        The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
     contingency_type : ContingencyType, default ``NO_CONTINGENCY``
         The order contingency type.
     order_list_id : OrderListId, optional
         The order list ID associated with the order.
     linked_order_ids : list[ClientOrderId], optional
         The order linked client order ID(s).
     parent_order_id : ClientOrderId, optional
@@ -147,16 +153,18 @@
         TriggerType trigger_type,
         UUID4 init_id not None,
         uint64_t ts_init,
         TimeInForce time_in_force = TimeInForce.GTC,
         uint64_t expire_time_ns = 0,
         bint post_only = False,
         bint reduce_only = False,
+        bint quote_quantity = False,
         Quantity display_qty = None,
         TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
+        InstrumentId trigger_instrument_id = None,
         ContingencyType contingency_type = ContingencyType.NO_CONTINGENCY,
         OrderListId order_list_id = None,
         list linked_order_ids = None,
         ClientOrderId parent_order_id = None,
         ExecAlgorithmId exec_algorithm_id = None,
         dict exec_algorithm_params = None,
         ClientOrderId exec_spawn_id = None,
@@ -195,16 +203,18 @@
             client_order_id=client_order_id,
             order_side=order_side,
             order_type=OrderType.STOP_LIMIT,
             quantity=quantity,
             time_in_force=time_in_force,
             post_only=post_only,
             reduce_only=reduce_only,
+            quote_quantity=quote_quantity,
             options=options,
             emulation_trigger=emulation_trigger,
+            trigger_instrument_id=trigger_instrument_id,
             contingency_type=contingency_type,
             order_list_id=order_list_id,
             linked_order_ids=linked_order_ids,
             parent_order_id=parent_order_id,
             exec_algorithm_id=exec_algorithm_id,
             exec_algorithm_params=exec_algorithm_params,
             exec_spawn_id=exec_spawn_id,
@@ -311,16 +321,18 @@
             "filled_qty": str(self.filled_qty),
             "liquidity_side": liquidity_side_to_str(self.liquidity_side),
             "avg_px": str(self.avg_px),
             "slippage": str(self.slippage),
             "status": self._fsm.state_string_c(),
             "is_post_only": self.is_post_only,
             "is_reduce_only": self.is_reduce_only,
+            "is_quote_quantity": self.is_quote_quantity,
             "display_qty": str(self.display_qty) if self.display_qty is not None else None,
             "emulation_trigger": trigger_type_to_str(self.emulation_trigger),
+            "trigger_instrument_id": self.trigger_instrument_id.to_str() if self.trigger_instrument_id is not None else None,
             "contingency_type": contingency_type_to_str(self.contingency_type),
             "order_list_id": self.order_list_id.to_str() if self.order_list_id is not None else None,
             "linked_order_ids": ",".join([o.to_str() for o in self.linked_order_ids]) if self.linked_order_ids is not None else None,  # noqa
             "parent_order_id": self.parent_order_id.to_str() if self.parent_order_id is not None else None,
             "exec_algorithm_id": self.exec_algorithm_id.to_str() if self.exec_algorithm_id is not None else None,
             "exec_algorithm_params": msgspec.json.encode(self.exec_algorithm_params) if self.exec_algorithm_params is not None else None,  # noqa
             "exec_spawn_id": self.exec_spawn_id.to_str() if self.exec_spawn_id is not None else None,
@@ -366,16 +378,18 @@
             trigger_type=trigger_type_from_str(init.options["trigger_type"]),
             time_in_force=init.time_in_force,
             expire_time_ns=init.options["expire_time_ns"],
             init_id=init.id,
             ts_init=init.ts_init,
             post_only=init.post_only,
             reduce_only=init.reduce_only,
+            quote_quantity=init.quote_quantity,
             display_qty=Quantity.from_str_c(display_qty_str) if display_qty_str is not None else None,
             emulation_trigger=init.emulation_trigger,
+            trigger_instrument_id=init.trigger_instrument_id,
             contingency_type=init.contingency_type,
             order_list_id=init.order_list_id,
             linked_order_ids=init.linked_order_ids,
             parent_order_id=init.parent_order_id,
             exec_algorithm_id=init.exec_algorithm_id,
             exec_algorithm_params=init.exec_algorithm_params,
             exec_spawn_id=init.exec_spawn_id,
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/orders/stop_market.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/orders/trailing_stop_market.pxd`

 * *Files 14% similar despite different names*

```diff
@@ -11,23 +11,28 @@
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from libc.stdint cimport uint64_t
 
+from nautilus_trader.model.enums_c cimport TrailingOffsetType
 from nautilus_trader.model.enums_c cimport TriggerType
 from nautilus_trader.model.events.order cimport OrderInitialized
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.orders.base cimport Order
 
 
-cdef class StopMarketOrder(Order):
+cdef class TrailingStopMarketOrder(Order):
     cdef readonly Price trigger_price
-    """The order trigger price (STOP).\n\n:returns: `Price`"""
+    """The order trigger price (STOP).\n\n:returns: `Price` or ``None``"""
     cdef readonly TriggerType trigger_type
     """The trigger type for the order.\n\n:returns: `TriggerType`"""
+    cdef readonly object trailing_offset
+    """The trailing offset for the orders trigger price (STOP).\n\n:returns: `Decimal`"""
+    cdef readonly TrailingOffsetType trailing_offset_type
+    """The trailing offset type.\n\n:returns: `TrailingOffsetType`"""
     cdef readonly uint64_t expire_time_ns
     """The order expiration (UNIX epoch nanoseconds), zero for no expiration.\n\n:returns: `uint64_t`"""
 
     @staticmethod
-    cdef StopMarketOrder create(OrderInitialized init)
+    cdef TrailingStopMarketOrder create(OrderInitialized init)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/orders/stop_market.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/orders/stop_market.pyx`

 * *Files 6% similar despite different names*

```diff
@@ -85,16 +85,20 @@
         The UNIX timestamp (nanoseconds) when the object was initialized.
     time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``}, default ``GTC``
         The order time in force.
     expire_time_ns : uint64_t, default 0 (no expiry)
         The UNIX timestamp (nanoseconds) when the order will expire.
     reduce_only : bool, default False
         If the order carries the 'reduce-only' execution instruction.
+    quote_quantity : bool, default False
+        If the order quantity is denominated in the quote currency.
     emulation_trigger : TriggerType, default ``NO_TRIGGER``
         The order emulation trigger.
+    trigger_instrument_id : InstrumentId, optional
+        The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
     contingency_type : ContingencyType, default ``NO_CONTINGENCY``
         The order contingency type.
     order_list_id : OrderListId, optional
         The order list ID associated with the order.
     linked_order_ids : list[ClientOrderId], optional
         The order linked client order ID(s).
     parent_order_id : ClientOrderId, optional
@@ -138,15 +142,17 @@
         Price trigger_price not None,
         TriggerType trigger_type,
         UUID4 init_id not None,
         uint64_t ts_init,
         TimeInForce time_in_force = TimeInForce.GTC,
         uint64_t expire_time_ns = 0,
         bint reduce_only = False,
+        bint quote_quantity = False,
         TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
+        InstrumentId trigger_instrument_id = None,
         ContingencyType contingency_type = ContingencyType.NO_CONTINGENCY,
         OrderListId order_list_id = None,
         list linked_order_ids = None,
         ClientOrderId parent_order_id = None,
         ExecAlgorithmId exec_algorithm_id = None,
         dict exec_algorithm_params = None,
         ClientOrderId exec_spawn_id = None,
@@ -179,16 +185,18 @@
             client_order_id=client_order_id,
             order_side=order_side,
             order_type=OrderType.STOP_MARKET,
             quantity=quantity,
             time_in_force=time_in_force,
             post_only=False,
             reduce_only=reduce_only,
+            quote_quantity=quote_quantity,
             options=options,
             emulation_trigger=emulation_trigger,
+            trigger_instrument_id=trigger_instrument_id,
             contingency_type=contingency_type,
             order_list_id=order_list_id,
             linked_order_ids=linked_order_ids,
             parent_order_id=parent_order_id,
             exec_algorithm_id=exec_algorithm_id,
             exec_algorithm_params=exec_algorithm_params,
             exec_spawn_id=exec_spawn_id,
@@ -283,15 +291,17 @@
             "time_in_force": time_in_force_to_str(self.time_in_force),
             "filled_qty": str(self.filled_qty),
             "liquidity_side": liquidity_side_to_str(self.liquidity_side),
             "avg_px": str(self.avg_px),
             "slippage": str(self.slippage),
             "status": self._fsm.state_string_c(),
             "is_reduce_only": self.is_reduce_only,
+            "is_quote_quantity": self.is_quote_quantity,
             "emulation_trigger": trigger_type_to_str(self.emulation_trigger),
+            "trigger_instrument_id": self.trigger_instrument_id.to_str() if self.trigger_instrument_id is not None else None,
             "contingency_type": contingency_type_to_str(self.contingency_type),
             "order_list_id": self.order_list_id.to_str() if self.order_list_id is not None else None,
             "linked_order_ids": ",".join([o.to_str() for o in self.linked_order_ids]) if self.linked_order_ids is not None else None,  # noqa
             "parent_order_id": self.parent_order_id.to_str() if self.parent_order_id is not None else None,
             "exec_algorithm_id": self.exec_algorithm_id.to_str() if self.exec_algorithm_id is not None else None,
             "exec_algorithm_params": msgspec.json.encode(self.exec_algorithm_params) if self.exec_algorithm_params is not None else None,  # noqa
             "exec_spawn_id": self.exec_spawn_id.to_str() if self.exec_spawn_id is not None else None,
@@ -333,15 +343,17 @@
             trigger_price=Price.from_str_c(init.options["trigger_price"]),
             trigger_type=trigger_type_from_str(init.options["trigger_type"]),
             time_in_force=init.time_in_force,
             expire_time_ns=init.options["expire_time_ns"],
             init_id=init.id,
             ts_init=init.ts_init,
             reduce_only=init.reduce_only,
+            quote_quantity=init.quote_quantity,
             emulation_trigger=init.emulation_trigger,
+            trigger_instrument_id=init.trigger_instrument_id,
             contingency_type=init.contingency_type,
             order_list_id=init.order_list_id,
             linked_order_ids=init.linked_order_ids,
             parent_order_id=init.parent_order_id,
             exec_algorithm_id=init.exec_algorithm_id,
             exec_algorithm_params=init.exec_algorithm_params,
             exec_spawn_id=init.exec_spawn_id,
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/orders/trailing_stop_limit.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/orders/trailing_stop_limit.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/orders/trailing_stop_limit.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/orders/trailing_stop_market.pyx`

 * *Files 6% similar despite different names*

```diff
@@ -35,30 +35,29 @@
 from nautilus_trader.model.enums_c cimport order_type_to_str
 from nautilus_trader.model.enums_c cimport time_in_force_to_str
 from nautilus_trader.model.enums_c cimport trailing_offset_type_from_str
 from nautilus_trader.model.enums_c cimport trailing_offset_type_to_str
 from nautilus_trader.model.enums_c cimport trigger_type_from_str
 from nautilus_trader.model.enums_c cimport trigger_type_to_str
 from nautilus_trader.model.events.order cimport OrderInitialized
-from nautilus_trader.model.events.order cimport OrderTriggered
 from nautilus_trader.model.events.order cimport OrderUpdated
 from nautilus_trader.model.identifiers cimport ClientOrderId
 from nautilus_trader.model.identifiers cimport ExecAlgorithmId
 from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.identifiers cimport OrderListId
 from nautilus_trader.model.identifiers cimport StrategyId
 from nautilus_trader.model.identifiers cimport TraderId
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.objects cimport Quantity
 from nautilus_trader.model.orders.base cimport Order
 
 
-cdef class TrailingStopLimitOrder(Order):
+cdef class TrailingStopMarketOrder(Order):
     """
-    Represents a `Trailing-Stop-Limit` conditional order.
+    Represents a `Trailing-Stop-Market` conditional order.
 
     Parameters
     ----------
     trader_id : TraderId
         The trader ID associated with the order.
     strategy_id : StrategyId
         The strategy ID associated with the order.
@@ -66,44 +65,39 @@
         The order instrument ID.
     client_order_id : ClientOrderId
         The client order ID.
     order_side : OrderSide {``BUY``, ``SELL``}
         The order side.
     quantity : Quantity
         The order quantity (> 0).
-    price : Price, optional with no default so ``None`` must be passed explicitly
-        The order price (LIMIT). If ``None`` then will typically default to the
-        delta of market price and `limit_offset`.
     trigger_price : Price, optional with no default so ``None`` must be passed explicitly
         The order trigger price (STOP). If ``None`` then will typically default
         to the delta of market price and `trailing_offset`.
     trigger_type : TriggerType
         The order trigger type.
-    limit_offset : Decimal
-        The trailing offset for the order price (LIMIT).
     trailing_offset : Decimal
-        The trailing offset for the order trigger price (STOP).
+        The trailing offset for the trigger price (STOP).
     trailing_offset_type : TrailingOffsetType
         The order trailing offset type.
     init_id : UUID4
         The order initialization event ID.
     ts_init : uint64_t
         The UNIX timestamp (nanoseconds) when the object was initialized.
     time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``}, default ``GTC``
         The order time in force.
     expire_time_ns : uint64_t, default 0 (no expiry)
         The UNIX timestamp (nanoseconds) when the order will expire.
-    post_only : bool, default False
-        If the ``LIMIT`` order will only provide liquidity (once triggered).
     reduce_only : bool, default False
-        If the ``LIMIT`` order carries the 'reduce-only' execution instruction.
-    display_qty : Quantity, optional
-        The quantity of the ``LIMIT`` order to display on the public book (iceberg).
+        If the order carries the 'reduce-only' execution instruction.
+    quote_quantity : bool, default False
+        If the order quantity is denominated in the quote currency.
     emulation_trigger : TriggerType, default ``NO_TRIGGER``
         The order emulation trigger.
+    trigger_instrument_id : InstrumentId, optional
+        The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
     contingency_type : ContingencyType, default ``NO_CONTINGENCY``
         The order contingency type.
     order_list_id : OrderListId, optional
         The order list ID associated with the order.
     linked_order_ids : list[ClientOrderId], optional
         The order linked client order ID(s).
     parent_order_id : ClientOrderId, optional
@@ -128,40 +122,36 @@
         If `trigger_type` is ``NO_TRIGGER``.
     ValueError
         If `trailing_offset_type` is ``NO_TRAILING_OFFSET``.
     ValueError
         If `time_in_force` is ``AT_THE_OPEN`` or ``AT_THE_CLOSE``.
     ValueError
         If `time_in_force` is ``GTD`` and `expire_time_ns` <= UNIX epoch.
-    ValueError
-        If `display_qty` is negative (< 0) or greater than `quantity`.
     """
 
     def __init__(
         self,
         TraderId trader_id not None,
         StrategyId strategy_id not None,
         InstrumentId instrument_id not None,
         ClientOrderId client_order_id not None,
         OrderSide order_side,
         Quantity quantity not None,
-        Price price: Optional[Price],
         Price trigger_price: Optional[Price],
         TriggerType trigger_type,
-        limit_offset: Decimal,
         trailing_offset: Decimal,
         TrailingOffsetType trailing_offset_type,
         UUID4 init_id not None,
         uint64_t ts_init,
         TimeInForce time_in_force = TimeInForce.GTC,
         uint64_t expire_time_ns = 0,
-        bint post_only = False,
         bint reduce_only = False,
-        Quantity display_qty = None,
+        bint quote_quantity = False,
         TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
+        InstrumentId trigger_instrument_id = None,
         ContingencyType contingency_type = ContingencyType.NO_CONTINGENCY,
         OrderListId order_list_id = None,
         list linked_order_ids = None,
         ClientOrderId parent_order_id = None,
         ExecAlgorithmId exec_algorithm_id = None,
         dict exec_algorithm_params = None,
         ClientOrderId exec_spawn_id = None,
@@ -175,93 +165,80 @@
 
         if time_in_force == TimeInForce.GTD:
             # Must have an expire time
             Condition.true(expire_time_ns > 0, "`expire_time_ns` cannot be <= UNIX epoch.")
         else:
             # Should not have an expire time
             Condition.true(expire_time_ns == 0, "`expire_time_ns` was set when `time_in_force` not GTD.")
-        Condition.true(
-            display_qty is None or 0 <= display_qty <= quantity,
-            fail_msg="`display_qty` was negative or greater than order quantity",
-        )
 
         # Set options
         cdef dict options = {
-            "price": str(price) if price is not None else None,
             "trigger_price": str(trigger_price) if trigger_price is not None else None,
             "trigger_type": trigger_type_to_str(trigger_type),
-            "limit_offset": str(limit_offset),
             "trailing_offset": str(trailing_offset),
             "trailing_offset_type": trailing_offset_type_to_str(trailing_offset_type),
             "expire_time_ns": expire_time_ns,
-            "display_qty": str(display_qty) if display_qty is not None else None,
         }
 
         # Create initialization event
         cdef OrderInitialized init = OrderInitialized(
             trader_id=trader_id,
             strategy_id=strategy_id,
             instrument_id=instrument_id,
             client_order_id=client_order_id,
             order_side=order_side,
-            order_type=OrderType.TRAILING_STOP_LIMIT,
+            order_type=OrderType.TRAILING_STOP_MARKET,
             quantity=quantity,
             time_in_force=time_in_force,
-            post_only=post_only,
+            post_only=False,
             reduce_only=reduce_only,
+            quote_quantity=quote_quantity,
             options=options,
             emulation_trigger=emulation_trigger,
+            trigger_instrument_id=trigger_instrument_id,
             contingency_type=contingency_type,
             order_list_id=order_list_id,
             linked_order_ids=linked_order_ids,
             parent_order_id=parent_order_id,
             exec_algorithm_id=exec_algorithm_id,
             exec_algorithm_params=exec_algorithm_params,
             exec_spawn_id=exec_spawn_id,
             tags=tags,
             event_id=init_id,
             ts_init=ts_init,
         )
         super().__init__(init=init)
 
-        self.price = price
         self.trigger_price = trigger_price
         self.trigger_type = trigger_type
-        self.limit_offset = limit_offset
         self.trailing_offset = trailing_offset
         self.trailing_offset_type = trailing_offset_type
         self.expire_time_ns = expire_time_ns
-        self.display_qty = display_qty
-        self.is_triggered = False
-        self.ts_triggered = 0
 
     cdef void _updated(self, OrderUpdated event):
         if self.venue_order_id is not None and event.venue_order_id is not None and self.venue_order_id != event.venue_order_id:
             self._venue_order_ids.append(self.venue_order_id)
             self.venue_order_id = event.venue_order_id
         if event.quantity is not None:
             self.quantity = event.quantity
             self.leaves_qty = Quantity.from_raw_c(self.quantity._mem.raw - self.filled_qty._mem.raw, self.quantity._mem.precision)
-        if event.price is not None:
-            self.price = event.price
         if event.trigger_price is not None:
             self.trigger_price = event.trigger_price
 
-    cdef void _triggered(self, OrderTriggered event):
-        self.is_triggered = True
-        self.ts_triggered = event.ts_event
-
     cdef void _set_slippage(self):
+        if self.trigger_price is None:
+            return  # Prevents an attribute error below
+
         if self.side == OrderSide.BUY:
-            self.slippage = self.avg_px - self.price.as_f64_c()
+            self.slippage = self.avg_px - self.trigger_price.as_f64_c()
         elif self.side == OrderSide.SELL:
-            self.slippage = self.price.as_f64_c() - self.avg_px
+            self.slippage = self.trigger_price.as_f64_c() - self.avg_px
 
     cdef bint has_price_c(self):
-        return self.price is not None
+        return False
 
     cdef bint has_trigger_price_c(self):
         return self.trigger_price is not None
 
     @property
     def expire_time(self):
         """
@@ -285,17 +262,15 @@
         """
         cdef str expiration_str = "" if self.expire_time_ns == 0 else f" {format_iso8601(unix_nanos_to_dt(self.expire_time_ns))}"
         cdef str emulation_str = "" if self.emulation_trigger == TriggerType.NO_TRIGGER else f" EMULATED[{trigger_type_to_str(self.emulation_trigger)}]"
         return (
             f"{order_side_to_str(self.side)} {self.quantity.to_str()} {self.instrument_id} "
             f"{order_type_to_str(self.order_type)}[{trigger_type_to_str(self.trigger_type)}] "
             f"{'@ ' + str(self.trigger_price) + '-STOP ' if self.trigger_price else ''}"
-            f"[{trigger_type_to_str(self.trigger_type)}] {self.price}-LIMIT "
             f"{self.trailing_offset}-TRAILING_OFFSET[{trailing_offset_type_to_str(self.trailing_offset_type)}] "
-            f"{self.limit_offset}-LIMIT_OFFSET[{trailing_offset_type_to_str(self.trailing_offset_type)}] "
             f"{time_in_force_to_str(self.time_in_force)}{expiration_str}"
             f"{emulation_str}"
         )
 
     cpdef dict to_dict(self):
         """
         Return a dictionary representation of this object.
@@ -307,98 +282,92 @@
         """
         cdef ClientOrderId o
         return {
             "trader_id": self.trader_id.to_str(),
             "strategy_id": self.strategy_id.to_str(),
             "instrument_id": self.instrument_id.to_str(),
             "client_order_id": self.client_order_id.to_str(),
-            "venue_order_id": self.venue_order_id.to_str() if self.venue_order_id is not None else None,
+            "venue_order_id": self.venue_order_id if self.venue_order_id is not None else None,
             "position_id": self.position_id.to_str() if self.position_id is not None else None,
             "account_id": self.account_id.to_str() if self.account_id is not None else None,
             "last_trade_id": self.last_trade_id.to_str() if self.last_trade_id is not None else None,
             "type": order_type_to_str(self.order_type),
             "side": order_side_to_str(self.side),
             "quantity": str(self.quantity),
-            "price": str(self.price) if self.price is not None else None,
             "trigger_price": str(self.trigger_price) if self.trigger_price is not None else None,
             "trigger_type": trigger_type_to_str(self.trigger_type),
-            "limit_offset": str(self.limit_offset),
             "trailing_offset": str(self.trailing_offset),
             "trailing_offset_type": trailing_offset_type_to_str(self.trailing_offset_type),
             "expire_time_ns": self.expire_time_ns,
             "time_in_force": time_in_force_to_str(self.time_in_force),
             "filled_qty": str(self.filled_qty),
             "liquidity_side": liquidity_side_to_str(self.liquidity_side),
             "avg_px": str(self.avg_px),
             "slippage": str(self.slippage),
             "status": self._fsm.state_string_c(),
-            "is_post_only": self.is_post_only,
             "is_reduce_only": self.is_reduce_only,
-            "display_qty": str(self.display_qty) if self.display_qty is not None else None,
+            "is_quote_quantity": self.is_quote_quantity,
             "emulation_trigger": trigger_type_to_str(self.emulation_trigger),
+            "trigger_instrument_id": self.trigger_instrument_id.to_str() if self.trigger_instrument_id is not None else None,
             "contingency_type": contingency_type_to_str(self.contingency_type),
             "order_list_id": self.order_list_id.to_str() if self.order_list_id is not None else None,
             "linked_order_ids": ",".join([o.to_str() for o in self.linked_order_ids]) if self.linked_order_ids is not None else None,  # noqa
             "parent_order_id": self.parent_order_id.to_str() if self.parent_order_id is not None else None,
             "exec_algorithm_id": self.exec_algorithm_id.to_str() if self.exec_algorithm_id is not None else None,
             "exec_algorithm_params": msgspec.json.encode(self.exec_algorithm_params) if self.exec_algorithm_params is not None else None,  # noqa
             "exec_spawn_id": self.exec_spawn_id.to_str() if self.exec_spawn_id is not None else None,
             "tags": self.tags,
             "ts_last": self.ts_last,
             "ts_init": self.ts_init,
         }
 
     @staticmethod
-    cdef TrailingStopLimitOrder create(OrderInitialized init):
+    cdef TrailingStopMarketOrder create(OrderInitialized init):
         """
-        Return a `Trailing-Stop-Limit` order from the given initialized event.
+        Return a `Trailing-Stop-Market` order from the given initialized event.
 
         Parameters
         ----------
         init : OrderInitialized
             The event to initialize with.
 
         Returns
         -------
-        TrailingStopLimitOrder
+        TrailingStopMarketOrder
 
         Raises
         ------
         ValueError
-            If `init.order_type` is not equal to ``TRAILING_STOP_LIMIT``.
+            If `init.order_type` is not equal to ``TRAILING_STOP_MARKET``.
 
         """
         Condition.not_none(init, "init")
-        Condition.equal(init.order_type, OrderType.TRAILING_STOP_LIMIT, "init.order_type", "OrderType")
+        Condition.equal(init.order_type, OrderType.TRAILING_STOP_MARKET, "init.order_type", "OrderType")
 
-        cdef str price_str = init.options.get("price")
         cdef str trigger_price_str = init.options.get("trigger_price")
-        cdef str display_qty_str = init.options.get("display_qty")
 
-        return TrailingStopLimitOrder(
+        return TrailingStopMarketOrder(
             trader_id=init.trader_id,
             strategy_id=init.strategy_id,
             instrument_id=init.instrument_id,
             client_order_id=init.client_order_id,
             order_side=init.side,
             quantity=init.quantity,
-            price=Price.from_str_c(price_str) if price_str is not None else None,
             trigger_price=Price.from_str_c(trigger_price_str) if trigger_price_str is not None else None,
             trigger_type=trigger_type_from_str(init.options["trigger_type"]),
-            limit_offset=Decimal(init.options["limit_offset"]),
             trailing_offset=Decimal(init.options["trailing_offset"]),
             trailing_offset_type=trailing_offset_type_from_str(init.options["trailing_offset_type"]),
             time_in_force=init.time_in_force,
             expire_time_ns=init.options["expire_time_ns"],
             init_id=init.id,
             ts_init=init.ts_init,
-            post_only=init.post_only,
             reduce_only=init.reduce_only,
-            display_qty=Quantity.from_str_c(display_qty_str) if display_qty_str is not None else None,
+            quote_quantity=init.quote_quantity,
             emulation_trigger=init.emulation_trigger,
+            trigger_instrument_id=init.trigger_instrument_id,
             contingency_type=init.contingency_type,
             order_list_id=init.order_list_id,
             linked_order_ids=init.linked_order_ids,
             parent_order_id=init.parent_order_id,
             exec_algorithm_id=init.exec_algorithm_id,
             exec_algorithm_params=init.exec_algorithm_params,
             exec_spawn_id=init.exec_spawn_id,
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/orders/trailing_stop_market.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/orders/trailing_stop_limit.pyx`

 * *Files 18% similar despite different names*

```diff
@@ -35,29 +35,30 @@
 from nautilus_trader.model.enums_c cimport order_type_to_str
 from nautilus_trader.model.enums_c cimport time_in_force_to_str
 from nautilus_trader.model.enums_c cimport trailing_offset_type_from_str
 from nautilus_trader.model.enums_c cimport trailing_offset_type_to_str
 from nautilus_trader.model.enums_c cimport trigger_type_from_str
 from nautilus_trader.model.enums_c cimport trigger_type_to_str
 from nautilus_trader.model.events.order cimport OrderInitialized
+from nautilus_trader.model.events.order cimport OrderTriggered
 from nautilus_trader.model.events.order cimport OrderUpdated
 from nautilus_trader.model.identifiers cimport ClientOrderId
 from nautilus_trader.model.identifiers cimport ExecAlgorithmId
 from nautilus_trader.model.identifiers cimport InstrumentId
 from nautilus_trader.model.identifiers cimport OrderListId
 from nautilus_trader.model.identifiers cimport StrategyId
 from nautilus_trader.model.identifiers cimport TraderId
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.objects cimport Quantity
 from nautilus_trader.model.orders.base cimport Order
 
 
-cdef class TrailingStopMarketOrder(Order):
+cdef class TrailingStopLimitOrder(Order):
     """
-    Represents a `Trailing-Stop-Market` conditional order.
+    Represents a `Trailing-Stop-Limit` conditional order.
 
     Parameters
     ----------
     trader_id : TraderId
         The trader ID associated with the order.
     strategy_id : StrategyId
         The strategy ID associated with the order.
@@ -65,35 +66,48 @@
         The order instrument ID.
     client_order_id : ClientOrderId
         The client order ID.
     order_side : OrderSide {``BUY``, ``SELL``}
         The order side.
     quantity : Quantity
         The order quantity (> 0).
+    price : Price, optional with no default so ``None`` must be passed explicitly
+        The order price (LIMIT). If ``None`` then will typically default to the
+        delta of market price and `limit_offset`.
     trigger_price : Price, optional with no default so ``None`` must be passed explicitly
         The order trigger price (STOP). If ``None`` then will typically default
         to the delta of market price and `trailing_offset`.
     trigger_type : TriggerType
         The order trigger type.
+    limit_offset : Decimal
+        The trailing offset for the order price (LIMIT).
     trailing_offset : Decimal
-        The trailing offset for the trigger price (STOP).
+        The trailing offset for the order trigger price (STOP).
     trailing_offset_type : TrailingOffsetType
         The order trailing offset type.
     init_id : UUID4
         The order initialization event ID.
     ts_init : uint64_t
         The UNIX timestamp (nanoseconds) when the object was initialized.
     time_in_force : TimeInForce {``GTC``, ``IOC``, ``FOK``, ``GTD``, ``DAY``}, default ``GTC``
         The order time in force.
     expire_time_ns : uint64_t, default 0 (no expiry)
         The UNIX timestamp (nanoseconds) when the order will expire.
+    post_only : bool, default False
+        If the ``LIMIT`` order will only provide liquidity (once triggered).
     reduce_only : bool, default False
-        If the order carries the 'reduce-only' execution instruction.
+        If the ``LIMIT`` order carries the 'reduce-only' execution instruction.
+    quote_quantity : bool, default False
+        If the order quantity is denominated in the quote currency.
+    display_qty : Quantity, optional
+        The quantity of the ``LIMIT`` order to display on the public book (iceberg).
     emulation_trigger : TriggerType, default ``NO_TRIGGER``
         The order emulation trigger.
+    trigger_instrument_id : InstrumentId, optional
+        The emulation trigger instrument ID for the order (if ``None`` then will be the `instrument_id`).
     contingency_type : ContingencyType, default ``NO_CONTINGENCY``
         The order contingency type.
     order_list_id : OrderListId, optional
         The order list ID associated with the order.
     linked_order_ids : list[ClientOrderId], optional
         The order linked client order ID(s).
     parent_order_id : ClientOrderId, optional
@@ -118,34 +132,42 @@
         If `trigger_type` is ``NO_TRIGGER``.
     ValueError
         If `trailing_offset_type` is ``NO_TRAILING_OFFSET``.
     ValueError
         If `time_in_force` is ``AT_THE_OPEN`` or ``AT_THE_CLOSE``.
     ValueError
         If `time_in_force` is ``GTD`` and `expire_time_ns` <= UNIX epoch.
+    ValueError
+        If `display_qty` is negative (< 0) or greater than `quantity`.
     """
 
     def __init__(
         self,
         TraderId trader_id not None,
         StrategyId strategy_id not None,
         InstrumentId instrument_id not None,
         ClientOrderId client_order_id not None,
         OrderSide order_side,
         Quantity quantity not None,
+        Price price: Optional[Price],
         Price trigger_price: Optional[Price],
         TriggerType trigger_type,
+        limit_offset: Decimal,
         trailing_offset: Decimal,
         TrailingOffsetType trailing_offset_type,
         UUID4 init_id not None,
         uint64_t ts_init,
         TimeInForce time_in_force = TimeInForce.GTC,
         uint64_t expire_time_ns = 0,
+        bint post_only = False,
         bint reduce_only = False,
+        bint quote_quantity = False,
+        Quantity display_qty = None,
         TriggerType emulation_trigger = TriggerType.NO_TRIGGER,
+        InstrumentId trigger_instrument_id = None,
         ContingencyType contingency_type = ContingencyType.NO_CONTINGENCY,
         OrderListId order_list_id = None,
         list linked_order_ids = None,
         ClientOrderId parent_order_id = None,
         ExecAlgorithmId exec_algorithm_id = None,
         dict exec_algorithm_params = None,
         ClientOrderId exec_spawn_id = None,
@@ -159,78 +181,95 @@
 
         if time_in_force == TimeInForce.GTD:
             # Must have an expire time
             Condition.true(expire_time_ns > 0, "`expire_time_ns` cannot be <= UNIX epoch.")
         else:
             # Should not have an expire time
             Condition.true(expire_time_ns == 0, "`expire_time_ns` was set when `time_in_force` not GTD.")
+        Condition.true(
+            display_qty is None or 0 <= display_qty <= quantity,
+            fail_msg="`display_qty` was negative or greater than order quantity",
+        )
 
         # Set options
         cdef dict options = {
+            "price": str(price) if price is not None else None,
             "trigger_price": str(trigger_price) if trigger_price is not None else None,
             "trigger_type": trigger_type_to_str(trigger_type),
+            "limit_offset": str(limit_offset),
             "trailing_offset": str(trailing_offset),
             "trailing_offset_type": trailing_offset_type_to_str(trailing_offset_type),
             "expire_time_ns": expire_time_ns,
+            "display_qty": str(display_qty) if display_qty is not None else None,
         }
 
         # Create initialization event
         cdef OrderInitialized init = OrderInitialized(
             trader_id=trader_id,
             strategy_id=strategy_id,
             instrument_id=instrument_id,
             client_order_id=client_order_id,
             order_side=order_side,
-            order_type=OrderType.TRAILING_STOP_MARKET,
+            order_type=OrderType.TRAILING_STOP_LIMIT,
             quantity=quantity,
             time_in_force=time_in_force,
-            post_only=False,
+            post_only=post_only,
             reduce_only=reduce_only,
+            quote_quantity=quote_quantity,
             options=options,
             emulation_trigger=emulation_trigger,
+            trigger_instrument_id=trigger_instrument_id,
             contingency_type=contingency_type,
             order_list_id=order_list_id,
             linked_order_ids=linked_order_ids,
             parent_order_id=parent_order_id,
             exec_algorithm_id=exec_algorithm_id,
             exec_algorithm_params=exec_algorithm_params,
             exec_spawn_id=exec_spawn_id,
             tags=tags,
             event_id=init_id,
             ts_init=ts_init,
         )
         super().__init__(init=init)
 
+        self.price = price
         self.trigger_price = trigger_price
         self.trigger_type = trigger_type
+        self.limit_offset = limit_offset
         self.trailing_offset = trailing_offset
         self.trailing_offset_type = trailing_offset_type
         self.expire_time_ns = expire_time_ns
+        self.display_qty = display_qty
+        self.is_triggered = False
+        self.ts_triggered = 0
 
     cdef void _updated(self, OrderUpdated event):
         if self.venue_order_id is not None and event.venue_order_id is not None and self.venue_order_id != event.venue_order_id:
             self._venue_order_ids.append(self.venue_order_id)
             self.venue_order_id = event.venue_order_id
         if event.quantity is not None:
             self.quantity = event.quantity
             self.leaves_qty = Quantity.from_raw_c(self.quantity._mem.raw - self.filled_qty._mem.raw, self.quantity._mem.precision)
+        if event.price is not None:
+            self.price = event.price
         if event.trigger_price is not None:
             self.trigger_price = event.trigger_price
 
-    cdef void _set_slippage(self):
-        if self.trigger_price is None:
-            return  # Prevents an attribute error below
+    cdef void _triggered(self, OrderTriggered event):
+        self.is_triggered = True
+        self.ts_triggered = event.ts_event
 
+    cdef void _set_slippage(self):
         if self.side == OrderSide.BUY:
-            self.slippage = self.avg_px - self.trigger_price.as_f64_c()
+            self.slippage = self.avg_px - self.price.as_f64_c()
         elif self.side == OrderSide.SELL:
-            self.slippage = self.trigger_price.as_f64_c() - self.avg_px
+            self.slippage = self.price.as_f64_c() - self.avg_px
 
     cdef bint has_price_c(self):
-        return False
+        return self.price is not None
 
     cdef bint has_trigger_price_c(self):
         return self.trigger_price is not None
 
     @property
     def expire_time(self):
         """
@@ -254,15 +293,17 @@
         """
         cdef str expiration_str = "" if self.expire_time_ns == 0 else f" {format_iso8601(unix_nanos_to_dt(self.expire_time_ns))}"
         cdef str emulation_str = "" if self.emulation_trigger == TriggerType.NO_TRIGGER else f" EMULATED[{trigger_type_to_str(self.emulation_trigger)}]"
         return (
             f"{order_side_to_str(self.side)} {self.quantity.to_str()} {self.instrument_id} "
             f"{order_type_to_str(self.order_type)}[{trigger_type_to_str(self.trigger_type)}] "
             f"{'@ ' + str(self.trigger_price) + '-STOP ' if self.trigger_price else ''}"
+            f"[{trigger_type_to_str(self.trigger_type)}] {self.price}-LIMIT "
             f"{self.trailing_offset}-TRAILING_OFFSET[{trailing_offset_type_to_str(self.trailing_offset_type)}] "
+            f"{self.limit_offset}-LIMIT_OFFSET[{trailing_offset_type_to_str(self.trailing_offset_type)}] "
             f"{time_in_force_to_str(self.time_in_force)}{expiration_str}"
             f"{emulation_str}"
         )
 
     cpdef dict to_dict(self):
         """
         Return a dictionary representation of this object.
@@ -274,88 +315,102 @@
         """
         cdef ClientOrderId o
         return {
             "trader_id": self.trader_id.to_str(),
             "strategy_id": self.strategy_id.to_str(),
             "instrument_id": self.instrument_id.to_str(),
             "client_order_id": self.client_order_id.to_str(),
-            "venue_order_id": self.venue_order_id if self.venue_order_id is not None else None,
+            "venue_order_id": self.venue_order_id.to_str() if self.venue_order_id is not None else None,
             "position_id": self.position_id.to_str() if self.position_id is not None else None,
             "account_id": self.account_id.to_str() if self.account_id is not None else None,
             "last_trade_id": self.last_trade_id.to_str() if self.last_trade_id is not None else None,
             "type": order_type_to_str(self.order_type),
             "side": order_side_to_str(self.side),
             "quantity": str(self.quantity),
+            "price": str(self.price) if self.price is not None else None,
             "trigger_price": str(self.trigger_price) if self.trigger_price is not None else None,
             "trigger_type": trigger_type_to_str(self.trigger_type),
+            "limit_offset": str(self.limit_offset),
             "trailing_offset": str(self.trailing_offset),
             "trailing_offset_type": trailing_offset_type_to_str(self.trailing_offset_type),
             "expire_time_ns": self.expire_time_ns,
             "time_in_force": time_in_force_to_str(self.time_in_force),
             "filled_qty": str(self.filled_qty),
             "liquidity_side": liquidity_side_to_str(self.liquidity_side),
             "avg_px": str(self.avg_px),
             "slippage": str(self.slippage),
             "status": self._fsm.state_string_c(),
+            "is_post_only": self.is_post_only,
             "is_reduce_only": self.is_reduce_only,
+            "is_quote_quantity": self.is_quote_quantity,
+            "display_qty": str(self.display_qty) if self.display_qty is not None else None,
             "emulation_trigger": trigger_type_to_str(self.emulation_trigger),
+            "trigger_instrument_id": self.trigger_instrument_id.to_str() if self.trigger_instrument_id is not None else None,
             "contingency_type": contingency_type_to_str(self.contingency_type),
             "order_list_id": self.order_list_id.to_str() if self.order_list_id is not None else None,
             "linked_order_ids": ",".join([o.to_str() for o in self.linked_order_ids]) if self.linked_order_ids is not None else None,  # noqa
             "parent_order_id": self.parent_order_id.to_str() if self.parent_order_id is not None else None,
             "exec_algorithm_id": self.exec_algorithm_id.to_str() if self.exec_algorithm_id is not None else None,
             "exec_algorithm_params": msgspec.json.encode(self.exec_algorithm_params) if self.exec_algorithm_params is not None else None,  # noqa
             "exec_spawn_id": self.exec_spawn_id.to_str() if self.exec_spawn_id is not None else None,
             "tags": self.tags,
             "ts_last": self.ts_last,
             "ts_init": self.ts_init,
         }
 
     @staticmethod
-    cdef TrailingStopMarketOrder create(OrderInitialized init):
+    cdef TrailingStopLimitOrder create(OrderInitialized init):
         """
-        Return a `Trailing-Stop-Market` order from the given initialized event.
+        Return a `Trailing-Stop-Limit` order from the given initialized event.
 
         Parameters
         ----------
         init : OrderInitialized
             The event to initialize with.
 
         Returns
         -------
-        TrailingStopMarketOrder
+        TrailingStopLimitOrder
 
         Raises
         ------
         ValueError
-            If `init.order_type` is not equal to ``TRAILING_STOP_MARKET``.
+            If `init.order_type` is not equal to ``TRAILING_STOP_LIMIT``.
 
         """
         Condition.not_none(init, "init")
-        Condition.equal(init.order_type, OrderType.TRAILING_STOP_MARKET, "init.order_type", "OrderType")
+        Condition.equal(init.order_type, OrderType.TRAILING_STOP_LIMIT, "init.order_type", "OrderType")
 
+        cdef str price_str = init.options.get("price")
         cdef str trigger_price_str = init.options.get("trigger_price")
+        cdef str display_qty_str = init.options.get("display_qty")
 
-        return TrailingStopMarketOrder(
+        return TrailingStopLimitOrder(
             trader_id=init.trader_id,
             strategy_id=init.strategy_id,
             instrument_id=init.instrument_id,
             client_order_id=init.client_order_id,
             order_side=init.side,
             quantity=init.quantity,
+            price=Price.from_str_c(price_str) if price_str is not None else None,
             trigger_price=Price.from_str_c(trigger_price_str) if trigger_price_str is not None else None,
             trigger_type=trigger_type_from_str(init.options["trigger_type"]),
+            limit_offset=Decimal(init.options["limit_offset"]),
             trailing_offset=Decimal(init.options["trailing_offset"]),
             trailing_offset_type=trailing_offset_type_from_str(init.options["trailing_offset_type"]),
             time_in_force=init.time_in_force,
             expire_time_ns=init.options["expire_time_ns"],
             init_id=init.id,
             ts_init=init.ts_init,
+            post_only=init.post_only,
             reduce_only=init.reduce_only,
+            quote_quantity=init.quote_quantity,
+            display_qty=Quantity.from_str_c(display_qty_str) if display_qty_str is not None else None,
             emulation_trigger=init.emulation_trigger,
+            trigger_instrument_id=init.trigger_instrument_id,
             contingency_type=init.contingency_type,
             order_list_id=init.order_list_id,
             linked_order_ids=init.linked_order_ids,
             parent_order_id=init.parent_order_id,
             exec_algorithm_id=init.exec_algorithm_id,
             exec_algorithm_params=init.exec_algorithm_params,
             exec_spawn_id=init.exec_spawn_id,
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/orders/unpacker.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/orders/unpacker.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/position.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/position.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/position.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/position.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/tick_scheme/__init__.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/tick_scheme/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/tick_scheme/base.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/base.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/tick_scheme/base.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/base.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/tick_scheme/implementations/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/implementations/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/tick_scheme/implementations/fixed.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/implementations/tiered.pxd`

 * *Files 27% similar despite different names*

```diff
@@ -9,21 +9,25 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
+cimport numpy as np
+
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.tick_scheme.base cimport TickScheme
 
 
-cdef class FixedTickScheme(TickScheme):
-    cdef double _increment
+cdef class TieredTickScheme(TickScheme):
+    cdef list tiers
+    cdef int max_ticks_per_tier
+    cdef int tick_count
+
+    cdef readonly np.ndarray ticks
 
-    cdef readonly int price_precision
-    """The tick scheme price precision.\n\n:returns: `int`"""
-    cdef readonly Price increment
-    """The tick scheme price increment.\n\n:returns: `Price`"""
+    cpdef _build_ticks(self)
 
+    cpdef int find_tick_index(self, double value)
     cpdef Price next_ask_price(self, double value, int n=*)
     cpdef Price next_bid_price(self, double value, int n=*)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/tick_scheme/implementations/fixed.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/implementations/fixed.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/tick_scheme/implementations/tiered.pxd` & `nautilus_trader-1.175.0/nautilus_trader/model/instruments/synthetic.pxd`

 * *Files 20% similar despite different names*

```diff
@@ -9,25 +9,17 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-cimport numpy as np
-
+from nautilus_trader.core.rust.core cimport CVec
+from nautilus_trader.core.rust.model cimport SyntheticInstrument_API
 from nautilus_trader.model.objects cimport Price
-from nautilus_trader.model.tick_scheme.base cimport TickScheme
-
-
-cdef class TieredTickScheme(TickScheme):
-    cdef list tiers
-    cdef int max_ticks_per_tier
-    cdef int tick_count
 
-    cdef readonly np.ndarray ticks
 
-    cpdef _build_ticks(self)
+cdef class SyntheticInstrument:
+    cdef SyntheticInstrument_API _mem
 
-    cpdef int find_tick_index(self, double value)
-    cpdef Price next_ask_price(self, double value, int n=*)
-    cpdef Price next_bid_price(self, double value, int n=*)
+    cpdef void change_formula(self, str formula)
+    cpdef Price calculate(self, list[double] inputs)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/model/tick_scheme/implementations/tiered.pyx` & `nautilus_trader-1.175.0/nautilus_trader/model/tick_scheme/implementations/tiered.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/msgbus/__init__.pxd` & `nautilus_trader-1.175.0/nautilus_trader/msgbus/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/msgbus/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/msgbus/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/msgbus/bus.pxd` & `nautilus_trader-1.175.0/nautilus_trader/msgbus/bus.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/msgbus/bus.pyx` & `nautilus_trader-1.175.0/nautilus_trader/persistence/catalog/parquet.py`

 * *Files 25% similar despite different names*

```diff
@@ -9,535 +9,514 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from typing import Any, Callable
+import heapq
+import itertools
+import os
+import pathlib
+import platform
+import sys
+from pathlib import Path
+from typing import Callable, Optional, Union
 
-import cython
+import fsspec
 import numpy as np
+import pandas as pd
+import pyarrow as pa
+import pyarrow.dataset as ds
+import pyarrow.parquet as pq
+from fsspec.implementations.local import make_path_posix
+from fsspec.implementations.memory import MemoryFileSystem
+from fsspec.utils import infer_storage_options
+from pyarrow import ArrowInvalid
+
+from nautilus_trader.core.datetime import dt_to_unix_nanos
+from nautilus_trader.core.inspect import is_nautilus_class
+from nautilus_trader.model.data import Bar
+from nautilus_trader.model.data import BarSpecification
+from nautilus_trader.model.data import DataType
+from nautilus_trader.model.data import GenericData
+from nautilus_trader.model.data import QuoteTick
+from nautilus_trader.model.data import TradeTick
+from nautilus_trader.model.objects import FIXED_SCALAR
+from nautilus_trader.persistence.catalog.base import BaseDataCatalog
+from nautilus_trader.persistence.external.metadata import load_mappings
+from nautilus_trader.persistence.external.util import is_filename_in_time_range
+from nautilus_trader.persistence.streaming.batching import generate_batches_rust
+from nautilus_trader.serialization.arrow.serializer import ParquetSerializer
+from nautilus_trader.serialization.arrow.serializer import list_schemas
+from nautilus_trader.serialization.arrow.util import camel_to_snake_case
+from nautilus_trader.serialization.arrow.util import class_to_filename
+from nautilus_trader.serialization.arrow.util import clean_key
+from nautilus_trader.serialization.arrow.util import dict_of_lists_to_list_of_dicts
 
-cimport numpy as np
 
-from nautilus_trader.common.clock cimport Clock
-from nautilus_trader.common.logging cimport Logger
-from nautilus_trader.core.correctness cimport Condition
-from nautilus_trader.core.uuid cimport UUID4
-from nautilus_trader.model.identifiers cimport TraderId
-
-
-cdef class MessageBus:
+class ParquetDataCatalog(BaseDataCatalog):
     """
-    Provides a generic message bus to facilitate various messaging patterns.
-
-    The bus provides both a producer and consumer API for Pub/Sub, Req/Rep, as
-    well as direct point-to-point messaging to registered endpoints.
-
-    Pub/Sub wildcard patterns for hierarchical topics are possible:
-     - `*` asterisk represents one or more characters in a pattern.
-     - `?` question mark represents a single character in a pattern.
-
-    Given a topic and pattern potentially containing wildcard characters, i.e.
-    `*` and `?`, where `?` can match any single character in the topic, and `*`
-    can match any number of characters including zero characters.
-
-    The asterisk in a wildcard matches any character zero or more times. For
-    example, `comp*` matches anything beginning with `comp` which means `comp`,
-    `complete`, and `computer` are all matched.
-
-    A question mark matches a single character once. For example, `c?mp` matches
-    `camp` and `comp`. The question mark can also be used more than once.
-    For example, `c??p` would match both of the above examples and `coop`.
+    Provides a queryable data catalog persisted to files in parquet format.
 
     Parameters
     ----------
-    trader_id : TraderId
-        The trader ID associated with the message bus.
-    clock : Clock
-        The clock for the message bus.
-    logger : Logger
-        The logger for the message bus.
-    name : str, optional
-        The custom name for the message bus.
-
-    Raises
-    ------
-    ValueError
-        If `name` is not ``None`` and not a valid string.
+    path : str
+        The root path for this data catalog. Must exist and must be an absolute path.
+    fs_protocol : str, default 'file'
+        The fsspec filesystem protocol to use.
+    fs_storage_options : dict, optional
+        The fs storage options.
 
     Warnings
     --------
-    This message bus is not thread-safe and must be called from the same thread
-    as the event loop.
+    The catalog is not threadsafe.
     """
 
     def __init__(
         self,
-        TraderId trader_id not None,
-        Clock clock not None,
-        Logger logger not None,
-        str name = None,
+        path: str,
+        fs_protocol: Optional[str] = "file",
+        fs_storage_options: Optional[dict] = None,
     ):
-        if name is None:
-            name = type(self).__name__
-        Condition.valid_string(name, "name")
-
-        self.trader_id = trader_id
-
-        self._clock = clock
-        self._log = LoggerAdapter(component_name=name, logger=logger)
-
-        self._endpoints: dict[str, Callable[[Any], None]] = {}
-        self._patterns: dict[str, Subscription[:]] = {}
-        self._subscriptions: dict[Subscription, list[str]] = {}
-        self._correlation_index: dict[UUID4, Callable[[Any], None]] = {}
-
-        # Counters
-        self.sent_count = 0
-        self.req_count = 0
-        self.res_count = 0
-        self.pub_count = 0
-
-    cpdef list endpoints(self):
-        """
-        Return all endpoint addresses registered with the message bus.
-
-        Returns
-        -------
-        list[str]
-
-        """
-        return list(self._endpoints.keys())
-
-    cpdef list topics(self):
-        """
-        Return all topics with active subscribers.
-
-        Returns
-        -------
-        list[str]
-
-        """
-        return sorted(set([s.topic for s in self._subscriptions.keys()]))
-
-    cpdef list subscriptions(self, str pattern = None):
-        """
-        Return all subscriptions matching the given topic `pattern`.
-
-        Parameters
-        ----------
-        pattern : str, optional
-            The topic pattern filter. May include wildcard characters `*` and `?`.
-            If ``None`` then query is for **all** topics.
-
-        Returns
-        -------
-        list[Subscription]
-
-        """
-        if pattern is None:
-            pattern = "*"  # Wildcard
-        Condition.valid_string(pattern, "pattern")
-
-        return [s for s in self._subscriptions if is_matching(s.topic, pattern)]
-
-    cpdef bint has_subscribers(self, str pattern = None):
-        """
-        If the message bus has subscribers for the give topic `pattern`.
-
-        Parameters
-        ----------
-        pattern : str, optional
-            The topic filter. May include wildcard characters `*` and `?`.
-            If ``None`` then query is for **all** topics.
-
-        Returns
-        -------
-        bool
-
-        """
-        return len(self.subscriptions(pattern)) > 0
-
-    cpdef bint is_subscribed(self, str topic, handler: Callable[[Any], None]):
-        """
-        Return if topic and handler is subscribed to the message bus.
-
-        Does not consider any previous `priority`.
-
-        Parameters
-        ----------
-        topic : str
-            The topic of the subscription.
-        handler : Callable[[Any], None]
-            The handler of the subscription.
-
-        Returns
-        -------
-        bool
-
-        """
-        Condition.valid_string(topic, "topic")
-        Condition.callable(handler, "handler")
-
-        # Create subscription
-        cdef Subscription sub = Subscription(
-            topic=topic,
-            handler=handler,
+        self.fs_protocol = fs_protocol
+        self.fs_storage_options = fs_storage_options or {}
+        self.fs: fsspec.AbstractFileSystem = fsspec.filesystem(
+            self.fs_protocol, **self.fs_storage_options
         )
 
-        return sub in self._subscriptions
+        path = make_path_posix(str(path))
 
-    cpdef void register(self, str endpoint, handler: Callable[[Any], None]):
-        """
-        Register the given `handler` to receive messages at the `endpoint` address.
-
-        Parameters
-        ----------
-        endpoint : str
-            The endpoint address to register.
-        handler : Callable[[Any], None]
-            The handler for the registration.
-
-        Raises
-        ------
-        ValueError
-            If `endpoint` is not a valid string.
-        ValueError
-            If `handler` is not of type `Callable`.
-        KeyError
-            If `endpoint` already registered.
-
-        """
-        Condition.valid_string(endpoint, "endpoint")
-        Condition.callable(handler, "handler")
-        Condition.not_in(endpoint, self._endpoints, "endpoint", "_endpoints")
-
-        self._endpoints[endpoint] = handler
-
-        self._log.debug(f"Added endpoint '{endpoint}' {handler}.")
-
-    cpdef void deregister(self, str endpoint, handler: Callable[[Any], None]):
-        """
-        Deregister the given `handler` from the `endpoint` address.
-
-        Parameters
-        ----------
-        endpoint : str
-            The endpoint address to deregister.
-        handler : Callable[[Any], None]
-            The handler to deregister.
-
-        Raises
-        ------
-        ValueError
-            If `endpoint` is not a valid string.
-        ValueError
-            If `handler` is not of type `Callable`.
-        KeyError
-            If `endpoint` is not registered.
-        ValueError
-            If `handler` is not registered at the endpoint.
-
-        """
-        Condition.valid_string(endpoint, "endpoint")
-        Condition.callable(handler, "handler")
-        Condition.is_in(endpoint, self._endpoints, "endpoint", "self._endpoints")
-        Condition.equal(handler, self._endpoints[endpoint], "handler", "self._endpoints[endpoint]")
-
-        del self._endpoints[endpoint]
-
-        self._log.debug(f"Removed endpoint '{endpoint}' {handler}.")
-
-    cpdef void send(self, str endpoint, msg: Any):
-        """
-        Send the given message to the given `endpoint` address.
-
-        Parameters
-        ----------
-        endpoint : str
-            The endpoint address to send the message to.
-        msg : object
-            The message to send.
-
-        """
-        Condition.not_none(endpoint, "endpoint")
-        Condition.not_none(msg, "msg")
-
-        handler = self._endpoints.get(endpoint)
-        if handler is None:
-            self._log.error(
-                f"Cannot send message: no endpoint registered at '{endpoint}'.",
+        if (
+            isinstance(self.fs, MemoryFileSystem)
+            and platform.system() == "Windows"
+            and not path.startswith("/")
+        ):
+            path = "/" + path
+
+        self.path = str(path)
+
+    @classmethod
+    def from_env(cls):
+        return cls.from_uri(os.environ["NAUTILUS_PATH"] + "/catalog")
+
+    @classmethod
+    def from_uri(cls, uri):
+        if "://" not in uri:
+            # Assume a local path
+            uri = "file://" + uri
+        parsed = infer_storage_options(uri)
+        path = parsed.pop("path")
+        protocol = parsed.pop("protocol")
+        storage_options = parsed.copy()
+        return cls(path=path, fs_protocol=protocol, fs_storage_options=storage_options)
+
+    # -- QUERIES -----------------------------------------------------------------------------------
+
+    def query(self, cls, filter_expr=None, instrument_ids=None, as_nautilus=False, **kwargs):
+        if not is_nautilus_class(cls):
+            # Special handling for generic data
+            return self.generic_data(
+                cls=cls,
+                filter_expr=filter_expr,
+                instrument_ids=instrument_ids,
+                as_nautilus=as_nautilus,
+                **kwargs,
+            )
+        else:
+            return self._query(
+                cls=cls,
+                filter_expr=filter_expr,
+                instrument_ids=instrument_ids,
+                as_nautilus=as_nautilus,
+                **kwargs,
             )
-            return  # Cannot send
-
-        handler(msg)
-        self.sent_count += 1
 
-    cpdef void request(self, str endpoint, Request request):
-        """
-        Handle the given `request`.
-
-        Will log an error if the correlation ID already exists.
-
-        Parameters
-        ----------
-        endpoint : str
-            The endpoint address to send the request to.
-        request : Request
-            The request to handle.
-
-        """
-        Condition.not_none(endpoint, "endpoint")
-        Condition.not_none(request, "request")
-
-        if request.id in self._correlation_index:
-            self._log.error(
-                f"Cannot handle request: "
-                f"duplicate ID {request.id} found in correlation index.",
+    def _query(  # noqa (too complex)
+        self,
+        cls: type,
+        instrument_ids: Optional[list[str]] = None,
+        filter_expr: Optional[Callable] = None,
+        start: Optional[Union[pd.Timestamp, str, int]] = None,
+        end: Optional[Union[pd.Timestamp, str, int]] = None,
+        ts_column: str = "ts_init",
+        raise_on_empty: bool = True,
+        instrument_id_column="instrument_id",
+        table_kwargs: Optional[dict] = None,
+        clean_instrument_keys: bool = True,
+        as_dataframe: bool = True,
+        projections: Optional[dict] = None,
+        **kwargs,
+    ):
+        filters = [filter_expr] if filter_expr is not None else []
+        if instrument_ids is not None:
+            if not isinstance(instrument_ids, list):
+                instrument_ids = [instrument_ids]
+            if clean_instrument_keys:
+                instrument_ids = list(set(map(clean_key, instrument_ids)))
+            filters.append(ds.field(instrument_id_column).cast("string").isin(instrument_ids))
+        if start is not None:
+            filters.append(ds.field(ts_column) >= pd.Timestamp(start).value)
+        if end is not None:
+            filters.append(ds.field(ts_column) <= pd.Timestamp(end).value)
+
+        full_path = self.make_path(cls=cls)
+
+        if not (self.fs.exists(full_path) or self.fs.isdir(full_path)):
+            if raise_on_empty:
+                raise FileNotFoundError(f"protocol={self.fs.protocol}, path={full_path}")
+            else:
+                return pd.DataFrame() if as_dataframe else None
+
+        # Load rust objects
+        if isinstance(start, int) or start is None:
+            start_nanos = start
+        else:
+            start_nanos = dt_to_unix_nanos(start)  # datetime > nanos
+
+        if isinstance(end, int) or end is None:
+            end_nanos = end
+        else:
+            end_nanos = dt_to_unix_nanos(end)  # datetime > nanos
+
+        use_rust = kwargs.get("use_rust") and cls in (QuoteTick, TradeTick)
+        if use_rust and kwargs.get("as_nautilus"):
+            assert instrument_ids is not None
+            assert len(instrument_ids) > 0
+
+            to_merge = []
+            for instrument_id in instrument_ids:
+                files = self.get_files(cls, instrument_id, start_nanos, end_nanos)
+
+                if raise_on_empty and not files:
+                    raise RuntimeError("No files found.")
+
+                batches = generate_batches_rust(
+                    files=files,
+                    cls=cls,
+                    batch_size=sys.maxsize,
+                    start_nanos=start_nanos,
+                    end_nanos=end_nanos,
+                )
+                objs = list(itertools.chain.from_iterable(batches))
+                if len(instrument_ids) == 1:
+                    return objs  # skip merge, only 1 instrument
+                to_merge.append(objs)
+
+            return list(heapq.merge(*to_merge, key=lambda x: x.ts_init))
+
+        dataset = ds.dataset(full_path, partitioning="hive", filesystem=self.fs)
+
+        table_kwargs = table_kwargs or {}
+        if projections:
+            projected = {**{c: ds.field(c) for c in dataset.schema.names}, **projections}
+            table_kwargs.update(columns=projected)
+
+        try:
+            table = dataset.to_table(filter=combine_filters(*filters), **(table_kwargs or {}))
+        except Exception as e:
+            print(e)
+            raise e
+
+        if use_rust:
+            df = int_to_float_dataframe(table.to_pandas())
+            if start_nanos and end_nanos is None:
+                return df
+            if start_nanos is None:
+                start_nanos = 0
+            if end_nanos is None:
+                end_nanos = sys.maxsize
+            df = df[(df["ts_init"] >= start_nanos) & (df["ts_init"] <= end_nanos)]
+            return df
+
+        mappings = self.load_inverse_mappings(path=full_path)
+
+        if "as_nautilus" in kwargs:
+            as_dataframe = not kwargs.pop("as_nautilus")
+
+        if as_dataframe:
+            return self._handle_table_dataframe(
+                table=table, mappings=mappings, raise_on_empty=raise_on_empty, **kwargs
             )
-            return  # Do not handle duplicates
+        else:
+            return self._handle_table_nautilus(table=table, cls=cls, mappings=mappings)
 
-        self._correlation_index[request.id] = request.callback
+    def make_path(self, cls: type, instrument_id: Optional[str] = None) -> str:
+        path = f"{self.path}/data/{class_to_filename(cls=cls)}.parquet"
+        if instrument_id is not None:
+            path += f"/instrument_id={clean_key(instrument_id)}"
+        return path
 
-        handler = self._endpoints.get(endpoint)
-        if handler is None:
-            self._log.error(
-                f"Cannot handle request: no endpoint registered at '{endpoint}'.",
-            )
-            return  # Cannot handle
+    def get_files(
+        self,
+        cls: type,
+        instrument_id: Optional[str] = None,
+        start_nanos: Optional[int] = None,
+        end_nanos: Optional[int] = None,
+        bar_spec: Optional[BarSpecification] = None,
+    ) -> list[str]:
+        folder = self.make_path(cls=cls, instrument_id=instrument_id)
+
+        if not self.fs.isdir(folder):
+            return []
+
+        paths = self.fs.glob(f"{folder}/**")
+
+        file_paths = []
+        for path in paths:
+            # Filter by BarType
+            bar_spec_matched = False
+            if cls is Bar:
+                bar_spec_matched = bar_spec and str(bar_spec) in path
+                if not bar_spec_matched:
+                    continue
+
+            # Filter by time range
+            file_path = pathlib.PurePosixPath(path).name
+            matched = is_filename_in_time_range(file_path, start_nanos, end_nanos)
+            if matched:
+                file_paths.append(str(path))
 
-        handler(request)
-        self.req_count += 1
+        file_paths = sorted(file_paths, key=lambda x: Path(x).stem)
 
-    cpdef void response(self, Response response):
-        """
-        Handle the given `response`.
-
-        Will log an error if the correlation ID is not found.
-
-        Parameters
-        ----------
-        response : Response
-            The response to handle
-
-        """
-        Condition.not_none(response, "response")
-
-        callback = self._correlation_index.pop(response.correlation_id, None)
-        if callback is None:
-            self._log.error(
-                f"Cannot handle response: "
-                f"callback not found for correlation_id {response.correlation_id}.",
+        return file_paths
+
+    def _get_files(
+        self,
+        cls: type,
+        instrument_id: Optional[str] = None,
+        start_nanos: Optional[int] = None,
+        end_nanos: Optional[int] = None,
+    ) -> list[str]:
+        folder = (
+            self.path
+            if instrument_id is None
+            else self.make_path(cls=cls, instrument_id=instrument_id)
+        )
+
+        if not os.path.exists(folder):
+            return []
+
+        paths = self.fs.glob(f"{folder}/**")
+
+        files = []
+        for path in paths:
+            fn = pathlib.PurePosixPath(path).name
+            matched = is_filename_in_time_range(fn, start_nanos, end_nanos)
+            if matched:
+                files.append(str(path))
+
+        files = sorted(files, key=lambda x: Path(x).stem)
+
+        return files
+
+    def load_inverse_mappings(self, path):
+        mappings = load_mappings(fs=self.fs, path=path)
+        for key in mappings:
+            mappings[key] = {v: k for k, v in mappings[key].items()}
+        return mappings
+
+    @staticmethod
+    def _handle_table_dataframe(
+        table: pa.Table,
+        mappings: Optional[dict],
+        raise_on_empty: bool = True,
+        sort_columns: Optional[list] = None,
+        as_type: Optional[dict] = None,
+    ):
+        df = table.to_pandas().drop_duplicates()
+        for col in mappings:
+            df.loc[:, col] = df[col].map(mappings[col])
+
+        if df.empty and raise_on_empty:
+            raise ValueError("Data empty")
+        if sort_columns:
+            df = df.sort_values(sort_columns)
+        if as_type:
+            df = df.astype(as_type)
+        return df
+
+    @staticmethod
+    def _handle_table_nautilus(
+        table: Union[pa.Table, pd.DataFrame],
+        cls: type,
+        mappings: Optional[dict],
+    ):
+        if isinstance(table, pa.Table):
+            dicts = dict_of_lists_to_list_of_dicts(table.to_pydict())
+        elif isinstance(table, pd.DataFrame):
+            dicts = table.to_dict("records")
+        else:
+            raise TypeError(
+                f"`table` was {type(table)}, expected `pyarrow.Table` or `pandas.DataFrame`",
             )
-            return  # Cannot handle
+        if not dicts:
+            return []
+        for key, maps in mappings.items():
+            for d in dicts:
+                if d[key] in maps:
+                    d[key] = maps[d[key]]
+        data = ParquetSerializer.deserialize(cls=cls, chunk=dicts)
+        return data
+
+    def _query_subclasses(
+        self,
+        base_cls: type,
+        instrument_ids: Optional[list[str]] = None,
+        filter_expr: Optional[Callable] = None,
+        as_nautilus: bool = False,
+        **kwargs,
+    ):
+        subclasses = [base_cls, *base_cls.__subclasses__()]
 
-        callback(response)
-        self.res_count += 1
+        dfs = []
+        for cls in subclasses:
+            try:
+                df = self.query(
+                    cls=cls,
+                    filter_expr=filter_expr,
+                    instrument_ids=instrument_ids,
+                    raise_on_empty=False,
+                    as_nautilus=as_nautilus,
+                    **kwargs,
+                )
+                dfs.append(df)
+            except ArrowInvalid as e:
+                # If we're using a `filter_expr` here, there's a good chance
+                # this error is using a filter that is specific to one set of
+                # instruments and not to others, so we ignore it (if not; raise).
+                if filter_expr is not None:
+                    continue
+                else:
+                    raise e
+
+        if not as_nautilus:
+            return pd.concat([df for df in dfs if df is not None])
+        else:
+            objects = [o for objs in [df for df in dfs if df is not None] for o in objs]
+            return objects
 
-    cpdef void subscribe(
+    # ---  OVERLOADED BASE METHODS ------------------------------------------------
+    def generic_data(
         self,
-        str topic,
-        handler: Callable[[Any], None],
-        int priority = 0,
+        cls: type,
+        as_nautilus: bool = False,
+        metadata: Optional[dict] = None,
+        filter_expr: Optional[Callable] = None,
+        **kwargs,
     ):
-        """
-        Subscribe to the given message `topic` with the given callback `handler`.
+        data = self._query(
+            cls=cls,
+            filter_expr=filter_expr,
+            as_dataframe=not as_nautilus,
+            **kwargs,
+        )
+        if as_nautilus:
+            if data is None:
+                return []
+            return [GenericData(data_type=DataType(cls, metadata=metadata), data=d) for d in data]
+        return data
 
-        Parameters
-        ----------
-        topic : str
-            The topic for the subscription. May include wildcard characters
-            `*` and `?`.
-        handler : Callable[[Any], None]
-            The handler for the subscription.
-        priority : int, optional
-            The priority for the subscription. Determines the ordering of
-            handlers receiving messages being processed, higher priority
-            handlers will receive messages prior to lower priority handlers.
-
-        Raises
-        ------
-        ValueError
-            If `topic` is not a valid string.
-        ValueError
-            If `handler` is not of type `Callable`.
-
-        Warnings
-        --------
-        Assigning priority handling is an advanced feature which *shouldn't
-        normally be needed by most users*. **Only assign a higher priority to the
-        subscription if you are certain of what you're doing**. If an inappropriate
-        priority is assigned then the handler may receive messages before core
-        system components have been able to process necessary calculations and
-        produce potential side effects for logically sound behaviour.
-
-        """
-        Condition.valid_string(topic, "topic")
-        Condition.callable(handler, "handler")
-
-        # Create subscription
-        cdef Subscription sub = Subscription(
-            topic=topic,
-            handler=handler,
-            priority=priority,
+    def instruments(
+        self,
+        instrument_type: Optional[type] = None,
+        instrument_ids: Optional[list[str]] = None,
+        **kwargs,
+    ):
+        kwargs["clean_instrument_keys"] = False
+        return super().instruments(
+            instrument_type=instrument_type,
+            instrument_ids=instrument_ids,
+            **kwargs,
         )
 
-        # Check if already exists
-        if sub in self._subscriptions:
-            self._log.debug(f"{sub} already exists.")
-            return
-
-        cdef list matches = []
-        cdef list patterns = list(self._patterns.keys())
-
-        cdef str pattern
-        cdef list subs
-        for pattern in patterns:
-            if is_matching(topic, pattern):
-                subs = list(self._patterns[pattern])
-                subs.append(sub)
-                subs = sorted(subs, reverse=True)
-                self._patterns[pattern] = np.ascontiguousarray(subs, dtype=Subscription)
-                matches.append(pattern)
-
-        self._subscriptions[sub] = sorted(matches)
-
-        self._log.debug(f"Added {sub}.")
-
-    cpdef void unsubscribe(self, str topic, handler: Callable[[Any], None]):
-        """
-        Unsubscribe the given callback `handler` from the given message `topic`.
-
-        Parameters
-        ----------
-        topic : str, optional
-            The topic to unsubscribe from. May include wildcard characters `*`
-            and `?`.
-        handler : Callable[[Any], None]
-            The handler for the subscription.
-
-        Raises
-        ------
-        ValueError
-            If `topic` is not a valid string.
-        ValueError
-            If `handler` is not of type `Callable`.
-
-        """
-        Condition.valid_string(topic, "topic")
-        Condition.callable(handler, "handler")
-
-        cdef Subscription sub = Subscription(topic=topic, handler=handler)
-
-        cdef list patterns = self._subscriptions.get(sub)
-
-        # Check if exists
-        if patterns is None:
-            self._log.warning(f"{sub} not found.")
-            return
-
-        cdef str pattern
-        for pattern in patterns:
-            subs = list(self._patterns[pattern])
-            subs.remove(sub)
-            subs = sorted(subs, reverse=True)
-            self._patterns[pattern] = np.ascontiguousarray(subs, dtype=Subscription)
-
-        del self._subscriptions[sub]
-
-        self._log.debug(f"Removed {sub}.")
-
-    cpdef void publish(self, str topic, msg: Any):
-        """
-        Publish the given message for the given `topic`.
-
-        Subscription handlers will receive the message in priority order
-        (highest first).
-
-        Parameters
-        ----------
-        topic : str
-            The topic to publish on.
-        msg : object
-            The message to publish.
-
-        """
-        self.publish_c(topic, msg)
-
-    @cython.boundscheck(False)
-    @cython.wraparound(False)
-    cdef void publish_c(self, str topic, msg: Any):
-        Condition.not_none(topic, "topic")
-        Condition.not_none(msg, "msg")
-
-        # Get all subscriptions matching topic pattern
-        cdef Subscription[:] subs = self._patterns.get(topic)
-        if subs is None:
-            # Add the topic pattern and get matching subscribers
-            subs = self._resolve_subscriptions(topic)
-
-        # Send message to all matched subscribers
-        cdef:
-            int i
-            Subscription sub
-        for i in range(len(subs)):
-            sub = subs[i]
-            sub.handler(msg)
-
-        self.pub_count += 1
-
-    cdef Subscription[:] _resolve_subscriptions(self, str topic):
-        cdef list subs_list = []
-        cdef Subscription existing_sub
-        for existing_sub in self._subscriptions:
-            if is_matching(topic, existing_sub.topic):
-                subs_list.append(existing_sub)
-
-        subs_list = sorted(subs_list, reverse=True)
-        cdef Subscription[:] subs_array = np.ascontiguousarray(subs_list, dtype=Subscription)
-        self._patterns[topic] = subs_array
-
-        cdef list matches
-        for sub in subs_array:
-            matches = self._subscriptions.get(sub, [])
-            if topic not in matches:
-                matches.append(topic)
-            self._subscriptions[sub] = sorted(matches)
-
-        return subs_array
-
-
-cdef inline bint is_matching(str topic, str pattern):
-    # Get length of string and wildcard pattern
-    cdef int n = len(topic)
-    cdef int m = len(pattern)
-
-    # Create a DP lookup table
-    cdef np.ndarray[np.int8_t, ndim=2] t = np.empty((n + 1, m + 1), dtype=np.int8)
-    t.fill(False)
-
-    # If both pattern and string are empty: match
-    t[0, 0] = True
-
-    # Handle empty string case (i == 0)
-    cdef int j
-    for j in range(1, m + 1):
-        if pattern[j - 1] == '*':
-            t[0, j] = t[0, j - 1]
-
-    # Build a matrix in a bottom-up manner
-    cdef int i
-    for i in range(1, n + 1):
-        for j in range(1, m + 1):
-            if pattern[j - 1] == '*':
-                t[i, j] = t[i - 1, j] or t[i, j - 1]
-            elif pattern[j - 1] == '?' or topic[i - 1] == pattern[j - 1]:
-                t[i, j] = t[i - 1, j - 1]
-
-    return t[n, m]
-
-
-# Python wrapper for test access
-def is_matching_py(str topic, str pattern) -> bool:
-    return is_matching(topic, pattern)
+    def list_data_types(self):
+        glob_path = f"{self.path}/data/*.parquet"
+        return [pathlib.Path(p).stem for p in self.fs.glob(glob_path)]
+
+    def list_partitions(self, cls_type: type):
+        assert isinstance(cls_type, type), "`cls_type` should be type, i.e. TradeTick"
+        name = class_to_filename(cls_type)
+        dataset = pq.ParquetDataset(
+            f"{self.path}/data/{name}.parquet",
+            filesystem=self.fs,
+        )
+        # TODO(cs): Catalog v1 impl below
+        # partitions = {}
+        # for level in dataset.partitioning:
+        #     partitions[level.name] = level.keys
+        return dataset.partitioning
+
+    def list_backtests(self) -> list[str]:
+        glob_path = f"{self.path}/backtest/*.feather"
+        return [p.stem for p in map(Path, self.fs.glob(glob_path))]
+
+    def list_live_runs(self) -> list[str]:
+        glob_path = f"{self.path}/live/*.feather"
+        return [p.stem for p in map(Path, self.fs.glob(glob_path))]
+
+    def read_live_run(self, live_run_id: str, **kwargs):
+        return self._read_feather(kind="live", run_id=live_run_id, **kwargs)
+
+    def read_backtest(self, backtest_run_id: str, **kwargs):
+        return self._read_feather(kind="backtest", run_id=backtest_run_id, **kwargs)
+
+    def _read_feather(self, kind: str, run_id: str, raise_on_failed_deserialize: bool = False):
+        class_mapping: dict[str, type] = {class_to_filename(cls): cls for cls in list_schemas()}
+        data = {}
+        glob_path = f"{self.path}/{kind}/{run_id}.feather/*.feather"
+
+        for path in list(self.fs.glob(glob_path)):
+            cls_name = camel_to_snake_case(pathlib.Path(path).stem).replace("__", "_")
+            df = read_feather_file(path=path, fs=self.fs)
+
+            if df is None:
+                print(f"No data for {cls_name}")
+                continue
+            # Apply post read fixes
+            try:
+                objs = self._handle_table_nautilus(
+                    table=df,
+                    cls=class_mapping[cls_name],
+                    mappings={},
+                )
+                data[cls_name] = objs
+            except Exception as e:
+                if raise_on_failed_deserialize:
+                    raise
+                print(f"Failed to deserialize {cls_name}: {e}")
+        return sorted(sum(data.values(), []), key=lambda x: x.ts_init)
+
+
+def read_feather_file(path: str, fs: fsspec.AbstractFileSystem = None):
+    fs = fs or fsspec.filesystem("file")
+    if not fs.exists(path):
+        return
+    try:
+        with fs.open(path) as f:
+            reader = pa.ipc.open_stream(f)
+            return reader.read_pandas()
+    except (pa.ArrowInvalid, FileNotFoundError):
+        return
+
+
+def combine_filters(*filters):
+    filters = tuple(x for x in filters if x is not None)
+    if len(filters) == 0:
+        return
+    elif len(filters) == 1:
+        return filters[0]
+    else:
+        expr = filters[0]
+        for f in filters[1:]:
+            expr = expr & f
+        return expr
+
+
+def int_to_float_dataframe(df: pd.DataFrame):
+    cols = [
+        col
+        for col, dtype in dict(df.dtypes).items()
+        if dtype == np.int64 or dtype == np.uint64 and (col != "ts_event" and col != "ts_init")
+    ]
+    df[cols] = df[cols] / FIXED_SCALAR
+    return df
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/msgbus/subscription.pxd` & `nautilus_trader-1.175.0/nautilus_trader/msgbus/subscription.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/msgbus/subscription.pyx` & `nautilus_trader-1.175.0/nautilus_trader/msgbus/subscription.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/network/__init__.pxd` & `nautilus_trader-1.175.0/nautilus_trader/network/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/network/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/network/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/network/error.py` & `nautilus_trader-1.175.0/nautilus_trader/network/error.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/network/http.pxd` & `nautilus_trader-1.175.0/nautilus_trader/network/http.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/network/http.pyx` & `nautilus_trader-1.175.0/nautilus_trader/network/http.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/network/socket.pxd` & `nautilus_trader-1.175.0/nautilus_trader/network/socket.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/network/socket.pyx` & `nautilus_trader-1.175.0/nautilus_trader/network/socket.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/network/websocket.pxd` & `nautilus_trader-1.175.0/nautilus_trader/core/data.pyx`

 * *Files 26% similar despite different names*

```diff
@@ -9,35 +9,59 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.common.logging cimport LoggerAdapter
+import cython
 
 
-cdef class WebSocketClient:
-    cdef readonly object _loop
-    cdef readonly LoggerAdapter _log
-    cdef str _ws_url
-    cdef dict _ws_kwargs
-    cdef object _session
-    cdef object _ws
-    cdef object _task
-    cdef object _handler
-    cdef bytes _pong_msg
-    cdef bint _log_send
-    cdef bint _log_recv
-
-    cdef readonly bint is_connected
-    """If the client is connected.\n\n:returns: `bool`"""
-    cdef readonly bint is_running
-    """If the client is running.\n\n:returns: `bool`"""
-    cdef readonly bint is_stopping
-    """If the client is stopping.\n\n:returns: `bool`"""
-    cdef readonly int max_retry_connection
-    """The max connection retries.\n\n:returns: `int`"""
-    cdef readonly int connection_retry_count
-    """The current connection retry count.\n\n:returns: `int`"""
-    cdef readonly int unknown_message_count
-    """The current unknown message count.\n\n:returns: `int`"""
+@cython.auto_pickle(False)
+cdef class Data:
+    """
+    The abstract base class for all data.
+
+    Warnings
+    --------
+    This class should not be used directly, but through a concrete subclass.
+    """
+
+    @property
+    def ts_event(self) -> int:
+        """
+        The UNIX timestamp (nanoseconds) when the data event occurred.
+
+        Returns
+        -------
+        int
+
+        """
+        raise NotImplementedError("abstract property must be implemented")
+
+    @property
+    def ts_init(self) -> int:
+        """
+        The UNIX timestamp (nanoseconds) when the object was initialized.
+
+        Returns
+        -------
+        int
+
+        """
+        raise NotImplementedError("abstract property must be implemented")
+
+    @classmethod
+    def fully_qualified_name(cls) -> str:
+        """
+        Return the fully qualified name for the `Data` class.
+
+        Returns
+        -------
+        str
+
+        References
+        ----------
+        https://www.python.org/dev/peps/pep-3155/
+
+        """
+        return cls.__module__ + ':' + cls.__qualname__
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/persistence/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/persistence/external/__init__.py`

 * *Files 12% similar despite different names*

```diff
@@ -8,9 +8,7 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
-"""The `persistence` subpackage handles data storage and retrieval, mainly to support backtesting."""
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/persistence/catalog/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/persistence/catalog/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/persistence/catalog/base.py` & `nautilus_trader-1.175.0/nautilus_trader/persistence/catalog/base.py`

 * *Files 3% similar despite different names*

```diff
@@ -14,23 +14,23 @@
 # -------------------------------------------------------------------------------------------------
 
 from abc import ABC
 from abc import ABCMeta
 from abc import abstractmethod
 from typing import Optional
 
-from nautilus_trader.model.data.bar import Bar
-from nautilus_trader.model.data.base import DataType
-from nautilus_trader.model.data.base import GenericData
-from nautilus_trader.model.data.book import OrderBookDelta
-from nautilus_trader.model.data.tick import QuoteTick
-from nautilus_trader.model.data.tick import TradeTick
-from nautilus_trader.model.data.ticker import Ticker
-from nautilus_trader.model.data.venue import InstrumentClose
-from nautilus_trader.model.data.venue import InstrumentStatusUpdate
+from nautilus_trader.model.data import Bar
+from nautilus_trader.model.data import DataType
+from nautilus_trader.model.data import GenericData
+from nautilus_trader.model.data import InstrumentClose
+from nautilus_trader.model.data import InstrumentStatusUpdate
+from nautilus_trader.model.data import OrderBookDelta
+from nautilus_trader.model.data import QuoteTick
+from nautilus_trader.model.data import Ticker
+from nautilus_trader.model.data import TradeTick
 from nautilus_trader.model.instruments import Instrument
 from nautilus_trader.persistence.external.util import Singleton
 from nautilus_trader.serialization.arrow.util import GENERIC_DATA_PREFIX
 
 
 class _CombinedMeta(Singleton, ABCMeta):
     pass
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/persistence/catalog/parquet.py` & `nautilus_trader-1.175.0/nautilus_trader/persistence/wranglers.pyx`

 * *Files 21% similar despite different names*

```diff
@@ -9,514 +9,507 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-import heapq
-import itertools
-import os
-import pathlib
-import platform
-import sys
-from pathlib import Path
-from typing import Callable, Optional, Union
+import random
+from copy import copy
+from typing import Optional
 
-import fsspec
 import numpy as np
 import pandas as pd
-import pyarrow as pa
-import pyarrow.dataset as ds
-import pyarrow.parquet as pq
-from fsspec.implementations.local import make_path_posix
-from fsspec.implementations.memory import MemoryFileSystem
-from fsspec.utils import infer_storage_options
-from pyarrow import ArrowInvalid
-
-from nautilus_trader.core.datetime import dt_to_unix_nanos
-from nautilus_trader.core.inspect import is_nautilus_class
-from nautilus_trader.model.data.bar import Bar
-from nautilus_trader.model.data.bar import BarSpecification
-from nautilus_trader.model.data.base import DataType
-from nautilus_trader.model.data.base import GenericData
-from nautilus_trader.model.data.tick import QuoteTick
-from nautilus_trader.model.data.tick import TradeTick
-from nautilus_trader.model.objects import FIXED_SCALAR
-from nautilus_trader.persistence.catalog.base import BaseDataCatalog
-from nautilus_trader.persistence.external.metadata import load_mappings
-from nautilus_trader.persistence.external.util import is_filename_in_time_range
-from nautilus_trader.persistence.streaming.batching import generate_batches_rust
-from nautilus_trader.serialization.arrow.serializer import ParquetSerializer
-from nautilus_trader.serialization.arrow.serializer import list_schemas
-from nautilus_trader.serialization.arrow.util import camel_to_snake_case
-from nautilus_trader.serialization.arrow.util import class_to_filename
-from nautilus_trader.serialization.arrow.util import clean_key
-from nautilus_trader.serialization.arrow.util import dict_of_lists_to_list_of_dicts
 
+from cpython.pycapsule cimport PyCapsule_GetPointer
+from libc.stdint cimport int64_t
+from libc.stdint cimport uint64_t
+
+from nautilus_trader.core.correctness cimport Condition
+from nautilus_trader.core.data cimport Data
+from nautilus_trader.core.datetime cimport as_utc_index
+from nautilus_trader.core.rust.core cimport CVec
+from nautilus_trader.core.rust.core cimport secs_to_nanos
+from nautilus_trader.core.rust.model cimport Data_t
+from nautilus_trader.core.rust.model cimport Data_t_Tag
+from nautilus_trader.model.data.bar cimport Bar
+from nautilus_trader.model.data.bar cimport BarType
+from nautilus_trader.model.data.tick cimport QuoteTick
+from nautilus_trader.model.data.tick cimport TradeTick
+from nautilus_trader.model.enums_c cimport AggressorSide
+from nautilus_trader.model.identifiers cimport TradeId
+from nautilus_trader.model.instruments.base cimport Instrument
+from nautilus_trader.model.objects cimport Price
+from nautilus_trader.model.objects cimport Quantity
+
+
+# Safety: Do NOT deallocate the capsule here
+cdef inline list capsule_to_data_list(object capsule):
+    cdef CVec* data = <CVec*>PyCapsule_GetPointer(capsule, NULL)
+    cdef Data_t* ptr = <Data_t*>data.ptr
+    cdef list ticks = []
+
+    cdef uint64_t i
+    for i in range(0, data.len):
+        if ptr[i].tag == Data_t_Tag.TRADE:
+            ticks.append(TradeTick.from_mem_c(ptr[i].trade))
+        elif ptr[i].tag == Data_t_Tag.QUOTE:
+            ticks.append(QuoteTick.from_mem_c(ptr[i].quote))
 
-class ParquetDataCatalog(BaseDataCatalog):
+    return ticks
+
+
+def list_from_capsule(capsule) -> list[Data]:
+    return capsule_to_data_list(capsule)
+
+
+cdef class QuoteTickDataWrangler:
     """
-    Provides a queryable data catalog persisted to files in parquet format.
+    Provides a means of building lists of Nautilus `QuoteTick` objects.
 
     Parameters
     ----------
-    path : str
-        The root path for this data catalog. Must exist and must be an absolute path.
-    fs_protocol : str, default 'file'
-        The fsspec filesystem protocol to use.
-    fs_storage_options : dict, optional
-        The fs storage options.
-
-    Warnings
-    --------
-    The catalog is not threadsafe.
+    instrument : Instrument
+        The instrument for the data wrangler.
     """
 
-    def __init__(
+    def __init__(self, Instrument instrument not None):
+        self.instrument = instrument
+
+    def process(
         self,
-        path: str,
-        fs_protocol: Optional[str] = "file",
-        fs_storage_options: Optional[dict] = None,
+        data: pd.DataFrame,
+        default_volume: float=1_000_000.0,
+        ts_init_delta: int=0,
     ):
-        self.fs_protocol = fs_protocol
-        self.fs_storage_options = fs_storage_options or {}
-        self.fs: fsspec.AbstractFileSystem = fsspec.filesystem(
-            self.fs_protocol, **self.fs_storage_options
-        )
+        """
+        Process the give tick dataset into Nautilus `QuoteTick` objects.
 
-        path = make_path_posix(str(path))
+        Expects columns ['bid', 'ask'] with 'timestamp' index.
+        Note: The 'bid_size' and 'ask_size' columns are optional, will then use
+        the `default_volume`.
+
+        Parameters
+        ----------
+        data : pd.DataFrame
+            The tick data to process.
+        default_volume : float
+            The default volume for each tick (if not provided).
+        ts_init_delta : int
+            The difference in nanoseconds between the data timestamps and the
+            `ts_init` value. Can be used to represent/simulate latency between
+            the data source and the Nautilus system. Cannot be negative.
+
+        Returns
+        -------
+        list[QuoteTick]
+
+        """
+        Condition.false(data.empty, "data.empty")
+        Condition.not_none(default_volume, "default_volume")
+
+        as_utc_index(data)
+
+        if "bid_size" not in data.columns:
+            data["bid_size"] = float(default_volume)
+        if "ask_size" not in data.columns:
+            data["ask_size"] = float(default_volume)
+
+        cdef uint64_t[:] ts_events = np.ascontiguousarray([secs_to_nanos(dt.timestamp()) for dt in data.index], dtype=np.uint64)  # noqa
+        cdef uint64_t[:] ts_inits = np.ascontiguousarray([ts_event + ts_init_delta for ts_event in ts_events], dtype=np.uint64)  # noqa
+
+        return list(map(
+            self._build_tick,
+            data["bid"],
+            data["ask"],
+            data["bid_size"],
+            data["ask_size"],
+            ts_events,
+            ts_inits,
+        ))
 
-        if (
-            isinstance(self.fs, MemoryFileSystem)
-            and platform.system() == "Windows"
-            and not path.startswith("/")
-        ):
-            path = "/" + path
-
-        self.path = str(path)
-
-    @classmethod
-    def from_env(cls):
-        return cls.from_uri(os.environ["NAUTILUS_PATH"] + "/catalog")
-
-    @classmethod
-    def from_uri(cls, uri):
-        if "://" not in uri:
-            # Assume a local path
-            uri = "file://" + uri
-        parsed = infer_storage_options(uri)
-        path = parsed.pop("path")
-        protocol = parsed.pop("protocol")
-        storage_options = parsed.copy()
-        return cls(path=path, fs_protocol=protocol, fs_storage_options=storage_options)
-
-    # -- QUERIES -----------------------------------------------------------------------------------
-
-    def query(self, cls, filter_expr=None, instrument_ids=None, as_nautilus=False, **kwargs):
-        if not is_nautilus_class(cls):
-            # Special handling for generic data
-            return self.generic_data(
-                cls=cls,
-                filter_expr=filter_expr,
-                instrument_ids=instrument_ids,
-                as_nautilus=as_nautilus,
-                **kwargs,
-            )
-        else:
-            return self._query(
-                cls=cls,
-                filter_expr=filter_expr,
-                instrument_ids=instrument_ids,
-                as_nautilus=as_nautilus,
-                **kwargs,
-            )
-
-    def _query(  # noqa (too complex)
+    def process_bar_data(
         self,
-        cls: type,
-        instrument_ids: Optional[list[str]] = None,
-        filter_expr: Optional[Callable] = None,
-        start: Optional[Union[pd.Timestamp, str, int]] = None,
-        end: Optional[Union[pd.Timestamp, str, int]] = None,
-        ts_column: str = "ts_init",
-        raise_on_empty: bool = True,
-        instrument_id_column="instrument_id",
-        table_kwargs: Optional[dict] = None,
-        clean_instrument_keys: bool = True,
-        as_dataframe: bool = True,
-        projections: Optional[dict] = None,
-        **kwargs,
+        bid_data: pd.DataFrame,
+        ask_data: pd.DataFrame,
+        default_volume: float = 1_000_000.0,
+        ts_init_delta: int = 0,
+        random_seed: Optional[int] = None,
+        bint is_raw: bool = False,
     ):
-        filters = [filter_expr] if filter_expr is not None else []
-        if instrument_ids is not None:
-            if not isinstance(instrument_ids, list):
-                instrument_ids = [instrument_ids]
-            if clean_instrument_keys:
-                instrument_ids = list(set(map(clean_key, instrument_ids)))
-            filters.append(ds.field(instrument_id_column).cast("string").isin(instrument_ids))
-        if start is not None:
-            filters.append(ds.field(ts_column) >= pd.Timestamp(start).value)
-        if end is not None:
-            filters.append(ds.field(ts_column) <= pd.Timestamp(end).value)
-
-        full_path = self.make_path(cls=cls)
-
-        if not (self.fs.exists(full_path) or self.fs.isdir(full_path)):
-            if raise_on_empty:
-                raise FileNotFoundError(f"protocol={self.fs.protocol}, path={full_path}")
-            else:
-                return pd.DataFrame() if as_dataframe else None
-
-        # Load rust objects
-        if isinstance(start, int) or start is None:
-            start_nanos = start
-        else:
-            start_nanos = dt_to_unix_nanos(start)  # datetime > nanos
+        """
+        Process the given bar datasets into Nautilus `QuoteTick` objects.
 
-        if isinstance(end, int) or end is None:
-            end_nanos = end
-        else:
-            end_nanos = dt_to_unix_nanos(end)  # datetime > nanos
+        Expects columns ['open', 'high', 'low', 'close', 'volume'] with 'timestamp' index.
+        Note: The 'volume' column is optional, will then use the `default_volume`.
 
-        use_rust = kwargs.get("use_rust") and cls in (QuoteTick, TradeTick)
-        if use_rust and kwargs.get("as_nautilus"):
-            assert instrument_ids is not None
-            assert len(instrument_ids) > 0
-
-            to_merge = []
-            for instrument_id in instrument_ids:
-                files = self.get_files(cls, instrument_id, start_nanos, end_nanos)
-
-                if raise_on_empty and not files:
-                    raise RuntimeError("No files found.")
-
-                batches = generate_batches_rust(
-                    files=files,
-                    cls=cls,
-                    batch_size=sys.maxsize,
-                    start_nanos=start_nanos,
-                    end_nanos=end_nanos,
-                )
-                objs = list(itertools.chain.from_iterable(batches))
-                if len(instrument_ids) == 1:
-                    return objs  # skip merge, only 1 instrument
-                to_merge.append(objs)
-
-            return list(heapq.merge(*to_merge, key=lambda x: x.ts_init))
-
-        dataset = ds.dataset(full_path, partitioning="hive", filesystem=self.fs)
-
-        table_kwargs = table_kwargs or {}
-        if projections:
-            projected = {**{c: ds.field(c) for c in dataset.schema.names}, **projections}
-            table_kwargs.update(columns=projected)
-
-        try:
-            table = dataset.to_table(filter=combine_filters(*filters), **(table_kwargs or {}))
-        except Exception as e:
-            print(e)
-            raise e
-
-        if use_rust:
-            df = int_to_float_dataframe(table.to_pandas())
-            if start_nanos and end_nanos is None:
-                return df
-            if start_nanos is None:
-                start_nanos = 0
-            if end_nanos is None:
-                end_nanos = sys.maxsize
-            df = df[(df["ts_init"] >= start_nanos) & (df["ts_init"] <= end_nanos)]
-            return df
-
-        mappings = self.load_inverse_mappings(path=full_path)
-
-        if "as_nautilus" in kwargs:
-            as_dataframe = not kwargs.pop("as_nautilus")
-
-        if as_dataframe:
-            return self._handle_table_dataframe(
-                table=table, mappings=mappings, raise_on_empty=raise_on_empty, **kwargs
-            )
+        Parameters
+        ----------
+        bid_data : pd.DataFrame
+            The bid bar data.
+        ask_data : pd.DataFrame
+            The ask bar data.
+        default_volume : float
+            The volume per tick if not available from the data.
+        ts_init_delta : int
+            The difference in nanoseconds between the data timestamps and the
+            `ts_init` value. Can be used to represent/simulate latency between
+            the data source and the Nautilus system.
+        random_seed : int, optional
+            The random seed for shuffling order of high and low ticks from bar
+            data. If random_seed is ``None`` then won't shuffle.
+        is_raw : bool, default False
+            If the data is scaled to the Nautilus fixed precision.
+
+        """
+        Condition.not_none(bid_data, "bid_data")
+        Condition.not_none(ask_data, "ask_data")
+        Condition.false(bid_data.empty, "bid_data.empty")
+        Condition.false(ask_data.empty, "ask_data.empty")
+        Condition.not_none(default_volume, "default_volume")
+        if random_seed is not None:
+            Condition.type(random_seed, int, "random_seed")
+
+        # Ensure index is tz-aware UTC
+        bid_data = as_utc_index(bid_data)
+        ask_data = as_utc_index(ask_data)
+
+        if "volume" not in bid_data:
+            bid_data["volume"] = float(default_volume * 4)
+
+        if "volume" not in ask_data:
+            ask_data["volume"] = float(default_volume * 4)
+
+        cdef dict data_open = {
+            "bid": bid_data["open"],
+            "ask": ask_data["open"],
+            "bid_size": bid_data["volume"] / 4,
+            "ask_size": ask_data["volume"] / 4,
+        }
+
+        cdef dict data_high = {
+            "bid": bid_data["high"],
+            "ask": ask_data["high"],
+            "bid_size": bid_data["volume"] / 4,
+            "ask_size": ask_data["volume"] / 4,
+        }
+
+        cdef dict data_low = {
+            "bid": bid_data["low"],
+            "ask": ask_data["low"],
+            "bid_size": bid_data["volume"] / 4,
+            "ask_size": ask_data["volume"] / 4,
+        }
+
+        cdef dict data_close = {
+            "bid": bid_data["close"],
+            "ask": ask_data["close"],
+            "bid_size": bid_data["volume"] / 4,
+            "ask_size": ask_data["volume"] / 4,
+        }
+
+        df_ticks_o = pd.DataFrame(data=data_open)
+        df_ticks_h = pd.DataFrame(data=data_high)
+        df_ticks_l = pd.DataFrame(data=data_low)
+        df_ticks_c = pd.DataFrame(data=data_close)
+
+        # Latency offsets
+        df_ticks_o.index = df_ticks_o.index.shift(periods=-300, freq="ms")
+        df_ticks_h.index = df_ticks_h.index.shift(periods=-200, freq="ms")
+        df_ticks_l.index = df_ticks_l.index.shift(periods=-100, freq="ms")
+
+        # Merge tick data
+        df_ticks_final = pd.concat([df_ticks_o, df_ticks_h, df_ticks_l, df_ticks_c])
+        df_ticks_final.dropna(inplace=True)
+        df_ticks_final.sort_index(axis=0, kind="mergesort", inplace=True)
+
+        cdef int i
+        # Randomly shift high low prices
+        if random_seed is not None:
+            random.seed(random_seed)
+            for i in range(0, len(df_ticks_final), 4):
+                if random.getrandbits(1):
+                    high = copy(df_ticks_final.iloc[i + 1])
+                    low = copy(df_ticks_final.iloc[i + 2])
+                    df_ticks_final.iloc[i + 1] = low
+                    df_ticks_final.iloc[i + 2] = high
+
+        cdef uint64_t[:] ts_events = np.ascontiguousarray([secs_to_nanos(dt.timestamp()) for dt in df_ticks_final.index], dtype=np.uint64)  # noqa
+        cdef uint64_t[:] ts_inits = np.ascontiguousarray([ts_event + ts_init_delta for ts_event in ts_events], dtype=np.uint64)  # noqa
+
+        if is_raw:
+            return list(map(
+                self._build_tick_from_raw,
+                df_ticks_final["bid"],
+                df_ticks_final["ask"],
+                df_ticks_final["bid_size"],
+                df_ticks_final["ask_size"],
+                ts_events,
+                ts_inits,
+            ))
         else:
-            return self._handle_table_nautilus(table=table, cls=cls, mappings=mappings)
+            return list(map(
+                self._build_tick,
+                df_ticks_final["bid"],
+                df_ticks_final["ask"],
+                df_ticks_final["bid_size"],
+                df_ticks_final["ask_size"],
+                ts_events,
+                ts_inits,
+            ))
 
-    def make_path(self, cls: type, instrument_id: Optional[str] = None) -> str:
-        path = f"{self.path}/data/{class_to_filename(cls=cls)}.parquet"
-        if instrument_id is not None:
-            path += f"/instrument_id={clean_key(instrument_id)}"
-        return path
+    # cpdef method for Python wrap() (called with map)
+    cpdef QuoteTick _build_tick_from_raw(
+        self,
+        int64_t raw_bid,
+        int64_t raw_ask,
+        uint64_t raw_bid_size,
+        uint64_t raw_ask_size,
+        uint64_t ts_event,
+        uint64_t ts_init,
+    ):
+        return QuoteTick.from_raw_c(
+            self.instrument.id,
+            raw_bid,
+            raw_ask,
+            self.instrument.price_precision,
+            self.instrument.price_precision,
+            raw_bid_size,
+            raw_ask_size,
+            self.instrument.size_precision,
+            self.instrument.size_precision,
+            ts_event,
+            ts_init,
+        )
 
-    def get_files(
+    # cpdef method for Python wrap() (called with map)
+    cpdef QuoteTick _build_tick(
         self,
-        cls: type,
-        instrument_id: Optional[str] = None,
-        start_nanos: Optional[int] = None,
-        end_nanos: Optional[int] = None,
-        bar_spec: Optional[BarSpecification] = None,
-    ) -> list[str]:
-        folder = self.make_path(cls=cls, instrument_id=instrument_id)
-
-        if not self.fs.isdir(folder):
-            return []
-
-        paths = self.fs.glob(f"{folder}/**")
-
-        file_paths = []
-        for path in paths:
-            # Filter by BarType
-            bar_spec_matched = False
-            if cls is Bar:
-                bar_spec_matched = bar_spec and str(bar_spec) in path
-                if not bar_spec_matched:
-                    continue
-
-            # Filter by time range
-            file_path = pathlib.PurePosixPath(path).name
-            matched = is_filename_in_time_range(file_path, start_nanos, end_nanos)
-            if matched:
-                file_paths.append(str(path))
+        double bid,
+        double ask,
+        double bid_size,
+        double ask_size,
+        uint64_t ts_event,
+        uint64_t ts_init,
+    ):
+        # Build a quote tick from the given values. The function expects the values to
+        # be an ndarray with 4 elements [bid, ask, bid_size, ask_size] of type double.
+        return QuoteTick.from_raw_c(
+            self.instrument.id,
+            int(bid * 1e9),
+            int(ask * 1e9),
+            self.instrument.price_precision,
+            self.instrument.price_precision,
+            int(bid_size * 1e9),
+            int(ask_size * 1e9),
+            self.instrument.size_precision,
+            self.instrument.size_precision,
+            ts_event,
+            ts_init,
+        )
 
-        file_paths = sorted(file_paths, key=lambda x: Path(x).stem)
 
-        return file_paths
+cdef class TradeTickDataWrangler:
+    """
+    Provides a means of building lists of Nautilus `TradeTick` objects.
 
-    def _get_files(
-        self,
-        cls: type,
-        instrument_id: Optional[str] = None,
-        start_nanos: Optional[int] = None,
-        end_nanos: Optional[int] = None,
-    ) -> list[str]:
-        folder = (
-            self.path
-            if instrument_id is None
-            else self.make_path(cls=cls, instrument_id=instrument_id)
-        )
+    Parameters
+    ----------
+    instrument : Instrument
+        The instrument for the data wrangler.
+    """
 
-        if not os.path.exists(folder):
-            return []
+    def __init__(self, Instrument instrument not None):
+        self.instrument = instrument
 
-        paths = self.fs.glob(f"{folder}/**")
+    def process(self, data: pd.DataFrame, ts_init_delta: int=0, bint is_raw=False):
+        """
+        Process the given trade tick dataset into Nautilus `TradeTick` objects.
+
+        Parameters
+        ----------
+        data : pd.DataFrame
+            The data to process.
+        ts_init_delta : int
+            The difference in nanoseconds between the data timestamps and the
+            `ts_init` value. Can be used to represent/simulate latency between
+            the data source and the Nautilus system.
+        is_raw : bool, default False
+            If the data is scaled to the Nautilus fixed precision.
+
+        Raises
+        ------
+        ValueError
+            If `data` is empty.
+
+        """
+        Condition.not_none(data, "data")
+        Condition.false(data.empty, "data.empty")
+
+        data = as_utc_index(data)
+
+        cdef uint64_t[:] ts_events = np.ascontiguousarray([secs_to_nanos(dt.timestamp()) for dt in data.index], dtype=np.uint64)  # noqa
+        cdef uint64_t[:] ts_inits = np.ascontiguousarray([ts_event + ts_init_delta for ts_event in ts_events], dtype=np.uint64)  # noqa
+
+        if is_raw:
+            return list(map(
+                self._build_tick_from_raw,
+                data["price"],
+                data["quantity"],
+                self._create_side_if_not_exist(data),
+                data["trade_id"].astype(str),
+                ts_events,
+                ts_inits,
+            ))
+        else:
+            return list(map(
+                self._build_tick,
+                data["price"],
+                data["quantity"],
+                self._create_side_if_not_exist(data),
+                data["trade_id"].astype(str),
+                ts_events,
+                ts_inits,
+            ))
+
+    def _create_side_if_not_exist(self, data):
+        if "side" in data.columns:
+            return data["side"].apply(lambda x: AggressorSide.BUYER if str(x).upper() == "BUY" else AggressorSide.SELLER)
+        else:
+            return data["buyer_maker"].apply(lambda x: AggressorSide.SELLER if x is True else AggressorSide.BUYER)
 
-        files = []
-        for path in paths:
-            fn = pathlib.PurePosixPath(path).name
-            matched = is_filename_in_time_range(fn, start_nanos, end_nanos)
-            if matched:
-                files.append(str(path))
-
-        files = sorted(files, key=lambda x: Path(x).stem)
-
-        return files
-
-    def load_inverse_mappings(self, path):
-        mappings = load_mappings(fs=self.fs, path=path)
-        for key in mappings:
-            mappings[key] = {v: k for k, v in mappings[key].items()}
-        return mappings
-
-    @staticmethod
-    def _handle_table_dataframe(
-        table: pa.Table,
-        mappings: Optional[dict],
-        raise_on_empty: bool = True,
-        sort_columns: Optional[list] = None,
-        as_type: Optional[dict] = None,
-    ):
-        df = table.to_pandas().drop_duplicates()
-        for col in mappings:
-            df.loc[:, col] = df[col].map(mappings[col])
-
-        if df.empty and raise_on_empty:
-            raise ValueError("Data empty")
-        if sort_columns:
-            df = df.sort_values(sort_columns)
-        if as_type:
-            df = df.astype(as_type)
-        return df
-
-    @staticmethod
-    def _handle_table_nautilus(
-        table: Union[pa.Table, pd.DataFrame],
-        cls: type,
-        mappings: Optional[dict],
+    # cpdef method for Python wrap() (called with map)
+    cpdef TradeTick _build_tick_from_raw(
+        self,
+        int64_t raw_price,
+        uint64_t raw_size,
+        AggressorSide aggressor_side,
+        str trade_id,
+        uint64_t ts_event,
+        uint64_t ts_init,
     ):
-        if isinstance(table, pa.Table):
-            dicts = dict_of_lists_to_list_of_dicts(table.to_pydict())
-        elif isinstance(table, pd.DataFrame):
-            dicts = table.to_dict("records")
-        else:
-            raise TypeError(
-                f"`table` was {type(table)}, expected `pyarrow.Table` or `pandas.DataFrame`",
-            )
-        if not dicts:
-            return []
-        for key, maps in mappings.items():
-            for d in dicts:
-                if d[key] in maps:
-                    d[key] = maps[d[key]]
-        data = ParquetSerializer.deserialize(cls=cls, chunk=dicts)
-        return data
+        return TradeTick.from_raw_c(
+            self.instrument.id,
+            raw_price,
+            self.instrument.price_precision,
+            raw_size,
+            self.instrument.size_precision,
+            aggressor_side,
+            TradeId(trade_id),
+            ts_event,
+            ts_init,
+        )
 
-    def _query_subclasses(
+    # cpdef method for Python wrap() (called with map)
+    cpdef TradeTick _build_tick(
         self,
-        base_cls: type,
-        instrument_ids: Optional[list[str]] = None,
-        filter_expr: Optional[Callable] = None,
-        as_nautilus: bool = False,
-        **kwargs,
+        double price,
+        double size,
+        AggressorSide aggressor_side,
+        str trade_id,
+        uint64_t ts_event,
+        uint64_t ts_init,
     ):
-        subclasses = [base_cls, *base_cls.__subclasses__()]
+        # Build a quote tick from the given values. The function expects the values to
+        # be an ndarray with 4 elements [bid, ask, bid_size, ask_size] of type double.
+        return TradeTick.from_raw_c(
+            self.instrument.id,
+            int(price * 1e9),
+            self.instrument.price_precision,
+            int(size * 1e9),
+            self.instrument.size_precision,
+            aggressor_side,
+            TradeId(trade_id),
+            ts_event,
+            ts_init,
+        )
 
-        dfs = []
-        for cls in subclasses:
-            try:
-                df = self.query(
-                    cls=cls,
-                    filter_expr=filter_expr,
-                    instrument_ids=instrument_ids,
-                    raise_on_empty=False,
-                    as_nautilus=as_nautilus,
-                    **kwargs,
-                )
-                dfs.append(df)
-            except ArrowInvalid as e:
-                # If we're using a `filter_expr` here, there's a good chance
-                # this error is using a filter that is specific to one set of
-                # instruments and not to others, so we ignore it (if not; raise).
-                if filter_expr is not None:
-                    continue
-                else:
-                    raise e
 
-        if not as_nautilus:
-            return pd.concat([df for df in dfs if df is not None])
-        else:
-            objects = [o for objs in [df for df in dfs if df is not None] for o in objs]
-            return objects
+cdef class BarDataWrangler:
+    """
+    Provides a means of building lists of Nautilus `Bar` objects.
+
+    Parameters
+    ----------
+    bar_type : BarType
+        The bar type for the wrangler.
+    instrument : Instrument
+        The instrument for the wrangler.
+    """
 
-    # ---  OVERLOADED BASE METHODS ------------------------------------------------
-    def generic_data(
+    def __init__(
         self,
-        cls: type,
-        as_nautilus: bool = False,
-        metadata: Optional[dict] = None,
-        filter_expr: Optional[Callable] = None,
-        **kwargs,
+        BarType bar_type not None,
+        Instrument instrument not None,
     ):
-        data = self._query(
-            cls=cls,
-            filter_expr=filter_expr,
-            as_dataframe=not as_nautilus,
-            **kwargs,
-        )
-        if as_nautilus:
-            if data is None:
-                return []
-            return [GenericData(data_type=DataType(cls, metadata=metadata), data=d) for d in data]
-        return data
+        Condition.not_none(bar_type, "bar_type")
+        Condition.not_none(instrument, "instrument")
+
+        self.bar_type = bar_type
+        self.instrument = instrument
 
-    def instruments(
+    def process(
         self,
-        instrument_type: Optional[type] = None,
-        instrument_ids: Optional[list[str]] = None,
-        **kwargs,
+        data: pd.DataFrame,
+        default_volume: float=1_000_000.0,
+        ts_init_delta: int=0,
     ):
-        kwargs["clean_instrument_keys"] = False
-        return super().instruments(
-            instrument_type=instrument_type,
-            instrument_ids=instrument_ids,
-            **kwargs,
-        )
+        """
+        Process the given bar dataset into Nautilus `Bar` objects.
+
+        Expects columns ['open', 'high', 'low', 'close', 'volume'] with 'timestamp' index.
+        Note: The 'volume' column is optional, will then use the `default_volume`.
 
-    def list_data_types(self):
-        glob_path = f"{self.path}/data/*.parquet"
-        return [pathlib.Path(p).stem for p in self.fs.glob(glob_path)]
-
-    def list_partitions(self, cls_type: type):
-        assert isinstance(cls_type, type), "`cls_type` should be type, i.e. TradeTick"
-        name = class_to_filename(cls_type)
-        dataset = pq.ParquetDataset(
-            f"{self.path}/data/{name}.parquet",
-            filesystem=self.fs,
+        Parameters
+        ----------
+        data : pd.DataFrame
+            The data to process.
+        default_volume : float
+            The default volume for each bar (if not provided).
+        ts_init_delta : int
+            The difference in nanoseconds between the data timestamps and the
+            `ts_init` value. Can be used to represent/simulate latency between
+            the data source and the Nautilus system.
+
+        Returns
+        -------
+        list[Bar]
+
+        Raises
+        ------
+        ValueError
+            If `data` is empty.
+
+        """
+        Condition.not_none(data, "data")
+        Condition.false(data.empty, "data.empty")
+        Condition.not_none(default_volume, "default_volume")
+
+        data = as_utc_index(data)
+
+        if "volume" not in data:
+            data["volume"] = float(default_volume)
+
+        cdef uint64_t[:] ts_events = np.ascontiguousarray([secs_to_nanos(dt.timestamp()) for dt in data.index], dtype=np.uint64)  # noqa
+        cdef uint64_t[:] ts_inits = np.ascontiguousarray([ts_event + ts_init_delta for ts_event in ts_events], dtype=np.uint64)  # noqa
+
+        return list(map(
+            self._build_bar,
+            data.values,
+            ts_events,
+            ts_inits
+        ))
+
+    # cpdef method for Python wrap() (called with map)
+    cpdef Bar _build_bar(self, double[:] values, uint64_t ts_event, uint64_t ts_init):
+        # Build a bar from the given index and values. The function expects the
+        # values to be an ndarray with 5 elements [open, high, low, close, volume].
+        return Bar(
+            bar_type=self.bar_type,
+            open=Price(values[0], self.instrument.price_precision),
+            high=Price(values[1], self.instrument.price_precision),
+            low=Price(values[2], self.instrument.price_precision),
+            close=Price(values[3], self.instrument.price_precision),
+            volume=Quantity(values[4], self.instrument.size_precision),
+            ts_event=ts_event,
+            ts_init=ts_init,
         )
-        # TODO(cs): Catalog v1 impl below
-        # partitions = {}
-        # for level in dataset.partitioning:
-        #     partitions[level.name] = level.keys
-        return dataset.partitioning
-
-    def list_backtests(self) -> list[str]:
-        glob_path = f"{self.path}/backtest/*.feather"
-        return [p.stem for p in map(Path, self.fs.glob(glob_path))]
-
-    def list_live_runs(self) -> list[str]:
-        glob_path = f"{self.path}/live/*.feather"
-        return [p.stem for p in map(Path, self.fs.glob(glob_path))]
-
-    def read_live_run(self, live_run_id: str, **kwargs):
-        return self._read_feather(kind="live", run_id=live_run_id, **kwargs)
-
-    def read_backtest(self, backtest_run_id: str, **kwargs):
-        return self._read_feather(kind="backtest", run_id=backtest_run_id, **kwargs)
-
-    def _read_feather(self, kind: str, run_id: str, raise_on_failed_deserialize: bool = False):
-        class_mapping: dict[str, type] = {class_to_filename(cls): cls for cls in list_schemas()}
-        data = {}
-        glob_path = f"{self.path}/{kind}/{run_id}.feather/*.feather"
-
-        for path in list(self.fs.glob(glob_path)):
-            cls_name = camel_to_snake_case(pathlib.Path(path).stem).replace("__", "_")
-            df = read_feather_file(path=path, fs=self.fs)
-
-            if df is None:
-                print(f"No data for {cls_name}")
-                continue
-            # Apply post read fixes
-            try:
-                objs = self._handle_table_nautilus(
-                    table=df,
-                    cls=class_mapping[cls_name],
-                    mappings={},
-                )
-                data[cls_name] = objs
-            except Exception as e:
-                if raise_on_failed_deserialize:
-                    raise
-                print(f"Failed to deserialize {cls_name}: {e}")
-        return sorted(sum(data.values(), []), key=lambda x: x.ts_init)
-
-
-def read_feather_file(path: str, fs: fsspec.AbstractFileSystem = None):
-    fs = fs or fsspec.filesystem("file")
-    if not fs.exists(path):
-        return
-    try:
-        with fs.open(path) as f:
-            reader = pa.ipc.open_stream(f)
-            return reader.read_pandas()
-    except (pa.ArrowInvalid, FileNotFoundError):
-        return
-
-
-def combine_filters(*filters):
-    filters = tuple(x for x in filters if x is not None)
-    if len(filters) == 0:
-        return
-    elif len(filters) == 1:
-        return filters[0]
-    else:
-        expr = filters[0]
-        for f in filters[1:]:
-            expr = expr & f
-        return expr
-
-
-def int_to_float_dataframe(df: pd.DataFrame):
-    cols = [
-        col
-        for col, dtype in dict(df.dtypes).items()
-        if dtype == np.int64 or dtype == np.uint64 and (col != "ts_event" and col != "ts_init")
-    ]
-    df[cols] = df[cols] / FIXED_SCALAR
-    return df
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/persistence/external/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/persistence/streaming/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/persistence/external/core.py` & `nautilus_trader-1.175.0/nautilus_trader/persistence/external/core.py`

 * *Files 1% similar despite different names*

```diff
@@ -27,15 +27,15 @@
 from fsspec.core import OpenFile
 from pyarrow import ArrowInvalid
 from pyarrow import dataset as ds
 from pyarrow import parquet as pq
 from tqdm import tqdm
 
 from nautilus_trader.core.correctness import PyCondition
-from nautilus_trader.model.data.base import GenericData
+from nautilus_trader.model.data import GenericData
 from nautilus_trader.model.instruments import Instrument
 from nautilus_trader.persistence.catalog.base import BaseDataCatalog
 from nautilus_trader.persistence.catalog.parquet import ParquetDataCatalog
 from nautilus_trader.persistence.external.metadata import load_mappings
 from nautilus_trader.persistence.external.metadata import write_partition_column_mappings
 from nautilus_trader.persistence.external.readers import Reader
 from nautilus_trader.persistence.external.util import parse_filename_start
@@ -247,24 +247,32 @@
         try:
             schema = get_schema(cls)
         except KeyError:
             print(f"Can't find parquet schema for type: {cls}, skipping!")
             continue
         partition_cols = determine_partition_cols(cls=cls, instrument_id=instrument_id)
         path = f"{catalog.path}/data/{class_to_filename(cls)}.parquet"
-        merged = merge_existing_data(catalog=catalog, cls=cls, df=df)
+        if kwargs.get("merge_existing_data") is False:
+            merged = df
+        else:
+            merged = merge_existing_data(catalog=catalog, cls=cls, df=df)
+        kwargs.pop("merge_existing_data", None)
 
         write_parquet(
             fs=catalog.fs,
             path=path,
             df=merged,
             partition_cols=partition_cols,
             schema=schema,
             **kwargs,
-            **({"basename_template": "{i}.parquet"} if cls in Instrument.__subclasses__() else {}),
+            **(
+                {"basename_template": "{i}.parquet"}
+                if not kwargs.get("basename_template") and cls in Instrument.__subclasses__()
+                else {}
+            ),
         )
         rows_written += len(df)
 
     return rows_written
 
 
 def write_parquet_rust(catalog: ParquetDataCatalog, objs: list, instrument: Instrument):
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/persistence/external/metadata.py` & `nautilus_trader-1.175.0/nautilus_trader/persistence/external/metadata.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/persistence/external/readers.py` & `nautilus_trader-1.175.0/nautilus_trader/persistence/external/readers.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/persistence/external/util.py` & `nautilus_trader-1.175.0/nautilus_trader/persistence/external/util.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,18 +1,33 @@
+# -------------------------------------------------------------------------------------------------
+#  Copyright (C) 2015-2023 Nautech Systems Pty Ltd. All rights reserved.
+#  https://nautechsystems.io
+#
+#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
+#  You may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+# -------------------------------------------------------------------------------------------------
+
 import inspect
 import os
 import re
 import sys
 from typing import Optional
 
 import pandas as pd
 
 from nautilus_trader.core.nautilus_pyo3.persistence import ParquetType
-from nautilus_trader.model.data.tick import QuoteTick
-from nautilus_trader.model.data.tick import TradeTick
+from nautilus_trader.model.data import QuoteTick
+from nautilus_trader.model.data import TradeTick
 
 
 class Singleton(type):
     """
     The base class to ensure a singleton.
     """
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/persistence/funcs.py` & `nautilus_trader-1.175.0/nautilus_trader/persistence/funcs.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/persistence/loaders.py` & `nautilus_trader-1.175.0/nautilus_trader/persistence/loaders.py`

 * *Files 4% similar despite different names*

```diff
@@ -34,19 +34,21 @@
             The path to the CSV file.
 
         Returns
         -------
         pd.DataFrame
 
         """
-        return pd.read_csv(
+        df = pd.read_csv(
             file_path,
             index_col="timestamp",
             parse_dates=True,
         )
+        df.index = pd.to_datetime(df.index, format="mixed")
+        return df
 
 
 class CSVBarDataLoader:
     """
     Provides a means of loading bar data pandas DataFrames from CSV files.
     """
 
@@ -61,19 +63,21 @@
             The path to the CSV file.
 
         Returns
         -------
         pd.DataFrame
 
         """
-        return pd.read_csv(
+        df = pd.read_csv(
             file_path,
             index_col="timestamp",
             parse_dates=True,
         )
+        df.index = pd.to_datetime(df.index, format="mixed")
+        return df
 
 
 def _ts_parser(time_in_secs: str) -> datetime:
     return datetime.utcfromtimestamp(int(time_in_secs) / 1_000_000.0)
 
 
 class TardisTradeDataLoader:
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/persistence/migrate.py` & `nautilus_trader-1.175.0/nautilus_trader/persistence/migrate.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/persistence/streaming/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/portfolio/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/persistence/streaming/batching.py` & `nautilus_trader-1.175.0/nautilus_trader/persistence/streaming/batching.py`

 * *Files 9% similar despite different names*

```diff
@@ -21,17 +21,20 @@
 
 import fsspec
 import numpy as np
 import pyarrow as pa
 import pyarrow.parquet as pq
 
 from nautilus_trader.core.data import Data
-from nautilus_trader.model.data.tick import QuoteTick
-from nautilus_trader.model.data.tick import TradeTick
+from nautilus_trader.core.nautilus_pyo3.persistence import DataBackendSession
+from nautilus_trader.model.data import QuoteTick
+from nautilus_trader.model.data import TradeTick
 from nautilus_trader.model.identifiers import InstrumentId
+from nautilus_trader.persistence.external.util import py_type_to_parquet_type
+from nautilus_trader.persistence.wranglers import list_from_capsule
 from nautilus_trader.serialization.arrow.serializer import ParquetSerializer
 
 
 def _generate_batches_within_time_range(
     batches: Generator[list[Data], None, None],
     start_nanos: Optional[int] = None,
     end_nanos: Optional[int] = None,
@@ -75,36 +78,31 @@
 
 
 def _generate_batches_rust(
     files: list[str],
     cls: type,
     batch_size: int = 10_000,
 ) -> Generator[list[Union[QuoteTick, TradeTick]], None, None]:
+    files = sorted(files, key=lambda x: Path(x).stem)
+
     assert cls in (QuoteTick, TradeTick)
 
-    # TODO: Replace with new Rust datafusion backend
-    yield []
-    # files = sorted(files, key=lambda x: Path(x).stem)
-    # for file in files:
-    #     reader = ParquetReader(
-    #         file,
-    #         batch_size,
-    #         py_type_to_parquet_type(cls),
-    #         ParquetReaderType.File,
-    #     )
-    #     for capsule in reader:
-    #         # PyCapsule > List
-    #         if cls == QuoteTick:
-    #             objs = QuoteTick.list_from_capsule(capsule)
-    #         elif cls == TradeTick:
-    #             objs = TradeTick.list_from_capsule(capsule)
-    #         else:
-    #             raise RuntimeError(f"Data type {cls} unsupported for Rust.")
-    #
-    #         yield objs
+    session = DataBackendSession(chunk_size=batch_size)
+
+    for file in files:
+        session.add_file(
+            "data",
+            file,
+            py_type_to_parquet_type(cls),
+        )
+
+    result = session.to_query_result()
+
+    for chunk in result:
+        yield list_from_capsule(chunk)
 
 
 def generate_batches_rust(
     files: list[str],
     cls: type,
     batch_size: int = 10_000,
     start_nanos: Optional[int] = None,
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/persistence/streaming/engine.py` & `nautilus_trader-1.175.0/nautilus_trader/persistence/streaming/engine.py`

 * *Files 1% similar despite different names*

```diff
@@ -19,16 +19,16 @@
 from collections.abc import Generator
 
 import fsspec
 import numpy as np
 
 from nautilus_trader.config import BacktestDataConfig
 from nautilus_trader.core.data import Data
-from nautilus_trader.model.data.bar import Bar
-from nautilus_trader.model.data.bar import BarSpecification
+from nautilus_trader.model.data import Bar
+from nautilus_trader.model.data import BarSpecification
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.persistence.funcs import parse_bytes
 from nautilus_trader.persistence.streaming.batching import generate_batches
 from nautilus_trader.persistence.streaming.batching import generate_batches_rust
 
 
 class _StreamingBuffer:
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/persistence/streaming/writer.py` & `nautilus_trader-1.175.0/nautilus_trader/persistence/streaming/writer.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,22 +1,36 @@
+# -------------------------------------------------------------------------------------------------
+#  Copyright (C) 2015-2023 Nautech Systems Pty Ltd. All rights reserved.
+#  https://nautechsystems.io
+#
+#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
+#  You may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+# -------------------------------------------------------------------------------------------------
+
 import datetime
-from typing import BinaryIO, Optional
+from typing import Any, BinaryIO, Optional
 
 import fsspec
 import pyarrow as pa
 from pyarrow import RecordBatchStreamWriter
 
 from nautilus_trader.common.logging import LoggerAdapter
 from nautilus_trader.core.correctness import PyCondition
 from nautilus_trader.core.data import Data
 from nautilus_trader.core.inspect import is_nautilus_class
-from nautilus_trader.model.data.base import GenericData
-from nautilus_trader.model.data.book import OrderBookDelta
-from nautilus_trader.model.data.book import OrderBookDeltas
-from nautilus_trader.model.data.book import OrderBookSnapshot
+from nautilus_trader.model.data import GenericData
+from nautilus_trader.model.data import OrderBookDelta
+from nautilus_trader.model.data import OrderBookDeltas
 from nautilus_trader.serialization.arrow.serializer import ParquetSerializer
 from nautilus_trader.serialization.arrow.serializer import get_cls_table
 from nautilus_trader.serialization.arrow.serializer import list_schemas
 from nautilus_trader.serialization.arrow.serializer import register_parquet
 from nautilus_trader.serialization.arrow.util import GENERIC_DATA_PREFIX
 from nautilus_trader.serialization.arrow.util import list_dicts_to_dict_lists
 
@@ -66,15 +80,14 @@
         self.fs.makedirs(self.fs._parent(self.path), exist_ok=True)
 
         self._schemas = list_schemas()
         self._schemas.update(
             {
                 OrderBookDelta: self._schemas[OrderBookDelta],
                 OrderBookDeltas: self._schemas[OrderBookDelta],
-                OrderBookSnapshot: self._schemas[OrderBookDelta],
             },
         )
         self.logger = logger
         self._files: dict[type, BinaryIO] = {}
         self._writers: dict[type, RecordBatchStreamWriter] = {}
         self._create_writers()
 
@@ -181,32 +194,67 @@
         for cls in tuple(self._writers):
             self._writers[cls].close()
             del self._writers[cls]
         for cls in self._files:
             self._files[cls].close()
 
 
-def generate_signal_class(name: str, value_type: type):
+def generate_signal_class(name: str, value_type: type) -> type:
     """
     Dynamically create a Data subclass for this signal.
+
+    Parameters
+    ----------
+    name : str
+        The name of the signal data.
+    value_type : type
+        The type for the signal data value.
+
+    Returns
+    -------
+    SignalData
     """
 
     class SignalData(Data):
         """
         Represents generic signal data.
         """
 
-        def __init__(self, value, ts_event: int, ts_init: int):
-            super().__init__(ts_event=ts_event, ts_init=ts_init)
+        def __init__(self, value: Any, ts_event: int, ts_init: int) -> None:
             self.value = value
+            self._ts_event = ts_event
+            self._ts_init = ts_init
+
+        @property
+        def ts_event(self) -> int:
+            """
+            The UNIX timestamp (nanoseconds) when the data event occurred.
+
+            Returns
+            -------
+            int
+
+            """
+            return self._ts_event
+
+        @property
+        def ts_init(self) -> int:
+            """
+            The UNIX timestamp (nanoseconds) when the object was initialized.
+
+            Returns
+            -------
+            int
+
+            """
+            return self._ts_init
 
     SignalData.__name__ = f"Signal{name.title()}"
 
     # Parquet serialization
-
     def serialize_signal(self):
         return {
             "ts_init": self.ts_init,
             "ts_event": self.ts_event,
             "value": self.value,
         }
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/persistence/wranglers.pxd` & `nautilus_trader-1.175.0/nautilus_trader/persistence/wranglers.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/persistence/wranglers.pyx` & `nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/data.py`

 * *Files 24% similar despite different names*

```diff
@@ -9,508 +9,512 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-import random
-from copy import copy
-from typing import Optional
+import json
+from datetime import datetime
+from typing import Any, Optional
 
-import numpy as np
 import pandas as pd
+import pytz
 
-from cpython.pycapsule cimport PyCapsule_GetPointer
-from libc.stdint cimport int64_t
-from libc.stdint cimport uint64_t
-
-from nautilus_trader.core.correctness cimport Condition
-from nautilus_trader.core.data cimport Data
-from nautilus_trader.core.datetime cimport as_utc_index
-from nautilus_trader.core.rust.core cimport CVec
-from nautilus_trader.core.rust.core cimport secs_to_nanos
-from nautilus_trader.core.rust.model cimport Data_t
-from nautilus_trader.core.rust.model cimport Data_t_Tag
-from nautilus_trader.model.data.bar cimport Bar
-from nautilus_trader.model.data.bar cimport BarType
-from nautilus_trader.model.data.tick cimport QuoteTick
-from nautilus_trader.model.data.tick cimport TradeTick
-from nautilus_trader.model.enums_c cimport AggressorSide
-from nautilus_trader.model.identifiers cimport TradeId
-from nautilus_trader.model.instruments.base cimport Instrument
-from nautilus_trader.model.objects cimport Price
-from nautilus_trader.model.objects cimport Quantity
-
-
-# Safety: Do NOT deallocate the capsule here
-cdef inline list capsule_to_data_list(object capsule):
-    cdef CVec* data = <CVec*>PyCapsule_GetPointer(capsule, NULL)
-    cdef Data_t* ptr = <Data_t*>data.ptr
-    cdef list ticks = []
-
-    cdef uint64_t i
-    for i in range(0, data.len):
-        if ptr[i].tag == Data_t_Tag.TRADE:
-            ticks.append(TradeTick.from_mem_c(ptr[i].trade))
-        elif ptr[i].tag == Data_t_Tag.QUOTE:
-            ticks.append(QuoteTick.from_mem_c(ptr[i].quote))
-
-    return ticks
-
-
-@staticmethod
-def list_from_capsule(capsule) -> list[Data]:
-    return capsule_to_data_list(capsule)
-
-
-cdef class QuoteTickDataWrangler:
-    """
-    Provides a means of building lists of Nautilus `QuoteTick` objects.
+from nautilus_trader.core.data import Data
+from nautilus_trader.core.datetime import millis_to_nanos
+from nautilus_trader.model.data import Bar
+from nautilus_trader.model.data import BarSpecification
+from nautilus_trader.model.data import BarType
+from nautilus_trader.model.data import BookOrder
+from nautilus_trader.model.data import InstrumentClose
+from nautilus_trader.model.data import InstrumentStatusUpdate
+from nautilus_trader.model.data import OrderBookDelta
+from nautilus_trader.model.data import OrderBookDeltas
+from nautilus_trader.model.data import QuoteTick
+from nautilus_trader.model.data import Ticker
+from nautilus_trader.model.data import TradeTick
+from nautilus_trader.model.data import VenueStatusUpdate
+from nautilus_trader.model.enums import AggressorSide
+from nautilus_trader.model.enums import BarAggregation
+from nautilus_trader.model.enums import BookAction
+from nautilus_trader.model.enums import BookType
+from nautilus_trader.model.enums import InstrumentCloseType
+from nautilus_trader.model.enums import MarketStatus
+from nautilus_trader.model.enums import OrderSide
+from nautilus_trader.model.enums import PriceType
+from nautilus_trader.model.identifiers import InstrumentId
+from nautilus_trader.model.identifiers import Symbol
+from nautilus_trader.model.identifiers import TradeId
+from nautilus_trader.model.identifiers import Venue
+from nautilus_trader.model.instruments import Instrument
+from nautilus_trader.model.objects import Price
+from nautilus_trader.model.objects import Quantity
+from nautilus_trader.model.orderbook import OrderBook
+from nautilus_trader.model.orders import Order
+from nautilus_trader.persistence.wranglers import QuoteTickDataWrangler
+from nautilus_trader.test_kit.providers import TestDataProvider
+from nautilus_trader.test_kit.providers import TestInstrumentProvider
+from nautilus_trader.test_kit.stubs.identifiers import TestIdStubs
+
+
+UNIX_EPOCH = datetime(1970, 1, 1, 0, 0, 0, 0, tzinfo=pytz.utc)
+
+
+class TestDataStubs:
+    @staticmethod
+    def ticker(instrument_id: Optional[InstrumentId] = None) -> Ticker:
+        return Ticker(
+            instrument_id=instrument_id or TestIdStubs.audusd_id(),
+            ts_event=0,
+            ts_init=0,
+        )
 
-    Parameters
-    ----------
-    instrument : Instrument
-        The instrument for the data wrangler.
-    """
+    @staticmethod
+    def quote_tick(
+        instrument: Optional[Instrument] = None,
+        bid: float = 1.0,
+        ask: float = 1.0,
+        bid_size: float = 100_000.0,
+        ask_size: float = 100_000.0,
+        ts_event: int = 0,
+        ts_init: int = 0,
+    ) -> QuoteTick:
+        inst: Instrument = instrument or TestInstrumentProvider.default_fx_ccy("AUD/USD")
+        return QuoteTick(
+            instrument_id=inst.id,
+            bid=inst.make_price(bid),
+            ask=inst.make_price(ask),
+            bid_size=inst.make_qty(bid_size),
+            ask_size=inst.make_qty(ask_size),
+            ts_event=ts_event,
+            ts_init=ts_init,
+        )
 
-    def __init__(self, Instrument instrument not None):
-        self.instrument = instrument
+    @staticmethod
+    def trade_tick(
+        instrument: Optional[Instrument] = None,
+        price: float = 1.0,
+        quantity: float = 100_000,
+        aggressor_side: AggressorSide = AggressorSide.BUYER,
+        trade_id: str = "123456",
+        ts_event: int = 0,
+        ts_init: int = 0,
+    ) -> TradeTick:
+        inst: Instrument = instrument or TestInstrumentProvider.default_fx_ccy("AUD/USD")
+        return TradeTick(
+            instrument_id=inst.id,
+            price=inst.make_price(price),
+            size=inst.make_qty(quantity),
+            aggressor_side=aggressor_side,
+            trade_id=TradeId(trade_id),
+            ts_event=ts_event,
+            ts_init=ts_init,
+        )
 
-    def process(
-        self,
-        data: pd.DataFrame,
-        default_volume: float=1_000_000.0,
-        ts_init_delta: int=0,
-    ):
-        """
-        Process the give tick dataset into Nautilus `QuoteTick` objects.
+    @staticmethod
+    def quote_ticks_usdjpy() -> list[QuoteTick]:
+        usdjpy = TestInstrumentProvider.default_fx_ccy("USD/JPY")
+        wrangler = QuoteTickDataWrangler(instrument=usdjpy)
+        provider = TestDataProvider()
+        ticks = wrangler.process_bar_data(
+            bid_data=provider.read_csv_bars("fxcm-usdjpy-m1-bid-2013.csv")[:2000],
+            ask_data=provider.read_csv_bars("fxcm-usdjpy-m1-ask-2013.csv")[:2000],
+        )
+        return ticks
 
-        Expects columns ['bid', 'ask'] with 'timestamp' index.
-        Note: The 'bid_size' and 'ask_size' columns are optional, will then use
-        the `default_volume`.
-
-        Parameters
-        ----------
-        data : pd.DataFrame
-            The tick data to process.
-        default_volume : float
-            The default volume for each tick (if not provided).
-        ts_init_delta : int
-            The difference in nanoseconds between the data timestamps and the
-            `ts_init` value. Can be used to represent/simulate latency between
-            the data source and the Nautilus system. Cannot be negative.
-
-        Returns
-        -------
-        list[QuoteTick]
-
-        """
-        Condition.false(data.empty, "data.empty")
-        Condition.not_none(default_volume, "default_volume")
-
-        as_utc_index(data)
-
-        if "bid_size" not in data.columns:
-            data["bid_size"] = float(default_volume)
-        if "ask_size" not in data.columns:
-            data["ask_size"] = float(default_volume)
-
-        cdef uint64_t[:] ts_events = np.ascontiguousarray([secs_to_nanos(dt.timestamp()) for dt in data.index], dtype=np.uint64)  # noqa
-        cdef uint64_t[:] ts_inits = np.ascontiguousarray([ts_event + ts_init_delta for ts_event in ts_events], dtype=np.uint64)  # noqa
-
-        return list(map(
-            self._build_tick,
-            data["bid"],
-            data["ask"],
-            data["bid_size"],
-            data["ask_size"],
-            ts_events,
-            ts_inits,
-        ))
+    @staticmethod
+    def bar_spec_1min_bid() -> BarSpecification:
+        return BarSpecification(1, BarAggregation.MINUTE, PriceType.BID)
+
+    @staticmethod
+    def bar_spec_1min_ask() -> BarSpecification:
+        return BarSpecification(1, BarAggregation.MINUTE, PriceType.ASK)
+
+    @staticmethod
+    def bar_spec_1min_last() -> BarSpecification:
+        return BarSpecification(1, BarAggregation.MINUTE, PriceType.LAST)
+
+    @staticmethod
+    def bar_spec_1min_mid() -> BarSpecification:
+        return BarSpecification(1, BarAggregation.MINUTE, PriceType.MID)
+
+    @staticmethod
+    def bar_spec_1sec_mid() -> BarSpecification:
+        return BarSpecification(1, BarAggregation.SECOND, PriceType.MID)
+
+    @staticmethod
+    def bar_spec_100tick_last() -> BarSpecification:
+        return BarSpecification(100, BarAggregation.TICK, PriceType.LAST)
+
+    @staticmethod
+    def bartype_audusd_1min_bid() -> BarType:
+        return BarType(TestIdStubs.audusd_id(), TestDataStubs.bar_spec_1min_bid())
+
+    @staticmethod
+    def bartype_audusd_1min_ask() -> BarType:
+        return BarType(TestIdStubs.audusd_id(), TestDataStubs.bar_spec_1min_ask())
+
+    @staticmethod
+    def bartype_gbpusd_1min_bid() -> BarType:
+        return BarType(TestIdStubs.gbpusd_id(), TestDataStubs.bar_spec_1min_bid())
+
+    @staticmethod
+    def bartype_gbpusd_1min_ask() -> BarType:
+        return BarType(TestIdStubs.gbpusd_id(), TestDataStubs.bar_spec_1min_ask())
+
+    @staticmethod
+    def bartype_gbpusd_1sec_mid() -> BarType:
+        return BarType(TestIdStubs.gbpusd_id(), TestDataStubs.bar_spec_1sec_mid())
+
+    @staticmethod
+    def bartype_usdjpy_1min_bid() -> BarType:
+        return BarType(TestIdStubs.usdjpy_id(), TestDataStubs.bar_spec_1min_bid())
+
+    @staticmethod
+    def bartype_usdjpy_1min_ask() -> BarType:
+        return BarType(TestIdStubs.usdjpy_id(), TestDataStubs.bar_spec_1min_ask())
+
+    @staticmethod
+    def bartype_btcusdt_binance_100tick_last() -> BarType:
+        return BarType(TestIdStubs.btcusdt_binance_id(), TestDataStubs.bar_spec_100tick_last())
+
+    @staticmethod
+    def bartype_adabtc_binance_1min_last() -> BarType:
+        return BarType(TestIdStubs.adabtc_binance_id(), TestDataStubs.bar_spec_1min_last())
 
-    def process_bar_data(
-        self,
-        bid_data: pd.DataFrame,
-        ask_data: pd.DataFrame,
-        default_volume: float = 1_000_000.0,
-        ts_init_delta: int = 0,
-        random_seed: Optional[int] = None,
-        bint is_raw: bool = False,
-    ):
-        """
-        Process the given bar datasets into Nautilus `QuoteTick` objects.
+    @staticmethod
+    def bar_5decimal() -> Bar:
+        return Bar(
+            bar_type=TestDataStubs.bartype_audusd_1min_bid(),
+            open=Price.from_str("1.00002"),
+            high=Price.from_str("1.00004"),
+            low=Price.from_str("1.00001"),
+            close=Price.from_str("1.00003"),
+            volume=Quantity.from_int(1_000_000),
+            ts_event=0,
+            ts_init=0,
+        )
 
-        Expects columns ['open', 'high', 'low', 'close', 'volume'] with 'timestamp' index.
-        Note: The 'volume' column is optional, will then use the `default_volume`.
+    @staticmethod
+    def bar_3decimal() -> Bar:
+        return Bar(
+            bar_type=TestDataStubs.bartype_usdjpy_1min_bid(),
+            open=Price.from_str("90.002"),
+            high=Price.from_str("90.004"),
+            low=Price.from_str("90.001"),
+            close=Price.from_str("90.003"),
+            volume=Quantity.from_int(1_000_000),
+            ts_event=0,
+            ts_init=0,
+        )
 
-        Parameters
-        ----------
-        bid_data : pd.DataFrame
-            The bid bar data.
-        ask_data : pd.DataFrame
-            The ask bar data.
-        default_volume : float
-            The volume per tick if not available from the data.
-        ts_init_delta : int
-            The difference in nanoseconds between the data timestamps and the
-            `ts_init` value. Can be used to represent/simulate latency between
-            the data source and the Nautilus system.
-        random_seed : int, optional
-            The random seed for shuffling order of high and low ticks from bar
-            data. If random_seed is ``None`` then won't shuffle.
-        is_raw : bool, default False
-            If the data is scaled to the Nautilus fixed precision.
-
-        """
-        Condition.not_none(bid_data, "bid_data")
-        Condition.not_none(ask_data, "ask_data")
-        Condition.false(bid_data.empty, "bid_data.empty")
-        Condition.false(ask_data.empty, "ask_data.empty")
-        Condition.not_none(default_volume, "default_volume")
-        if random_seed is not None:
-            Condition.type(random_seed, int, "random_seed")
-
-        # Ensure index is tz-aware UTC
-        bid_data = as_utc_index(bid_data)
-        ask_data = as_utc_index(ask_data)
-
-        if "volume" not in bid_data:
-            bid_data["volume"] = float(default_volume * 4)
-
-        if "volume" not in ask_data:
-            ask_data["volume"] = float(default_volume * 4)
-
-        cdef dict data_open = {
-            "bid": bid_data["open"],
-            "ask": ask_data["open"],
-            "bid_size": bid_data["volume"] / 4,
-            "ask_size": ask_data["volume"] / 4,
-        }
-
-        cdef dict data_high = {
-            "bid": bid_data["high"],
-            "ask": ask_data["high"],
-            "bid_size": bid_data["volume"] / 4,
-            "ask_size": ask_data["volume"] / 4,
-        }
-
-        cdef dict data_low = {
-            "bid": bid_data["low"],
-            "ask": ask_data["low"],
-            "bid_size": bid_data["volume"] / 4,
-            "ask_size": ask_data["volume"] / 4,
-        }
-
-        cdef dict data_close = {
-            "bid": bid_data["close"],
-            "ask": ask_data["close"],
-            "bid_size": bid_data["volume"] / 4,
-            "ask_size": ask_data["volume"] / 4,
-        }
-
-        df_ticks_o = pd.DataFrame(data=data_open)
-        df_ticks_h = pd.DataFrame(data=data_high)
-        df_ticks_l = pd.DataFrame(data=data_low)
-        df_ticks_c = pd.DataFrame(data=data_close)
-
-        # Latency offsets
-        df_ticks_o.index = df_ticks_o.index.shift(periods=-300, freq="ms")
-        df_ticks_h.index = df_ticks_h.index.shift(periods=-200, freq="ms")
-        df_ticks_l.index = df_ticks_l.index.shift(periods=-100, freq="ms")
-
-        # Merge tick data
-        df_ticks_final = pd.concat([df_ticks_o, df_ticks_h, df_ticks_l, df_ticks_c])
-        df_ticks_final.dropna(inplace=True)
-        df_ticks_final.sort_index(axis=0, kind="mergesort", inplace=True)
-
-        cdef int i
-        # Randomly shift high low prices
-        if random_seed is not None:
-            random.seed(random_seed)
-            for i in range(0, len(df_ticks_final), 4):
-                if random.getrandbits(1):
-                    high = copy(df_ticks_final.iloc[i + 1])
-                    low = copy(df_ticks_final.iloc[i + 2])
-                    df_ticks_final.iloc[i + 1] = low
-                    df_ticks_final.iloc[i + 2] = high
-
-        cdef uint64_t[:] ts_events = np.ascontiguousarray([secs_to_nanos(dt.timestamp()) for dt in df_ticks_final.index], dtype=np.uint64)  # noqa
-        cdef uint64_t[:] ts_inits = np.ascontiguousarray([ts_event + ts_init_delta for ts_event in ts_events], dtype=np.uint64)  # noqa
-
-        if is_raw:
-            return list(map(
-                self._build_tick_from_raw,
-                df_ticks_final["bid"],
-                df_ticks_final["ask"],
-                df_ticks_final["bid_size"],
-                df_ticks_final["ask_size"],
-                ts_events,
-                ts_inits,
-            ))
-        else:
-            return list(map(
-                self._build_tick,
-                df_ticks_final["bid"],
-                df_ticks_final["ask"],
-                df_ticks_final["bid_size"],
-                df_ticks_final["ask_size"],
-                ts_events,
-                ts_inits,
-            ))
+    @staticmethod
+    def instrument_close() -> InstrumentClose:
+        from nautilus_trader.adapters.betfair.common import BETFAIR_PRICE_PRECISION
+
+        return InstrumentClose(
+            TestIdStubs.betting_instrument_id(),
+            Price(1.0, BETFAIR_PRICE_PRECISION),
+            InstrumentCloseType.CONTRACT_EXPIRED,
+            0,
+            0,
+        )
 
-    # cpdef method for Python wrap() (called with map)
-    cpdef QuoteTick _build_tick_from_raw(
-        self,
-        int64_t raw_bid,
-        int64_t raw_ask,
-        uint64_t raw_bid_size,
-        uint64_t raw_ask_size,
-        uint64_t ts_event,
-        uint64_t ts_init,
-    ):
-        return QuoteTick.from_raw_c(
-            self.instrument.id,
-            raw_bid,
-            raw_ask,
-            self.instrument.price_precision,
-            self.instrument.price_precision,
-            raw_bid_size,
-            raw_ask_size,
-            self.instrument.size_precision,
-            self.instrument.size_precision,
-            ts_event,
-            ts_init,
+    @staticmethod
+    def order(
+        side: OrderSide = OrderSide.BUY,
+        price: float = 100.0,
+        size: float = 10.0,
+    ) -> BookOrder:
+        return BookOrder(
+            price=Price(price, 2),
+            size=Quantity(size, 0),
+            side=side,
+            order_id=0,
         )
 
-    # cpdef method for Python wrap() (called with map)
-    cpdef QuoteTick _build_tick(
-        self,
-        double bid,
-        double ask,
-        double bid_size,
-        double ask_size,
-        uint64_t ts_event,
-        uint64_t ts_init,
-    ):
-        # Build a quote tick from the given values. The function expects the values to
-        # be an ndarray with 4 elements [bid, ask, bid_size, ask_size] of type double.
-        return QuoteTick.from_raw_c(
-            self.instrument.id,
-            int(bid * 1e9),
-            int(ask * 1e9),
-            self.instrument.price_precision,
-            self.instrument.price_precision,
-            int(bid_size * 1e9),
-            int(ask_size * 1e9),
-            self.instrument.size_precision,
-            self.instrument.size_precision,
-            ts_event,
-            ts_init,
+    @staticmethod
+    def order_book(
+        instrument_id: Optional[InstrumentId] = None,
+        book_type: BookType = BookType.L2_MBP,
+        bid_price: float = 10.0,
+        ask_price: float = 15.0,
+        bid_size: float = 10.0,
+        ask_size: float = 10.0,
+        bid_levels: int = 3,
+        ask_levels: int = 3,
+        ts_event: int = 0,
+        ts_init: int = 0,
+    ) -> OrderBook:
+        instrument_id = instrument_id or TestIdStubs.audusd_id()
+        order_book = OrderBook(
+            instrument_id=instrument_id,
+            book_type=book_type,
         )
+        snapshot = TestDataStubs.order_book_snapshot(
+            instrument_id=instrument_id,
+            bid_price=bid_price,
+            ask_price=ask_price,
+            bid_levels=bid_levels,
+            ask_levels=ask_levels,
+            bid_size=bid_size,
+            ask_size=ask_size,
+            ts_event=ts_event,
+            ts_init=ts_init,
+        )
+        order_book.apply_deltas(snapshot)
+        return order_book
 
+    @staticmethod
+    def order_book_snapshot(
+        instrument_id: Optional[InstrumentId] = None,
+        bid_price: float = 10.0,
+        ask_price: float = 15.0,
+        bid_size: float = 10.0,
+        ask_size: float = 10.0,
+        bid_levels: int = 3,
+        ask_levels: int = 3,
+        ts_event: int = 0,
+        ts_init: int = 0,
+    ) -> OrderBookDeltas:
+        err = "Too many levels generated; orders will be in cross. Increase bid/ask spread or reduce number of levels"
+        assert bid_price < ask_price, err
+        instrument_id = instrument_id or TestIdStubs.audusd_id()
+        bids = [
+            BookOrder(
+                OrderSide.BUY,
+                Price(bid_price - i, 2),
+                Quantity(bid_size * (1 + i), 2),
+                0,
+            )
+            for i in range(bid_levels)
+        ]
+        asks = [
+            BookOrder(
+                OrderSide.SELL,
+                Price(ask_price + i, 2),
+                Quantity(ask_size * (1 + i), 2),
+                0,
+            )
+            for i in range(ask_levels)
+        ]
+
+        deltas = [OrderBookDelta.clear(instrument_id, ts_event, ts_init)]
+        deltas += [
+            OrderBookDelta(instrument_id, BookAction.ADD, order, ts_event, ts_init)
+            for order in bids + asks
+        ]
+        return OrderBookDeltas(
+            instrument_id=instrument_id,
+            deltas=deltas,
+        )
 
-cdef class TradeTickDataWrangler:
-    """
-    Provides a means of building lists of Nautilus `TradeTick` objects.
+    @staticmethod
+    def order_book_delta(
+        instrument_id: Optional[InstrumentId] = None,
+        order: Optional[Order] = None,
+    ) -> OrderBookDeltas:
+        return OrderBookDelta(
+            instrument_id=instrument_id or TestIdStubs.audusd_id(),
+            action=BookAction.ADD,
+            order=order or TestDataStubs.order(),
+            ts_event=0,
+            ts_init=0,
+        )
 
-    Parameters
-    ----------
-    instrument : Instrument
-        The instrument for the data wrangler.
-    """
+    @staticmethod
+    def order_book_deltas(
+        instrument_id: Optional[InstrumentId] = None,
+        deltas: Optional[list[OrderBookDelta]] = None,
+    ) -> OrderBookDeltas:
+        return OrderBookDeltas(
+            instrument_id=instrument_id or TestIdStubs.audusd_id(),
+            deltas=deltas or [TestDataStubs.order_book_delta()],
+        )
 
-    def __init__(self, Instrument instrument not None):
-        self.instrument = instrument
+    @staticmethod
+    def make_book(
+        instrument: Instrument,
+        book_type: BookType,
+        bids: Optional[list[tuple]] = None,
+        asks: Optional[list[tuple]] = None,
+    ) -> OrderBook:
+        book = OrderBook(
+            instrument_id=instrument.id,
+            book_type=book_type,
+        )
 
-    def process(self, data: pd.DataFrame, ts_init_delta: int=0, bint is_raw=False):
-        """
-        Process the given trade tick dataset into Nautilus `TradeTick` objects.
-
-        Parameters
-        ----------
-        data : pd.DataFrame
-            The data to process.
-        ts_init_delta : int
-            The difference in nanoseconds between the data timestamps and the
-            `ts_init` value. Can be used to represent/simulate latency between
-            the data source and the Nautilus system.
-        is_raw : bool, default False
-            If the data is scaled to the Nautilus fixed precision.
-
-        Raises
-        ------
-        ValueError
-            If `data` is empty.
-
-        """
-        Condition.not_none(data, "data")
-        Condition.false(data.empty, "data.empty")
-
-        data = as_utc_index(data)
-
-        cdef uint64_t[:] ts_events = np.ascontiguousarray([secs_to_nanos(dt.timestamp()) for dt in data.index], dtype=np.uint64)  # noqa
-        cdef uint64_t[:] ts_inits = np.ascontiguousarray([ts_event + ts_init_delta for ts_event in ts_events], dtype=np.uint64)  # noqa
-
-        if is_raw:
-            return list(map(
-                self._build_tick_from_raw,
-                data["price"],
-                data["quantity"],
-                self._create_side_if_not_exist(data),
-                data["trade_id"].astype(str),
-                ts_events,
-                ts_inits,
-            ))
-        else:
-            return list(map(
-                self._build_tick,
-                data["price"],
-                data["quantity"],
-                self._create_side_if_not_exist(data),
-                data["trade_id"].astype(str),
-                ts_events,
-                ts_inits,
-            ))
-
-    def _create_side_if_not_exist(self, data):
-        if "side" in data.columns:
-            return data["side"].apply(lambda x: AggressorSide.BUYER if str(x).upper() == "BUY" else AggressorSide.SELLER)
-        else:
-            return data["buyer_maker"].apply(lambda x: AggressorSide.SELLER if x is True else AggressorSide.BUYER)
+        bids_counter: int = 0
+        asks_counter: int = 0
 
-    # cpdef method for Python wrap() (called with map)
-    cpdef TradeTick _build_tick_from_raw(
-        self,
-        int64_t raw_price,
-        uint64_t raw_size,
-        AggressorSide aggressor_side,
-        str trade_id,
-        uint64_t ts_event,
-        uint64_t ts_init,
-    ):
-        return TradeTick.from_raw_c(
-            self.instrument.id,
-            raw_price,
-            self.instrument.price_precision,
-            raw_size,
-            self.instrument.size_precision,
-            aggressor_side,
-            TradeId(trade_id),
-            ts_event,
-            ts_init,
+        for price, size in bids or []:
+            order = BookOrder(
+                side=OrderSide.BUY,
+                price=Price(price, instrument.price_precision),
+                size=Quantity(size, instrument.size_precision),
+                order_id=bids_counter,
+            )
+            book.add(order, 0)
+            bids_counter += 1
+        for price, size in asks or []:
+            order = BookOrder(
+                side=OrderSide.SELL,
+                price=Price(price, instrument.price_precision),
+                size=Quantity(size, instrument.size_precision),
+                order_id=asks_counter,
+            )
+            book.add(order, 0)
+            asks_counter += 1
+
+        return book
+
+    @staticmethod
+    def venue_status_update(
+        venue: Venue = None,
+        status: MarketStatus = None,
+    ) -> VenueStatusUpdate:
+        return VenueStatusUpdate(
+            venue=venue or Venue("BINANCE"),
+            status=status or MarketStatus.OPEN,
+            ts_event=0,
+            ts_init=0,
         )
 
-    # cpdef method for Python wrap() (called with map)
-    cpdef TradeTick _build_tick(
-        self,
-        double price,
-        double size,
-        AggressorSide aggressor_side,
-        str trade_id,
-        uint64_t ts_event,
-        uint64_t ts_init,
-    ):
-        # Build a quote tick from the given values. The function expects the values to
-        # be an ndarray with 4 elements [bid, ask, bid_size, ask_size] of type double.
-        return TradeTick.from_raw_c(
-            self.instrument.id,
-            int(price * 1e9),
-            self.instrument.price_precision,
-            int(size * 1e9),
-            self.instrument.size_precision,
-            aggressor_side,
-            TradeId(trade_id),
-            ts_event,
-            ts_init,
+    @staticmethod
+    def instrument_status_update(
+        instrument_id: InstrumentId = None,
+        status: MarketStatus = None,
+    ) -> InstrumentStatusUpdate:
+        return InstrumentStatusUpdate(
+            instrument_id=instrument_id or InstrumentId(Symbol("BTCUSDT"), Venue("BINANCE")),
+            status=status or MarketStatus.PAUSE,
+            ts_event=0,
+            ts_init=0,
         )
 
+    @staticmethod
+    def l1_feed():
+        provider = TestDataProvider()
+        updates = []
+        for _, row in provider.read_csv_ticks("truefx-usdjpy-ticks.csv").iterrows():
+            for side, order_side in zip(("bid", "ask"), (OrderSide.BUY, OrderSide.SELL)):
+                updates.append(
+                    {
+                        "op": "update",
+                        "order": BookOrder(
+                            price=Price(row[side], precision=6),
+                            size=Quantity(1e9, precision=2),
+                            side=order_side,
+                        ),
+                    },
+                )
+        return updates
+
+    @staticmethod
+    def l2_feed(filename: str) -> list:
+        def parse_line(d):
+            if "status" in d:
+                return {}
+            elif "close_price" in d:
+                # return {'timestamp': d['remote_timestamp'], "close_price": d['close_price']}
+                return {}
+            if "trade" in d:
+                ts = millis_to_nanos(pd.Timestamp(d["remote_timestamp"]).timestamp())
+                return {
+                    "timestamp": d["remote_timestamp"],
+                    "op": "trade",
+                    "trade": TradeTick(
+                        instrument_id=InstrumentId(Symbol("TEST"), Venue("BETFAIR")),
+                        price=Price(d["trade"]["price"], 4),
+                        size=Quantity(d["trade"]["volume"], 4),
+                        aggressor_side=d["trade"]["side"],
+                        trade_id=TradeId(d["trade"]["trade_id"]),
+                        ts_event=ts,
+                        ts_init=ts,
+                    ),
+                }
+            elif "level" in d and d["level"]["orders"][0]["volume"] == 0:
+                op = "delete"
+            else:
+                op = "update"
+            order_like = d["level"]["orders"][0] if op != "trade" else d["trade"]
+            return {
+                "timestamp": d["remote_timestamp"],
+                "op": op,
+                "order": BookOrder(
+                    price=Price(order_like["price"], precision=6),
+                    size=Quantity(abs(order_like["volume"]), precision=4),
+                    # Betting sides are reversed
+                    side={2: OrderSide.BUY, 1: OrderSide.SELL}[order_like["side"]],
+                    order_id=str(order_like["order_id"]),
+                ),
+            }
+
+        return [parse_line(line) for line in json.loads(open(filename).read())]
+
+    @staticmethod
+    def l3_feed(filename: str) -> list[dict[str, Any]]:
+        def parser(data):
+            parsed = data
+            if not isinstance(parsed, list):
+                # print(parsed)
+                return
+            elif isinstance(parsed, list):
+                channel, updates = parsed
+                if not isinstance(updates[0], list):
+                    updates = [updates]
+            else:
+                raise KeyError
+            if isinstance(updates, int):
+                print("Err", updates)
+                return
+            for values in updates:
+                keys = ("order_id", "price", "size")
+                data = dict(zip(keys, values))
+                side = OrderSide.BUY if data["size"] >= 0 else OrderSide.SELL
+                if data["price"] == 0:
+                    yield {
+                        "op": "delete",
+                        "order": BookOrder(
+                            price=Price(data["price"], precision=9),
+                            size=Quantity(abs(data["size"]), precision=9),
+                            side=side,
+                            order_id=str(data["order_id"]),
+                        ),
+                    }
+                else:
+                    yield {
+                        "op": "update",
+                        "order": BookOrder(
+                            price=Price(data["price"], precision=9),
+                            size=Quantity(abs(data["size"]), precision=9),
+                            side=side,
+                            order_id=str(data["order_id"]),
+                        ),
+                    }
 
-cdef class BarDataWrangler:
-    """
-    Provides a means of building lists of Nautilus `Bar` objects.
+        return [msg for data in json.loads(open(filename).read()) for msg in parser(data)]
 
-    Parameters
-    ----------
-    bar_type : BarType
-        The bar type for the wrangler.
-    instrument : Instrument
-        The instrument for the wrangler.
+
+class MyData(Data):
+    """
+    Represents an example user-defined data class.
     """
 
     def __init__(
         self,
-        BarType bar_type not None,
-        Instrument instrument not None,
-    ):
-        Condition.not_none(bar_type, "bar_type")
-        Condition.not_none(instrument, "instrument")
-
-        self.bar_type = bar_type
-        self.instrument = instrument
-
-    def process(
-        self,
-        data: pd.DataFrame,
-        default_volume: float=1_000_000.0,
-        ts_init_delta: int=0,
+        value,
+        ts_event=0,
+        ts_init=0,
     ):
-        """
-        Process the given bar dataset into Nautilus `Bar` objects.
-
-        Expects columns ['open', 'high', 'low', 'close', 'volume'] with 'timestamp' index.
-        Note: The 'volume' column is optional, will then use the `default_volume`.
-
-        Parameters
-        ----------
-        data : pd.DataFrame
-            The data to process.
-        default_volume : float
-            The default volume for each bar (if not provided).
-        ts_init_delta : int
-            The difference in nanoseconds between the data timestamps and the
-            `ts_init` value. Can be used to represent/simulate latency between
-            the data source and the Nautilus system.
-
-        Returns
-        -------
-        list[Bar]
-
-        Raises
-        ------
-        ValueError
-            If `data` is empty.
-
-        """
-        Condition.not_none(data, "data")
-        Condition.false(data.empty, "data.empty")
-        Condition.not_none(default_volume, "default_volume")
-
-        data = as_utc_index(data)
-
-        if "volume" not in data:
-            data["volume"] = float(default_volume)
-
-        cdef uint64_t[:] ts_events = np.ascontiguousarray([secs_to_nanos(dt.timestamp()) for dt in data.index], dtype=np.uint64)  # noqa
-        cdef uint64_t[:] ts_inits = np.ascontiguousarray([ts_event + ts_init_delta for ts_event in ts_events], dtype=np.uint64)  # noqa
-
-        return list(map(
-            self._build_bar,
-            data.values,
-            ts_events,
-            ts_inits
-        ))
-
-    # cpdef method for Python wrap() (called with map)
-    cpdef Bar _build_bar(self, double[:] values, uint64_t ts_event, uint64_t ts_init):
-        # Build a bar from the given index and values. The function expects the
-        # values to be an ndarray with 5 elements [open, high, low, close, volume].
-        return Bar(
-            bar_type=self.bar_type,
-            open=Price(values[0], self.instrument.price_precision),
-            high=Price(values[1], self.instrument.price_precision),
-            low=Price(values[2], self.instrument.price_precision),
-            close=Price(values[3], self.instrument.price_precision),
-            volume=Quantity(values[4], self.instrument.size_precision),
-            ts_event=ts_event,
-            ts_init=ts_init,
-        )
+        self.value = value
+        self._ts_event = ts_event
+        self._ts_init = ts_init
+
+    @property
+    def ts_event(self) -> int:
+        return self._ts_event
+
+    @property
+    def ts_init(self) -> int:
+        return self._ts_init
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/portfolio/__init__.pxd` & `nautilus_trader-1.175.0/nautilus_trader/risk/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/portfolio/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/serialization/__init__.pxd`

 * *Files 9% similar despite different names*

```diff
@@ -8,9 +8,7 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
-"""The `portfolio` subpackage provides portfolio management functionality."""
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/portfolio/base.pxd` & `nautilus_trader-1.175.0/nautilus_trader/portfolio/base.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/portfolio/base.pyx` & `nautilus_trader-1.175.0/nautilus_trader/portfolio/base.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/portfolio/portfolio.pxd` & `nautilus_trader-1.175.0/nautilus_trader/portfolio/portfolio.pxd`

 * *Files 6% similar despite different names*

```diff
@@ -20,14 +20,15 @@
 from nautilus_trader.common.logging cimport LoggerAdapter
 from nautilus_trader.model.data.tick cimport QuoteTick
 from nautilus_trader.model.enums_c cimport OrderSide
 from nautilus_trader.model.events.account cimport AccountState
 from nautilus_trader.model.events.order cimport OrderEvent
 from nautilus_trader.model.events.position cimport PositionEvent
 from nautilus_trader.model.identifiers cimport InstrumentId
+from nautilus_trader.model.identifiers cimport Venue
 from nautilus_trader.model.instruments.base cimport Instrument
 from nautilus_trader.model.objects cimport Money
 from nautilus_trader.model.objects cimport Price
 from nautilus_trader.model.position cimport Position
 from nautilus_trader.msgbus.bus cimport MessageBus
 from nautilus_trader.portfolio.base cimport PortfolioFacade
 
@@ -35,20 +36,22 @@
 cdef class Portfolio(PortfolioFacade):
     cdef LoggerAdapter _log
     cdef Clock _clock
     cdef MessageBus _msgbus
     cdef Cache _cache
     cdef AccountsManager _accounts
 
+    cdef Venue _venue
     cdef dict _unrealized_pnls
     cdef dict _net_positions
     cdef set _pending_calcs
 
 # -- COMMANDS -------------------------------------------------------------------------------------
 
+    cpdef void set_specific_venue(self, Venue venue)
     cpdef void initialize_orders(self)
     cpdef void initialize_positions(self)
     cpdef void update_quote_tick(self, QuoteTick tick)
     cpdef void update_account(self, AccountState event)
     cpdef void update_order(self, OrderEvent event)
     cpdef void update_position(self, PositionEvent event)
     cpdef void reset(self)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/portfolio/portfolio.pyx` & `nautilus_trader-1.175.0/nautilus_trader/portfolio/portfolio.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -105,14 +105,15 @@
         self._cache = cache
         self._accounts = AccountsManager(
             cache=cache,
             clock=clock,
             log=self._log,
         )
 
+        self._venue = None  # Venue for specific portfolio behaviour (Interactive Brokers)
         self._unrealized_pnls: dict[InstrumentId, Money] = {}
         self._net_positions: dict[InstrumentId, float] = {}
         self._pending_calcs: set[InstrumentId] = set()
 
         self.analyzer = PortfolioAnalyzer()
 
         # Register default statistics
@@ -143,14 +144,28 @@
         self._msgbus.subscribe(topic="events.position.*", handler=self.update_position, priority=10)
         self._msgbus.subscribe(topic="events.account.*", handler=self.update_account, priority=10)
 
         self.initialized = False
 
 # -- COMMANDS -------------------------------------------------------------------------------------
 
+    cpdef void set_specific_venue(self, Venue venue):
+        """
+        Set a specific venue for the portfolio.
+
+        Parameters
+        ----------
+        venue : Venue
+            The specific venue to set.
+
+        """
+        Condition.not_none(venue, "venue")
+
+        self._venue = venue
+
     cpdef void initialize_orders(self):
         """
         Initialize the portfolios orders.
 
         Performs all account calculations for the current orders state.
         """
         cdef list all_orders_open = self._cache.orders_open()
@@ -172,15 +187,15 @@
                 self._log.error(
                     f"Cannot update initial (order) margin: "
                     f"no instrument found for {instrument.id}."
                 )
                 initialized = False
                 break
 
-            account = self._cache.account_for_venue(instrument.id.venue)
+            account = self._cache.account_for_venue(self._venue or instrument.id.venue)
             if account is None:
                 self._log.error(
                     f"Cannot update initial (order) margin: "
                     f"no account registered for {instrument.id.venue}."
                 )
                 initialized = False
                 break
@@ -240,15 +255,15 @@
             self._update_net_position(
                 instrument_id=instrument_id,
                 positions_open=positions_open,
             )
 
             self._unrealized_pnls[instrument_id] = self._calculate_unrealized_pnl(instrument_id)
 
-            account = self._cache.account_for_venue(instrument_id.venue)
+            account = self._cache.account_for_venue(self._venue or instrument_id.venue)
             if account is None:
                 self._log.error(
                     f"Cannot update maintenance (position) margin: "
                     f"no account registered for {instrument_id.venue}."
                 )
                 initialized = False
                 break
@@ -305,23 +320,23 @@
 
         if self.initialized:
             return
 
         if tick.instrument_id not in self._pending_calcs:
             return
 
-        cdef Account account = self._cache.account_for_venue(tick.instrument_id.venue)
+        cdef Account account = self._cache.account_for_venue(self._venue or tick.instrument_id.venue)
         if account is None:
             self._log.error(
                 f"Cannot update tick: "
                 f"no account registered for {tick.instrument_id.venue}."
             )
             return  # No account registered
 
-        cdef Instrument instrument = self._cache.instrument(tick.instrument_id)
+        cdef Instrument instrument = self._cache.instrument(self._venue or tick.instrument_id)
         if instrument is None:
             self._log.error(
                 f"Cannot update tick: "
                 f"no instrument found for {tick.instrument_id}"
             )
             return  # No instrument found
 
@@ -822,15 +837,15 @@
         Returns
         -------
         Money or ``None``
 
         """
         Condition.not_none(instrument_id, "instrument_id")
 
-        cdef Account account = self._cache.account_for_venue(instrument_id.venue)
+        cdef Account account = self._cache.account_for_venue(self._venue or instrument_id.venue)
         if account is None:
             self._log.error(
                 f"Cannot calculate net exposure: "
                 f"no account registered for {instrument_id.venue}."
             )
             return None  # Cannot calculate
 
@@ -998,15 +1013,15 @@
 
         cdef double existing_position = self._net_positions.get(instrument_id, 0.0)
         if existing_position is None or existing_position != net_position:
             self._net_positions[instrument_id] = net_position
             self._log.info(f"{instrument_id} net_position={net_position}")
 
     cdef Money _calculate_unrealized_pnl(self, InstrumentId instrument_id):
-        cdef Account account = self._cache.account_for_venue(instrument_id.venue)
+        cdef Account account = self._cache.account_for_venue(self._venue or instrument_id.venue)
         if account is None:
             self._log.error(
                 f"Cannot calculate unrealized PnL: "
                 f"no account registered for {instrument_id.venue}."
             )
             return None  # Cannot calculate
 
@@ -1087,14 +1102,14 @@
 
         cdef TradeTick trade_tick = self._cache.trade_tick(position.instrument_id)
         return trade_tick.price if trade_tick is not None else None
 
     cdef double _calculate_xrate_to_base(self, Account account, Instrument instrument, OrderSide side):
         if account.base_currency is not None:
             return self._cache.get_xrate(
-                venue=instrument.id.venue,
+                venue=self._venue or instrument.id.venue,
                 from_currency=instrument.get_settlement_currency(),
                 to_currency=account.base_currency,
                 price_type=PriceType.BID if side == OrderSide.BUY else PriceType.ASK,
             )
 
         return Decimal(1)  # No conversion needed
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/risk/__init__.pxd` & `nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/risk/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/risk/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/risk/engine.pxd` & `nautilus_trader-1.175.0/nautilus_trader/risk/engine.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/risk/engine.pyx` & `nautilus_trader-1.175.0/nautilus_trader/risk/engine.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/risk/sizing.pxd` & `nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/bar.py`

 * *Files 26% similar despite different names*

```diff
@@ -9,37 +9,28 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.model.instruments.base cimport Instrument
-from nautilus_trader.model.objects cimport Money
-from nautilus_trader.model.objects cimport Price
-from nautilus_trader.model.objects cimport Quantity
-
-
-cdef class PositionSizer:
-    cdef readonly Instrument instrument
-    """The instrument for position sizing.\n\n:returns: `Instrument`"""
-
-    cpdef void update_instrument(self, Instrument instrument)
-    cpdef Quantity calculate(
-        self,
-        Price entry,
-        Price stop_loss,
-        Money equity,
-        risk,
-        commission_rate=*,
-        exchange_rate=*,
-        hard_limit=*,
-        unit_batch_size=*,
-        int units=*,
-    )
+from nautilus_trader.model.data import Bar
+from nautilus_trader.serialization.arrow.serializer import register_parquet
 
-    cdef object _calculate_risk_ticks(self, Price entry, Price stop_loss)
-    cdef object _calculate_riskable_money(self, equity, risk, commission_rate)
 
+def serialize(bar: Bar):
+    data = bar.to_dict(bar)
+    data["instrument_id"] = bar.bar_type.instrument_id.value
+    return data
 
-cdef class FixedRiskSizer(PositionSizer):
-    pass
+
+def deserialize(data: dict) -> Bar:
+    ignore = ("instrument_id",)
+    bar = Bar.from_dict({k: v for k, v in data.items() if k not in ignore})
+    return bar
+
+
+register_parquet(
+    Bar,
+    serializer=serialize,
+    deserializer=deserialize,
+)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/risk/sizing.pyx` & `nautilus_trader-1.175.0/nautilus_trader/risk/sizing.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/serialization/__init__.pxd` & `nautilus_trader-1.175.0/nautilus_trader/serialization/msgpack/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/serialization/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/serialization/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/serialization/arrow/__init__.pxd` & `nautilus_trader-1.175.0/nautilus_trader/serialization/msgpack/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/serialization/arrow/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/test_kit/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -9,8 +9,11 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.serialization.arrow import implementations  # noqa: F401
+"""
+The test kit contains test doubles and helpers to support the NautilusTrader
+test suite, as well as supporting testing for downstream projects and packages.
+"""
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/serialization/arrow/implementations/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/serialization/arrow/implementations/account_state.py` & `nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/account_state.py`

 * *Files 2% similar despite different names*

```diff
@@ -16,15 +16,15 @@
 import itertools
 from typing import Optional
 
 import msgspec
 import pandas as pd
 
 from nautilus_trader.model.currency import Currency
-from nautilus_trader.model.events.account import AccountState
+from nautilus_trader.model.events import AccountState
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.serialization.arrow.serializer import register_parquet
 
 
 def serialize(state: AccountState):
     result: dict[tuple[Currency, Optional[InstrumentId]], dict] = {}
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/serialization/arrow/implementations/bar.py` & `nautilus_trader-1.175.0/nautilus_trader/serialization/msgpack/serializer.pxd`

 * *Files 25% similar despite different names*

```diff
@@ -9,28 +9,13 @@
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
-from nautilus_trader.model.data.bar import Bar
-from nautilus_trader.serialization.arrow.serializer import register_parquet
+from nautilus_trader.serialization.base cimport Serializer
 
 
-def serialize(bar: Bar):
-    data = bar.to_dict(bar)
-    data["instrument_id"] = bar.bar_type.instrument_id.value
-    return data
-
-
-def deserialize(data: dict) -> Bar:
-    ignore = ("instrument_id",)
-    bar = Bar.from_dict({k: v for k, v in data.items() if k not in ignore})
-    return bar
-
-
-register_parquet(
-    Bar,
-    serializer=serialize,
-    deserializer=deserialize,
-)
+cdef class MsgPackSerializer(Serializer):
+    cdef readonly bint timestamps_as_str
+    """If the serializer converts timestamp int64_t to str.\n\n:returns: `bool`"""
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/serialization/arrow/implementations/order_book.py` & `nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/orderbook_v2.py`

 * *Files 18% similar despite different names*

```diff
@@ -10,99 +10,69 @@
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 import itertools
-from itertools import repeat
 from typing import Union
 
-from nautilus_trader.model.data.book import BookOrder
-from nautilus_trader.model.data.book import OrderBookDelta
-from nautilus_trader.model.data.book import OrderBookDeltas
-from nautilus_trader.model.data.book import OrderBookSnapshot
-from nautilus_trader.model.enums import BookAction
-from nautilus_trader.model.enums import OrderSide
+from nautilus_trader.model.data import OrderBookDelta
+from nautilus_trader.model.data import OrderBookDeltas
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.serialization.arrow.serializer import register_parquet
 
 
-def _parse_delta(delta: OrderBookDelta, cls):
+def _parse_delta(delta: Union[OrderBookDelta, OrderBookDeltas], cls):
     return dict(**OrderBookDelta.to_dict(delta), _type=cls.__name__)
 
 
-def serialize(data: Union[OrderBookDelta, OrderBookDeltas, OrderBookSnapshot]):
+def serialize(data: Union[OrderBookDelta, OrderBookDeltas]):
     if isinstance(data, OrderBookDelta):
         result = [_parse_delta(delta=data, cls=OrderBookDelta)]
     elif isinstance(data, OrderBookDeltas):
         result = [_parse_delta(delta=delta, cls=OrderBookDeltas) for delta in data.deltas]
-    elif isinstance(data, OrderBookSnapshot):
-        # For a snapshot, we store the individual deltas required to rebuild, namely a CLEAR, followed by ADDs
-        result = [
-            _parse_delta(
-                OrderBookDelta(
-                    instrument_id=data.instrument_id,
-                    order=None,
-                    action=BookAction.CLEAR,
-                    ts_event=data.ts_event,
-                    ts_init=data.ts_init,
-                ),
-                cls=OrderBookSnapshot,
-            ),
-        ]
-        orders = list(zip(repeat(OrderSide.BUY), data.bids)) + list(
-            zip(repeat(OrderSide.SELL), data.asks),
-        )
-        result.extend(
-            [
-                _parse_delta(
-                    OrderBookDelta(
-                        instrument_id=data.instrument_id,
-                        ts_event=data.ts_event,
-                        ts_init=data.ts_init,
-                        order=BookOrder(price=price, size=volume, side=side),
-                        action=BookAction.ADD,
-                    ),
-                    cls=OrderBookSnapshot,
-                )
-                for side, (price, volume) in orders
-            ],
-        )
     else:  # pragma: no cover (design-time error)
         raise TypeError(f"invalid order book data, was {type(data)}")
     # Add a "last" message to let downstream consumers know the end of this group of messages
     if result:
         result[-1]["_last"] = True
     return result
 
 
 def _is_orderbook_snapshot(values: list):
+    # TODO: Reimplement
     return values[0]["_type"] == "OrderBookSnapshot"
 
 
 def _build_order_book_snapshot(values):
     # First value is a CLEAR message, which we ignore
     assert len({v["instrument_id"] for v in values}) == 1
     assert len(values) >= 2, f"Not enough values passed! {values}"
-    return OrderBookSnapshot(
-        instrument_id=InstrumentId.from_str(values[1]["instrument_id"]),
-        bids=[(order["price"], order["size"]) for order in values[1:] if order["side"] == "BUY"],
-        asks=[(order["price"], order["size"]) for order in values[1:] if order["side"] == "SELL"],
-        ts_event=values[1]["ts_event"],
-        ts_init=values[1]["ts_init"],
+
+    instrument_id = InstrumentId.from_str(values[1]["instrument_id"])
+    ts_event = values[1]["ts_event"]
+    ts_init = values[1]["ts_init"]
+
+    # bids = [(order["price"], order["size"]) for order in values[1:] if order["side"] == "BUY"]
+    # asks = [(order["price"], order["size"]) for order in values[1:] if order["side"] == "SELL"]
+
+    deltas = [OrderBookDelta.clear(instrument_id, ts_event, ts_init)]
+    deltas += [OrderBookDelta.from_dict(v) for v in values]
+
+    return OrderBookDeltas(
+        instrument_id=instrument_id,
+        deltas=deltas,
     )
 
 
 def _build_order_book_deltas(values):
     return OrderBookDeltas(
         instrument_id=InstrumentId.from_str(values[0]["instrument_id"]),
         deltas=[OrderBookDelta.from_dict(v) for v in values],
-        ts_event=values[0]["ts_event"],
-        ts_init=values[0]["ts_init"],
     )
 
 
 def _sort_func(x):
     return x["instrument_id"], x["ts_event"]
 
 
@@ -114,15 +84,15 @@
         if _is_orderbook_snapshot(values=chunk):  # type: ignore
             results.append(_build_order_book_snapshot(values=chunk))
         elif len(chunk) >= 1:  # type: ignore
             results.append(_build_order_book_deltas(values=chunk))
     return sorted(results, key=lambda x: x.ts_event)
 
 
-for cls in [OrderBookDelta, OrderBookDeltas, OrderBookSnapshot]:
+for cls in [OrderBookDelta, OrderBookDeltas]:
     register_parquet(
         cls=cls,
         serializer=serialize,
         deserializer=deserialize,
         table=OrderBookDelta,
         chunk=True,
     )
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/serialization/arrow/implementations/order_events.py` & `nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/order_events.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,18 +13,18 @@
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 import json
 
 import msgspec
 
-from nautilus_trader.model.events.order import OrderEvent
-from nautilus_trader.model.events.order import OrderFilled
-from nautilus_trader.model.events.order import OrderInitialized
-from nautilus_trader.model.events.order import OrderUpdated
+from nautilus_trader.model.events import OrderEvent
+from nautilus_trader.model.events import OrderFilled
+from nautilus_trader.model.events import OrderInitialized
+from nautilus_trader.model.events import OrderUpdated
 from nautilus_trader.serialization.arrow.schema import NAUTILUS_PARQUET_SCHEMA
 from nautilus_trader.serialization.arrow.serializer import register_parquet
 
 
 def serialize(event: OrderEvent):
     caster = {
         "last_qty": float,
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/serialization/arrow/implementations/orderbook_v2.py` & `nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/order_book.py`

 * *Files 22% similar despite different names*

```diff
@@ -10,102 +10,66 @@
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 import itertools
-from itertools import repeat
 from typing import Union
 
-from nautilus_trader.model.data.book import BookOrder
-from nautilus_trader.model.data.book import OrderBookDelta
-from nautilus_trader.model.data.book import OrderBookDeltas
-from nautilus_trader.model.data.book import OrderBookSnapshot
-from nautilus_trader.model.enums import BookAction
-from nautilus_trader.model.enums import OrderSide
-from nautilus_trader.model.enums import book_type_from_str
+from nautilus_trader.model.data import OrderBookDelta
+from nautilus_trader.model.data import OrderBookDeltas
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.serialization.arrow.serializer import register_parquet
 
 
-def _parse_delta(delta: Union[OrderBookDelta, OrderBookDeltas, OrderBookSnapshot], cls):
+def _parse_delta(delta: OrderBookDelta, cls):
     return dict(**OrderBookDelta.to_dict(delta), _type=cls.__name__)
 
 
-def serialize(data: Union[OrderBookDelta, OrderBookDeltas, OrderBookSnapshot]):
+def serialize(data: Union[OrderBookDelta, OrderBookDeltas]):
     if isinstance(data, OrderBookDelta):
         result = [_parse_delta(delta=data, cls=OrderBookDelta)]
     elif isinstance(data, OrderBookDeltas):
         result = [_parse_delta(delta=delta, cls=OrderBookDeltas) for delta in data.deltas]
-    elif isinstance(data, OrderBookSnapshot):
-        # For a snapshot, we store the individual deltas required to rebuild, namely a CLEAR, followed by ADDs
-        result = [
-            _parse_delta(
-                OrderBookDelta(
-                    instrument_id=data.instrument_id,
-                    order=None,
-                    action=BookAction.CLEAR,
-                    ts_event=data.ts_event,
-                    ts_init=data.ts_init,
-                ),
-                cls=OrderBookSnapshot,
-            ),
-        ]
-        orders = list(zip(repeat(OrderSide.BUY), data.bids)) + list(
-            zip(repeat(OrderSide.SELL), data.asks),
-        )
-        result.extend(
-            [
-                _parse_delta(
-                    OrderBookDelta(
-                        instrument_id=data.instrument_id,
-                        ts_event=data.ts_event,
-                        ts_init=data.ts_init,
-                        order=BookOrder(price=price, size=volume, side=side),
-                        action=BookAction.ADD,
-                    ),
-                    cls=OrderBookSnapshot,
-                )
-                for side, (price, volume) in orders
-            ],
-        )
     else:  # pragma: no cover (design-time error)
         raise TypeError(f"invalid order book data, was {type(data)}")
     # Add a "last" message to let downstream consumers know the end of this group of messages
     if result:
         result[-1]["_last"] = True
     return result
 
 
 def _is_orderbook_snapshot(values: list):
+    # TODO: Reimplement
     return values[0]["_type"] == "OrderBookSnapshot"
 
 
 def _build_order_book_snapshot(values):
     # First value is a CLEAR message, which we ignore
     assert len({v["instrument_id"] for v in values}) == 1
     assert len(values) >= 2, f"Not enough values passed! {values}"
-    return OrderBookSnapshot(
-        instrument_id=InstrumentId.from_str(values[1]["instrument_id"]),
-        book_type=book_type_from_str(values[1]["book_type"]),
-        bids=[(order["price"], order["size"]) for order in values[1:] if order["side"] == "BUY"],
-        asks=[(order["price"], order["size"]) for order in values[1:] if order["side"] == "SELL"],
-        ts_event=values[1]["ts_event"],
-        ts_init=values[1]["ts_init"],
-    )
+
+    instrument_id = InstrumentId.from_str(values[1]["instrument_id"])
+    ts_event = values[1]["ts_event"]
+    ts_init = values[1]["ts_init"]
+
+    # bids = [(order["price"], order["size"]) for order in values[1:] if order["side"] == "BUY"]
+    # asks = [(order["price"], order["size"]) for order in values[1:] if order["side"] == "SELL"]
+
+    deltas = [OrderBookDelta.clear(instrument_id, ts_event, ts_init)]
+    deltas += [OrderBookDelta.from_dict(v) for v in values]
+
+    return OrderBookDeltas(instrument_id=instrument_id, deltas=deltas)
 
 
 def _build_order_book_deltas(values):
     return OrderBookDeltas(
         instrument_id=InstrumentId.from_str(values[0]["instrument_id"]),
-        book_type=book_type_from_str(values[0]["book_type"]),
         deltas=[OrderBookDelta.from_dict(v) for v in values],
-        ts_event=values[0]["ts_event"],
-        ts_init=values[0]["ts_init"],
     )
 
 
 def _sort_func(x):
     return x["instrument_id"], x["ts_event"]
 
 
@@ -117,15 +81,15 @@
         if _is_orderbook_snapshot(values=chunk):  # type: ignore
             results.append(_build_order_book_snapshot(values=chunk))
         elif len(chunk) >= 1:  # type: ignore
             results.append(_build_order_book_deltas(values=chunk))
     return sorted(results, key=lambda x: x.ts_event)
 
 
-for cls in [OrderBookDelta, OrderBookDeltas, OrderBookSnapshot]:
+for cls in [OrderBookDelta, OrderBookDeltas]:
     register_parquet(
         cls=cls,
         serializer=serialize,
         deserializer=deserialize,
         table=OrderBookDelta,
         chunk=True,
     )
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/serialization/arrow/implementations/position_events.py` & `nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/implementations/position_events.py`

 * *Files 4% similar despite different names*

```diff
@@ -11,18 +11,18 @@
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from typing import Union
 
-from nautilus_trader.model.events.position import PositionChanged
-from nautilus_trader.model.events.position import PositionClosed
-from nautilus_trader.model.events.position import PositionEvent
-from nautilus_trader.model.events.position import PositionOpened
+from nautilus_trader.model.events import PositionChanged
+from nautilus_trader.model.events import PositionClosed
+from nautilus_trader.model.events import PositionEvent
+from nautilus_trader.model.events import PositionOpened
 from nautilus_trader.model.objects import Money
 from nautilus_trader.serialization.arrow.serializer import register_parquet
 
 
 def try_float(x):
     if x == "None" or x is None:
         return
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/serialization/arrow/schema.py` & `nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/schema.py`

 * *Files 0% similar despite different names*

```diff
@@ -15,40 +15,40 @@
 
 import msgspec
 import pyarrow as pa
 
 from nautilus_trader.adapters.binance.common.types import BinanceBar
 from nautilus_trader.common.messages import ComponentStateChanged
 from nautilus_trader.common.messages import TradingStateChanged
-from nautilus_trader.model.data.bar import Bar
-from nautilus_trader.model.data.book import OrderBookDelta
-from nautilus_trader.model.data.tick import QuoteTick
-from nautilus_trader.model.data.tick import TradeTick
-from nautilus_trader.model.data.ticker import Ticker
-from nautilus_trader.model.data.venue import InstrumentClose
-from nautilus_trader.model.data.venue import InstrumentStatusUpdate
-from nautilus_trader.model.data.venue import VenueStatusUpdate
-from nautilus_trader.model.events.account import AccountState
-from nautilus_trader.model.events.order import OrderAccepted
-from nautilus_trader.model.events.order import OrderCanceled
-from nautilus_trader.model.events.order import OrderCancelRejected
-from nautilus_trader.model.events.order import OrderDenied
-from nautilus_trader.model.events.order import OrderExpired
-from nautilus_trader.model.events.order import OrderFilled
-from nautilus_trader.model.events.order import OrderInitialized
-from nautilus_trader.model.events.order import OrderModifyRejected
-from nautilus_trader.model.events.order import OrderPendingCancel
-from nautilus_trader.model.events.order import OrderPendingUpdate
-from nautilus_trader.model.events.order import OrderRejected
-from nautilus_trader.model.events.order import OrderSubmitted
-from nautilus_trader.model.events.order import OrderTriggered
-from nautilus_trader.model.events.order import OrderUpdated
-from nautilus_trader.model.events.position import PositionChanged
-from nautilus_trader.model.events.position import PositionClosed
-from nautilus_trader.model.events.position import PositionOpened
+from nautilus_trader.model.data import Bar
+from nautilus_trader.model.data import InstrumentClose
+from nautilus_trader.model.data import InstrumentStatusUpdate
+from nautilus_trader.model.data import OrderBookDelta
+from nautilus_trader.model.data import QuoteTick
+from nautilus_trader.model.data import Ticker
+from nautilus_trader.model.data import TradeTick
+from nautilus_trader.model.data import VenueStatusUpdate
+from nautilus_trader.model.events import AccountState
+from nautilus_trader.model.events import OrderAccepted
+from nautilus_trader.model.events import OrderCanceled
+from nautilus_trader.model.events import OrderCancelRejected
+from nautilus_trader.model.events import OrderDenied
+from nautilus_trader.model.events import OrderExpired
+from nautilus_trader.model.events import OrderFilled
+from nautilus_trader.model.events import OrderInitialized
+from nautilus_trader.model.events import OrderModifyRejected
+from nautilus_trader.model.events import OrderPendingCancel
+from nautilus_trader.model.events import OrderPendingUpdate
+from nautilus_trader.model.events import OrderRejected
+from nautilus_trader.model.events import OrderSubmitted
+from nautilus_trader.model.events import OrderTriggered
+from nautilus_trader.model.events import OrderUpdated
+from nautilus_trader.model.events import PositionChanged
+from nautilus_trader.model.events import PositionClosed
+from nautilus_trader.model.events import PositionOpened
 from nautilus_trader.model.instruments import BettingInstrument
 from nautilus_trader.model.instruments import CryptoFuture
 from nautilus_trader.model.instruments import CryptoPerpetual
 from nautilus_trader.model.instruments import CurrencyPair
 from nautilus_trader.model.instruments import Equity
 from nautilus_trader.model.instruments import FuturesContract
 from nautilus_trader.model.instruments import OptionsContract
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/serialization/arrow/schema_v2.py` & `nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/schema_v2.py`

 * *Files 2% similar despite different names*

```diff
@@ -11,18 +11,18 @@
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 import pyarrow as pa
 
-from nautilus_trader.model.data.bar import Bar
-from nautilus_trader.model.data.book import OrderBookDelta
-from nautilus_trader.model.data.tick import QuoteTick
-from nautilus_trader.model.data.tick import TradeTick
+from nautilus_trader.model.data import Bar
+from nautilus_trader.model.data import OrderBookDelta
+from nautilus_trader.model.data import QuoteTick
+from nautilus_trader.model.data import TradeTick
 
 
 NAUTILUS_PARQUET_SCHEMA_V2 = {
     OrderBookDelta: pa.schema(
         {
             "action": pa.uint8(),
             "side": pa.uint8(),
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/serialization/arrow/serializer.pxd` & `nautilus_trader-1.175.0/nautilus_trader/system/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -8,11 +8,7 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
-
-cdef class ParquetSerializer:
-    pass
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/serialization/arrow/serializer.pyx` & `nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/serializer.pyx`

 * *Files 6% similar despite different names*

```diff
@@ -84,16 +84,15 @@
     chunk : bool, optional
         Whether to group objects by timestamp and operate together (Used for
         complex objects where we write each object as multiple rows in parquet,
         i.e. `OrderBook` or `AccountState`).
     table : type, optional
         An optional table override for `cls`. Used if `cls` is going to be
         transformed and stored in a table other than
-        its own. (for example, `OrderBookSnapshots` are stored as
-        `OrderBookDeltas`, so we use `table=OrderBookDeltas`).
+        its own.
 
     """
     Condition.type_or_none(serializer, Callable, "serializer")
     Condition.type_or_none(deserializer, Callable, "deserializer")
     Condition.type_or_none(schema, pa.Schema, "schema")
     Condition.type_or_none(table, type, "table")
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/serialization/arrow/util.py` & `nautilus_trader-1.175.0/nautilus_trader/serialization/arrow/util.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/serialization/base.pxd` & `nautilus_trader-1.175.0/nautilus_trader/test_kit/mocks/__init__.py`

 * *Files 23% similar despite different names*

```diff
@@ -8,15 +8,7 @@
 #
 #  Unless required by applicable law or agreed to in writing, software
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
-
-cdef dict _OBJECT_TO_DICT_MAP
-cdef dict _OBJECT_FROM_DICT_MAP
-
-
-cdef class Serializer:
-    cpdef bytes serialize(self, object obj)
-    cpdef object deserialize(self, bytes obj_bytes)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/serialization/base.pyx` & `nautilus_trader-1.175.0/nautilus_trader/serialization/base.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/serialization/msgpack/__init__.pxd` & `nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/__init__.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/serialization/msgpack/__init__.py` & `nautilus_trader-1.175.0/nautilus_trader/trading/__init__.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/serialization/msgpack/serializer.pyx` & `nautilus_trader-1.175.0/nautilus_trader/serialization/msgpack/serializer.pyx`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/system/__init__.py` & `nautilus_trader-1.175.0/nautilus_core/network/src/lib.rs`

 * *Files 27% similar despite different names*

```diff
@@ -1,14 +1,33 @@
-# -------------------------------------------------------------------------------------------------
-#  Copyright (C) 2015-2023 Nautech Systems Pty Ltd. All rights reserved.
-#  https://nautechsystems.io
-#
-#  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
-#  You may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
-#
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
-# -------------------------------------------------------------------------------------------------
+// -------------------------------------------------------------------------------------------------
+//  Copyright (C) 2015-2023 Nautech Systems Pty Ltd. All rights reserved.
+//  https://nautechsystems.io
+//
+//  Licensed under the GNU Lesser General Public License Version 3.0 (the "License");
+//  You may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at https://www.gnu.org/licenses/lgpl-3.0.en.html
+//
+//  Unless required by applicable law or agreed to in writing, software
+//  distributed under the License is distributed on an "AS IS" BASIS,
+//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//  See the License for the specific language governing permissions and
+//  limitations under the License.
+// -------------------------------------------------------------------------------------------------
+
+pub mod http;
+pub mod socket;
+pub mod websocket;
+
+use http::{HttpClient, HttpResponse};
+use pyo3::prelude::*;
+use socket::SocketClient;
+use websocket::WebSocketClient;
+
+/// Loaded as nautilus_pyo3.network
+#[pymodule]
+pub fn network(_: Python<'_>, m: &PyModule) -> PyResult<()> {
+    m.add_class::<HttpClient>()?;
+    m.add_class::<HttpResponse>()?;
+    m.add_class::<WebSocketClient>()?;
+    m.add_class::<SocketClient>()?;
+    Ok(())
+}
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/system/kernel.py` & `nautilus_trader-1.175.0/nautilus_trader/system/kernel.py`

 * *Files 10% similar despite different names*

```diff
@@ -16,25 +16,27 @@
 import asyncio
 import concurrent.futures
 import platform
 import signal
 import socket
 import time
 from concurrent.futures import ThreadPoolExecutor
+from datetime import timedelta
 from typing import Callable, Optional
 
 import msgspec
 
 from nautilus_trader.cache.base import CacheFacade
 from nautilus_trader.cache.cache import Cache
 from nautilus_trader.common import Environment
 from nautilus_trader.common.actor import Actor
 from nautilus_trader.common.clock import Clock
 from nautilus_trader.common.clock import LiveClock
 from nautilus_trader.common.clock import TestClock
+from nautilus_trader.common.enums import LogColor
 from nautilus_trader.common.enums import LogLevel
 from nautilus_trader.common.enums import log_level_from_str
 from nautilus_trader.common.logging import Logger
 from nautilus_trader.common.logging import LoggerAdapter
 from nautilus_trader.common.logging import nautilus_header
 from nautilus_trader.config import ActorFactory
 from nautilus_trader.config import DataEngineConfig
@@ -106,29 +108,31 @@
 
     def __init__(  # noqa (too complex)
         self,
         name: str,
         config: NautilusKernelConfig,
         loop: Optional[asyncio.AbstractEventLoop] = None,
         loop_sig_callback: Optional[Callable] = None,
-    ):
+    ) -> None:
         PyCondition.valid_string(name, "name")
         PyCondition.type(config, NautilusKernelConfig, "config")
 
-        self._config = config
-        self._environment = config.environment
-        self._load_state = config.load_state
-        self._save_state = config.save_state
+        self._config: NautilusKernelConfig = config
+        self._environment: Environment = config.environment
+        self._load_state: bool = config.load_state
+        self._save_state: bool = config.save_state
 
         # Identifiers
-        self._name = name
-        self._trader_id = TraderId(config.trader_id)
-        self._machine_id = socket.gethostname()
-        self._instance_id = UUID4(config.instance_id) if config.instance_id is not None else UUID4()
-        self._ts_created = time.time_ns()
+        self._name: str = name
+        self._trader_id: TraderId = TraderId(config.trader_id)
+        self._machine_id: str = socket.gethostname()
+        self._instance_id: UUID4 = (
+            UUID4(config.instance_id) if config.instance_id is not None else UUID4()
+        )
+        self._ts_created: int = time.time_ns()
 
         # Components
         if self._environment == Environment.BACKTEST:
             self._clock = TestClock()
         elif self.environment in (Environment.SANDBOX, Environment.LIVE):
             self._clock = LiveClock(loop=loop)
         else:
@@ -136,15 +140,15 @@
                 f"environment {self._environment} not recognized",  # pragma: no cover (design-time error)
             )
 
         logging: LoggingConfig = config.logging or LoggingConfig()
 
         # Setup the logger with a `LiveClock` initially,
         # which is later swapped out for a `TestClock` in the `BacktestEngine`.
-        self._logger = Logger(
+        self._logger: Logger = Logger(
             clock=self._clock if isinstance(self._clock, LiveClock) else LiveClock(),
             trader_id=self._trader_id,
             machine_id=self._machine_id,
             instance_id=self._instance_id,
             level_stdout=log_level_from_str(logging.log_level),
             level_file=log_level_from_str(logging.log_level_file)
             if logging.log_level_file is not None
@@ -154,15 +158,15 @@
             file_name=logging.log_file_name,
             file_format=logging.log_file_format,
             component_levels=logging.log_component_levels,
             bypass=False if self._environment == Environment.LIVE else logging.bypass_logging,
         )
 
         # Setup logging
-        self._log = LoggerAdapter(
+        self._log: LoggerAdapter = LoggerAdapter(
             component_name=name,
             logger=self._logger,
         )
 
         nautilus_header(self._log)
         self.log.info("Building system kernel...")
 
@@ -678,20 +682,127 @@
         Returns
         -------
         ParquetDataCatalog or ``None``
 
         """
         return self._catalog
 
+    async def start(self) -> None:
+        self._log.info("STARTING...")
+
+        # Start system
+        self._data_engine.start()
+        self._risk_engine.start()
+        self._exec_engine.start()
+
+        # Connect all clients
+        self._data_engine.connect()
+        self._exec_engine.connect()
+
+        if self._loop is not None:
+            # Await engine connection and initialization
+            self._log.info(
+                f"Awaiting engine connections and initializations "
+                f"({self._config.timeout_connection}s timeout)...",
+                color=LogColor.BLUE,
+            )
+            if not await self._await_engines_connected():
+                self._log.warning(
+                    f"Timed out ({self._config.timeout_connection}s) waiting for engines to connect and initialize."
+                    f"\nStatus"
+                    f"\n------"
+                    f"\nDataEngine.check_connected() == {self._data_engine.check_connected()}"
+                    f"\nExecEngine.check_connected() == {self._exec_engine.check_connected()}",
+                )
+                return
+
+            # Await execution state reconciliation
+            self._log.info(
+                f"Awaiting execution state reconciliation "
+                f"({self._config.timeout_reconciliation}s timeout)...",
+                color=LogColor.BLUE,
+            )
+            if not await self._exec_engine.reconcile_state(
+                timeout_secs=self._config.timeout_reconciliation,
+            ):
+                self._log.error("Execution state could not be reconciled.")
+                return
+
+        if self._exec_engine.reconciliation:
+            self._log.info("State reconciled.", color=LogColor.GREEN)
+
+        self._emulator.start()
+
+        # Initialize portfolio
+        self._portfolio.initialize_orders()
+        self._portfolio.initialize_positions()
+
+        if self._loop is not None:
+            # Await portfolio initialization
+            self._log.info(
+                "Awaiting portfolio initialization "
+                f"({self._config.timeout_portfolio}s timeout)...",
+                color=LogColor.BLUE,
+            )
+            if not await self._await_portfolio_initialized():
+                self._log.warning(
+                    f"Timed out ({self._config.timeout_portfolio}s) waiting for portfolio to initialize."
+                    f"\nStatus"
+                    f"\n------"
+                    f"\nPortfolio.initialized == {self._portfolio.initialized}",
+                )
+                return
+        self._log.info("Portfolio initialized.", color=LogColor.GREEN)
+
+        # Start trader and strategies
+        self._trader.start()
+
+    async def _await_engines_connected(self) -> bool:
+        # - The data engine clients will be set connected when all
+        # instruments are received and updated with the data engine.
+        # - The execution engine clients will be set connected when all
+        # accounts are updated and the current order and position status is
+        # reconciled.
+        # Thus any delay here will be due to blocking network I/O.
+        seconds = self._config.timeout_connection
+        timeout: timedelta = self.clock.utc_now() + timedelta(seconds=seconds)
+        while True:
+            await asyncio.sleep(0)
+            if self.clock.utc_now() >= timeout:
+                return False
+            if not self._data_engine.check_connected():
+                continue
+            if not self._exec_engine.check_connected():
+                continue
+            break
+
+        return True  # Engines connected
+
+    async def _await_portfolio_initialized(self) -> bool:
+        # - The portfolio will be set initialized when all margin and unrealized
+        # PnL calculations are completed (maybe waiting on first quotes).
+        # Thus any delay here will be due to blocking network I/O.
+        seconds = self._config.timeout_portfolio
+        timeout: timedelta = self._clock.utc_now() + timedelta(seconds=seconds)
+        while True:
+            await asyncio.sleep(0)
+            if self._clock.utc_now() >= timeout:
+                return False
+            if not self._portfolio.initialized:
+                continue
+            break
+
+        return True  # Portfolio initialized
+
     def dispose(self) -> None:
         """
         Dispose of the kernel releasing system resources.
 
-        This method is idempotent and irreversible. No other methods should be
-        called after disposal.
+        Calling this method multiple times has the same effect as calling it once (it is idempotent).
+        Once called, it cannot be reversed, and no other methods should be called on this instance.
 
         """
         # Stop all engines
         if self.data_engine.is_running:
             self.data_engine.stop()
         if self.risk_engine.is_running:
             self.risk_engine.stop()
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/test_kit/mocks/actors.py` & `nautilus_trader-1.175.0/nautilus_trader/test_kit/mocks/actors.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/test_kit/mocks/cache_database.py` & `nautilus_trader-1.175.0/nautilus_trader/test_kit/mocks/cache_database.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/test_kit/mocks/data.py` & `nautilus_trader-1.175.0/nautilus_trader/test_kit/mocks/data.py`

 * *Files 6% similar despite different names*

```diff
@@ -18,15 +18,15 @@
 from pathlib import Path
 
 import pandas as pd
 
 from nautilus_trader.common.clock import TestClock
 from nautilus_trader.common.logging import Logger
 from nautilus_trader.common.providers import InstrumentProvider
-from nautilus_trader.model.data.tick import QuoteTick
+from nautilus_trader.model.data import QuoteTick
 from nautilus_trader.model.identifiers import Venue
 from nautilus_trader.model.objects import Price
 from nautilus_trader.model.objects import Quantity
 from nautilus_trader.persistence.catalog.parquet import ParquetDataCatalog
 from nautilus_trader.persistence.external.core import process_files
 from nautilus_trader.persistence.external.readers import CSVReader
 from nautilus_trader.persistence.external.readers import Reader
@@ -47,24 +47,23 @@
     if protocol not in ("memory", "file"):
         raise ValueError("`protocol` should only be one of `memory` or `file` for testing")
 
     clear_singleton_instances(ParquetDataCatalog)
 
     path = Path.cwd() / "data_catalog" if path is None else Path(path).resolve()
 
-    path = str(path)
-    catalog = ParquetDataCatalog(path=path, fs_protocol=protocol)
+    catalog = ParquetDataCatalog(path=path.as_posix(), fs_protocol=protocol)
 
-    if catalog.fs.exists(path):
-        catalog.fs.rm(path, recursive=True)
+    if catalog.fs.exists(catalog.path):
+        catalog.fs.rm(catalog.path, recursive=True)
 
-    catalog.fs.mkdir(path, create_parents=True)
+    catalog.fs.mkdir(catalog.path, create_parents=True)
 
-    assert catalog.fs.isdir(path)
-    assert not catalog.fs.glob(f"{path}/**")
+    assert catalog.fs.isdir(catalog.path)
+    assert not catalog.fs.glob(f"{catalog.path}/**")
 
     return catalog
 
 
 def aud_usd_data_loader(catalog: ParquetDataCatalog):
     from nautilus_trader.test_kit.providers import TestInstrumentProvider
     from nautilus_trader.test_kit.stubs.identifiers import TestIdStubs
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/test_kit/mocks/engines.py` & `nautilus_trader-1.175.0/nautilus_trader/test_kit/mocks/engines.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/test_kit/mocks/exec_clients.py` & `nautilus_trader-1.175.0/nautilus_trader/test_kit/mocks/exec_clients.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/test_kit/mocks/strategies.py` & `nautilus_trader-1.175.0/nautilus_trader/test_kit/mocks/strategies.py`

 * *Files 0% similar despite different names*

```diff
@@ -13,15 +13,15 @@
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 import inspect
 from typing import Optional
 
 from nautilus_trader.indicators.average.ema import ExponentialMovingAverage
-from nautilus_trader.model.data.bar import BarType
+from nautilus_trader.model.data import BarType
 from nautilus_trader.model.enums import OrderSide
 from nautilus_trader.model.identifiers import PositionId
 from nautilus_trader.trading.strategy import Strategy
 
 
 class MockStrategy(Strategy):
     """
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/test_kit/performance.py` & `nautilus_trader-1.175.0/nautilus_trader/test_kit/performance.py`

 * *Files 6% similar despite different names*

```diff
@@ -11,39 +11,47 @@
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 import inspect
 import timeit
+from typing import Callable
 
 import pytest
 
 
 class PerformanceHarness:
     @pytest.fixture(autouse=True)
     @pytest.mark.benchmark(disable_gc=True, warmup=True)
     def setup(self, benchmark):
         self.benchmark = benchmark
 
 
 class PerformanceBench:
     @staticmethod
-    def profile_function(target, runs, iterations, print_output=True) -> float:
+    def profile_function(
+        target: Callable,
+        runs: int,
+        iterations: int,
+        print_output: bool = True,
+    ) -> float:
         """
         Profile the given function.
+
         Return the minimum elapsed time in seconds taken to call the given
         function iteration times.
+
         Also prints the elapsed time in milliseconds (ms), microseconds (s) and
         nanoseconds (ns). As a rule of thumb a CPU cycles in 1 nanosecond per
         GHz of clock speed.
 
         Parameters
         ----------
-        target : callable
+        target : Callable
             The target to call and profile.
         runs : int
             The number of runs for the test.
         iterations : int
             The number of call iterations per run.
         print_output : bool
             If the output should be printed to the console.
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/test_kit/providers.py` & `nautilus_trader-1.175.0/nautilus_trader/test_kit/providers.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/test_kit/stubs/commands.py` & `nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/commands.py`

 * *Files 4% similar despite different names*

```diff
@@ -14,20 +14,22 @@
 # -------------------------------------------------------------------------------------------------
 
 from typing import Optional
 
 from nautilus_trader.execution.messages import CancelOrder
 from nautilus_trader.execution.messages import ModifyOrder
 from nautilus_trader.execution.messages import SubmitOrder
+from nautilus_trader.execution.messages import SubmitOrderList
 from nautilus_trader.model.identifiers import ClientOrderId
 from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.model.identifiers import VenueOrderId
 from nautilus_trader.model.objects import Price
 from nautilus_trader.model.objects import Quantity
 from nautilus_trader.model.orders import Order
+from nautilus_trader.model.orders import OrderList
 from nautilus_trader.test_kit.stubs.identifiers import TestIdStubs
 
 
 class TestCommandStubs:
     @staticmethod
     def submit_order_command(order: Order) -> SubmitOrder:
         return SubmitOrder(
@@ -36,14 +38,25 @@
             position_id=TestIdStubs.position_id(),
             order=order,
             command_id=TestIdStubs.uuid(),
             ts_init=0,
         )
 
     @staticmethod
+    def submit_order_list_command(order_list: OrderList) -> SubmitOrderList:
+        return SubmitOrderList(
+            trader_id=TestIdStubs.trader_id(),
+            strategy_id=TestIdStubs.strategy_id(),
+            order_list=order_list,
+            position_id=TestIdStubs.position_id(),
+            command_id=TestIdStubs.uuid(),
+            ts_init=0,
+        )
+
+    @staticmethod
     def modify_order_command(
         price: Optional[Price] = None,
         quantity: Optional[Quantity] = None,
         instrument_id: Optional[InstrumentId] = None,
         client_order_id: Optional[ClientOrderId] = None,
         venue_order_id: Optional[VenueOrderId] = None,
         order: Optional[Order] = None,
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/test_kit/stubs/component.py` & `nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/component.py`

 * *Files 2% similar despite different names*

```diff
@@ -18,15 +18,15 @@
 
 from nautilus_trader.backtest.engine import BacktestEngine
 from nautilus_trader.backtest.engine import BacktestEngineConfig
 from nautilus_trader.backtest.models import FillModel
 from nautilus_trader.backtest.node import BacktestNode
 from nautilus_trader.cache.cache import Cache
 from nautilus_trader.common.clock import LiveClock
-from nautilus_trader.common.enums import log_level_from_str
+from nautilus_trader.common.enums import LogLevel
 from nautilus_trader.common.factories import OrderFactory
 from nautilus_trader.common.logging import Logger
 from nautilus_trader.core.data import Data
 from nautilus_trader.model.currencies import USD
 from nautilus_trader.model.currency import Currency
 from nautilus_trader.model.enums import AccountType
 from nautilus_trader.model.enums import OmsType
@@ -47,18 +47,18 @@
 
 class TestComponentStubs:
     @staticmethod
     def clock() -> LiveClock:
         return LiveClock()
 
     @staticmethod
-    def logger(level="INFO") -> Logger:
+    def logger(level: LogLevel = LogLevel.INFO) -> Logger:
         return Logger(
             clock=TestComponentStubs.clock(),
-            level_stdout=log_level_from_str(level),
+            level_stdout=level,
             bypass=True,
         )
 
     @staticmethod
     def msgbus() -> MessageBus:
         return MessageBus(
             trader_id=TestIdStubs.trader_id(),
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/test_kit/stubs/config.py` & `nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/config.py`

 * *Files 2% similar despite different names*

```diff
@@ -21,15 +21,16 @@
 from nautilus_trader.config import BacktestVenueConfig
 from nautilus_trader.config import ExecEngineConfig
 from nautilus_trader.config import ImportableStrategyConfig
 from nautilus_trader.config import LoggingConfig
 from nautilus_trader.config import RiskEngineConfig
 from nautilus_trader.config import StreamingConfig
 from nautilus_trader.core.data import Data
-from nautilus_trader.model.data.tick import QuoteTick
+from nautilus_trader.model.data import QuoteTick
+from nautilus_trader.model.identifiers import InstrumentId
 from nautilus_trader.persistence.catalog.parquet import ParquetDataCatalog
 from nautilus_trader.test_kit.providers import TestInstrumentProvider
 from nautilus_trader.test_kit.stubs.identifiers import TestIdStubs
 
 
 AAPL_US = TestInstrumentProvider.aapl_equity()
 
@@ -52,15 +53,17 @@
             account_type="CASH",
             base_currency="USD",
             starting_balances=["10000 USD"],
             book_type="L2_MBP",
         )
 
     @staticmethod
-    def order_book_imbalance(instrument_id=None) -> ImportableStrategyConfig:
+    def order_book_imbalance(
+        instrument_id: Optional[InstrumentId] = None,
+    ) -> ImportableStrategyConfig:
         return ImportableStrategyConfig(
             strategy_path="nautilus_trader.examples.strategies.orderbook_imbalance:OrderBookImbalance",
             config_path="nautilus_trader.examples.strategies.orderbook_imbalance:OrderBookImbalanceConfig",
             config={
                 "instrument_id": instrument_id or AAPL_US,
                 "max_trade_size": 50,
             },
@@ -91,18 +94,18 @@
                 },
             ),
         ]
 
     @staticmethod
     def backtest_engine_config(
         log_level="INFO",
-        bypass_logging=True,
-        bypass_risk=False,
-        allow_cash_position=True,
-        persist=False,
+        bypass_logging: bool = True,
+        bypass_risk: bool = False,
+        allow_cash_position: bool = True,
+        persist: bool = False,
         catalog: Optional[ParquetDataCatalog] = None,
         strategies: Optional[list[ImportableStrategyConfig]] = None,
     ) -> BacktestEngineConfig:
         if persist:
             assert catalog is not None, "If `persist=True`, must pass `catalog`"
         return BacktestEngineConfig(
             logging=LoggingConfig(log_level=log_level, bypass_logging=bypass_logging),
@@ -121,15 +124,15 @@
             base_currency="USD",
             starting_balances=["1000000 USD"],
         )
 
     @staticmethod
     def backtest_data_config(
         catalog: ParquetDataCatalog,
-        data_cls=QuoteTick,
+        data_cls: Data = QuoteTick,
         instrument_id: Optional[str] = None,
     ) -> BacktestDataConfig:
         return BacktestDataConfig(
             data_cls=data_cls.fully_qualified_name(),
             catalog_path=str(catalog.path),
             catalog_fs_protocol=catalog.fs_protocol,
             instrument_id=instrument_id,
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/test_kit/stubs/events.py` & `nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/events.py`

 * *Files 5% similar despite different names*

```diff
@@ -12,47 +12,52 @@
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from decimal import Decimal
 from typing import Optional
 
+from nautilus_trader.accounting.accounts.base import Account
 from nautilus_trader.common.enums import ComponentState
 from nautilus_trader.common.messages import ComponentStateChanged
 from nautilus_trader.common.messages import TradingStateChanged
 from nautilus_trader.core.uuid import UUID4
 from nautilus_trader.model.currencies import GBP
 from nautilus_trader.model.currencies import USD
 from nautilus_trader.model.enums import AccountType
 from nautilus_trader.model.enums import LiquiditySide
 from nautilus_trader.model.enums import TradingState
-from nautilus_trader.model.events.account import AccountState
-from nautilus_trader.model.events.order import OrderAccepted
-from nautilus_trader.model.events.order import OrderCanceled
-from nautilus_trader.model.events.order import OrderExpired
-from nautilus_trader.model.events.order import OrderFilled
-from nautilus_trader.model.events.order import OrderPendingCancel
-from nautilus_trader.model.events.order import OrderPendingUpdate
-from nautilus_trader.model.events.order import OrderRejected
-from nautilus_trader.model.events.order import OrderSubmitted
-from nautilus_trader.model.events.order import OrderTriggered
-from nautilus_trader.model.events.order import OrderUpdated
-from nautilus_trader.model.events.position import PositionChanged
-from nautilus_trader.model.events.position import PositionClosed
-from nautilus_trader.model.events.position import PositionOpened
+from nautilus_trader.model.events import AccountState
+from nautilus_trader.model.events import OrderAccepted
+from nautilus_trader.model.events import OrderCanceled
+from nautilus_trader.model.events import OrderExpired
+from nautilus_trader.model.events import OrderFilled
+from nautilus_trader.model.events import OrderPendingCancel
+from nautilus_trader.model.events import OrderPendingUpdate
+from nautilus_trader.model.events import OrderRejected
+from nautilus_trader.model.events import OrderSubmitted
+from nautilus_trader.model.events import OrderTriggered
+from nautilus_trader.model.events import OrderUpdated
+from nautilus_trader.model.events import PositionChanged
+from nautilus_trader.model.events import PositionClosed
+from nautilus_trader.model.events import PositionOpened
 from nautilus_trader.model.identifiers import AccountId
 from nautilus_trader.model.identifiers import ComponentId
+from nautilus_trader.model.identifiers import PositionId
+from nautilus_trader.model.identifiers import StrategyId
 from nautilus_trader.model.identifiers import TradeId
 from nautilus_trader.model.identifiers import VenueOrderId
+from nautilus_trader.model.instruments import Instrument
 from nautilus_trader.model.objects import AccountBalance
 from nautilus_trader.model.objects import MarginBalance
 from nautilus_trader.model.objects import Money
 from nautilus_trader.model.objects import Price
 from nautilus_trader.model.objects import Quantity
 from nautilus_trader.model.orders import Order
+from nautilus_trader.model.position import Position
 from nautilus_trader.test_kit.stubs.identifiers import TestIdStubs
 
 
 class TestEventStubs:
     @staticmethod
     def component_state_changed() -> ComponentStateChanged:
         return ComponentStateChanged(
@@ -74,15 +79,15 @@
             config={"max_order_submit_rate": "100/00:00:01"},
             event_id=UUID4(),
             ts_event=0,
             ts_init=0,
         )
 
     @staticmethod
-    def cash_account_state(account_id=None) -> AccountState:
+    def cash_account_state(account_id: Optional[AccountId] = None) -> AccountState:
         return AccountState(
             account_id=account_id or TestIdStubs.account_id(),
             account_type=AccountType.CASH,
             base_currency=USD,
             reported=True,  # reported
             balances=[
                 AccountBalance(
@@ -95,15 +100,15 @@
             info={},
             event_id=UUID4(),
             ts_event=0,
             ts_init=0,
         )
 
     @staticmethod
-    def margin_account_state(account_id=None) -> AccountState:
+    def margin_account_state(account_id: Optional[AccountId] = None) -> AccountState:
         return AccountState(
             account_id=account_id or TestIdStubs.account_id(),
             account_type=AccountType.MARGIN,
             base_currency=USD,
             reported=True,  # reported
             balances=[
                 AccountBalance(
@@ -122,15 +127,15 @@
             info={},
             event_id=UUID4(),
             ts_event=0,
             ts_init=0,
         )
 
     @staticmethod
-    def betting_account_state(account_id=None) -> AccountState:
+    def betting_account_state(account_id: Optional[AccountId] = None) -> AccountState:
         return AccountState(
             account_id=account_id or TestIdStubs.account_id(),
             account_type=AccountType.BETTING,
             base_currency=GBP,
             reported=False,  # reported
             balances=[
                 AccountBalance(
@@ -159,58 +164,65 @@
             account_id=account_id or TestIdStubs.account_id(),
             ts_event=0,
             event_id=UUID4(),
             ts_init=0,
         )
 
     @staticmethod
-    def order_accepted(order, account_id=None, venue_order_id=None) -> OrderAccepted:
+    def order_accepted(
+        order: Order,
+        account_id: Optional[AccountId] = None,
+        venue_order_id: Optional[VenueOrderId] = None,
+    ) -> OrderAccepted:
         return OrderAccepted(
             trader_id=order.trader_id,
             strategy_id=order.strategy_id,
             instrument_id=order.instrument_id,
             client_order_id=order.client_order_id,
             venue_order_id=venue_order_id or TestIdStubs.venue_order_id(),
             account_id=account_id or TestIdStubs.account_id(),
             ts_event=0,
             event_id=UUID4(),
             ts_init=0,
         )
 
     @staticmethod
-    def order_rejected(order, account_id=None) -> OrderRejected:
+    def order_rejected(
+        order: Order,
+        account_id: Optional[AccountId] = None,
+    ) -> OrderRejected:
         return OrderRejected(
             trader_id=order.trader_id,
             strategy_id=order.strategy_id,
             instrument_id=order.instrument_id,
             client_order_id=order.client_order_id,
             account_id=account_id or TestIdStubs.account_id(),
             reason="ORDER_REJECTED",
             ts_event=0,
             event_id=UUID4(),
             ts_init=0,
         )
 
     @staticmethod
-    def order_pending_update(order) -> OrderPendingUpdate:
+    def order_pending_update(order: Order) -> OrderPendingUpdate:
         return OrderPendingUpdate(
             trader_id=order.trader_id,
             strategy_id=order.strategy_id,
             instrument_id=order.instrument_id,
             client_order_id=order.client_order_id,
             venue_order_id=order.venue_order_id,
             account_id=order.account_id,
             ts_event=0,
             event_id=UUID4(),
             ts_init=0,
         )
 
     @staticmethod
     def order_updated(
-        order,
+        order: Order,
         quantity: Optional[Quantity] = None,
         price: Optional[Price] = None,
         trigger_price: Optional[Price] = None,
     ) -> OrderUpdated:
         return OrderUpdated(
             trader_id=order.trader_id,
             strategy_id=order.strategy_id,
@@ -223,41 +235,41 @@
             price=price,
             trigger_price=trigger_price,
             ts_init=0,
             ts_event=0,
         )
 
     @staticmethod
-    def order_pending_cancel(order) -> OrderPendingCancel:
+    def order_pending_cancel(order: Order) -> OrderPendingCancel:
         return OrderPendingCancel(
             trader_id=order.trader_id,
             strategy_id=order.strategy_id,
             instrument_id=order.instrument_id,
             client_order_id=order.client_order_id,
             venue_order_id=order.venue_order_id,
             account_id=order.account_id,
             ts_event=0,
             event_id=UUID4(),
             ts_init=0,
         )
 
     @staticmethod
     def order_filled(
-        order,
-        instrument,
-        strategy_id=None,
-        account_id=None,
-        venue_order_id=None,
-        trade_id=None,
-        position_id=None,
-        last_qty=None,
-        last_px=None,
-        liquidity_side=LiquiditySide.TAKER,
-        ts_filled_ns=0,
-        account=None,
+        order: Order,
+        instrument: Instrument,
+        strategy_id: Optional[StrategyId] = None,
+        account_id: Optional[AccountId] = None,
+        venue_order_id: Optional[VenueOrderId] = None,
+        trade_id: Optional[TradeId] = None,
+        position_id: Optional[PositionId] = None,
+        last_qty: Optional[Quantity] = None,
+        last_px: Optional[Price] = None,
+        liquidity_side: LiquiditySide = LiquiditySide.TAKER,
+        ts_filled_ns: int = 0,
+        account: Optional[Account] = None,
     ) -> OrderFilled:
         if strategy_id is None:
             strategy_id = order.strategy_id
         if account_id is None:
             account_id = order.account_id
             if account_id is None:
                 account_id = TestIdStubs.account_id()
@@ -268,17 +280,19 @@
         if position_id is None:
             position_id = order.position_id
         if last_px is None:
             last_px = Price.from_str(f"{1:.{instrument.price_precision}f}")
         if last_qty is None:
             last_qty = order.quantity
         if account is None:
+            # Causes circular import if moved to the top
             from nautilus_trader.test_kit.stubs.execution import TestExecStubs
 
             account = TestExecStubs.cash_account()
+        assert account is not None  # Type checking
 
         commission = account.calculate_commission(
             instrument=instrument,
             last_qty=order.quantity,
             last_px=last_px,
             liquidity_side=liquidity_side,
         )
@@ -301,74 +315,74 @@
             liquidity_side=liquidity_side,
             ts_event=ts_filled_ns,
             event_id=UUID4(),
             ts_init=0,
         )
 
     @staticmethod
-    def order_canceled(order) -> OrderCanceled:
+    def order_canceled(order: Order) -> OrderCanceled:
         return OrderCanceled(
             trader_id=order.trader_id,
             strategy_id=order.strategy_id,
             instrument_id=order.instrument_id,
             client_order_id=order.client_order_id,
             venue_order_id=order.venue_order_id,
             account_id=TestIdStubs.account_id(),
             ts_event=0,
             event_id=UUID4(),
             ts_init=0,
         )
 
     @staticmethod
-    def order_expired(order) -> OrderExpired:
+    def order_expired(order: Order) -> OrderExpired:
         return OrderExpired(
             trader_id=order.trader_id,
             strategy_id=order.strategy_id,
             instrument_id=order.instrument_id,
             client_order_id=order.client_order_id,
             venue_order_id=order.venue_order_id,
             account_id=TestIdStubs.account_id(),
             ts_event=0,
             event_id=UUID4(),
             ts_init=0,
         )
 
     @staticmethod
-    def order_triggered(order) -> OrderTriggered:
+    def order_triggered(order: Order) -> OrderTriggered:
         return OrderTriggered(
             trader_id=order.trader_id,
             strategy_id=order.strategy_id,
             instrument_id=order.instrument_id,
             client_order_id=order.client_order_id,
             venue_order_id=order.venue_order_id,
             account_id=TestIdStubs.account_id(),
             ts_event=0,
             event_id=UUID4(),
             ts_init=0,
         )
 
     @staticmethod
-    def position_opened(position) -> PositionOpened:
+    def position_opened(position: Position) -> PositionOpened:
         return PositionOpened.create(
             position=position,
             fill=position.last_event,
             event_id=UUID4(),
             ts_init=0,
         )
 
     @staticmethod
-    def position_changed(position) -> PositionChanged:
+    def position_changed(position: Position) -> PositionChanged:
         return PositionChanged.create(
             position=position,
             fill=position.last_event,
             event_id=UUID4(),
             ts_init=0,
         )
 
     @staticmethod
-    def position_closed(position) -> PositionClosed:
+    def position_closed(position: Position) -> PositionClosed:
         return PositionClosed.create(
             position=position,
             fill=position.last_event,
             event_id=UUID4(),
             ts_init=0,
         )
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/test_kit/stubs/execution.py` & `nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/execution.py`

 * *Files 22% similar despite different names*

```diff
@@ -15,30 +15,36 @@
 
 from typing import Optional
 
 from nautilus_trader.accounting.accounts.betting import BettingAccount
 from nautilus_trader.accounting.accounts.cash import CashAccount
 from nautilus_trader.accounting.accounts.margin import MarginAccount
 from nautilus_trader.accounting.factory import AccountFactory
+from nautilus_trader.adapters.interactive_brokers.common import IBOrderTags
 from nautilus_trader.core.datetime import dt_to_unix_nanos
+from nautilus_trader.core.uuid import UUID4
 from nautilus_trader.model.enums import ContingencyType
 from nautilus_trader.model.enums import OrderSide
 from nautilus_trader.model.enums import TimeInForce
+from nautilus_trader.model.enums import TriggerType
 from nautilus_trader.model.identifiers import AccountId
 from nautilus_trader.model.identifiers import ClientOrderId
 from nautilus_trader.model.identifiers import InstrumentId
+from nautilus_trader.model.identifiers import OrderListId
 from nautilus_trader.model.identifiers import StrategyId
 from nautilus_trader.model.identifiers import TradeId
 from nautilus_trader.model.identifiers import VenueOrderId
 from nautilus_trader.model.instruments import Instrument
 from nautilus_trader.model.objects import Price
 from nautilus_trader.model.objects import Quantity
 from nautilus_trader.model.orders import LimitOrder
 from nautilus_trader.model.orders import MarketOrder
 from nautilus_trader.model.orders import Order
+from nautilus_trader.model.orders import OrderList
+from nautilus_trader.model.orders import StopMarketOrder
 from nautilus_trader.test_kit.stubs.events import TestEventStubs
 from nautilus_trader.test_kit.stubs.identifiers import TestIdStubs
 
 
 class TestExecStubs:
     @staticmethod
     def cash_account(account_id: Optional[AccountId] = None) -> CashAccount:
@@ -65,14 +71,15 @@
         price=None,
         quantity=None,
         time_in_force=None,
         trader_id: Optional[TradeId] = None,
         strategy_id: Optional[StrategyId] = None,
         client_order_id: Optional[ClientOrderId] = None,
         expire_time=None,
+        tags=None,
     ) -> LimitOrder:
         return LimitOrder(
             trader_id=trader_id or TestIdStubs.trader_id(),
             strategy_id=strategy_id or TestIdStubs.strategy_id(),
             instrument_id=instrument_id or TestIdStubs.audusd_id(),
             client_order_id=client_order_id or TestIdStubs.client_order_id(),
             order_side=order_side or OrderSide.BUY,
@@ -85,17 +92,71 @@
             post_only=False,
             reduce_only=False,
             display_qty=None,
             contingency_type=ContingencyType.NO_CONTINGENCY,
             order_list_id=None,
             linked_order_ids=None,
             parent_order_id=None,
-            tags=None,
+            tags=tags,
         )
 
+    def limit_with_stop_market(
+        instrument_id=None,
+        order_side=None,
+        price=None,
+        quantity=None,
+        time_in_force=None,
+        trader_id: Optional[TradeId] = None,
+        strategy_id: Optional[StrategyId] = None,
+        order_list_id: Optional[OrderListId] = None,
+        entry_client_order_id: Optional[ClientOrderId] = None,
+        sl_client_order_id: Optional[ClientOrderId] = None,
+        sl_trigger_price=None,
+        expire_time=None,
+        tags=None,
+    ):
+        entry_order = LimitOrder(
+            trader_id=trader_id or TestIdStubs.trader_id(),
+            strategy_id=strategy_id or TestIdStubs.strategy_id(),
+            instrument_id=instrument_id or TestIdStubs.audusd_id(),
+            client_order_id=entry_client_order_id or TestIdStubs.client_order_id(1),
+            order_side=order_side or OrderSide.BUY,
+            quantity=quantity or Quantity.from_str("100"),
+            price=price or Price.from_str("55.0"),
+            time_in_force=time_in_force or TimeInForce.GTC,
+            expire_time_ns=0 if expire_time is None else dt_to_unix_nanos(expire_time),
+            init_id=TestIdStubs.uuid(),
+            ts_init=0,
+            post_only=False,
+            reduce_only=False,
+            display_qty=None,
+            contingency_type=ContingencyType.OTO,
+            order_list_id=order_list_id or TestIdStubs.order_list_id(),
+            linked_order_ids=[sl_client_order_id or TestIdStubs.client_order_id(2)],
+            parent_order_id=None,
+            tags=tags,
+        )
+        sl_order = StopMarketOrder(
+            trader_id=trader_id or TestIdStubs.trader_id(),
+            strategy_id=strategy_id or TestIdStubs.strategy_id(),
+            instrument_id=instrument_id or TestIdStubs.audusd_id(),
+            client_order_id=sl_client_order_id or TestIdStubs.client_order_id(2),
+            order_side=Order.opposite_side(entry_order.side),
+            quantity=entry_order.quantity,
+            trigger_price=sl_trigger_price or Price.from_str("50.0"),
+            trigger_type=TriggerType.MID_POINT,
+            init_id=UUID4(),
+            ts_init=0,
+            time_in_force=TimeInForce.GTC,
+            order_list_id=order_list_id or TestIdStubs.order_list_id(),
+            parent_order_id=entry_order.client_order_id,
+            tags=IBOrderTags(outsideRth=True).value,
+        )
+        return OrderList(order_list_id or TestIdStubs.order_list_id(), [entry_order, sl_order])
+
     @staticmethod
     def market_order(
         instrument_id=None,
         order_side=None,
         quantity=None,
         trader_id: Optional[TradeId] = None,
         strategy_id: Optional[StrategyId] = None,
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/test_kit/stubs/identifiers.py` & `nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/identifiers.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,14 +13,15 @@
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from nautilus_trader.core.uuid import UUID4
 from nautilus_trader.model.identifiers import AccountId
 from nautilus_trader.model.identifiers import ClientOrderId
 from nautilus_trader.model.identifiers import InstrumentId
+from nautilus_trader.model.identifiers import OrderListId
 from nautilus_trader.model.identifiers import PositionId
 from nautilus_trader.model.identifiers import StrategyId
 from nautilus_trader.model.identifiers import Symbol
 from nautilus_trader.model.identifiers import TradeId
 from nautilus_trader.model.identifiers import TraderId
 from nautilus_trader.model.identifiers import Venue
 from nautilus_trader.model.identifiers import VenueOrderId
@@ -82,16 +83,20 @@
         return betfair_instrument_id(
             market_id="1.179082386",
             selection_id="50214",
             selection_handicap=None,
         )
 
     @staticmethod
-    def client_order_id() -> ClientOrderId:
-        return ClientOrderId("O-20210410-022422-001-001-1")
+    def client_order_id(counter: int = 1) -> ClientOrderId:
+        return ClientOrderId(f"O-20210410-022422-001-001-{counter}")
+
+    @staticmethod
+    def order_list_id(counter: int = 1) -> OrderListId:
+        return OrderListId(f"OL-20210410-022422-001-001-{counter}")
 
     @staticmethod
     def venue_order_id() -> VenueOrderId:
         return VenueOrderId("1")
 
     @staticmethod
     def trade_id() -> TradeId:
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/test_kit/stubs/persistence.py` & `nautilus_trader-1.175.0/nautilus_trader/test_kit/stubs/persistence.py`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/trading/filters.pxd` & `nautilus_trader-1.175.0/nautilus_trader/trading/filters.pxd`

 * *Files 3% similar despite different names*

```diff
@@ -10,14 +10,15 @@
 #  distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions and
 #  limitations under the License.
 # -------------------------------------------------------------------------------------------------
 
 from cpython.datetime cimport datetime
+from libc.stdint cimport uint64_t
 
 from nautilus_trader.core.data cimport Data
 from nautilus_trader.model.currency cimport Currency
 
 
 cdef class ForexSessionFilter:
     cdef object _tz_sydney
@@ -29,14 +30,17 @@
     cpdef datetime next_start(self, session, datetime time_now)
     cpdef datetime prev_start(self, session, datetime time_now)
     cpdef datetime next_end(self, session, datetime time_now)
     cpdef datetime prev_end(self, session, datetime time_now)
 
 
 cdef class NewsEvent(Data):
+    cdef uint64_t _ts_event
+    cdef uint64_t _ts_init
+
     cdef readonly object impact
     """The expected news impact.\n\n:returns: `Enum`"""
     cdef readonly str name
     """The descriptive name of the news event.\n\n:returns: `str`"""
     cdef readonly Currency currency
     """The currency affected by the news event.\n\n:returns: `Currency`"""
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/trading/filters.pyx` & `nautilus_trader-1.175.0/nautilus_trader/trading/filters.pyx`

 * *Files 2% similar despite different names*

```diff
@@ -349,19 +349,27 @@
         self,
         impact: NewsImpact,
         str name,
         Currency currency,
         uint64_t ts_event,
         uint64_t ts_init,
     ):
-        super().__init__(ts_event, ts_init)
-
         self.impact = impact
         self.name = name
         self.currency = currency
+        self._ts_event = ts_event
+        self._ts_init = ts_init
+
+    @property
+    def ts_event(self) -> int:
+        return self._ts_event
+
+    @property
+    def ts_init(self) -> int:
+        return self._ts_init
 
 
 cdef class EconomicNewsEventFilter:
     """
     Provides methods to help filter trading strategy rules based on economic news events.
 
     Parameters
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/trading/strategy.pxd` & `nautilus_trader-1.175.0/nautilus_trader/trading/strategy.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/trading/strategy.pyx` & `nautilus_trader-1.175.0/nautilus_trader/trading/strategy.pyx`

 * *Files 0% similar despite different names*

```diff
@@ -938,14 +938,15 @@
         # Create closing order
         cdef MarketOrder order = self.order_factory.market(
             instrument_id=position.instrument_id,
             order_side=Order.closing_side_c(position.side),
             quantity=position.quantity,
             time_in_force=TimeInForce.GTC,
             reduce_only=True,
+            quote_quantity=False,
             exec_algorithm_id=None,
             exec_algorithm_params=None,
             tags=tags,
         )
 
         self.submit_order(order, position_id=position.id, client_id=client_id)
```

### Comparing `nautilus_trader-1.174.0/nautilus_trader/trading/trader.pxd` & `nautilus_trader-1.175.0/nautilus_trader/trading/trader.pxd`

 * *Files identical despite different names*

### Comparing `nautilus_trader-1.174.0/nautilus_trader/trading/trader.pyx` & `nautilus_trader-1.175.0/nautilus_trader/trading/trader.pyx`

 * *Files 1% similar despite different names*

```diff
@@ -536,14 +536,15 @@
             self._log.error("Cannot clear the actors of a running trader.")
             return
 
         for actor in self._actors:
             actor.dispose()
 
         self._actors.clear()
+        self._log.info(f"Cleared all actors.")
 
     cpdef void clear_strategies(self):
         """
         Dispose and clear all strategies held by the trader.
 
         Raises
         ------
@@ -555,14 +556,15 @@
             self._log.error("Cannot clear the strategies of a running trader.")
             return
 
         for strategy in self._strategies:
             strategy.dispose()
 
         self._strategies.clear()
+        self._log.info(f"Cleared all trading strategies.")
 
     cpdef void clear_exec_algorithms(self):
         """
         Dispose and clear all execution algorithms held by the trader.
 
         Raises
         ------
@@ -574,14 +576,15 @@
             self._log.error("Cannot clear the execution algorithm of a running trader.")
             return
 
         for exec_algorithm in self._exec_algorithms:
             exec_algorithm.dispose()
 
         self._exec_algorithms.clear()
+        self._log.info(f"Cleared all execution algorithms.")
 
     cpdef void subscribe(self, str topic, handler: Callable[[Any], None]):
         """
         Subscribe to the given message topic with the given callback handler.
 
         Parameters
         ----------
```

### Comparing `nautilus_trader-1.174.0/pyproject.toml` & `nautilus_trader-1.175.0/pyproject.toml`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 [tool.poetry]
 name = "nautilus_trader"
-version = "1.174.0"
+version = "1.175.0"
 description = "A high-performance algorithmic trading platform and event-driven backtester"
 authors = ["Nautech Systems <info@nautechsystems.io>"]
 license = "LGPL-3.0-or-later"
 readme = "README.md"
 homepage = "https://nautilustrader.io"
 repository = "https://github.com/nautechsystems/nautilus_trader"
 classifiers = [
@@ -28,78 +28,78 @@
     { path = "nautilus_trader/**/*.so", format = "wheel" },
     { path = "nautilus_trader/**/*.pyd", format = "wheel" },
 ]
 
 [build-system]
 requires = [
     "setuptools",
-    "poetry-core>=1.5.2",
+    "poetry-core>=1.6.1",
     "numpy>=1.24.3",
-    "Cython==3.0.0b2",
+    "Cython==3.0.0b3",
 ]
 build-backend = "poetry.core.masonry.api"
 
 [tool.poetry.build]
 script = "build.py"
 generate-setup-file = false
 
 [tool.poetry.dependencies]
 python = ">=3.9,<3.12"
-cython = "==3.0.0b2"
+cython = "==3.0.0b3"
 aiodns = "^3.0.0"
 aiohttp = "^3.8.4"
 click = "^8.1.3"
 frozendict = "^2.3.8"
 fsspec = ">=2022.5.0"
-msgspec = "^0.14.2"
+msgspec = "^0.15.1"
 numpy = "^1.24.3"
-pandas = "^1.5.3"
+pandas = "^2.0.2"
 psutil = "^5.9.5"
-pyarrow = "^12.0.0"
+pyarrow = "^12.0.1"
 pytz = "^2023.3.0"
-tabulate = "^0.9.0"
 toml = "^0.10.2"
 tqdm = "^4.65.0"
 uvloop = {version = "^0.17.0", markers = "sys_platform != 'win32'"}
 hiredis = {version = "^2.2.3", optional = true}
+# ibapi = {git = "https://github.com/nautechsystems/ibapi.git", optional = true}
 ib_insync = {version = "^0.9.85", optional = true}
 redis = {version = "^4.5.5", optional = true}
-docker = {version = "^6.1.2", optional = true}
-betfair_parser = {version = "==0.1.21", optional = true}
+docker = {version = "^6.1.3", optional = true}
+betfair_parser = {version = "0.2.6", optional = true}  # Pinned for stability
 
 [tool.poetry.extras]
 betfair = ["betfair_parser"]
 docker = ["docker"]
 ib = ["ib_insync"]
 redis = ["hiredis", "redis"]
 
 [tool.poetry.group.dev]
 optional = true
 
 [tool.poetry.group.dev.dependencies]
 black = "^23.3.0"
 mypy = "^1.3.0"
-pre-commit = "^3.3.2"
-ruff = "^0.0.269"
-types-pytz = "^2022.3.0"
+pre-commit = "^3.3.3"
+ruff = "^0.0.272"
+types-pytz = "^2023.3.0"
 types-redis = "^4.5.5"
 types-requests = "^2.29.0"
 types-toml = "^0.10.2"
 
 [tool.poetry.group.test]
 optional = true
 
 [tool.poetry.group.test.dependencies]
-coverage = "^7.2.5"
-pytest = "^7.3.1"
+coverage = "^7.2.7"
+pytest = "^7.3.2"
 pytest-aiohttp = "^1.0.4"
 pytest-asyncio = "^0.21.0"
 pytest-benchmark = "^4.0.0"
 pytest-cov = "4.0.0"
-pytest-mock = "^3.10.0"
+pytest-mock = "^3.11.1"
 pytest-xdist = { version = "^3.3.1", extras = ["psutil"] }
 
 [tool.poetry.group.docs]
 optional = true
 
 [tool.poetry.group.docs.dependencies]
 numpydoc = "^1.5.0"
@@ -232,19 +232,17 @@
     "venv",
 ]
 
 # Allow unused variables when underscore-prefixed.
 dummy-variable-rgx = "^(_+|(_+[a-zA-Z0-9_]*[a-zA-Z0-9]+?))$"
 
 [tool.ruff.isort]
-combine-as-imports = true
 force-single-line = true
 single-line-exclusions = ["typing"]
 lines-after-imports = 2
-split-on-trailing-comma = true
 
 [tool.ruff.mccabe]
 max-complexity = 10
 
 ##########################################################
 # Static analysis configs                                #
 ##########################################################
```

### Comparing `nautilus_trader-1.174.0/PKG-INFO` & `nautilus_trader-1.175.0/PKG-INFO`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: nautilus-trader
-Version: 1.174.0
+Version: 1.175.0
 Summary: A high-performance algorithmic trading platform and event-driven backtester
 Home-page: https://nautilustrader.io
 License: LGPL-3.0-or-later
 Author: Nautech Systems
 Author-email: info@nautechsystems.io
 Requires-Python: >=3.9,<3.12
 Classifier: Development Status :: 4 - Beta
@@ -24,30 +24,29 @@
 Classifier: Topic :: Software Development :: Libraries :: Python Modules
 Provides-Extra: betfair
 Provides-Extra: docker
 Provides-Extra: ib
 Provides-Extra: redis
 Requires-Dist: aiodns (>=3.0.0,<4.0.0)
 Requires-Dist: aiohttp (>=3.8.4,<4.0.0)
-Requires-Dist: betfair_parser (==0.1.21) ; extra == "betfair"
+Requires-Dist: betfair_parser (==0.2.6) ; extra == "betfair"
 Requires-Dist: click (>=8.1.3,<9.0.0)
-Requires-Dist: cython (==3.0.0b2)
-Requires-Dist: docker (>=6.1.2,<7.0.0) ; extra == "docker"
+Requires-Dist: cython (==3.0.0b3)
+Requires-Dist: docker (>=6.1.3,<7.0.0) ; extra == "docker"
 Requires-Dist: frozendict (>=2.3.8,<3.0.0)
 Requires-Dist: fsspec (>=2022.5.0)
 Requires-Dist: hiredis (>=2.2.3,<3.0.0) ; extra == "redis"
 Requires-Dist: ib_insync (>=0.9.85,<0.10.0) ; extra == "ib"
-Requires-Dist: msgspec (>=0.14.2,<0.15.0)
+Requires-Dist: msgspec (>=0.15.1,<0.16.0)
 Requires-Dist: numpy (>=1.24.3,<2.0.0)
-Requires-Dist: pandas (>=1.5.3,<2.0.0)
+Requires-Dist: pandas (>=2.0.2,<3.0.0)
 Requires-Dist: psutil (>=5.9.5,<6.0.0)
-Requires-Dist: pyarrow (>=12.0.0,<13.0.0)
+Requires-Dist: pyarrow (>=12.0.1,<13.0.0)
 Requires-Dist: pytz (>=2023.3.0,<2024.0.0)
 Requires-Dist: redis (>=4.5.5,<5.0.0) ; extra == "redis"
-Requires-Dist: tabulate (>=0.9.0,<0.10.0)
 Requires-Dist: toml (>=0.10.2,<0.11.0)
 Requires-Dist: tqdm (>=4.65.0,<5.0.0)
 Requires-Dist: uvloop (>=0.17.0,<0.18.0) ; sys_platform != "win32"
 Project-URL: Repository, https://github.com/nautechsystems/nautilus_trader
 Description-Content-Type: text/markdown
 
 # <img src="https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/_images/nautilus-trader-logo.png" width="500">
@@ -56,38 +55,38 @@
 [![codecov](https://codecov.io/gh/nautechsystems/nautilus_trader/branch/master/graph/badge.svg?token=DXO9QQI40H)](https://codecov.io/gh/nautechsystems/nautilus_trader)
 ![pythons](https://img.shields.io/pypi/pyversions/nautilus_trader)
 ![pypi-version](https://img.shields.io/pypi/v/nautilus_trader)
 ![pypi-format](https://img.shields.io/pypi/format/nautilus_trader?color=blue)
 [![Downloads](https://pepy.tech/badge/nautilus-trader)](https://pepy.tech/project/nautilus-trader)
 [![discord](https://img.shields.io/discord/924497682343550976?color=768AD4&label=discord)](https://discord.gg/AUWVs3XaCS)
 
-| Branch    | Version | Status |
-|:----------|:--------|:-------|
-| `master`  | ![version](https://img.shields.io/endpoint?url=https%3A%2F%2Fraw.githubusercontent.com%2Fnautechsystems%2Fnautilus_trader%2Fmaster%2Fversion.json) | [![build](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml/badge.svg?branch=master)](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml) |
+| Branch    | Version                                                                                                                                             | Status                                                                                                                                                                                            |
+| :-------- | :-------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
+| `master`  | ![version](https://img.shields.io/endpoint?url=https%3A%2F%2Fraw.githubusercontent.com%2Fnautechsystems%2Fnautilus_trader%2Fmaster%2Fversion.json)  | [![build](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml/badge.svg?branch=master)](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml)  |
 | `develop` | ![version](https://img.shields.io/endpoint?url=https%3A%2F%2Fraw.githubusercontent.com%2Fnautechsystems%2Fnautilus_trader%2Fdevelop%2Fversion.json) | [![build](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml/badge.svg?branch=develop)](https://github.com/nautechsystems/nautilus_trader/actions/workflows/build.yml) |
 
 | Platform           | Rust    | Python |
-|:-------------------|:--------|:-------|
-| `Linux (x86_64)`   | 1.69.0+ | 3.9+   |
-| `macOS (x86_64)`   | 1.69.0+ | 3.9+   |
-| `macOS (arm64)`    | 1.69.0+ | 3.9+   |
-| `Windows (x86_64)` | 1.69.0+ | 3.9+   |
+| :----------------- | :------ | :----- |
+| `Linux (x86_64)`   | 1.70.0+ | 3.9+   |
+| `macOS (x86_64)`   | 1.70.0+ | 3.9+   |
+| `macOS (arm64)`    | 1.70.0+ | 3.9+   |
+| `Windows (x86_64)` | 1.70.0+ | 3.9+   |
 
 - **Website:** https://nautilustrader.io
 - **Docs:** https://docs.nautilustrader.io
 - **Support:** [support@nautilustrader.io](mailto:support@nautilustrader.io)
 
 ## Introduction
 
 NautilusTrader is an open-source, high-performance, production-grade algorithmic trading platform,
 providing quantitative traders with the ability to backtest portfolios of automated trading strategies
 on historical data with an event-driven engine, and also deploy those same strategies live, with no code changes.
 
-The platform is 'AI-first', designed to develop and deploy algorithmic trading strategies within a highly performant 
-and robust Python native environment. This helps to address the parity challenge of keeping the Python research/backtest 
+The platform is 'AI-first', designed to develop and deploy algorithmic trading strategies within a highly performant
+and robust Python native environment. This helps to address the parity challenge of keeping the Python research/backtest
 environment, consistent with the production live trading environment.
 
 NautilusTraders design, architecture and implementation philosophy holds software correctness and safety at the
 highest level, with the aim of supporting Python native, mission-critical, trading system backtesting
 and live deployment workloads.
 
 The platform is also universal and asset class agnostic - with any REST, WebSocket or FIX API able to be integrated via modular
@@ -104,18 +103,19 @@
 - **Customizable** - Add user defined custom components, or assemble entire systems from scratch leveraging the cache and message bus
 - **Backtesting** - Run with multiple venues, instruments and strategies simultaneously using historical quote tick, trade tick, bar, order book and custom data with nanosecond resolution
 - **Live** - Use identical strategy implementations between backtesting and live deployments
 - **Multi-venue** - Multiple venue capabilities facilitate market making and statistical arbitrage strategies
 - **AI Agent Training** - Backtest engine fast enough to be used to train AI trading agents (RL/ES)
 
 ![Alt text](https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/_images/nautilus-art.png?raw=true "nautilus")
-> *nautilus - from ancient Greek 'sailor' and naus 'ship'.*
+
+> _nautilus - from ancient Greek 'sailor' and naus 'ship'._
 >
-> *The nautilus shell consists of modular chambers with a growth factor which approximates a logarithmic spiral.
-> The idea is that this can be translated to the aesthetics of design and architecture.*
+> _The nautilus shell consists of modular chambers with a growth factor which approximates a logarithmic spiral.
+> The idea is that this can be translated to the aesthetics of design and architecture._
 
 ## Why NautilusTrader?
 
 - **Highly performant event-driven Python** - native binary core components
 - **Parity between backtesting and live trading** - identical strategy code
 - **Reduced operational risk** - risk management functionality, logical correctness and type safety
 - **Highly extendable** - message bus, custom components and actors, custom data, custom adapters
@@ -123,15 +123,15 @@
 Traditionally, trading strategy research and backtesting might be conducted in Python (or other suitable language)
 using vectorized methods, with the strategy then needing to be reimplemented in a more event-drive way
 using C++, C#, Java or other statically typed language(s). The reasoning here is that vectorized backtesting code cannot
 express the granular time and event dependent complexity of real-time trading, where compiled languages have
 proven to be more suitable due to their inherently higher performance, and type safety.
 
 One of the key advantages of NautilusTrader here, is that this reimplementation step is now circumvented - as the critical core components of the platform
-have all been written entirely in Rust or Cython. This means we're using the right tools for the job, where systems programming languages compile performant binaries, 
+have all been written entirely in Rust or Cython. This means we're using the right tools for the job, where systems programming languages compile performant binaries,
 with CPython C extension modules then able to offer a Python native environment, suitable for professional quantitative traders and trading firms.
 
 ## Why Python?
 
 Python was originally created decades ago as a simple scripting language with a clean straight
 forward syntax. It has since evolved into a fully fledged general purpose object-oriented
 programming language. Based on the TIOBE index, Python is currently the most popular programming language in the world.
@@ -164,15 +164,16 @@
 
 The project increasingly utilizes Rust for core performance-critical components. Python language binding is handled through
 Cython, with static libraries linked at compile-time before the wheel binaries are packaged, so a user
 does not need to have Rust installed to run NautilusTrader. In the future as more Rust code is introduced,
 [PyO3](https://pyo3.rs/latest) will be leveraged for easier Python bindings.
 
 This project makes the [Soundness Pledge](https://raphlinus.github.io/rust/2020/01/18/soundness-pledge.html):
-> The intent of this project is to be free of soundness bugs. 
+
+> The intent of this project is to be free of soundness bugs.
 > The developers will do their best to avoid them, and welcome help in analyzing and fixing them.
 
 ## Architecture (data flow)
 
 ![Architecture](https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/_images/architecture-overview.png?raw=true "architecture")
 
 ## Quality Attributes
@@ -186,93 +187,98 @@
 
 ## Integrations
 
 NautilusTrader is designed in a modular way to work with 'adapters' which provide
 connectivity to data publishers and/or trading venues - converting their raw API
 into a unified interface. The following integrations are currently supported:
 
-| Name                                                    | ID        | Type                    | Status                                              | Docs                                                              |
-|:--------------------------------------------------------|:----------|:------------------------|:----------------------------------------------------|:------------------------------------------------------------------|
-[Betfair](https://betfair.com)                            | `BETFAIR` | Sports Betting Exchange | ![status](https://img.shields.io/badge/beta-yellow) | [Guide](https://docs.nautilustrader.io/integrations/betfair.html) |
-[Binance](https://binance.com)                            | `BINANCE` | Crypto Exchange (CEX)   | ![status](https://img.shields.io/badge/beta-yellow) | [Guide](https://docs.nautilustrader.io/integrations/binance.html) |
-[Binance US](https://binance.us)                          | `BINANCE` | Crypto Exchange (CEX)   | ![status](https://img.shields.io/badge/beta-yellow) | [Guide](https://docs.nautilustrader.io/integrations/binance.html) |
-[Binance Futures](https://www.binance.com/en/futures)     | `BINANCE` | Crypto Exchange (CEX)   | ![status](https://img.shields.io/badge/beta-yellow) | [Guide](https://docs.nautilustrader.io/integrations/binance.html) |
-[Interactive Brokers](https://www.interactivebrokers.com) | `IB`      | Brokerage (multi-venue) | ![status](https://img.shields.io/badge/beta-yellow) | [Guide](https://docs.nautilustrader.io/integrations/ib.html)      |
+| Name                                                      | ID        | Type                    | Status                                              | Docs                                                              |
+| :-------------------------------------------------------- | :-------- | :---------------------- | :-------------------------------------------------- | :---------------------------------------------------------------- |
+| [Betfair](https://betfair.com)                            | `BETFAIR` | Sports Betting Exchange | ![status](https://img.shields.io/badge/beta-yellow) | [Guide](https://docs.nautilustrader.io/integrations/betfair.html) |
+| [Binance](https://binance.com)                            | `BINANCE` | Crypto Exchange (CEX)   | ![status](https://img.shields.io/badge/beta-yellow) | [Guide](https://docs.nautilustrader.io/integrations/binance.html) |
+| [Binance US](https://binance.us)                          | `BINANCE` | Crypto Exchange (CEX)   | ![status](https://img.shields.io/badge/beta-yellow) | [Guide](https://docs.nautilustrader.io/integrations/binance.html) |
+| [Binance Futures](https://www.binance.com/en/futures)     | `BINANCE` | Crypto Exchange (CEX)   | ![status](https://img.shields.io/badge/beta-yellow) | [Guide](https://docs.nautilustrader.io/integrations/binance.html) |
+| [Interactive Brokers](https://www.interactivebrokers.com) | `IB`      | Brokerage (multi-venue) | ![status](https://img.shields.io/badge/beta-yellow) | [Guide](https://docs.nautilustrader.io/integrations/ib.html)      |
 
 Refer to the [Integrations](https://docs.nautilustrader.io/integrations/index.html) documentation for further details.
 
 ## Installation
 
 ### From PyPI
 
 We recommend running the platform with the latest stable version of Python, and in a virtual environment to isolate the dependencies.
 
 To install the latest binary wheel from PyPI:
 
     pip install -U nautilus_trader
 
 ### From Source
+
 Installation from source requires the `Python.h` header file, which is included in development releases such as `python-dev`.
 You'll also need the latest stable `rustc` and `cargo` to compile the Rust libraries.
 
 For MacBook Pro M1/M2, make sure your Python installed using pyenv is configured with `--enable-shared`:
 
     PYTHON_CONFIGURE_OPTS="--enable-shared" pyenv install <python_version>
 
 See https://pyo3.rs/latest/getting_started#virtualenvs.
 
 It's possible to install from source using `pip` if you first install the build dependencies
 as specified in the `pyproject.toml`. However, we highly recommend installing using [poetry](https://python-poetry.org/) as below.
 
 1. Install [rustup](https://rustup.rs/) (the Rust toolchain installer):
+
    - Linux and macOS:
-       ```
-       curl https://sh.rustup.rs -sSf | sh
-       ```
+     ```
+     curl https://sh.rustup.rs -sSf | sh
+     ```
    - Windows:
-       - Download and install [`rustup-init.exe`](https://win.rustup.rs/x86_64)
-       - Install "Desktop development with C++" with [Build Tools for Visual Studio 2019](https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?sku=BuildTools&rel=16)
+     - Download and install [`rustup-init.exe`](https://win.rustup.rs/x86_64)
+     - Install "Desktop development with C++" with [Build Tools for Visual Studio 2019](https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?sku=BuildTools&rel=16)
 
 2. Enable `cargo` in the current shell:
+
    - Linux and macOS:
-       ```
-       source $HOME/.cargo/env
-       ```
+     ```
+     source $HOME/.cargo/env
+     ```
    - Windows:
      - Start a new PowerShell
 
 3. Install poetry (or follow the installation guide on their site):
 
-       curl -sSL https://install.python-poetry.org | python3 -
+   curl -sSL https://install.python-poetry.org | python3 -
 
 4. Clone the source with `git`, and install from the projects root directory:
 
-       git clone https://github.com/nautechsystems/nautilus_trader
-       cd nautilus_trader
-       poetry install --only main --all-extras
+   git clone https://github.com/nautechsystems/nautilus_trader
+   cd nautilus_trader
+   poetry install --only main --all-extras
 
 Refer to the [Installation Guide](https://docs.nautilustrader.io/getting_started/installation.html) for other options and further details.
 
 ## Versioning and releases
 
 NautilusTrader is currently following a bi-weekly beta release schedule.
 The API is becoming more stable, however breaking changes are still possible between releases.
 Documentation of these changes in the release notes are made on a best-effort basis.
 
 ### Branches
+
 - `master` branch will always reflect the source code for the latest released version
-- `develop` branch is normally very active with frequent commits and may contain experimental features. We aim to maintain a stable 
-passing build on this branch
+- `develop` branch is normally very active with frequent commits and may contain experimental features. We aim to maintain a stable
+  passing build on this branch
 
 The current roadmap has a goal of achieving a stable API for a `2.x` version. From this
 point we will follow a formal process for releases, with deprecation periods for any API changes.
 
 ## Makefile
 
 A `Makefile` is provided to automate most installation and build tasks for development. It provides the following targets:
+
 - `make install` -- Installs in `release` build mode with `main`, `dev` and `test` dependencies then installs the package using poetry (default)
 - `make install-debug` -- Same as `make install` but with `debug` build mode
 - `make install-just-deps` -- Installs just the `main`, `dev` and `test` dependencies (does not install package)
 - `make install-just-deps-all` -- Same as `make install-just-deps` and additionally installs `docs` dependencies
 - `make build` -- Runs the Cython build script in `release` build mode (default)
 - `make build-debug` -- Runs the Cython build script in `debug` build mode
 - `make clean` -- **CAUTION** Cleans all non-source artifacts from the repository
@@ -282,38 +288,44 @@
 - `make pytest` -- Runs all tests with `pytest` (except performance tests)
 - `make pytest-coverage` -- Same as `make pytest` and additionally runs with test coverage and produces a report
 
 ## Examples
 
 Indicators and strategies can be developed in both Python and Cython (although if performance and latency sensitivity are import we recommend Cython).
 The below are some examples of this:
+
 - [indicator](/examples/indicators/ema_python.py) example written in Python
 - [indicator](/nautilus_trader/indicators/) examples written in Cython
 - [strategy](/nautilus_trader/examples/strategies/) examples written in both Python and Cython
 - [backtest](/examples/backtest/) examples using a `BacktestEngine` directly
 
 ## Docker
 
 Docker containers are built using a base `python:3.10-slim` with the following image variant tags:
+
 - `nautilus_trader:latest` has the latest release version installed
 - `nautilus_trader:develop` has the head of the `develop` branch installed
 - `jupyterlab:develop` has the head of the `develop` branch installed along with `jupyterlab` and an
-example backtest notebook with accompanying data
+  example backtest notebook with accompanying data
 
 The container images can be pulled as follows:
 
-    docker pull ghcr.io/nautechsystems/<image_variant_tag>
+    docker pull ghcr.io/nautechsystems/<image_variant_tag> --platform linux/amd64
 
 You can launch the backtest example container by running:
 
-    docker pull ghcr.io/nautechsystems/jupyterlab:develop
+    docker pull ghcr.io/nautechsystems/jupyterlab:develop --platform linux/amd64
     docker run -p 8888:8888 ghcr.io/nautechsystems/jupyterlab:develop
 
-| :warning: WARNING                                                               |
-|:--------------------------------------------------------------------------------|
+Then open your browser at the following address:
+
+    http://127.0.0.1:8888/lab
+
+| :warning: WARNING |
+| :---------------- |
 
 **NautilusTrader currently exceeds the rate limit for Jupyter notebook logging (stdout output),
 this is why `log_level` in the examples is set to "ERROR". If you lower this level to see more
 logging then the notebook will hang during cell execution. A fix is currently
 being investigated which involves either raising the configured rate limits for
 Jupyter, or throttling the log flushing from Nautilus.**
 https://github.com/jupyterlab/jupyterlab/issues/12845
@@ -423,44 +435,45 @@
 ## Development
 
 We aim to provide the most pleasant developer experience possible for this hybrid codebase of Python, Cython and Rust.
 Refer to the [Developer Guide](https://docs.nautilustrader.io/developer_guide/index.html) for helpful information.
 
 ## Contributing
 
-Thank you for considering contributing to Nautilus Trader! We welcome any and all help to improve 
-the project. If you have an idea for an enhancement or a bug fix, the first step is to open an [issue](https://github.com/nautechsystems/nautilus_trader/issues) 
-on GitHub to discuss it with the team. This helps to ensure that your contribution will be 
+Thank you for considering contributing to Nautilus Trader! We welcome any and all help to improve
+the project. If you have an idea for an enhancement or a bug fix, the first step is to open an [issue](https://github.com/nautechsystems/nautilus_trader/issues)
+on GitHub to discuss it with the team. This helps to ensure that your contribution will be
 well-aligned with the goals of the project and avoids duplication of effort.
 
-Once you're ready to start working on your contribution, make sure to follow the guidelines 
-outlined in the [CONTRIBUTING.md](https://github.com/nautechsystems/nautilus_trader/blob/develop/CONTRIBUTING.md) file. This includes signing a Contributor License Agreement (CLA) 
+Once you're ready to start working on your contribution, make sure to follow the guidelines
+outlined in the [CONTRIBUTING.md](https://github.com/nautechsystems/nautilus_trader/blob/develop/CONTRIBUTING.md) file. This includes signing a Contributor License Agreement (CLA)
 to ensure that your contributions can be included in the project.
 
-Note that all pull requests should be made to the `develop` branch. This is where new features 
+Note that all pull requests should be made to the `develop` branch. This is where new features
 and improvements are integrated before being released to the public.
 
 Thank you again for your interest in Nautilus Trader! We look forward to reviewing your contributions and working with you to improve the project.
 
 ## Community
-Join our community of users and contributors on [Discord](https://discord.gg/AUWVs3XaCS) to chat 
-and stay up-to-date with the latest announcements and features of NautilusTrader. Whether you're a 
+
+Join our community of users and contributors on [Discord](https://discord.gg/AUWVs3XaCS) to chat
+and stay up-to-date with the latest announcements and features of NautilusTrader. Whether you're a
 developer looking to contribute or just want to learn more about the platform, all are welcome on our server.
 
 ## License
 
 The source code for NautilusTrader is available on GitHub under the [GNU Lesser General Public License v3.0](https://www.gnu.org/licenses/lgpl-3.0.en.html).
 Contributions to the project are welcome and require the completion of a standard Contributor License Agreement (CLA).
 
 ---
 
-NautilusTrader is developed and maintained by Nautech Systems, a technology 
-company specializing in the development of high-performance trading systems. 
-Although the project utilizes the Rust programming language and benefits from its ecosystem, 
-Nautech Systems is not affiliated with the Rust Foundation, and this project is not an official 
+NautilusTrader is developed and maintained by Nautech Systems, a technology
+company specializing in the development of high-performance trading systems.
+Although the project utilizes the Rust programming language and benefits from its ecosystem,
+Nautech Systems is not affiliated with the Rust Foundation, and this project is not an official
 work of the Rust Foundation.
 For more information, visit https://nautilustrader.io.
 
 Copyright (C) 2015-2023 Nautech Systems Pty Ltd. All rights reserved.
 
 ![nautechsystems](https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/_images/ns-logo.png?raw=true "nautechsystems")
 <img src="https://github.com/nautechsystems/nautilus_trader/blob/develop/docs/_images/ferris.png" width="128">
```

