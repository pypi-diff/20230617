# Comparing `tmp/mqt.ddsim-1.17.3.tar.gz` & `tmp/mqt.ddsim-1.18.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "mqt.ddsim-1.17.3.tar", last modified: Thu Jun 15 08:44:13 2023, max compression
+gzip compressed data, was "mqt.ddsim-1.18.0.tar", last modified: Sat Jun 17 10:29:15 2023, max compression
```

## Comparing `mqt.ddsim-1.17.3.tar` & `mqt.ddsim-1.18.0.tar`

### file list

```diff
@@ -1,3006 +1,1100 @@
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.958950 mqt.ddsim-1.17.3/
--rw-r--r--   0 runner    (1001) docker     (123)     2424 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/.clang-format
--rw-r--r--   0 runner    (1001) docker     (123)     2523 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/.clang-tidy
--rw-r--r--   0 runner    (1001) docker     (123)      125 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/.git_archival.txt
--rw-r--r--   0 runner    (1001) docker     (123)       32 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/.gitattributes
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.318947 mqt.ddsim-1.17.3/.github/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.318947 mqt.ddsim-1.17.3/.github/ISSUE_TEMPLATE/
--rw-r--r--   0 runner    (1001) docker     (123)     1878 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/.github/ISSUE_TEMPLATE/bug-report.yml
--rw-r--r--   0 runner    (1001) docker     (123)     1051 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/.github/ISSUE_TEMPLATE/feature-request.yml
--rw-r--r--   0 runner    (1001) docker     (123)      300 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/.github/codecov.yml
--rw-r--r--   0 runner    (1001) docker     (123)       68 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/.github/codeql-config.yml
--rw-r--r--   0 runner    (1001) docker     (123)      836 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/.github/dependabot.yml
--rw-r--r--   0 runner    (1001) docker     (123)     1063 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/.github/release-drafter.yml
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.318947 mqt.ddsim-1.17.3/.github/workflows/
--rw-r--r--   0 runner    (1001) docker     (123)     2884 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/.github/workflows/bindings.yml
--rw-r--r--   0 runner    (1001) docker     (123)     3125 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/.github/workflows/cmake.yml
--rw-r--r--   0 runner    (1001) docker     (123)     1629 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/.github/workflows/codeql.yml
--rw-r--r--   0 runner    (1001) docker     (123)     1162 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/.github/workflows/cpp-linter.yml
--rw-r--r--   0 runner    (1001) docker     (123)      467 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/.github/workflows/release-drafter.yml
--rw-r--r--   0 runner    (1001) docker     (123)      152 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/.gitignore
--rw-r--r--   0 runner    (1001) docker     (123)      391 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/.gitmodules
--rw-r--r--   0 runner    (1001) docker     (123)     2650 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/.pre-commit-config.yaml
--rw-r--r--   0 runner    (1001) docker     (123)      271 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/.readthedocs.yaml
--rw-r--r--   0 runner    (1001) docker     (123)     1572 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1122 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/LICENSE
--rw-r--r--   0 runner    (1001) docker     (123)     1404 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/MANIFEST.in
--rw-r--r--   0 runner    (1001) docker     (123)     7994 2023-06-15 08:44:13.958950 mqt.ddsim-1.17.3/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)     5149 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/README.md
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.318947 mqt.ddsim-1.17.3/apps/
--rw-r--r--   0 runner    (1001) docker     (123)     1207 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/apps/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)     4729 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/apps/frqi.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     7605 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/apps/noise_aware.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2466 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/apps/primebases.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    13747 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/apps/simple.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2087 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/apps/vectors.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.322947 mqt.ddsim-1.17.3/docs/
--rw-r--r--   0 runner    (1001) docker     (123)       16 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/docs/.gitignore
--rw-r--r--   0 runner    (1001) docker     (123)     6076 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/docs/Doxyfile
--rw-r--r--   0 runner    (1001) docker     (123)      638 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/docs/Makefile
--rw-r--r--   0 runner    (1001) docker     (123)      769 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/docs/make.bat
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.322947 mqt.ddsim-1.17.3/docs/source/
--rw-r--r--   0 runner    (1001) docker     (123)     6245 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/docs/source/Contributing.rst
--rw-r--r--   0 runner    (1001) docker     (123)     2944 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/docs/source/Development.rst
--rw-r--r--   0 runner    (1001) docker     (123)     1609 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/docs/source/FAQ.rst
--rw-r--r--   0 runner    (1001) docker     (123)     5572 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/docs/source/Installation.rst
--rw-r--r--   0 runner    (1001) docker     (123)       45 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/docs/source/Publications.rst
--rw-r--r--   0 runner    (1001) docker     (123)     3273 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/docs/source/Quickstart.rst
--rw-r--r--   0 runner    (1001) docker     (123)      636 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/docs/source/Simulators.rst
--rw-r--r--   0 runner    (1001) docker     (123)      910 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/docs/source/Support.rst
--rw-r--r--   0 runner    (1001) docker     (123)     9431 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/docs/source/Usage.ipynb
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.322947 mqt.ddsim-1.17.3/docs/source/_static/
--rw-r--r--   0 runner    (1001) docker     (123)     1391 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/docs/source/_static/custom.css
--rw-r--r--   0 runner    (1001) docker     (123)    61137 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/docs/source/_static/mqt_dark.png
--rw-r--r--   0 runner    (1001) docker     (123)    57266 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/docs/source/_static/mqt_light.png
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.322947 mqt.ddsim-1.17.3/docs/source/api/
--rw-r--r--   0 runner    (1001) docker     (123)      203 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/docs/source/api/Cpp.rst
--rw-r--r--   0 runner    (1001) docker     (123)     1890 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/docs/source/api/ddsim.rst
--rw-r--r--   0 runner    (1001) docker     (123)       74 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/docs/source/api/modules.rst
--rw-r--r--   0 runner    (1001) docker     (123)     2226 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/docs/source/conf.py
--rw-r--r--   0 runner    (1001) docker     (123)     1796 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/docs/source/index.rst
--rw-r--r--   0 runner    (1001) docker     (123)     7610 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/docs/source/refs.bib
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.326947 mqt.ddsim-1.17.3/docs/source/simulators/
--rw-r--r--   0 runner    (1001) docker     (123)     4218 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/docs/source/simulators/CircuitSimulator.rst
--rw-r--r--   0 runner    (1001) docker     (123)     2641 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/docs/source/simulators/HybridSchrodingerFeynman.rst
--rw-r--r--   0 runner    (1001) docker     (123)     4937 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/docs/source/simulators/NoiseAwareSimulator.rst
--rw-r--r--   0 runner    (1001) docker     (123)     5503 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/docs/source/simulators/SimulationPathFramework.rst
--rw-r--r--   0 runner    (1001) docker     (123)      491 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/docs/source/simulators/UnitarySimulator.rst
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.306947 mqt.ddsim-1.17.3/extern/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.326947 mqt.ddsim-1.17.3/extern/cxxopts/
--rw-r--r--   0 runner    (1001) docker     (123)      456 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/cxxopts/.clang-format
--rw-r--r--   0 runner    (1001) docker     (123)       42 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/extern/cxxopts/.git
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.282947 mqt.ddsim-1.17.3/extern/cxxopts/.github/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.326947 mqt.ddsim-1.17.3/extern/cxxopts/.github/workflows/
--rw-r--r--   0 runner    (1001) docker     (123)      394 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/cxxopts/.github/workflows/build.yml
--rw-r--r--   0 runner    (1001) docker     (123)      631 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/cxxopts/.github/workflows/cifuzz.yml
--rw-r--r--   0 runner    (1001) docker     (123)     2175 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/cxxopts/.github/workflows/cmake.yml
--rw-r--r--   0 runner    (1001) docker     (123)      751 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/cxxopts/.gitignore
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.330947 mqt.ddsim-1.17.3/extern/cxxopts/.tipi/
--rw-r--r--   0 runner    (1001) docker     (123)        3 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/cxxopts/.tipi/deps
--rw-r--r--   0 runner    (1001) docker     (123)        1 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/cxxopts/.tipi/opts
--rw-r--r--   0 runner    (1001) docker     (123)     2493 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/cxxopts/.travis.yml
--rw-r--r--   0 runner    (1001) docker     (123)      362 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/cxxopts/BUILD.bazel
--rw-r--r--   0 runner    (1001) docker     (123)     4340 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/cxxopts/CHANGELOG.md
--rw-r--r--   0 runner    (1001) docker     (123)     2996 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/cxxopts/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1232 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/cxxopts/INSTALL
--rw-r--r--   0 runner    (1001) docker     (123)     1055 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/cxxopts/LICENSE
--rw-r--r--   0 runner    (1001) docker     (123)     8511 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/cxxopts/README.md
--rw-r--r--   0 runner    (1001) docker     (123)      512 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/cxxopts/WORKSPACE
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.330947 mqt.ddsim-1.17.3/extern/cxxopts/cmake/
--rw-r--r--   0 runner    (1001) docker     (123)     7132 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/cxxopts/cmake/cxxopts.cmake
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.330947 mqt.ddsim-1.17.3/extern/cxxopts/include/
--rw-r--r--   0 runner    (1001) docker     (123)     1221 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/cxxopts/include/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)    57765 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/cxxopts/include/cxxopts.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.330947 mqt.ddsim-1.17.3/extern/cxxopts/packaging/
--rw-r--r--   0 runner    (1001) docker     (123)      114 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/cxxopts/packaging/cxxopts-config.cmake.in
--rw-r--r--   0 runner    (1001) docker     (123)      186 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/cxxopts/packaging/pkgconfig.pc.in
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.330947 mqt.ddsim-1.17.3/extern/cxxopts/src/
--rw-r--r--   0 runner    (1001) docker     (123)        8 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/cxxopts/src/.gitignore
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.330947 mqt.ddsim-1.17.3/extern/cxxopts/src/.tipi/
--rw-r--r--   0 runner    (1001) docker     (123)       32 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/cxxopts/src/.tipi/deps
--rw-r--r--   0 runner    (1001) docker     (123)     1221 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/cxxopts/src/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)     5916 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/cxxopts/src/example.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.330947 mqt.ddsim-1.17.3/extern/qfr/
--rwxr-xr-x   0 runner    (1001) docker     (123)     1267 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.290947 mqt.ddsim-1.17.3/extern/qfr/extern/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.330947 mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/
--rw-r--r--   0 runner    (1001) docker     (123)     2404 2023-06-15 08:43:31.000000 mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/CMakeLists.txt
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.330947 mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/cmake/
--rw-r--r--   0 runner    (1001) docker     (123)      427 2023-06-15 08:43:31.000000 mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/cmake/CheckSubmodule.cmake
--rw-r--r--   0 runner    (1001) docker     (123)     2294 2023-06-15 08:43:31.000000 mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/cmake/CompilerOptions.cmake
--rw-r--r--   0 runner    (1001) docker     (123)     5328 2023-06-15 08:43:31.000000 mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/cmake/CompilerWarnings.cmake
--rw-r--r--   0 runner    (1001) docker     (123)      708 2023-06-15 08:43:31.000000 mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/cmake/PackageAddTest.cmake
--rw-r--r--   0 runner    (1001) docker     (123)      718 2023-06-15 08:43:31.000000 mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/cmake/PreventInSourceBuilds.cmake
--rw-r--r--   0 runner    (1001) docker     (123)     1834 2023-06-15 08:43:31.000000 mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/cmake/Sanitizers.cmake
--rw-r--r--   0 runner    (1001) docker     (123)     2119 2023-06-15 08:43:31.000000 mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/cmake/StandardProjectSettings.cmake
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.286947 mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.334947 mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/
--rw-r--r--   0 runner    (1001) docker     (123)     3165 2023-06-15 08:43:31.000000 mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/Complex.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     4496 2023-06-15 08:43:31.000000 mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/ComplexCache.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     8371 2023-06-15 08:43:31.000000 mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/ComplexNumbers.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    22867 2023-06-15 08:43:31.000000 mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/ComplexTable.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     9942 2023-06-15 08:43:31.000000 mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/ComplexValue.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     3707 2023-06-15 08:43:31.000000 mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/ComputeTable.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2118 2023-06-15 08:43:31.000000 mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/Control.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     4157 2023-06-15 08:43:31.000000 mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/Definitions.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     3296 2023-06-15 08:43:31.000000 mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/DensityNoiseTable.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     4591 2023-06-15 08:43:31.000000 mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/Edge.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    36811 2023-06-15 08:43:31.000000 mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/Export.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    11557 2023-06-15 08:43:31.000000 mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/GateMatrixDefinitions.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    11570 2023-06-15 08:43:31.000000 mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/Node.hpp
--rw-r--r--   0 runner    (1001) docker     (123)   147055 2023-06-15 08:43:31.000000 mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/Package.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2628 2023-06-15 08:43:31.000000 mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/StochasticNoiseOperationTable.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     3301 2023-06-15 08:43:31.000000 mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/ToffoliTable.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2681 2023-06-15 08:43:31.000000 mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/UnaryComputeTable.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    16304 2023-06-15 08:43:31.000000 mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/UniqueTable.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.338947 mqt.ddsim-1.17.3/extern/qfr/extern/json/
--rw-r--r--   0 runner    (1001) docker     (123)      400 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/.cirrus.yml
--rw-r--r--   0 runner    (1001) docker     (123)     2442 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/.clang-format
--rw-r--r--   0 runner    (1001) docker     (123)     2241 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/.clang-tidy
--rw-r--r--   0 runner    (1001) docker     (123)       64 2023-06-15 08:43:28.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/.git
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.342947 mqt.ddsim-1.17.3/extern/qfr/extern/json/.github/
--rw-r--r--   0 runner    (1001) docker     (123)      271 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/.github/CODEOWNERS
--rw-r--r--   0 runner    (1001) docker     (123)     3213 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/.github/CODE_OF_CONDUCT.md
--rw-r--r--   0 runner    (1001) docker     (123)     8079 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/.github/CONTRIBUTING.md
--rw-r--r--   0 runner    (1001) docker     (123)       51 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/.github/FUNDING.yml
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.342947 mqt.ddsim-1.17.3/extern/qfr/extern/json/.github/ISSUE_TEMPLATE/
--rw-r--r--   0 runner    (1001) docker     (123)     3331 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/.github/ISSUE_TEMPLATE/bug.yaml
--rw-r--r--   0 runner    (1001) docker     (123)      188 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/.github/ISSUE_TEMPLATE/config.yml
--rw-r--r--   0 runner    (1001) docker     (123)     2507 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/.github/PULL_REQUEST_TEMPLATE.md
--rw-r--r--   0 runner    (1001) docker     (123)      446 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/.github/SECURITY.md
--rw-r--r--   0 runner    (1001) docker     (123)     1123 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/.github/config.yml
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.342947 mqt.ddsim-1.17.3/extern/qfr/extern/json/.github/external_ci/
--rw-r--r--   0 runner    (1001) docker     (123)     2985 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/.github/external_ci/appveyor.yml
--rw-r--r--   0 runner    (1001) docker     (123)      478 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/.github/labeler.yml
--rw-r--r--   0 runner    (1001) docker     (123)      691 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/.github/stale.yml
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.342947 mqt.ddsim-1.17.3/extern/qfr/extern/json/.github/workflows/
--rw-r--r--   0 runner    (1001) docker     (123)     2375 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/.github/workflows/check_amalgamation.yml
--rw-r--r--   0 runner    (1001) docker     (123)      725 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/.github/workflows/cifuzz.yml
--rw-r--r--   0 runner    (1001) docker     (123)      937 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/.github/workflows/codeql-analysis.yml
--rw-r--r--   0 runner    (1001) docker     (123)     2791 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/.github/workflows/comment_check_amalgamation.yml
--rw-r--r--   0 runner    (1001) docker     (123)      332 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/.github/workflows/labeler.yml
--rw-r--r--   0 runner    (1001) docker     (123)     1779 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/.github/workflows/macos.yml
--rw-r--r--   0 runner    (1001) docker     (123)      845 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/.github/workflows/publish_documentation.yml
--rw-r--r--   0 runner    (1001) docker     (123)     7354 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/.github/workflows/ubuntu.yml
--rw-r--r--   0 runner    (1001) docker     (123)     4534 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/.github/workflows/windows.yml
--rw-r--r--   0 runner    (1001) docker     (123)      608 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/.gitignore
--rw-r--r--   0 runner    (1001) docker     (123)       77 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/.lgtm.yml
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.346947 mqt.ddsim-1.17.3/extern/qfr/extern/json/.reuse/
--rw-r--r--   0 runner    (1001) docker     (123)      275 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/.reuse/README.md
--rw-r--r--   0 runner    (1001) docker     (123)      830 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/.reuse/dep5
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.346947 mqt.ddsim-1.17.3/extern/qfr/extern/json/.reuse/templates/
--rw-r--r--   0 runner    (1001) docker     (123)      349 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/.reuse/templates/json.jinja2
--rw-r--r--   0 runner    (1001) docker     (123)      367 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/.reuse/templates/json_support.jinja2
--rw-r--r--   0 runner    (1001) docker     (123)     2634 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/BUILD.bazel
--rw-r--r--   0 runner    (1001) docker     (123)      410 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/CITATION.cff
--rw-r--r--   0 runner    (1001) docker     (123)     7144 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)   304881 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/ChangeLog.md
--rw-r--r--   0 runner    (1001) docker     (123)     1076 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/LICENSE.MIT
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.346947 mqt.ddsim-1.17.3/extern/qfr/extern/json/LICENSES/
--rw-r--r--   0 runner    (1001) docker     (123)    10280 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/LICENSES/Apache-2.0.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1460 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/LICENSES/BSD-3-Clause.txt
--rw-r--r--   0 runner    (1001) docker     (123)    34670 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/LICENSES/GPL-3.0-only.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1078 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/LICENSES/MIT.txt
--rw-r--r--   0 runner    (1001) docker     (123)    13438 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/Makefile
--rw-r--r--   0 runner    (1001) docker     (123)   110430 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/README.md
--rw-r--r--   0 runner    (1001) docker     (123)       34 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/WORKSPACE.bazel
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.346947 mqt.ddsim-1.17.3/extern/qfr/extern/json/cmake/
--rw-r--r--   0 runner    (1001) docker     (123)    45191 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/cmake/ci.cmake
--rw-r--r--   0 runner    (1001) docker     (123)      710 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/cmake/config.cmake.in
--rw-r--r--   0 runner    (1001) docker     (123)     3185 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/cmake/download_test_data.cmake
--rw-r--r--   0 runner    (1001) docker     (123)      709 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/cmake/nlohmann_jsonConfigVersion.cmake.in
--rw-r--r--   0 runner    (1001) docker     (123)      126 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/cmake/pkg-config.pc.in
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.346947 mqt.ddsim-1.17.3/extern/qfr/extern/json/cmake/scripts/
--rw-r--r--   0 runner    (1001) docker     (123)      543 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/cmake/scripts/gen_bazel_build_file.cmake
--rw-r--r--   0 runner    (1001) docker     (123)    10468 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/cmake/test.cmake
--rw-r--r--   0 runner    (1001) docker     (123)      629 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/meson.build
--rw-r--r--   0 runner    (1001) docker     (123)    19578 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/nlohmann_json.natvis
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.286947 mqt.ddsim-1.17.3/extern/qfr/extern/json/single_include/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.350947 mqt.ddsim-1.17.3/extern/qfr/extern/json/single_include/nlohmann/
--rw-r--r--   0 runner    (1001) docker     (123)   914638 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/single_include/nlohmann/json.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     6340 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/single_include/nlohmann/json_fwd.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      608 2023-06-15 08:43:37.000000 mqt.ddsim-1.17.3/extern/qfr/extern/json/wsjcpp.yml
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.354947 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/
--rw-r--r--   0 runner    (1001) docker     (123)     1271 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.appveyor.yml
--rw-r--r--   0 runner    (1001) docker     (123)      996 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.clang-format
--rw-r--r--   0 runner    (1001) docker     (123)     2605 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.clang-tidy
--rw-r--r--   0 runner    (1001) docker     (123)     2196 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.cmake-format.yaml
--rw-r--r--   0 runner    (1001) docker     (123)     1308 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.codespell-ignore-lines
--rw-r--r--   0 runner    (1001) docker     (123)       68 2023-06-15 08:43:29.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.git
--rw-r--r--   0 runner    (1001) docker     (123)       18 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.gitattributes
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.354947 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.github/
--rw-r--r--   0 runner    (1001) docker     (123)      182 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.github/CODEOWNERS
--rw-r--r--   0 runner    (1001) docker     (123)    15284 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.github/CONTRIBUTING.md
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.354947 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.github/ISSUE_TEMPLATE/
--rw-r--r--   0 runner    (1001) docker     (123)     2561 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.github/ISSUE_TEMPLATE/bug-report.yml
--rw-r--r--   0 runner    (1001) docker     (123)      328 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.github/ISSUE_TEMPLATE/config.yml
--rw-r--r--   0 runner    (1001) docker     (123)      162 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.github/dependabot.yml
--rw-r--r--   0 runner    (1001) docker     (123)      116 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.github/labeler.yml
--rw-r--r--   0 runner    (1001) docker     (123)       50 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.github/labeler_merged.yml
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.354947 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.github/matchers/
--rw-r--r--   0 runner    (1001) docker     (123)      668 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.github/matchers/pylint.json
--rw-r--r--   0 runner    (1001) docker     (123)      645 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.github/pull_request_template.md
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.358947 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.github/workflows/
--rw-r--r--   0 runner    (1001) docker     (123)    33993 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.github/workflows/ci.yml
--rw-r--r--   0 runner    (1001) docker     (123)     2158 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.github/workflows/configure.yml
--rw-r--r--   0 runner    (1001) docker     (123)     1491 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.github/workflows/format.yml
--rw-r--r--   0 runner    (1001) docker     (123)      641 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.github/workflows/labeler.yml
--rw-r--r--   0 runner    (1001) docker     (123)     2589 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.github/workflows/pip.yml
--rw-r--r--   0 runner    (1001) docker     (123)     2784 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.github/workflows/upstream.yml
--rw-r--r--   0 runner    (1001) docker     (123)      502 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.gitignore
--rw-r--r--   0 runner    (1001) docker     (123)     3600 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.pre-commit-config.yaml
--rw-r--r--   0 runner    (1001) docker     (123)       62 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.readthedocs.yml
--rw-r--r--   0 runner    (1001) docker     (123)    12067 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1684 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/LICENSE
--rw-r--r--   0 runner    (1001) docker     (123)      247 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/MANIFEST.in
--rw-r--r--   0 runner    (1001) docker     (123)     7686 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/README.rst
--rw-r--r--   0 runner    (1001) docker     (123)      688 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/SECURITY.md
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.286947 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.362947 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/
--rw-r--r--   0 runner    (1001) docker     (123)    24334 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/attr.h
--rw-r--r--   0 runner    (1001) docker     (123)     7750 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/buffer_info.h
--rw-r--r--   0 runner    (1001) docker     (123)    67312 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/cast.h
--rw-r--r--   0 runner    (1001) docker     (123)     8458 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/chrono.h
--rw-r--r--   0 runner    (1001) docker     (123)      120 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/common.h
--rw-r--r--   0 runner    (1001) docker     (123)     2096 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/complex.h
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.362947 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/detail/
--rw-r--r--   0 runner    (1001) docker     (123)    28518 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/detail/class.h
--rw-r--r--   0 runner    (1001) docker     (123)    53759 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/detail/common.h
--rw-r--r--   0 runner    (1001) docker     (123)     5962 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/detail/descr.h
--rw-r--r--   0 runner    (1001) docker     (123)    17859 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/detail/init.h
--rw-r--r--   0 runner    (1001) docker     (123)    28221 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/detail/internals.h
--rw-r--r--   0 runner    (1001) docker     (123)    48364 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/detail/type_caster_base.h
--rw-r--r--   0 runner    (1001) docker     (123)     1625 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/detail/typeid.h
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.362947 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/eigen/
--rw-r--r--   0 runner    (1001) docker     (123)      378 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/eigen/common.h
--rw-r--r--   0 runner    (1001) docker     (123)    32135 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/eigen/matrix.h
--rw-r--r--   0 runner    (1001) docker     (123)    18442 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/eigen/tensor.h
--rw-r--r--   0 runner    (1001) docker     (123)      316 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/eigen.h
--rw-r--r--   0 runner    (1001) docker     (123)    13459 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/embed.h
--rw-r--r--   0 runner    (1001) docker     (123)     4731 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/eval.h
--rw-r--r--   0 runner    (1001) docker     (123)     5002 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/functional.h
--rw-r--r--   0 runner    (1001) docker     (123)     8262 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/gil.h
--rw-r--r--   0 runner    (1001) docker     (123)     8862 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/iostream.h
--rw-r--r--   0 runner    (1001) docker     (123)    79725 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/numpy.h
--rw-r--r--   0 runner    (1001) docker     (123)     9103 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/operators.h
--rw-r--r--   0 runner    (1001) docker     (123)     2734 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/options.h
--rw-r--r--   0 runner    (1001) docker     (123)   126708 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/pybind11.h
--rw-r--r--   0 runner    (1001) docker     (123)    97610 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/pytypes.h
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.362947 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/stl/
--rw-r--r--   0 runner    (1001) docker     (123)     4185 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/stl/filesystem.h
--rw-r--r--   0 runner    (1001) docker     (123)    15477 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/stl.h
--rw-r--r--   0 runner    (1001) docker     (123)    29897 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/stl_bind.h
--rw-r--r--   0 runner    (1001) docker     (123)     1929 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/type_caster_pyobject_ptr.h
--rw-r--r--   0 runner    (1001) docker     (123)     2765 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/noxfile.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.366947 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/pybind11/
--rw-r--r--   0 runner    (1001) docker     (123)      429 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/pybind11/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1544 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/pybind11/__main__.py
--rw-r--r--   0 runner    (1001) docker     (123)      233 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/pybind11/_version.py
--rw-r--r--   0 runner    (1001) docker     (123)     1207 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/pybind11/commands.py
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/pybind11/py.typed
--rw-r--r--   0 runner    (1001) docker     (123)    17462 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/pybind11/setup_helpers.py
--rw-r--r--   0 runner    (1001) docker     (123)     2360 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/pyproject.toml
--rw-r--r--   0 runner    (1001) docker     (123)     1452 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (123)     4877 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.370947 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/
--rw-r--r--   0 runner    (1001) docker     (123)     2449 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/FindCatch.cmake
--rw-r--r--   0 runner    (1001) docker     (123)     3105 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/FindEigen3.cmake
--rw-r--r--   0 runner    (1001) docker     (123)    11190 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/FindPythonLibsNew.cmake
--rw-r--r--   0 runner    (1001) docker     (123)      817 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/JoinPaths.cmake
--rwxr-xr-x   0 runner    (1001) docker     (123)     1423 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/check-style.sh
--rw-r--r--   0 runner    (1001) docker     (123)      952 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/cmake_uninstall.cmake.in
--rw-r--r--   0 runner    (1001) docker     (123)     1117 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/codespell_ignore_lines_from_errors.py
--rw-r--r--   0 runner    (1001) docker     (123)     1031 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/libsize.py
--rwxr-xr-x   0 runner    (1001) docker     (123)     1311 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/make_changelog.py
--rw-r--r--   0 runner    (1001) docker     (123)      196 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/pybind11.pc.in
--rw-r--r--   0 runner    (1001) docker     (123)    14179 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/pybind11Common.cmake
--rw-r--r--   0 runner    (1001) docker     (123)     6930 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/pybind11Config.cmake.in
--rw-r--r--   0 runner    (1001) docker     (123)     8960 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/pybind11NewTools.cmake
--rw-r--r--   0 runner    (1001) docker     (123)     8361 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/pybind11Tools.cmake
--rw-r--r--   0 runner    (1001) docker     (123)       94 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/pyproject.toml
--rw-r--r--   0 runner    (1001) docker     (123)     2104 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/setup_global.py.in
--rw-r--r--   0 runner    (1001) docker     (123)     1234 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/setup_main.py.in
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.370947 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11_json/
--rw-r--r--   0 runner    (1001) docker     (123)       73 2023-06-15 08:43:29.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11_json/.git
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.286947 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11_json/.github/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.370947 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11_json/.github/workflows/
--rw-r--r--   0 runner    (1001) docker     (123)     2275 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11_json/.github/workflows/main.yml
--rw-r--r--   0 runner    (1001) docker     (123)        8 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11_json/.gitignore
--rw-r--r--   0 runner    (1001) docker     (123)     5062 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11_json/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1499 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11_json/LICENSE
--rw-r--r--   0 runner    (1001) docker     (123)     4129 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11_json/README.md
--rw-r--r--   0 runner    (1001) docker     (123)      173 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11_json/dev-environment.yml
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.290947 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11_json/include/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.370947 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11_json/include/pybind11_json/
--rw-r--r--   0 runner    (1001) docker     (123)     7219 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11_json/include/pybind11_json/pybind11_json.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1213 2023-06-15 08:43:39.000000 mqt.ddsim-1.17.3/extern/qfr/extern/pybind11_json/pybind11_jsonConfig.cmake.in
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.374947 mqt.ddsim-1.17.3/extern/qfr/extern/zx/
--rw-r--r--   0 runner    (1001) docker     (123)      221 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/.clang-format
--rw-r--r--   0 runner    (1001) docker     (123)     2395 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/.clang-tidy
--rw-r--r--   0 runner    (1001) docker     (123)       67 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/.cmake-format.yaml
--rw-r--r--   0 runner    (1001) docker     (123)       62 2023-06-15 08:43:30.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/.git
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.374947 mqt.ddsim-1.17.3/extern/qfr/extern/zx/.github/
--rw-r--r--   0 runner    (1001) docker     (123)      272 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/.github/codecov.yml
--rw-r--r--   0 runner    (1001) docker     (123)       68 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/.github/codeql-config.yml
--rw-r--r--   0 runner    (1001) docker     (123)      360 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/.github/dependabot.yml
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.374947 mqt.ddsim-1.17.3/extern/qfr/extern/zx/.github/workflows/
--rw-r--r--   0 runner    (1001) docker     (123)     1617 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/.github/workflows/ci.yml
--rw-r--r--   0 runner    (1001) docker     (123)     1593 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/.github/workflows/codeql-analysis.yml
--rw-r--r--   0 runner    (1001) docker     (123)     1002 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/.github/workflows/cpp-linter.yml
--rw-r--r--   0 runner    (1001) docker     (123)      185 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/.gitignore
--rw-r--r--   0 runner    (1001) docker     (123)      375 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/.gitmodules
--rw-r--r--   0 runner    (1001) docker     (123)     1834 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/.pre-commit-config.yaml
--rw-r--r--   0 runner    (1001) docker     (123)     1875 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1095 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/LICENSE
--rw-r--r--   0 runner    (1001) docker     (123)     1431 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/README.md
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.374947 mqt.ddsim-1.17.3/extern/qfr/extern/zx/cmake/
--rw-r--r--   0 runner    (1001) docker     (123)     2844 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/cmake/FindGMP.cmake
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.302947 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.294947 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.374947 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.374947 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/.circleci/
--rw-r--r--   0 runner    (1001) docker     (123)     2409 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/.circleci/config.yml
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.378947 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/.drone/
--rwxr-xr-x   0 runner    (1001) docker     (123)       14 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/.drone/after-success.sh
--rwxr-xr-x   0 runner    (1001) docker     (123)       14 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/.drone/before-install.sh
--rwxr-xr-x   0 runner    (1001) docker     (123)       14 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/.drone/before-script.sh
--rwxr-xr-x   0 runner    (1001) docker     (123)     1529 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/.drone/boost.sh
--rw-r--r--   0 runner    (1001) docker     (123)     8443 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/.drone.star
--rw-r--r--   0 runner    (1001) docker     (123)       99 2023-06-15 08:43:41.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/.git
--rw-r--r--   0 runner    (1001) docker     (123)     3917 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/.gitattributes
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.290947 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/.github/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.378947 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/.github/workflows/
--rw-r--r--   0 runner    (1001) docker     (123)    23999 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/.github/workflows/ci.yml
--rw-r--r--   0 runner    (1001) docker     (123)       24 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/.gitignore
--rw-r--r--   0 runner    (1001) docker     (123)      530 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)     2647 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/README.md
--rw-r--r--   0 runner    (1001) docker     (123)     2630 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/appveyor.yml
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.378947 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/
--rw-r--r--   0 runner    (1001) docker     (123)    36764 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/Jamfile.v2
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.382947 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/architecture/
--rw-r--r--   0 runner    (1001) docker     (123)        4 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/architecture/.gitignore
--rw-r--r--   0 runner    (1001) docker     (123)      248 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/architecture/32.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      248 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/architecture/64.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      754 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/architecture/Jamfile.jam
--rw-r--r--   0 runner    (1001) docker     (123)      427 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/architecture/arm.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      934 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/architecture/combined.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      268 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/architecture/loongarch.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      307 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/architecture/mips.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      485 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/architecture/power.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      254 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/architecture/riscv.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      263 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/architecture/s390x.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      284 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/architecture/sparc.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      634 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/architecture/x86.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      491 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/config.jam
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.414947 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/
--rw-r--r--   0 runner    (1001) docker     (123)      749 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_aggregate_bases_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      749 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_aggregate_nsdmi_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      749 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_alias_templates_11.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      733 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_aligned_new_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      729 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_attributes_11.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      749 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_binary_literals_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      757 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_capture_star_this_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      717 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_char8_t_20.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      769 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_conditional_explicit_20.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      725 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_constexpr_11.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      725 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_constexpr_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      725 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_constexpr_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      721 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_decltype_11.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      741 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_decltype_auto_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      753 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_deduction_guides_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      781 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_delegating_constructors_11.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      773 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_enumerator_attributes_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      729 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_exceptions_03.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      765 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_explicit_conversion_11.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      753 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_fold_expressions_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      749 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_generic_lambdas_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      781 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_guaranteed_copy_elision_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      725 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_hex_float_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      737 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_if_constexpr_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      777 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_impl_destroying_delete_20.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      789 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_impl_three_way_comparison_20.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      781 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_inheriting_constructors_11.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      781 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_inheriting_constructors_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      741 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_init_captures_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      757 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_initializer_lists_11.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      753 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_inline_variables_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      717 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lambdas_11.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      800 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_addressof_constexpr_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      852 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_allocator_traits_is_always_equal_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      733 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_any_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      743 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_apply_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      786 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_array_constexpr_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      757 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_as_const_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      828 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_atomic_is_always_lock_free_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      764 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_atomic_ref_20.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      768 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_bind_front_20.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      753 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_bit_cast_20.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      781 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_bool_constant_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      808 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_boyer_moore_searcher_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      741 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_byte_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      752 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_char8_t_20.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      748 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_chrono_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      768 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_chrono_udls_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      747 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_clamp_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      773 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_complex_udls_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      758 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_concepts_20.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      779 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_constexpr_misc_20.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      827 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_constexpr_swap_algorithms_20.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      789 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_destroying_delete_20.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      816 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_enable_shared_from_this_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      756 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_erase_if_20.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      793 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_exchange_function_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      763 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_execution_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      768 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_filesystem_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      753 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_gcd_lcm_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      825 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_generic_associative_lookup_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      827 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_generic_unordered_lookup_20.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      825 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_hardware_interference_size_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      861 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_has_unique_object_representations_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      743 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_hypot_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      846 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_incomplete_container_elements_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      789 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_integer_sequence_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      833 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_integral_constant_callable_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      752 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_invoke_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      777 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_is_aggregate_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      813 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_is_constant_evaluated_20.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      761 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_is_final_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      777 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_is_invocable_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      789 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_is_null_pointer_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      777 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_is_swappable_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      749 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_launder_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      822 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_list_remove_return_type_20.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      785 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_logical_traits_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      783 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_make_from_tuple_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      810 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_make_reverse_iterator_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      768 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_make_unique_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      781 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_map_try_emplace_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      811 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_math_special_functions_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      793 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_memory_resource_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      769 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_node_extract_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      830 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_nonmember_container_access_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      752 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_not_fn_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      782 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_null_iterators_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      758 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_optional_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      799 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_parallel_algorithm_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      789 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_quoted_string_io_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      751 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_ranges_20.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      808 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_raw_memory_algorithms_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      792 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_result_of_sfinae_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      835 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_robust_nonmodifying_seq_ops_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      751 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_sample_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      767 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_scoped_lock_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      778 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_shared_mutex_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      792 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_shared_ptr_arrays_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      804 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_shared_ptr_weak_type_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      802 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_shared_timed_mutex_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      768 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_string_udls_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      768 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_string_view_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      805 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_three_way_comparison_20.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      757 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_to_chars_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      841 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_transformation_trait_aliases_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      812 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_transparent_operators_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      808 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_transparent_operators_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      783 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_tuple_element_t_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      781 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_tuples_by_type_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      845 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_type_trait_variable_templates_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      803 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_uncaught_exceptions_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      831 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_unordered_map_try_emplace_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      753 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_variant_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      753 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_void_t_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      769 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_namespace_attributes_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      777 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_noexcept_function_type_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      773 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_nontype_template_args_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      813 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_nontype_template_parameter_auto_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      817 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_nontype_template_parameter_class_20.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      709 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_nsdmi_11.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      749 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_range_based_for_11.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      749 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_range_based_for_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      733 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_raw_strings_11.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      745 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_ref_qualifiers_11.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      773 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_return_type_deduction_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      705 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_rtti_03.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      757 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_rvalue_references_11.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      761 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_sized_deallocation_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      741 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_static_assert_11.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      741 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_static_assert_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      765 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_structured_bindings_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      777 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_template_template_args_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      777 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_threadsafe_static_init_11.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      761 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_unicode_characters_11.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      753 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_unicode_literals_11.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      773 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_user_defined_literals_11.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      761 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_variable_templates_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      761 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_variadic_templates_11.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      745 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_variadic_using_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    36893 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/test_case.cpp
--rw-r--r--   0 runner    (1001) docker     (123)   105382 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/configure
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.418948 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/doc/
--rw-r--r--   0 runner    (1001) docker     (123)     2147 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/doc/Jamfile.v2
--rw-r--r--   0 runner    (1001) docker     (123)      876 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/doc/acknowledgements.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     4407 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/doc/build_time.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     1863 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/doc/config.qbk
--rw-r--r--   0 runner    (1001) docker     (123)    19931 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/doc/configuring_boost.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     6025 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/doc/cstdint.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     9959 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/doc/guidelines.qbk
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.418948 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/doc/html/
--rw-r--r--   0 runner    (1001) docker     (123)      161 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/doc/html/HTML.manifest
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.418948 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/doc/html/boost_config/
--rw-r--r--   0 runner    (1001) docker     (123)     3361 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/doc/html/boost_config/acknowledgements.html
--rw-r--r--   0 runner    (1001) docker     (123)   300445 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/doc/html/boost_config/boost_macro_reference.html
--rw-r--r--   0 runner    (1001) docker     (123)    11547 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/doc/html/boost_config/build_config.html
--rw-r--r--   0 runner    (1001) docker     (123)    16122 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/doc/html/boost_config/cstdint.html
--rw-r--r--   0 runner    (1001) docker     (123)    25016 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/doc/html/boost_config/guidelines_for_boost_authors.html
--rw-r--r--   0 runner    (1001) docker     (123)     7844 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/doc/html/boost_config/rationale.html
--rw-r--r--   0 runner    (1001) docker     (123)    60592 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/doc/html/index.html
--rw-r--r--   0 runner    (1001) docker     (123)    78091 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/doc/macro_reference.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     3492 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/doc/rationale.qbk
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.290947 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.422948 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.426947 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.426947 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/abi/
--rw-r--r--   0 runner    (1001) docker     (123)     1002 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/abi/borland_prefix.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      280 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/abi/borland_suffix.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      819 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/abi/msvc_prefix.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      252 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/abi/msvc_suffix.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      700 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/abi_prefix.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      781 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/abi_suffix.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    11405 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/assert_cxx03.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    11520 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/assert_cxx11.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2396 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/assert_cxx14.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     3174 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/assert_cxx17.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2948 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/assert_cxx20.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      989 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/assert_cxx98.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    17829 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/auto_link.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.434948 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/
--rw-r--r--   0 runner    (1001) docker     (123)    10760 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/borland.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    10085 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/clang.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2305 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/clang_version.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    11602 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/codegear.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1638 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/comeau.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     6038 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/common_edg.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      501 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/compaq_cxx.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    15493 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/cray.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      909 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/diab.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     4626 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/digitalmars.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    12427 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/gcc.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     4078 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/gcc_xml.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      822 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/greenhills.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     5000 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/hp_acc.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    22537 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/intel.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1030 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/kai.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     6408 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/metrowerks.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     4811 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/mpw.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2095 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/nvcc.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     5156 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/pathscale.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      770 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/pgi.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      774 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/sgi_mipspro.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     7705 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/sunpro_cc.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     6149 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/vacpp.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    12588 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/visualc.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     8202 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/xlcpp.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     4984 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/xlcpp_zos.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.438948 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/detail/
--rw-r--r--   0 runner    (1001) docker     (123)     8629 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/detail/cxx_composite.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     3736 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/detail/posix_features.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     5356 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/detail/select_compiler_config.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     4588 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/detail/select_platform_config.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     4653 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/detail/select_stdlib_config.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    46059 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/detail/suffix.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      848 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/header_deprecated.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1120 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/helper_macros.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.438948 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/no_tr1/
--rw-r--r--   0 runner    (1001) docker     (123)      838 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/no_tr1/cmath.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      854 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/no_tr1/complex.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      878 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/no_tr1/functional.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      846 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/no_tr1/memory.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      854 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/no_tr1/utility.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.442947 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/
--rw-r--r--   0 runner    (1001) docker     (123)      888 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/aix.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      442 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/amigaos.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      600 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/beos.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2592 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/bsd.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      530 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/cloudabi.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      456 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/cray.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1872 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/cygwin.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      807 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/haiku.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2484 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/hpux.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      796 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/irix.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2850 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/linux.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2350 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/macos.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      773 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/qnxnto.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      841 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/solaris.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2621 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/symbian.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      749 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/vms.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    14836 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/vxworks.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      578 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/wasm.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2718 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/win32.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      789 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/zos.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1019 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/pragma_message.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     3509 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/requires_threads.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.446948 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/stdlib/
--rw-r--r--   0 runner    (1001) docker     (123)    11403 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/stdlib/dinkumware.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2830 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/stdlib/libcomo.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     5867 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/stdlib/libcpp.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    15824 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/stdlib/libstdcpp3.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2235 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/stdlib/modena.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2836 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/stdlib/msl.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     6260 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/stdlib/roguewave.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     5061 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/stdlib/sgi.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     8585 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/stdlib/stlport.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2394 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/stdlib/vacpp.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1963 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/stdlib/xlcpp_zos.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     5365 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/user.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1820 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/warning_disable.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     8171 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/workaround.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2216 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    18497 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/cstdint.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     4160 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/cxx11_char_types.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.446948 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/detail/
--rw-r--r--   0 runner    (1001) docker     (123)      353 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/detail/workaround.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     6362 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/limits.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1117 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/version.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      558 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/index.html
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.446948 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/meta/
--rw-r--r--   0 runner    (1001) docker     (123)      376 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/meta/libraries.json
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.586948 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/
--rw-r--r--   0 runner    (1001) docker     (123)      950 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)     6198 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/Jamfile.v2
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.586948 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/abi/
--rw-r--r--   0 runner    (1001) docker     (123)      502 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/abi/abi_test.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1039 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/abi/abi_test.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      758 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/abi/main.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.586948 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/all/
--rw-r--r--   0 runner    (1001) docker     (123)    31054 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/all/Jamfile.v2
--rw-r--r--   0 runner    (1001) docker     (123)      414 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/all/options_v2.jam
--rw-r--r--   0 runner    (1001) docker     (123)      416 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_fallthrough_test.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      797 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_2arg_use_facet.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      653 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_bethreads.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      694 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_clock_gettime.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      605 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_detect_mismatch.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      565 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_dirent_h.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      554 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_expm1.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      690 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_float128.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      607 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_ftime.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      689 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_getsystemtimeasfiletime.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      679 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_gettimeofday.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1489 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_hash.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1767 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_int128.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      553 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_log1p.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      715 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_long_long.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      836 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_macro_use_facet.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      606 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_ms_int64.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      680 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_nanosleep.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      595 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_nl_types_h.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      844 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_nrvo.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     2038 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_part_alloc.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      695 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_pthread_delay_np.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      780 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_pthread_ma_st.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      657 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_pthread_yield.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1529 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_pthreads.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      639 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_rvalue_refs.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      651 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_sched_yield.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1027 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_sgi_type_traits.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      715 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_sigaction.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      944 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_slist.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      541 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_static_assert.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1213 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_stdint_h.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      784 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_stlp_use_facet.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      509 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_unistd_h.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      562 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_variadic_tmpl.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1310 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_vc6_mem_templ.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      907 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_vc_iterator.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      685 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_has_winthreads.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      756 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_adl_barrier.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      753 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_arg_dep_lookup.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      748 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_array_type_spec.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      705 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_auto_declarations.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      751 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_auto_multidecl.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      945 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_auto_ptr.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      955 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_bcb_partial_spec.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      906 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_char16_t.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      905 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_char32_t.ipp
--rw-r--r--   0 runner    (1001) docker     (123)    35185 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_com_value_init.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1566 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_constexpr.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1333 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_ctype_functions.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      851 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cv_spec.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      844 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cv_void_spec.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      801 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cwchar.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1095 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cwctype.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      494 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx03.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      494 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      743 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_addressof.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1123 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_alignas.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      556 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_alignof.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1540 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_allocator.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1300 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_atomic_sp.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      694 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_defaulted_moves.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1082 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_exception.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      764 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_final.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      612 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_hdr_array.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     3154 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_hdr_atomic.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      863 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_hdr_chrono.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      798 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_hdr_codecvt.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      687 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_hdr_condition_variable.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      644 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_hdr_forward_list.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      844 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_hdr_future.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      692 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_hdr_initializer_list.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      664 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_hdr_mutex.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      791 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_hdr_random.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      841 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_hdr_ratio.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      778 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_hdr_regex.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      698 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_hdr_system_error.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      721 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_hdr_thread.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      604 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_hdr_tuple.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     3489 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_hdr_type_traits.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      851 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_hdr_typeindex.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      700 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_hdr_unordered_map.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      688 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_hdr_unordered_set.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      684 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_inline_namespaces.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1003 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_non_pub_def_fun.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      737 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_numeric_limits.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      613 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_override.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      787 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_pointer_traits.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      852 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_ref_qualifiers.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      865 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_sfinae_expr.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      990 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_smart_ptr.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      856 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_std_align.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      794 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_thread_local.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      679 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_trailing_result_types.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1082 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_unrestricted_union.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1981 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx11_user_lit.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      494 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx14.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      586 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx14_binary_literals.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1529 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx14_constexpr.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      682 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx14_decltype_auto.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      553 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx14_digit_separator.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      578 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx14_generic_lambda.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      816 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx14_hdr_shared_mutex.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      622 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx14_lambda_capture.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      646 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx14_member_init.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      678 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx14_return_type_ded.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      621 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx14_std_exchange.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      617 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx14_var_templ.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      494 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx17.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      724 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx17_deduction_guides.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      564 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx17_fold_expressions.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      634 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx17_hdr_any.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      705 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx17_hdr_charconv.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      836 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx17_hdr_execution.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     2553 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx17_hdr_filesystem.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1009 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx17_hdr_memory_resource.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      591 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx17_hdr_optional.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      694 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx17_hdr_string_view.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      821 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx17_hdr_variant.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      933 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx17_if_constexpr.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      561 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx17_inline_variables.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1551 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx17_iterator_traits.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      665 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx17_std_apply.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      699 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx17_std_invoke.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      700 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx17_structured_bindings.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      632 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx20_hdr_barrier.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      887 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx20_hdr_bit.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1305 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx20_hdr_compare.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1565 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx20_hdr_concepts.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      847 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx20_hdr_coroutine.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1239 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx20_hdr_format.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      620 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx20_hdr_latch.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1025 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx20_hdr_numbers.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     3196 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx20_hdr_ranges.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      685 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx20_hdr_semaphore.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      680 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx20_hdr_source_location.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      701 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx20_hdr_span.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      762 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx20_hdr_stop_token.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      788 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx20_hdr_syncstream.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      608 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx20_hdr_version.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      718 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx98_binders.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      753 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx98_function_base.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      638 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx98_random_shuffle.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      895 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_cxx_hdr_functional.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1141 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_decltype.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     3386 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_decltype_n3276.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      781 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_ded_typename.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      769 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_defaulted_functions.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      758 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_deleted_functions.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1230 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_dep_nested_class.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      937 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_dep_val_param.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      682 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_excep_std.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      740 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_exceptions.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1150 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_exp_func_tem_arg.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      896 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_explicit_cvt_ops.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      893 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_extern_template.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1498 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_fenv_h.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      812 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_fixed_len_variadic_templates.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1045 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_func_tmp_order.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      906 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_function_template_default_args.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1224 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_function_type_spec.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      778 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_i64_limits.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1513 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_inline_memb_init.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1034 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_integral_int64_t.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      489 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_iosfwd.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      570 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_iostream.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1552 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_is_abstract.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      927 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_iter_construct.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      763 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_lambdas.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1071 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_limits.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1039 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_limits_const_exp.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      904 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_ll_limits.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      745 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_long_long.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1291 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_mem_func_spec.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1176 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_mem_tem_keyword.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      975 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_mem_tem_pnts.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1462 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_mem_templ_frnds.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1121 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_mem_templates.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      882 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_nested_friendship.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      650 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_noexcept.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      604 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_nullptr.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1720 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_ops_in_namespace.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1036 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_part_spec_def_args.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      994 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_partial_spec.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      856 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_priv_aggregate.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1767 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_ptr_mem_const.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      618 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_range_based_for.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      717 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_raw_literals.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1039 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_restrict_references.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1056 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_ret_det.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      903 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_rtti.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      687 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_rvalue_references.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      924 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_scoped_enums.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1106 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_sfinae.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1061 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_sfinae_expr.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      643 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_sstream.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      573 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_static_assert.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     2516 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_std_allocator.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      670 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_std_distance.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     2064 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_std_iter_traits.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1418 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_std_iterator.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      828 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_std_locale.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      813 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_std_messages.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      756 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_std_min_max.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1076 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_std_oi_assign.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      666 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_std_typeinfo.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      646 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_std_use_facet.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     3356 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_std_wstreambuf.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      663 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_std_wstring.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1165 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_stdc_namespace.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      605 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_swprintf.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1292 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_tem_local_classes.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      633 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_template_aliases.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      639 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_template_streams.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      952 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_template_template.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      793 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_two_phase_lookup.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      542 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_typeid.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      783 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_typename_with_ctor.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      928 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_unicode_literals.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1334 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_unified_init.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1592 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_using_breaks_adl.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1049 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_using_decl_overld.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1021 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_using_template.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     2537 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_variadic_macros.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      608 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_variadic_templates.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      724 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_void_returns.ipp
--rw-r--r--   0 runner    (1001) docker     (123)     1388 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_no_wchar_t.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      370 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/boost_override_test.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      357 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/check_memory.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      290 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/cmd_line_check.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      754 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/config_build_check.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    55394 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/config_info.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    76792 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/config_test.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    66197 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/config_test.cu
--rw-r--r--   0 runner    (1001) docker     (123)      293 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/config_test_c.c
--rw-r--r--   0 runner    (1001) docker     (123)     1877 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/cstdint_include_test.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     8826 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/cstdint_test.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     8962 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/cstdint_test2.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1015 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_2arg_use_facet_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1033 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_2arg_use_facet_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      973 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_bethreads_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      983 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_bethreads_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      997 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_clock_gettime_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1011 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_clock_gettime_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1061 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_detect_mismatch_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1084 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_detect_mismatch_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      967 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_dirent_h_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      976 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_dirent_h_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      949 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_expm1_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      955 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_expm1_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      991 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_float128_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1000 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_float128_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      949 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_ftime_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      955 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_ftime_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1136 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_getsystemtimeasfiletime_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1160 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_getsystemtimeasfiletime_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      991 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_gettimeofday_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1004 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_gettimeofday_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      943 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_hash_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      948 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_hash_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      979 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_int128_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      986 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_int128_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      949 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_log1p_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      955 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_log1p_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      973 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_long_long_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      983 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_long_long_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1009 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_macro_use_facet_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1025 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_macro_use_facet_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      967 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_ms_int64_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      976 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_ms_int64_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      973 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_nanosleep_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      983 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_nanosleep_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      979 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_nl_types_h_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      990 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_nl_types_h_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      943 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_nrvo_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      948 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_nrvo_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1023 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_part_alloc_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1045 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_part_alloc_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1015 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_pthread_delay_np_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1032 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_pthread_delay_np_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1045 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_pthread_ma_st_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1071 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_pthread_ma_st_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      997 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_pthread_yield_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1011 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_pthread_yield_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      967 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_pthreads_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      976 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_pthreads_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      985 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_rvalue_refs_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      997 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_rvalue_refs_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      985 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_sched_yield_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      997 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_sched_yield_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1009 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_sgi_type_traits_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1025 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_sgi_type_traits_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      973 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_sigaction_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      983 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_sigaction_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      949 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_slist_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      955 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_slist_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      997 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_static_assert_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1011 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_static_assert_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      967 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_stdint_h_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      976 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_stdint_h_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1003 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_stlp_use_facet_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1018 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_stlp_use_facet_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      967 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_unistd_h_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      976 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_unistd_h_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      997 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_variadic_tmpl_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1011 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_variadic_tmpl_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1017 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_vc6_mem_templ_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1036 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_vc6_mem_templ_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      993 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_vc_iterator_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1007 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_vc_iterator_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      979 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_winthreads_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      990 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/has_winthreads_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      533 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/header_deprecated_test.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1829 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/helper_macro_test.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      746 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/helper_macros_test.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     7229 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/limits_test.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.590948 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/link/
--rw-r--r--   0 runner    (1001) docker     (123)      690 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/link/Jamfile.v2
--rw-r--r--   0 runner    (1001) docker     (123)     8900 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/link/bc_gen.sh
--rw-r--r--   0 runner    (1001) docker     (123)    23612 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/link/borland.mak
--rw-r--r--   0 runner    (1001) docker     (123)      436 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/link/common.sh
--rw-r--r--   0 runner    (1001) docker     (123)     1824 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/link/link_test.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2401 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/link/link_test.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      527 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/link/main.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.590948 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/link/test/
--rw-r--r--   0 runner    (1001) docker     (123)     3807 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/link/test/Jamfile.v2
--rw-r--r--   0 runner    (1001) docker     (123)    20367 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/link/vc6-stlport.mak
--rw-r--r--   0 runner    (1001) docker     (123)    13977 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/link/vc6.mak
--rw-r--r--   0 runner    (1001) docker     (123)    20439 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/link/vc7-stlport.mak
--rw-r--r--   0 runner    (1001) docker     (123)    14025 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/link/vc7.mak
--rw-r--r--   0 runner    (1001) docker     (123)    20879 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/link/vc71-stlport.mak
--rw-r--r--   0 runner    (1001) docker     (123)    14415 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/link/vc71.mak
--rw-r--r--   0 runner    (1001) docker     (123)    11904 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/link/vc_gen.sh
--rw-r--r--   0 runner    (1001) docker     (123)    12831 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/math_info.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1060 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_adl_barrier_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1065 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_adl_barrier_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1044 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_arg_dep_lookup_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1063 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_arg_dep_lookup_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1050 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_array_type_spec_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1070 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_array_type_spec_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1066 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_auto_declarations_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1083 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_auto_declarations_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1080 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_auto_multidecl_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1102 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_auto_multidecl_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      964 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_auto_ptr_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      966 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_auto_ptr_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1056 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_bcb_partial_spec_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1077 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_bcb_partial_spec_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1012 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_char16_t_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1020 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_char16_t_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1012 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_char32_t_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1020 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_char32_t_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1138 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_com_value_init_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1161 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_com_value_init_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1018 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_constexpr_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1027 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_constexpr_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1006 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_ctype_functions_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1015 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_ctype_functions_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1002 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cv_spec_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1014 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cv_spec_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1032 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cv_void_spec_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1049 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cv_void_spec_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      952 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cwchar_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      952 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cwchar_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      958 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cwctype_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      959 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cwctype_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      970 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx03_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      969 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx03_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1030 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_addressof_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1039 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_addressof_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1018 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_alignas_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1025 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_alignas_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1018 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_alignof_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1025 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_alignof_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1085 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_allocator_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1094 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_allocator_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1113 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_atomic_sp_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1129 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_atomic_sp_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1066 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_defaulted_moves_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1081 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_defaulted_moves_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1046 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_exception_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1059 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_exception_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      970 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1006 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_final_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1011 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_final_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1030 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_array_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1039 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_array_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1036 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_atomic_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1046 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_atomic_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1036 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_chrono_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1046 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_chrono_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1042 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_codecvt_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1053 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_codecvt_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1108 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_condition_variable_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1130 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_condition_variable_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1072 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_forward_list_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_forward_list_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1036 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_future_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1046 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_future_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1096 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_initializer_list_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1116 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_initializer_list_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1030 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_mutex_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1039 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_mutex_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1036 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_random_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1046 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_random_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1030 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_ratio_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1039 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_ratio_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1030 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_regex_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1039 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_regex_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1072 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_system_error_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_system_error_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1036 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_thread_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1046 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_thread_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1030 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_tuple_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1039 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_tuple_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1066 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_type_traits_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1081 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_type_traits_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1108 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_typeindex_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1121 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_typeindex_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1078 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_unordered_map_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1095 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_unordered_map_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1078 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_unordered_set_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1095 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_hdr_unordered_set_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1078 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_inline_namespaces_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1095 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_inline_namespaces_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1126 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_non_pub_def_fun_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1156 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_non_pub_def_fun_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1107 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_numeric_limits_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1121 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_numeric_limits_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1024 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_override_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1032 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_override_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      969 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1060 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_pointer_traits_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1074 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_pointer_traits_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1060 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_ref_qualifiers_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1074 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_ref_qualifiers_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1042 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_sfinae_expr_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1053 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_sfinae_expr_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1085 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_smart_ptr_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1094 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_smart_ptr_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1030 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_std_align_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1039 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_std_align_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1048 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_thread_local_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1060 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_thread_local_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1102 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_trailing_result_types_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1123 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_trailing_result_types_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1084 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_unrestricted_union_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1102 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_unrestricted_union_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1131 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_user_lit_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1152 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx11_user_lit_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1066 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx14_binary_literals_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1081 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx14_binary_literals_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1030 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx14_constexpr_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1039 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx14_constexpr_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1054 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx14_decltype_auto_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1067 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx14_decltype_auto_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1070 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx14_digit_separator_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1086 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx14_digit_separator_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      970 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx14_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1064 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx14_generic_lambda_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1079 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx14_generic_lambda_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1072 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx14_hdr_shared_mutex_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx14_hdr_shared_mutex_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1112 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx14_lambda_capture_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1139 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx14_lambda_capture_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1058 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx14_member_init_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1073 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx14_member_init_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      969 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx14_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1090 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx14_return_type_ded_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1111 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx14_return_type_ded_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1039 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx14_std_exchange_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1051 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx14_std_exchange_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1066 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx14_var_templ_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1084 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx14_var_templ_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1073 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_deduction_guides_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1089 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_deduction_guides_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      970 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1072 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_fold_expressions_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_fold_expressions_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1018 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_hdr_any_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1025 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_hdr_any_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1054 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_hdr_char_conv_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1067 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_hdr_char_conv_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1048 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_hdr_charconv_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1060 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_hdr_charconv_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1054 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_hdr_execution_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1067 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_hdr_execution_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1060 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_hdr_filesystem_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1074 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_hdr_filesystem_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1090 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_hdr_memory_resource_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1109 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_hdr_memory_resource_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1048 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_hdr_optional_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1060 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_hdr_optional_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1066 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_hdr_string_view_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1081 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_hdr_string_view_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1042 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_hdr_variant_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1053 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_hdr_variant_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1048 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_if_constexpr_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1060 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_if_constexpr_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1072 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_inline_variables_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_inline_variables_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1066 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_iterator_traits_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1081 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_iterator_traits_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      969 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1030 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_std_apply_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1039 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_std_apply_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1030 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_std_invoke_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1040 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_std_invoke_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1090 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_structured_bindings_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1109 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx17_structured_bindings_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1042 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx20_hdr_barrier_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1053 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx20_hdr_barrier_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1018 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx20_hdr_bit_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1025 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx20_hdr_bit_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1042 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx20_hdr_compare_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1053 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx20_hdr_compare_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1048 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx20_hdr_concepts_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1060 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx20_hdr_concepts_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1054 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx20_hdr_coroutine_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1067 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx20_hdr_coroutine_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1036 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx20_hdr_format_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1046 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx20_hdr_format_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1030 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx20_hdr_latch_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1039 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx20_hdr_latch_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1042 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx20_hdr_numbers_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1053 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx20_hdr_numbers_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1036 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx20_hdr_ranges_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1046 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx20_hdr_ranges_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1054 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx20_hdr_semaphore_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1067 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx20_hdr_semaphore_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1090 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx20_hdr_source_location_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1109 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx20_hdr_source_location_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1024 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx20_hdr_span_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1032 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx20_hdr_span_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1060 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx20_hdr_stop_token_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1074 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx20_hdr_stop_token_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1060 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx20_hdr_syncstream_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1074 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx20_hdr_syncstream_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1043 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx20_hdr_version_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1054 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx20_hdr_version_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1018 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx98_binders_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1025 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx98_binders_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1054 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx98_function_base_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1067 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx98_function_base_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1060 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx98_random_shuffle_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1074 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx98_random_shuffle_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1111 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx_hdr_functional_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1125 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_cxx_hdr_functional_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1012 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_decltype_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1048 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_decltype_n3276_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1062 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_decltype_n3276_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1020 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_decltype_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      992 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_ded_typename_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      999 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_ded_typename_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1078 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_defaulted_functions_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1097 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_defaulted_functions_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1066 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_deleted_functions_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1083 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_deleted_functions_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1060 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_dep_nested_class_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1082 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_dep_nested_class_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1118 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_dep_val_param_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1156 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_dep_val_param_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1026 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_excep_std_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1043 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_excep_std_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      976 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_exceptions_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      980 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_exceptions_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1092 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_exp_func_tem_arg_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1122 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_exp_func_tem_arg_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1112 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_explicit_cvt_ops_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1141 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_explicit_cvt_ops_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1054 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_extern_template_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1069 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_extern_template_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      878 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_fenv_h_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      878 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_fenv_h_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1204 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_fixed_len_variadic_templates_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1250 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_fixed_len_variadic_templates_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1048 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_func_tmp_order_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1068 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_func_tmp_order_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1144 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_function_template_default_args_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1174 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_function_template_default_args_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1068 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_function_type_spec_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1091 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_function_type_spec_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1028 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_i64_limits_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1045 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_i64_limits_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1064 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_inline_memb_init_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1087 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_inline_memb_init_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1012 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_integral_int64_t_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1022 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_integral_int64_t_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      952 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_iosfwd_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      952 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_iosfwd_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      964 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_iostream_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      966 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_iostream_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      982 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_is_abstract_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      987 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_is_abstract_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1068 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_iter_construct_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1093 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_iter_construct_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1006 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_lambdas_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1013 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_lambdas_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1064 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_limits_const_exp_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1087 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_limits_const_exp_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      952 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_limits_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      952 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_limits_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1030 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_ll_limits_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1048 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_ll_limits_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      994 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_long_long_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      997 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_long_long_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1066 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_mem_func_spec_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1091 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_mem_func_spec_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1038 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_mem_tem_keyword_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1055 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_mem_tem_keyword_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_mem_tem_pnts_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1119 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_mem_tem_pnts_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1038 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_mem_templ_frnds_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1055 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_mem_templ_frnds_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1006 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_mem_templates_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1016 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_mem_templates_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1042 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_nested_friendship_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1053 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_nested_friendship_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1012 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_noexcept_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1020 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_noexcept_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1006 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_nullptr_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1013 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_nullptr_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1036 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_ops_in_namespace_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1052 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_ops_in_namespace_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1206 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_part_spec_def_args_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1244 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_part_spec_def_args_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1064 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_partial_spec_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1089 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_partial_spec_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1024 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_priv_aggregate_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1038 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_priv_aggregate_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1034 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_ptr_mem_const_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1051 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_ptr_mem_const_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1054 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_range_based_for_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1069 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_range_based_for_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1036 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_raw_literals_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1048 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_raw_literals_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1054 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_restrict_references_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1067 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_restrict_references_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1042 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_ret_det_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1064 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_ret_det_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1018 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_rtti_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1016 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_rtti_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1066 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_rvalue_references_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1083 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_rvalue_references_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1036 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_scoped_enums_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1048 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_scoped_enums_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1006 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_sfinae_expr_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1011 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_sfinae_expr_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      952 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_sfinae_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      952 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_sfinae_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      978 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_sstream_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      984 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_sstream_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1042 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_static_assert_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1055 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_static_assert_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      994 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_std_allocator_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1001 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_std_allocator_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      988 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_std_distance_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      994 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_std_distance_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1022 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_std_iter_traits_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1035 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_std_iter_traits_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      988 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_std_iterator_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      994 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_std_iterator_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      976 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_std_locale_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      980 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_std_locale_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      988 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_std_messages_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      994 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_std_messages_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      982 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_std_min_max_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      987 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_std_min_max_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1046 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_std_oi_assign_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1066 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_std_oi_assign_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      988 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_std_typeinfo_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      994 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_std_typeinfo_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      994 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_std_use_facet_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1001 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_std_use_facet_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1000 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_std_wstreambuf_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1008 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_std_wstreambuf_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      982 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_std_wstring_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      987 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_std_wstring_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1000 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_stdc_namespace_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1008 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_stdc_namespace_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      964 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_swprintf_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      966 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_swprintf_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1122 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_tem_local_classes_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1153 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_tem_local_classes_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1060 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_template_aliases_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1076 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_template_aliases_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1102 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_template_streams_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1115 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_template_streams_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1022 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_template_template_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1034 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_template_template_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1032 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_two_phase_lookup_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1047 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_two_phase_lookup_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      952 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_typeid_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      952 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_typeid_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1048 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_typename_with_ctor_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1060 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_typename_with_ctor_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1060 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_unicode_literals_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1076 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_unicode_literals_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1158 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_unified_init_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1187 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_unified_init_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1108 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_using_breaks_adl_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1142 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_using_breaks_adl_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1134 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_using_decl_overld_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1174 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_using_decl_overld_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1000 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_using_template_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1008 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_using_template_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1108 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_variadic_macros_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1123 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_variadic_macros_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1072 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_variadic_templates_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1090 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_variadic_templates_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      988 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_void_returns_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      994 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_void_returns_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      998 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_wchar_t_fail.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1009 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/no_wchar_t_pass.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      456 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/pragma_message_test.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      474 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/symbol_deprecated_test.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      429 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/test.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.590948 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/threads/
--rw-r--r--   0 runner    (1001) docker     (123)      405 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/threads/test_thread_fail1.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      462 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/test/threads/test_thread_fail2.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.590948 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/tools/
--rw-r--r--   0 runner    (1001) docker     (123)      371 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/tools/Jamfile.v2
--rw-r--r--   0 runner    (1001) docker     (123)     9935 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/tools/configure.in
--rw-r--r--   0 runner    (1001) docker     (123)    27756 2023-06-15 08:43:43.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/tools/generate.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.594948 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.594948 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/.circleci/
--rw-r--r--   0 runner    (1001) docker     (123)    11257 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/.circleci/config.yml
--rw-r--r--   0 runner    (1001) docker     (123)      706 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/.clang-format
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.594948 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/.drone/
--rwxr-xr-x   0 runner    (1001) docker     (123)       14 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/.drone/after-success.sh
--rwxr-xr-x   0 runner    (1001) docker     (123)       14 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/.drone/before-install.sh
--rwxr-xr-x   0 runner    (1001) docker     (123)       14 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/.drone/before-script.sh
--rwxr-xr-x   0 runner    (1001) docker     (123)     1818 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/.drone/boost.sh
--rw-r--r--   0 runner    (1001) docker     (123)    52843 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/.drone.star
--rw-r--r--   0 runner    (1001) docker     (123)      107 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/.git
--rw-r--r--   0 runner    (1001) docker     (123)     3917 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/.gitattributes
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.294947 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/.github/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.594948 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/.github/workflows/
--rw-r--r--   0 runner    (1001) docker     (123)    22563 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/.github/workflows/multiprecision.yml
--rw-r--r--   0 runner    (1001) docker     (123)      366 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/.gitignore
--rw-r--r--   0 runner    (1001) docker     (123)     1427 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1338 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/LICENSE
--rw-r--r--   0 runner    (1001) docker     (123)     4857 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/README.md
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.598948 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/config/
--rw-r--r--   0 runner    (1001) docker     (123)     3218 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/config/Jamfile.v2
--rw-r--r--   0 runner    (1001) docker     (123)      307 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/config/has_big_obj.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      395 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/config/has_constexpr_limits_cmd.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      350 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/config/has_eigen.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      271 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/config/has_f2c.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      510 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/config/has_float128.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      971 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/config/has_gmp.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      332 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/config/has_intel_quad.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1860 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/config/has_is_constant_evaluated.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1593 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/config/has_mpc.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1626 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/config/has_mpfi.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1273 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/config/has_mpfr.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      337 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/config/has_tommath.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      339 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/config/is_ci_sanitizer_run.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.618949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/
--rw-r--r--   0 runner    (1001) docker     (123)     4227 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/Jamfile.v2
--rw-r--r--   0 runner    (1001) docker     (123)    18899 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/debugger1.png
--rw-r--r--   0 runner    (1001) docker     (123)    29907 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/debugger2.png
--rw-r--r--   0 runner    (1001) docker     (123)    18453 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/debugger3.png
--rw-r--r--   0 runner    (1001) docker     (123)    18225 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/debugger4.png
--rw-r--r--   0 runner    (1001) docker     (123)    18600 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/debugger5.png
--rw-r--r--   0 runner    (1001) docker     (123)    40879 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/debugger6.png
--rw-r--r--   0 runner    (1001) docker     (123)    37343 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/debugger7.png
--rw-r--r--   0 runner    (1001) docker     (123)     3227 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/floating_point_eg1.mml
--rw-r--r--   0 runner    (1001) docker     (123)    10150 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/floating_point_eg1.png
--rw-r--r--   0 runner    (1001) docker     (123)    15786 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/floating_point_eg1.svg
--rw-r--r--   0 runner    (1001) docker     (123)     3500 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/floating_point_eg2.mml
--rw-r--r--   0 runner    (1001) docker     (123)     7972 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/floating_point_eg2.png
--rw-r--r--   0 runner    (1001) docker     (123)    15997 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/floating_point_eg2.svg
--rw-r--r--   0 runner    (1001) docker     (123)     1103 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/floating_point_eg3.mml
--rw-r--r--   0 runner    (1001) docker     (123)     3623 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/floating_point_eg3.png
--rw-r--r--   0 runner    (1001) docker     (123)     5407 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/floating_point_eg3.svg
--rwxr-xr-x   0 runner    (1001) docker     (123)      947 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/generate.sh
--rw-r--r--   0 runner    (1001) docker     (123)    37926 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/history.qbk
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.618949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.618949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.618949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/indexes/
--rw-r--r--   0 runner    (1001) docker     (123)   108941 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/indexes/s01.html
--rw-r--r--   0 runner    (1001) docker     (123)    19637 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/indexes/s02.html
--rw-r--r--   0 runner    (1001) docker     (123)     2777 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/indexes/s03.html
--rw-r--r--   0 runner    (1001) docker     (123)   203367 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/indexes/s04.html
--rw-r--r--   0 runner    (1001) docker     (123)     3181 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/indexes.html
--rw-r--r--   0 runner    (1001) docker     (123)    48654 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/intro.html
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.622949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/map/
--rw-r--r--   0 runner    (1001) docker     (123)     3681 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/map/ack.html
--rw-r--r--   0 runner    (1001) docker     (123)    10319 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/map/faq.html
--rw-r--r--   0 runner    (1001) docker     (123)    67203 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/map/hist.html
--rw-r--r--   0 runner    (1001) docker     (123)    11496 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/map/todo.html
--rw-r--r--   0 runner    (1001) docker     (123)     3193 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/map.html
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.622949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/perf/
--rw-r--r--   0 runner    (1001) docker     (123)    55959 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/perf/float_performance.html
--rw-r--r--   0 runner    (1001) docker     (123)    11556 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/perf/int_real_world.html
--rw-r--r--   0 runner    (1001) docker     (123)   165051 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/perf/integer_performance.html
--rw-r--r--   0 runner    (1001) docker     (123)     9264 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/perf/overhead.html
--rw-r--r--   0 runner    (1001) docker     (123)    62518 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/perf/rational_performance.html
--rw-r--r--   0 runner    (1001) docker     (123)    62103 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/perf/rational_real_world.html
--rw-r--r--   0 runner    (1001) docker     (123)    14099 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/perf/realworld.html
--rw-r--r--   0 runner    (1001) docker     (123)     6952 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/perf.html
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.626948 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/ref/
--rw-r--r--   0 runner    (1001) docker     (123)   258592 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/ref/backendconc.html
--rw-r--r--   0 runner    (1001) docker     (123)    18104 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/ref/cpp_bin_float_ref.html
--rw-r--r--   0 runner    (1001) docker     (123)     7148 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/ref/cpp_dec_ref.html
--rw-r--r--   0 runner    (1001) docker     (123)    24148 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/ref/cpp_int_ref.html
--rw-r--r--   0 runner    (1001) docker     (123)     4787 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/ref/gmp_int_ref.html
--rw-r--r--   0 runner    (1001) docker     (123)    11708 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/ref/headers.html
--rw-r--r--   0 runner    (1001) docker     (123)     9674 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/ref/internals.html
--rw-r--r--   0 runner    (1001) docker     (123)     7530 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/ref/mpf_ref.html
--rw-r--r--   0 runner    (1001) docker     (123)     7667 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/ref/mpfr_ref.html
--rw-r--r--   0 runner    (1001) docker     (123)   194861 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/ref/number.html
--rw-r--r--   0 runner    (1001) docker     (123)     4789 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/ref/tom_int_ref.html
--rw-r--r--   0 runner    (1001) docker     (123)     3824 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/ref.html
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.630949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.630949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/complex/
--rw-r--r--   0 runner    (1001) docker     (123)    41220 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/complex/complex128.html
--rw-r--r--   0 runner    (1001) docker     (123)     4107 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/complex/complex_adaptor.html
--rw-r--r--   0 runner    (1001) docker     (123)    55212 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/complex/cpp_complex.html
--rw-r--r--   0 runner    (1001) docker     (123)    49148 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/complex/mpc_complex.html
--rw-r--r--   0 runner    (1001) docker     (123)     7202 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/complex.html
--rw-r--r--   0 runner    (1001) docker     (123)    21373 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/conversions.html
--rw-r--r--   0 runner    (1001) docker     (123)    12869 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/eigen.html
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.634949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/floats/
--rw-r--r--   0 runner    (1001) docker     (123)    26086 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/floats/cpp_bin_float.html
--rw-r--r--   0 runner    (1001) docker     (123)    18322 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/floats/cpp_dec_float.html
--rw-r--r--   0 runner    (1001) docker     (123)    33232 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/floats/float128.html
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.634949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/floats/fp_eg/
--rw-r--r--   0 runner    (1001) docker     (123)    12657 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/floats/fp_eg/aos.html
--rw-r--r--   0 runner    (1001) docker     (123)    24139 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/floats/fp_eg/caveats.html
--rw-r--r--   0 runner    (1001) docker     (123)     8282 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/floats/fp_eg/floatbuiltinctor.html
--rw-r--r--   0 runner    (1001) docker     (123)    15447 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/floats/fp_eg/gauss_lagerre_quadrature.html
--rw-r--r--   0 runner    (1001) docker     (123)    20423 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/floats/fp_eg/gi.html
--rw-r--r--   0 runner    (1001) docker     (123)    28875 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/floats/fp_eg/jel.html
--rw-r--r--   0 runner    (1001) docker     (123)    23337 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/floats/fp_eg/nd.html
--rw-r--r--   0 runner    (1001) docker     (123)    25321 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/floats/fp_eg/poly_eg.html
--rw-r--r--   0 runner    (1001) docker     (123)    32716 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/floats/fp_eg/variable_precision.html
--rw-r--r--   0 runner    (1001) docker     (123)     4003 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/floats/fp_eg.html
--rw-r--r--   0 runner    (1001) docker     (123)    19383 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/floats/gmp_float.html
--rw-r--r--   0 runner    (1001) docker     (123)    26847 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/floats/mpfr_float.html
--rw-r--r--   0 runner    (1001) docker     (123)    10248 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/floats.html
--rw-r--r--   0 runner    (1001) docker     (123)    65635 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/fwd.html
--rw-r--r--   0 runner    (1001) docker     (123)    20566 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/gen_int.html
--rw-r--r--   0 runner    (1001) docker     (123)     8927 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/hash.html
--rw-r--r--   0 runner    (1001) docker     (123)    29163 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/import_export.html
--rw-r--r--   0 runner    (1001) docker     (123)    16226 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/input_output.html
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.634949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/interval/
--rw-r--r--   0 runner    (1001) docker     (123)    39400 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/interval/mpfi.html
--rw-r--r--   0 runner    (1001) docker     (123)     3310 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/interval.html
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.638949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/ints/
--rw-r--r--   0 runner    (1001) docker     (123)    42653 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/ints/cpp_int.html
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.638949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/ints/egs/
--rw-r--r--   0 runner    (1001) docker     (123)     8116 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/ints/egs/bitops.html
--rw-r--r--   0 runner    (1001) docker     (123)    15762 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/ints/egs/factorials.html
--rw-r--r--   0 runner    (1001) docker     (123)     3077 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/ints/egs.html
--rw-r--r--   0 runner    (1001) docker     (123)    12544 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/ints/gmp_int.html
--rw-r--r--   0 runner    (1001) docker     (123)    13430 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/ints/tom_int.html
--rw-r--r--   0 runner    (1001) docker     (123)     6816 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/ints.html
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.638949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/limits/
--rw-r--r--   0 runner    (1001) docker     (123)    62313 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/limits/constants.html
--rw-r--r--   0 runner    (1001) docker     (123)    64536 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/limits/functions.html
--rw-r--r--   0 runner    (1001) docker     (123)    15920 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/limits/how_to_tell.html
--rw-r--r--   0 runner    (1001) docker     (123)    44538 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/limits/limits32.html
--rw-r--r--   0 runner    (1001) docker     (123)     6325 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/limits.html
--rw-r--r--   0 runner    (1001) docker     (123)    48975 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/lits.html
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.638949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/misc/
--rw-r--r--   0 runner    (1001) docker     (123)     8756 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/misc/debug_adaptor.html
--rw-r--r--   0 runner    (1001) docker     (123)    38509 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/misc/logged_adaptor.html
--rw-r--r--   0 runner    (1001) docker     (123)     7109 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/misc/visualizers.html
--rw-r--r--   0 runner    (1001) docker     (123)     3392 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/misc.html
--rw-r--r--   0 runner    (1001) docker     (123)    50978 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/mixed.html
--rw-r--r--   0 runner    (1001) docker     (123)     9768 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/new_backend.html
--rw-r--r--   0 runner    (1001) docker     (123)    14414 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/primetest.html
--rw-r--r--   0 runner    (1001) docker     (123)    38949 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/random.html
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.638949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/rational/
--rw-r--r--   0 runner    (1001) docker     (123)     3557 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/rational/br.html
--rw-r--r--   0 runner    (1001) docker     (123)    11245 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/rational/cpp_rational.html
--rw-r--r--   0 runner    (1001) docker     (123)    14067 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/rational/gmp_rational.html
--rw-r--r--   0 runner    (1001) docker     (123)     5506 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/rational/rational_adaptor.html
--rw-r--r--   0 runner    (1001) docker     (123)    12044 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/rational/tommath_rational.html
--rw-r--r--   0 runner    (1001) docker     (123)    12063 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/rational/tommath_rational0.html
--rw-r--r--   0 runner    (1001) docker     (123)     8630 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/rational.html
--rw-r--r--   0 runner    (1001) docker     (123)     7439 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/rounding.html
--rw-r--r--   0 runner    (1001) docker     (123)     4083 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/serial.html
--rw-r--r--   0 runner    (1001) docker     (123)    60116 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut/variable.html
--rw-r--r--   0 runner    (1001) docker     (123)    10349 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/boost_multiprecision/tut.html
--rw-r--r--   0 runner    (1001) docker     (123)    14183 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/index.html
--rw-r--r--   0 runner    (1001) docker     (123)     5791 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/multiprecision.css
--rw-r--r--   0 runner    (1001) docker     (123)     3988 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html/standalone_HTML.manifest
--rw-r--r--   0 runner    (1001) docker     (123)    14819 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/html4_symbols.qbk
--rw-r--r--   0 runner    (1001) docker     (123)      629 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/index.idx
--rw-r--r--   0 runner    (1001) docker     (123)    17008 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/introduction.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     5947 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/multiprecision.css
--rw-r--r--   0 runner    (1001) docker     (123)     8194 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/multiprecision.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     4265 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/numeric_limits_32_tables.qbk
--rw-r--r--   0 runner    (1001) docker     (123)    29478 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/numeric_limits_qbk.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2995 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/performance.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     8756 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/performance_float.qbk
--rw-r--r--   0 runner    (1001) docker     (123)    25203 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/performance_integer.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     2802 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/performance_integer_real_world.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     2149 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/performance_overhead.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     8778 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/performance_rational.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     6704 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/performance_rational_real_world.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     2569 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/performance_real_world.qbk
--rw-r--r--   0 runner    (1001) docker     (123)      715 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/reference.qbk
--rw-r--r--   0 runner    (1001) docker     (123)    44600 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/reference_backend_requirements.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     6136 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/reference_cpp_bin_float.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     1788 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/reference_cpp_dec_float.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     5786 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/reference_cpp_int.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     1733 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/reference_gmp_float.qbk
--rw-r--r--   0 runner    (1001) docker     (123)      935 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/reference_gmp_int.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     2392 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/reference_header_structure.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     2092 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/reference_internal_support.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     1838 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/reference_mpfr_float.qbk
--rw-r--r--   0 runner    (1001) docker     (123)    55253 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/reference_number.qbk
--rw-r--r--   0 runner    (1001) docker     (123)      947 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/reference_tom_int.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     1480 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     1956 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_boost_rational.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     1272 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_complex.qbk
--rw-r--r--   0 runner    (1001) docker     (123)      719 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_complex_adaptor.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     8849 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_constexpr.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     6711 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_conversions.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     5470 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_cpp_bin_float.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     6153 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_cpp_complex.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     3912 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_cpp_dec_float.qbk
--rw-r--r--   0 runner    (1001) docker     (123)    12036 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_cpp_int.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     1642 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_cpp_rational.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     2262 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_debug_adaptor.qbk
--rw-r--r--   0 runner    (1001) docker     (123)      724 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_eigen.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     4098 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_float128.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     2380 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_float128_complex.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     2149 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_float_builtin_ctor.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     4495 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_float_eg.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     1720 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_floats.qbk
--rw-r--r--   0 runner    (1001) docker     (123)    11482 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_fwd.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     3339 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_gmp_float.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     2224 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_gmp_int.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     2053 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_gmp_rational.qbk
--rw-r--r--   0 runner    (1001) docker     (123)      402 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_hash.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     5275 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_import_export.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     1166 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_integer.qbk
--rw-r--r--   0 runner    (1001) docker     (123)      526 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_integer_examples.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     3534 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_integer_ops.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     7007 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_interval_mpfi.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     5053 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_io.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     3402 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_logged_adaptor.qbk
--rw-r--r--   0 runner    (1001) docker     (123)      573 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_misc_backends.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     8599 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_mixed_precision.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     4050 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_mpc_complex.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     5142 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_mpfr_float.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     3111 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_new_backend.qbk
--rw-r--r--   0 runner    (1001) docker     (123)    29176 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_numeric_limits.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     2123 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_primality.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     3495 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_random.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     1584 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_rational.qbk
--rw-r--r--   0 runner    (1001) docker     (123)      947 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_rational_adaptor.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     1753 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_rounding.qbk
--rw-r--r--   0 runner    (1001) docker     (123)      721 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_serialization.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     1887 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_tommath.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     1956 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_tommath_rational.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     8130 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_variable_precision.qbk
--rw-r--r--   0 runner    (1001) docker     (123)     2094 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_visualizers.qbk
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.646949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/
--rw-r--r--   0 runner    (1001) docker     (123)     6015 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/Jamfile.v2
--rw-r--r--   0 runner    (1001) docker     (123)     7923 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/big_seventh.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     5806 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/complex128_examples.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     9922 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/constexpr_float_arithmetic_examples.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1355 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/cpp_bin_float_import_export.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1384 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/cpp_bin_float_snips.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     5815 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/cpp_complex_examples.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1456 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/cpp_dec_float_snips.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1113 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/cpp_int_import_export.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     7525 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/cpp_int_mul_timing.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1627 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/cpp_int_snips.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      904 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/debug_adaptor_snips.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1487 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/eigen_example.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    15651 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/exercise_threading_log_agm.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     4002 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/float128_snips.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    25152 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/floating_point_examples.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    22324 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/gauss_laguerre_quadrature.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2682 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/gmp_snips.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1842 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/hashing_examples.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    26773 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/hypergeometric_luke_algorithms.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     7357 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/integer_examples.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     4693 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/logged_adaptor.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1367 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/mixed_integer_arithmetic.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     6574 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/mpc_examples.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1375 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/mpfi_snips.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     9370 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/mpfr_precision.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1323 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/mpfr_snips.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    13722 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/numeric_limits_snips.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    11319 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/random_snips.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1442 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/safe_prime.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    15503 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/scoped_precision_example.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    13893 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/standalone_bernoulli_tgamma.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1742 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/tommath_snips.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.298947 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.298947 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.654949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/
--rw-r--r--   0 runner    (1001) docker     (123)      636 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/complex128.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    31669 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/complex_adaptor.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.654949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/concepts/
--rw-r--r--   0 runner    (1001) docker     (123)     8625 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/concepts/mp_number_archetypes.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.654949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_bin_float/
--rw-r--r--   0 runner    (1001) docker     (123)    26429 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_bin_float/io.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     5100 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_bin_float/transcendental.hpp
--rw-r--r--   0 runner    (1001) docker     (123)   105093 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_bin_float.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      446 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_complex.hpp
--rw-r--r--   0 runner    (1001) docker     (123)   167646 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_dec_float.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.658949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/
--rw-r--r--   0 runner    (1001) docker     (123)    22328 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/add.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    14128 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/add_unsigned.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    42474 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/bitwise.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     5242 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/checked.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    19208 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/comparison.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     6805 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/cpp_int_config.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    27075 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/divide.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    12507 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/import_export.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     4280 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/intel_intrinsics.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    26868 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/limits.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    12241 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/literals.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    62061 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/misc.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    45749 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/multiply.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     7244 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/serialize.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      928 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/value_pack.hpp
--rw-r--r--   0 runner    (1001) docker     (123)   103936 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    35019 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/debug_adaptor.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.666949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/
--rw-r--r--   0 runner    (1001) docker     (123)      810 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/assert.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2004 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/atomic.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    10587 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/bitscan.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     3737 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/check_cpp11_config.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2139 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/constexpr.hpp
--rw-r--r--   0 runner    (1001) docker     (123)   239455 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/default_ops.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1343 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/digits.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1772 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/dynamic_array.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2568 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/empty_value.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1360 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/endian.hpp
--rw-r--r--   0 runner    (1001) docker     (123)   121893 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/et_ops.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2660 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/float128_functions.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     9240 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/float_string_cvt.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     3690 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/fpclassify.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.666949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/functions/
--rw-r--r--   0 runner    (1001) docker     (123)    11774 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/functions/constants.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    27767 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/functions/pow.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    32274 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/functions/trig.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1946 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/functions/trunc.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    26407 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/generic_interconvert.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1415 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/hash.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    18164 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/integer_ops.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1101 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/itos.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     5048 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/min_max.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    34948 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/no_et_ops.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1869 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/no_exceptions_support.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    72522 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/number_base.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    51232 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/number_compare.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    13298 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/precision.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      730 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/rebind.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     4625 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/standalone_config.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1456 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/static_array.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1446 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/string_helpers.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     6727 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/tables.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     4325 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/ublas_interop.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     6223 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/uniform_int_distribution.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     6001 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/utype_helper.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    13883 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/eigen.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    37229 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/float128.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    12594 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/fwd.hpp
--rw-r--r--   0 runner    (1001) docker     (123)   146941 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/gmp.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    12039 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/integer.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    42804 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/logged_adaptor.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     6412 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/miller_rabin.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    61210 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/mpc.hpp
--rw-r--r--   0 runner    (1001) docker     (123)   115307 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/mpfi.hpp
--rw-r--r--   0 runner    (1001) docker     (123)   204893 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/mpfr.hpp
--rw-r--r--   0 runner    (1001) docker     (123)   120836 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/number.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      777 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/random.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    39529 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/rational_adaptor.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    37350 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/tommath.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.666949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/traits/
--rw-r--r--   0 runner    (1001) docker     (123)     2480 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/traits/explicit_conversion.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      743 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/traits/extract_exponent_type.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2842 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/traits/is_backend.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1609 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/traits/is_byte_container.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      717 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/traits/is_complex.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1854 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/traits/is_convertible_arithmetic.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2533 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/traits/is_restricted_conversion.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      851 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/traits/is_variable_precision.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2896 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/traits/max_digits10.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2563 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/traits/std_integer_traits.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      621 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/traits/transcendental_reduction_type.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      558 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/index.html
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.670949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/meta/
--rw-r--r--   0 runner    (1001) docker     (123)      453 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/meta/libraries.json
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.678949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/
--rw-r--r--   0 runner    (1001) docker     (123)    14642 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/Jamfile.v2
--rw-r--r--   0 runner    (1001) docker     (123)    26000 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/arithmetic_backend.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     4412 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/cpp_bin_float_conversion_performance.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     9520 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/delaunay_test.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2298 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/delaunay_test.log
--rw-r--r--   0 runner    (1001) docker     (123)     7054 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/gcd_bench.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    34846 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/linpack-benchmark.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1876 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/miller_rabin_performance.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2481 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/miller_rabin_performance.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1649 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/miller_rabin_performance.log
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.678949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/miller_rabin_performance_files/
--rw-r--r--   0 runner    (1001) docker     (123)      479 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/miller_rabin_performance_files/test01.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      426 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/miller_rabin_performance_files/test02.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      465 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/miller_rabin_performance_files/test03.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      465 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/miller_rabin_performance_files/test04.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      465 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/miller_rabin_performance_files/test05.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      467 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/miller_rabin_performance_files/test06.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      432 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/miller_rabin_performance_files/test07.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      448 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/miller_rabin_performance_files/test08.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      465 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/miller_rabin_performance_files/test09.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      528 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/miller_rabin_performance_files/test10.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      496 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/miller_rabin_performance_files/test11.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      449 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/miller_rabin_performance_files/test12.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     8314 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/mixed_equivalent_types_bench.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    33287 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test-gcc-linux.log
--rw-r--r--   0 runner    (1001) docker     (123)    20844 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test-intel-linux.log
--rw-r--r--   0 runner    (1001) docker     (123)    57569 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test-msvc-10.log
--rw-r--r--   0 runner    (1001) docker     (123)     5781 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    26585 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test.hpp
--rw-r--r--   0 runner    (1001) docker     (123)   138507 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test.log
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.690949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/
--rw-r--r--   0 runner    (1001) docker     (123)      377 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test01.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      462 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test02.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      464 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test03.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      464 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test04.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      456 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test05.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      456 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test06.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      456 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test07.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      457 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test08.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1099 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test09.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      637 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test10.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      637 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test11.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      640 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test12.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      468 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test13.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      468 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      468 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test15.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      469 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test16.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      496 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      496 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test18.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      496 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test19.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      497 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test20.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      466 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test21.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      466 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test22.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      466 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test23.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      467 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test24.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      472 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test25.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      472 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test26.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      472 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test27.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      811 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test28.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      500 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test29.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      502 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test30.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      536 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test31.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      500 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test32.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      502 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test33.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      536 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test34.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      467 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test35.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      467 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test36.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      469 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test37.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      469 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test38.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      459 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test39.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      459 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test40.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      607 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test41.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      473 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test42.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      813 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test43.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      813 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test44.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      473 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test45.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      473 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test46.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      474 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test47.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      813 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test48.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      814 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test49.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      459 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test50.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      460 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test51.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3336 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/rational_bernoulli_allocations.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3751 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/rational_bernoulli_allocations.log
--rw-r--r--   0 runner    (1001) docker     (123)     2054 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/rational_bernoulli_bench.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    25575 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/rational_bernoulli_bench.log
--rw-r--r--   0 runner    (1001) docker     (123)     4054 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/rational_determinant_bench.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2424 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/rational_determinant_bench.log
--rw-r--r--   0 runner    (1001) docker     (123)     1283 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/rational_zeta18_bench.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2877 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance-msvc-10.log
--rw-r--r--   0 runner    (1001) docker     (123)     2719 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     6907 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    11229 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance.log
--rw-r--r--   0 runner    (1001) docker     (123)      487 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_basic.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1693 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_bessel.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.702949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/
--rw-r--r--   0 runner    (1001) docker     (123)      460 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_basic_1.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      448 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_basic_2.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      397 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_basic_3.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      397 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_basic_4.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      480 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_basic_5.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      447 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_basic_6.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      396 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_basic_7.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      396 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_basic_8.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1350 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_basic_9.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      676 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_01.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      733 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_02.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      726 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_03.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      780 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_04.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      438 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_05.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      481 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_06.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      456 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_07.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      456 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_08.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      469 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_09.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      469 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_10.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      441 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_11.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      492 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_12.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      455 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_13.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      438 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      481 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_15.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      456 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_16.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      456 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      439 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_18.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      439 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_19.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      442 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_01.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      493 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_02.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      456 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_03.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      439 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_04.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      482 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_05.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      391 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_06.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      457 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_07.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      460 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_08.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      442 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_09.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      442 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_10.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      445 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_11.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      496 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_12.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      459 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_13.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      442 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      485 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_15.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      392 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_16.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      460 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      460 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_18.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      443 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_19.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      443 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_20.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      445 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_01.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      496 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_02.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      459 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_03.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      442 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_04.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      485 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_05.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      460 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_06.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      460 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_07.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      445 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_08.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      445 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_09.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      448 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_10.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      498 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_11.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      462 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_12.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      445 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_13.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      488 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      463 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_15.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      463 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_16.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      446 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      446 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_18.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1474 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_nct.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1634 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_poly.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3716 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sqrt_bench.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1072 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/veronoi_performance.log
--rw-r--r--   0 runner    (1001) docker     (123)     8396 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/voronoi_performance.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.710949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/plots/
--rw-r--r--   0 runner    (1001) docker     (123)    89122 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/plots/cpp_bin_float_acos.png
--rw-r--r--   0 runner    (1001) docker     (123)     2005 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/plots/cpp_bin_float_acos_errors.cpp
--rw-r--r--   0 runner    (1001) docker     (123)   256514 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/plots/cpp_bin_float_asin.png
--rw-r--r--   0 runner    (1001) docker     (123)     1996 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/plots/cpp_bin_float_asin_errors.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    30207 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/plots/cpp_bin_float_atan.png
--rw-r--r--   0 runner    (1001) docker     (123)     1960 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/plots/cpp_bin_float_atan_errors.cpp
--rw-r--r--   0 runner    (1001) docker     (123)   301539 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/plots/cpp_bin_float_cos.png
--rw-r--r--   0 runner    (1001) docker     (123)     1950 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/plots/cpp_bin_float_cos_errors.cpp
--rw-r--r--   0 runner    (1001) docker     (123)   115535 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/plots/cpp_bin_float_erf.png
--rw-r--r--   0 runner    (1001) docker     (123)     2006 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/plots/cpp_bin_float_erf_errors.cpp
--rw-r--r--   0 runner    (1001) docker     (123)   144386 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/plots/cpp_bin_float_erfc.png
--rw-r--r--   0 runner    (1001) docker     (123)     2010 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/plots/cpp_bin_float_erfc_errors.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    88122 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/plots/cpp_bin_float_exp.png
--rw-r--r--   0 runner    (1001) docker     (123)     2009 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/plots/cpp_bin_float_exp_errors.cpp
--rw-r--r--   0 runner    (1001) docker     (123)   309656 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/plots/cpp_bin_float_log.png
--rw-r--r--   0 runner    (1001) docker     (123)     2005 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/plots/cpp_bin_float_log_errors.cpp
--rw-r--r--   0 runner    (1001) docker     (123)   280495 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/plots/cpp_bin_float_sin.png
--rw-r--r--   0 runner    (1001) docker     (123)     2019 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/plots/cpp_bin_float_sin_errors.cpp
--rw-r--r--   0 runner    (1001) docker     (123)   261156 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/plots/cpp_bin_float_tan.png
--rw-r--r--   0 runner    (1001) docker     (123)     1950 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/plots/cpp_bin_float_tan_errors.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2018 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/plots/cpp_bin_float_tgamma_errors.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.778949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/
--rw-r--r--   0 runner    (1001) docker     (123)    93892 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/Jamfile.v2
--rw-r--r--   0 runner    (1001) docker     (123)     1110 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/bug11922.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1570 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/bug12039.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.802950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/
--rw-r--r--   0 runner    (1001) docker     (123)      442 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_01.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      400 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_02.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      400 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_03.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      400 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_04.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      400 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_05.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      399 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_06.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      399 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_07.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      407 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_08.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      400 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_09.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      400 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_10.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      400 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_11.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      400 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_12.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      400 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_13.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      400 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      400 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_15.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      400 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_16.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      487 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_18.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      491 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_20.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      492 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_21.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      492 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_22.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      492 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_23.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      492 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_24.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      492 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_25.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      492 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_26.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      492 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_27.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      492 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_28.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      405 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_29.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      405 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_30.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      405 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_31.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      405 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_32.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      405 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_33.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      405 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_34.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      405 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_35.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      405 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_36.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      405 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_37.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      405 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_38.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      405 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_39.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      405 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_40.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      405 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_41.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      405 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_42.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      405 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_43.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      405 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_44.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      484 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_45.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      474 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_46.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      495 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_47.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      491 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_48.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      495 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_49.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      488 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_50.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      431 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_51.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      438 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_52.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      407 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_53.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      413 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_54.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      415 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_55.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      409 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_56.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      407 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_57.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      413 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_58.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      450 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/conv_fail_59.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      403 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/cpp_int_complement.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      404 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/cpp_int_negate_1.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      445 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/cpp_int_negate_2.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      476 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/operator_fail_01.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      486 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/operator_fail_02.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      446 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/operator_fail_03.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      446 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/operator_fail_04.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      446 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/operator_fail_05.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      446 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/operator_fail_06.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      449 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/operator_fail_07.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      449 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/operator_fail_08.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      449 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/operator_fail_09.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      449 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/operator_fail_10.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      449 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/operator_fail_11.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      449 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/operator_fail_12.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      449 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/operator_fail_13.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      449 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/operator_fail_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      450 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/operator_fail_15.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      450 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/operator_fail_16.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      465 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/operator_fail_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      465 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/compile_fail/operator_fail_18.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.806949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/concepts/
--rw-r--r--   0 runner    (1001) docker     (123)     7149 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/concepts/number_concept_check.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     5273 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/concepts/sf_concept_check_basic.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     4395 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/concepts/sf_concept_check_bessel.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     4003 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/concepts/sf_concept_check_beta.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3867 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/concepts/sf_concept_check_beta_2.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3949 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/concepts/sf_concept_check_beta_3.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     4612 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/concepts/sf_concept_check_elliptic.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     4712 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/concepts/sf_concept_check_gamma.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     4372 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/concepts/sf_concept_check_poly.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    11458 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/constexpr_arithmetric_test.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     4490 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/constexpr_test_arithmetic_backend.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3601 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/constexpr_test_cpp_int.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3489 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/constexpr_test_cpp_int_2.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3453 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/constexpr_test_cpp_int_3.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3352 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/constexpr_test_cpp_int_4.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     8408 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/constexpr_test_cpp_int_5.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     6834 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/constexpr_test_cpp_int_6.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     4060 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/constexpr_test_cpp_int_7.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2575 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/constexpr_test_float128.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.806949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/coverage/
--rw-r--r--   0 runner    (1001) docker     (123)    17663 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/coverage/Makefile
--rw-r--r--   0 runner    (1001) docker     (123)    17784 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/eigen.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      643 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/git_issue_167.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2653 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/git_issue_175.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1861 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/git_issue_248.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      861 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/git_issue_265.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      880 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/git_issue_277.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      724 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/git_issue_30.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1521 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/git_issue_313.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1823 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/git_issue_370.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      538 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/git_issue_393.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1220 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/git_issue_426.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      772 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/git_issue_464.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1406 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/git_issue_488.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      641 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/git_issue_506.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      656 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/git_issue_509.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1690 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/git_issue_526.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      908 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/git_issue_540.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1394 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/git_issue_98.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.806949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/include_test/
--rw-r--r--   0 runner    (1001) docker     (123)      383 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/include_test/cpp_bin_float_include_test.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      383 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/include_test/cpp_dec_float_include_test.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      758 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/include_test/cpp_int_include_test.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      406 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/include_test/gmp_include_test.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      367 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/include_test/mpfr_include_test.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      367 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/include_test/tommath_include_test.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2194 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/issue_13148.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2073 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/issue_13301.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2016 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/logged_adaptor_cpp_output_test.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2231 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/logged_adaptor_output_test.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.818950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.822950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/high_prec/
--rw-r--r--   0 runner    (1001) docker     (123)   815090 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/high_prec/gamma.ipp
--rw-r--r--   0 runner    (1001) docker     (123)   164936 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/high_prec/gamma_0.ipp
--rw-r--r--   0 runner    (1001) docker     (123)    68768 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/high_prec/gamma_1_2.ipp
--rw-r--r--   0 runner    (1001) docker     (123)    60642 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/high_prec/gamma_neg.ipp
--rw-r--r--   0 runner    (1001) docker     (123)      375 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/high_prec/readme.txt
--rw-r--r--   0 runner    (1001) docker     (123)     3388 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/high_prec/test_gamma.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2600 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/high_prec/test_gamma.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.822950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/instances/
--rw-r--r--   0 runner    (1001) docker     (123)     3390 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/instances/Jamfile.v2
--rw-r--r--   0 runner    (1001) docker     (123)      476 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/instances/instances.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3616 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/log1p_expm1_test.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3289 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/powm1_sqrtp1m1_test.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      605 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/readme.txt
--rw-r--r--   0 runner    (1001) docker     (123)     7063 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/setup.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1029 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/table_type.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1884 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_bessel_i.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     4591 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_bessel_j.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3476 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_bessel_k.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     5382 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_bessel_y.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3461 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_beta.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3013 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_binomial_coeff.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2612 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_carlson_1.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2286 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_carlson_2.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1990 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_carlson_3.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2056 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_carlson_4.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1452 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_cbrt.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3046 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_digamma.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1801 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_ellint_1.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1481 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_ellint_2.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3755 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_ellint_3.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3294 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_erf.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2908 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_expint.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3582 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_gamma.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1792 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_hermite.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3234 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_ibeta.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3240 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_ibeta_2.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2054 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_ibeta_3.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2284 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_ibeta_4.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2516 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_ibeta_inv_1.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1541 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_ibeta_inv_ab_4.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1794 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_igamma.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2567 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_igamma_inv.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1496 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_igamma_inva.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1490 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_laguerre.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1492 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_legendre.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2108 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_tgamma_ratio.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2261 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/math/test_zeta.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      671 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/no_eh_test_support.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.826949 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/serial_txts/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/serial_txts/boost-no-inspect
--rw-r--r--   0 runner    (1001) docker     (123)   238821 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/serial_txts/cpp_int1024_serial32.txt
--rw-r--r--   0 runner    (1001) docker     (123)   242709 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/serial_txts/cpp_int1024_serial64.txt
--rw-r--r--   0 runner    (1001) docker     (123)    37101 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/serial_txts/cpp_int128_serial32.txt
--rw-r--r--   0 runner    (1001) docker     (123)    40781 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/serial_txts/cpp_int128_serial64.txt
--rw-r--r--   0 runner    (1001) docker     (123)    22257 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/serial_txts/cpp_int64_serial32.txt
--rw-r--r--   0 runner    (1001) docker     (123)    26337 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/serial_txts/cpp_int64_serial64.txt
--rw-r--r--   0 runner    (1001) docker     (123)   563663 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/sincos.ipp
--rw-r--r--   0 runner    (1001) docker     (123)    82527 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/skeleton_backend.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     3511 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/standalone_constexpr_test_cpp_int.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2648 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/standalone_constexpr_test_float128.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      591 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/standalone_test_arithmetic_complex128.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1604 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/standalone_test_arithmetic_cpp_bin_float.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      717 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/standalone_test_arithmetic_cpp_dec_float.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1568 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/standalone_test_arithmetic_cpp_int.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1695 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/standalone_test_arithmetic_cpp_rational.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      549 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/standalone_test_arithmetic_float_128.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      589 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/standalone_test_arithmetic_gmp.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1569 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/standalone_test_arithmetic_int512.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      628 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/standalone_test_arithmetic_mpf_logged_adptr.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      855 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/standalone_test_arithmetic_mpz_rat.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      668 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/standalone_test_arithmetic_tommath.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     6398 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/standalone_test_convert_from_tom_int.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2994 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/standalone_test_miller_rabin.cpp
--rw-r--r--   0 runner    (1001) docker     (123)   112639 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/string_data.ipp
--rw-r--r--   0 runner    (1001) docker     (123)    19579 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     6669 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_acos.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     5710 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_adapt_serial.cpp
--rw-r--r--   0 runner    (1001) docker     (123)   124490 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      535 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_ab_1.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      532 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_ab_2.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      541 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_ab_3.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      811 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_backend_concept.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      547 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_complex128.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      636 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_complex_adaptor.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      638 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_complex_adaptor_2.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1672 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_bin_float_1.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1616 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_bin_float_2.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1665 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_bin_float_2m.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1584 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_bin_float_3.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      826 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_bin_float_4.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      705 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_bin_float_5.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      577 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_complex_dbg_adptr.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      579 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_complex_logged_adptr.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      652 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_dec_float_1.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      728 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_dec_float_2.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      772 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_dec_float_3.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      774 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_dec_float_3m.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1499 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_int_1.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1512 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_int_10.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2044 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_int_11.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2024 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_int_12.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2024 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_int_13.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1631 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_int_14.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2024 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_int_15.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2022 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_int_16.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1878 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_int_17.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2022 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_int_18.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1158 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_int_19.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1500 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_int_2.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1024 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_int_20.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1161 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_int_21.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1299 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_int_22.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      949 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_int_23.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1502 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_int_3.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1660 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_int_4.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1903 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_int_5.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1640 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_int_6.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1626 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_int_7.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1572 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_int_8.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1631 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_int_9.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1584 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_int_br.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1004 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_int_dbg_adptr.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1006 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_int_logged_adptr.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      571 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_rat_dbg_adptr.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      573 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_cpp_rat_logged_adptr.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      637 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_dbg_adptr1.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      639 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_dbg_adptr1m.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      609 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_dbg_adptr2.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      480 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_float_128.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      617 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_logged_1.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      611 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_logged_2.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      689 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_mpc.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      569 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_mpc_dbg_adptr.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      571 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_mpc_logged_adptr.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      947 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_mpf.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      805 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_mpf_50.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      564 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_mpf_dbg_adptr.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      566 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_mpf_logged_adptr.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      723 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_mpfi_50.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      569 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_mpfi_dbg_adptr.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      571 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_mpfi_logged_adptr.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      720 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_mpfr.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      723 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_mpfr_50.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      642 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_mpfr_50_mixed.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      730 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_mpfr_50_static.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      566 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_mpfr_dbg_adptr.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      568 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_mpfr_logged_adptr.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      602 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_mpq.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      567 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_mpq_dbg_adptr.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      569 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_mpq_logged_adptr.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      527 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_mpz.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      898 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_mpz_br.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      562 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_mpz_dbg_adptr.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      564 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_mpz_logged_adptr.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      794 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_mpz_rat.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      473 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_skeleton.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      606 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_tommath.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      903 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_tommath_br.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      916 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_arithmetic_tommath_rat.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     6134 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_asin.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     9284 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_assume_uniform_precision.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    29472 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_atan.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     7177 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_checked_cpp_int.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     4487 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_checked_mixed_cpp_int.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    16731 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_complex.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    87604 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_complex_signed_zero.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    12375 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_constants.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1486 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_constexpr.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3192 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_convert_cpp_int_2_float.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     6455 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_convert_from_cpp_bin_float.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     5917 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_convert_from_cpp_dec_float.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     7113 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_convert_from_cpp_int.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     7086 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_convert_from_cpp_rational.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     6406 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_convert_from_float128.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     7093 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_convert_from_gmp_rational.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     5853 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_convert_from_mpf_float.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     6019 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_convert_from_mpfi_float.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     5695 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_convert_from_mpfr_float.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     6169 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_convert_from_mpz_int.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     6237 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_convert_from_tom_int.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     7095 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_convert_from_tom_rational.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    43151 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_cos.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     5179 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_cos_near_half_pi.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    26473 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_cosh.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    45219 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_cpp_bin_float.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     9877 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_cpp_bin_float_conv.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     9896 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_cpp_bin_float_io.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2860 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_cpp_bin_float_round.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      728 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_cpp_bin_float_serial.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1994 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_cpp_bin_float_tgamma.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      948 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_cpp_dec_float_conv.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1618 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_cpp_dec_float_round.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      775 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_cpp_dec_float_serial.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1994 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_cpp_dec_float_tgamma.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    41217 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_cpp_int.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1926 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_cpp_int_conv.cpp
--rw-r--r--   0 runner    (1001) docker     (123)   225453 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_cpp_int_deserial.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     6202 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_cpp_int_import_export.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     8441 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_cpp_int_karatsuba.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2614 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_cpp_int_left_shift.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2127 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_cpp_int_lit.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     5512 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_cpp_int_serial.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     5183 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_cpp_rat_serial.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    33726 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_cpp_rational.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      505 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_eigen_interop_cpp_bin_float_1.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      509 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_eigen_interop_cpp_bin_float_2.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      509 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_eigen_interop_cpp_bin_float_3.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      450 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_eigen_interop_cpp_complex.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      645 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_eigen_interop_cpp_dec_float.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      651 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_eigen_interop_cpp_dec_float_2.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      651 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_eigen_interop_cpp_dec_float_3.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      548 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_eigen_interop_cpp_int.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      520 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_eigen_interop_gmp.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      475 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_eigen_interop_gmp_2.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      479 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_eigen_interop_mpc.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      460 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_eigen_interop_mpfr_1.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      462 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_eigen_interop_mpfr_2.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      462 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_eigen_interop_mpfr_3.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      463 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_eigen_interop_mpfr_4.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      465 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_eigen_interop_mpfr_5.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      465 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_eigen_interop_mpfr_6.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    16109 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_exp.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     7651 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_fixed_int.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     5799 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_fixed_zero_precision_io.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      569 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_float128_serial.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1644 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_float_conversions.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    13689 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_float_io.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     5854 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_float_serial.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    18754 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_fpclassify.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3779 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_gcd.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     6647 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_generic_conv.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3995 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_gmp_conversions.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2635 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_hash.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     5899 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_int_io.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2287 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_int_sqrt.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    48425 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_log.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2983 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_miller_rabin.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    12671 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_mixed.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1567 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_mixed_cpp_bin_float.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1338 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_mixed_cpp_dec_float.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3879 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_mixed_cpp_int.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1322 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_mixed_float.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     5132 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_mixed_move_cpp_int.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1312 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_mixed_mpf_float.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1349 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_mixed_mpfr_float.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    10096 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_move.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3112 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_mpc_conversions.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2045 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_mpc_overloads.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3609 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_mpf_precisions.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     7866 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_mpfi.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     4636 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_mpfi_precisions.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3090 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_mpfr_conversions.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     9530 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_mpfr_mpc_precisions.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2894 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_native_integer.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1138 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_nothrow_cpp_bin_float.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1129 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_nothrow_cpp_dec_float.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    22976 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_nothrow_cpp_int.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    13704 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_nothrow_cpp_rational.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3084 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_nothrow_float128.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1027 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_nothrow_gmp.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      823 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_nothrow_mpfr.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    10290 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_numeric_limits.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      897 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_optional_compat.cpp
--rw-r--r--   0 runner    (1001) docker     (123)   261775 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_pow.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    16763 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_preserve_all_precision.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    11638 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_preserve_component_precision.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    13168 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_preserve_related_precision.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    11355 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_preserve_source_precision.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     9284 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_preserve_target_precision.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     9145 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_rat_float_interconv.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     4125 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_rational_io.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    25252 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_roots_10k_digits.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    22339 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_round.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    75507 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_sf_import_c99.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     8894 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_signed_zero.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    42710 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_sin.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     5076 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_sin_near_half_pi.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    34263 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_sinh.cpp
--rw-r--r--   0 runner    (1001) docker     (123)   117944 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_sqrt.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    71494 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_tan.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    13999 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_tanh.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2824 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_test.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     5356 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_threaded_precision.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3121 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_trailing_io_delim.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2888 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/test_unchecked_cpp_int.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3377 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/timer.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.834950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.834950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/common/
--rw-r--r--   0 runner    (1001) docker     (123)     3022 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/common/init.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2000 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/common/testhelper.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      545 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test1.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1569 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test1.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     8742 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test11.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    11717 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test12.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    11440 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test13.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2430 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test2.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1947 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test2.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2598 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test21.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     5162 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test22.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     8833 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test23.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      545 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test3.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1815 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test3.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     8159 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test31.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    17593 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test32.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    16070 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test33.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      527 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test4.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1662 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test4.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    18375 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test42.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    11526 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test43.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      527 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test5.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1623 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test5.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    10707 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test52.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     8018 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test53.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      527 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test6.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1572 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test6.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    10749 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test62.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     7895 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test63.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      814 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test7.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1665 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test7.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     6110 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test71.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     7750 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test72.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     7658 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/test/ublas_interop/test73.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.834950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/tools/
--rw-r--r--   0 runner    (1001) docker     (123)     1790 2023-06-15 08:43:44.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/tools/sincos.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.838950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/
--rw-r--r--   0 runner    (1001) docker     (123)      116 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/.clang-format
--rw-r--r--   0 runner    (1001) docker     (123)       94 2023-06-15 08:43:42.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/.git
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.302947 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/.github/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.838950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/.github/ISSUE_TEMPLATE/
--rw-r--r--   0 runner    (1001) docker     (123)     2064 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/.github/ISSUE_TEMPLATE/00-bug_report.yml
--rw-r--r--   0 runner    (1001) docker     (123)     1058 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/.github/ISSUE_TEMPLATE/10-feature_request.yml
--rw-r--r--   0 runner    (1001) docker     (123)      175 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/.github/ISSUE_TEMPLATE/config.yml
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.838950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/.github/workflows/
--rw-r--r--   0 runner    (1001) docker     (123)      790 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/.github/workflows/gtest-ci.yml
--rw-r--r--   0 runner    (1001) docker     (123)     1561 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/.gitignore
--rw-r--r--   0 runner    (1001) docker     (123)     6426 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/BUILD.bazel
--rw-r--r--   0 runner    (1001) docker     (123)     1046 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)     5688 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/CONTRIBUTING.md
--rw-r--r--   0 runner    (1001) docker     (123)     2261 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/CONTRIBUTORS
--rw-r--r--   0 runner    (1001) docker     (123)     1475 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/LICENSE
--rw-r--r--   0 runner    (1001) docker     (123)     4425 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/README.md
--rw-r--r--   0 runner    (1001) docker     (123)     1183 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/WORKSPACE
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.838950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/ci/
--rw-r--r--   0 runner    (1001) docker     (123)     4533 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/ci/linux-presubmit.sh
--rw-r--r--   0 runner    (1001) docker     (123)     2699 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/ci/macos-presubmit.sh
--rw-r--r--   0 runner    (1001) docker     (123)     1563 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/ci/windows-presubmit.bat
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.842950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/docs/
--rw-r--r--   0 runner    (1001) docker     (123)       18 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/docs/_config.yml
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.842950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/docs/_data/
--rw-r--r--   0 runner    (1001) docker     (123)     1200 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/docs/_data/navigation.yml
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.842950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/docs/_layouts/
--rw-r--r--   0 runner    (1001) docker     (123)     2317 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/docs/_layouts/default.html
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.842950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/docs/_sass/
--rw-r--r--   0 runner    (1001) docker     (123)     2915 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/docs/_sass/main.scss
--rw-r--r--   0 runner    (1001) docker     (123)    88688 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/docs/advanced.md
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.302947 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/docs/assets/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.846950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/docs/assets/css/
--rw-r--r--   0 runner    (1001) docker     (123)       56 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/docs/assets/css/style.scss
--rw-r--r--   0 runner    (1001) docker     (123)      342 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/docs/community_created_documentation.md
--rw-r--r--   0 runner    (1001) docker     (123)    29898 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/docs/faq.md
--rw-r--r--   0 runner    (1001) docker     (123)     7382 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/docs/gmock_cheat_sheet.md
--rw-r--r--   0 runner    (1001) docker     (123)   147280 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/docs/gmock_cook_book.md
--rw-r--r--   0 runner    (1001) docker     (123)    14980 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/docs/gmock_faq.md
--rw-r--r--   0 runner    (1001) docker     (123)    29196 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/docs/gmock_for_dummies.md
--rw-r--r--   0 runner    (1001) docker     (123)     1034 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/docs/index.md
--rw-r--r--   0 runner    (1001) docker     (123)     5062 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/docs/pkgconfig.md
--rw-r--r--   0 runner    (1001) docker     (123)      929 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/docs/platforms.md
--rw-r--r--   0 runner    (1001) docker     (123)    19166 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/docs/primer.md
--rw-r--r--   0 runner    (1001) docker     (123)     5220 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/docs/quickstart-bazel.md
--rw-r--r--   0 runner    (1001) docker     (123)     5061 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/docs/quickstart-cmake.md
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.846950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/docs/reference/
--rw-r--r--   0 runner    (1001) docker     (123)     6872 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/docs/reference/actions.md
--rw-r--r--   0 runner    (1001) docker     (123)    21535 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/docs/reference/assertions.md
--rw-r--r--   0 runner    (1001) docker     (123)    20993 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/docs/reference/matchers.md
--rw-r--r--   0 runner    (1001) docker     (123)    21139 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/docs/reference/mocking.md
--rw-r--r--   0 runner    (1001) docker     (123)    43945 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/docs/reference/testing.md
--rw-r--r--   0 runner    (1001) docker     (123)     1116 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/docs/samples.md
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.846950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/
--rw-r--r--   0 runner    (1001) docker     (123)     8329 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1538 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/README.md
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.846950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/cmake/
--rw-r--r--   0 runner    (1001) docker     (123)      347 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/cmake/gmock.pc.in
--rw-r--r--   0 runner    (1001) docker     (123)      354 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/cmake/gmock_main.pc.in
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.846950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/docs/
--rw-r--r--   0 runner    (1001) docker     (123)      139 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/docs/README.md
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.302947 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/include/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.850950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/include/gmock/
--rw-r--r--   0 runner    (1001) docker     (123)    87946 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/include/gmock/gmock-actions.h
--rw-r--r--   0 runner    (1001) docker     (123)     6118 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/include/gmock/gmock-cardinalities.h
--rw-r--r--   0 runner    (1001) docker     (123)    25756 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/include/gmock/gmock-function-mocker.h
--rw-r--r--   0 runner    (1001) docker     (123)   210247 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/include/gmock/gmock-matchers.h
--rw-r--r--   0 runner    (1001) docker     (123)    38344 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/include/gmock/gmock-more-actions.h
--rw-r--r--   0 runner    (1001) docker     (123)     4499 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/include/gmock/gmock-more-matchers.h
--rw-r--r--   0 runner    (1001) docker     (123)    10858 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/include/gmock/gmock-nice-strict.h
--rw-r--r--   0 runner    (1001) docker     (123)    82067 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/include/gmock/gmock-spec-builders.h
--rw-r--r--   0 runner    (1001) docker     (123)     3723 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/include/gmock/gmock.h
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.850950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/include/gmock/internal/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.850950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/include/gmock/internal/custom/
--rw-r--r--   0 runner    (1001) docker     (123)      510 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/include/gmock/internal/custom/README.md
--rw-r--r--   0 runner    (1001) docker     (123)      314 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/include/gmock/internal/custom/gmock-generated-actions.h
--rw-r--r--   0 runner    (1001) docker     (123)     1918 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/include/gmock/internal/custom/gmock-matchers.h
--rw-r--r--   0 runner    (1001) docker     (123)     1953 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/include/gmock/internal/custom/gmock-port.h
--rw-r--r--   0 runner    (1001) docker     (123)    19372 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/include/gmock/internal/gmock-internal-utils.h
--rw-r--r--   0 runner    (1001) docker     (123)     6070 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/include/gmock/internal/gmock-port.h
--rw-r--r--   0 runner    (1001) docker     (123)    13491 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/include/gmock/internal/gmock-pp.h
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.854950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/src/
--rw-r--r--   0 runner    (1001) docker     (123)     2107 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/src/gmock-all.cc
--rw-r--r--   0 runner    (1001) docker     (123)     5330 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/src/gmock-cardinalities.cc
--rw-r--r--   0 runner    (1001) docker     (123)     9428 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/src/gmock-internal-utils.cc
--rw-r--r--   0 runner    (1001) docker     (123)    18555 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/src/gmock-matchers.cc
--rw-r--r--   0 runner    (1001) docker     (123)    29334 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/src/gmock-spec-builders.cc
--rw-r--r--   0 runner    (1001) docker     (123)     8547 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/src/gmock.cc
--rw-r--r--   0 runner    (1001) docker     (123)     3037 2023-06-15 08:43:45.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/src/gmock_main.cc
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.862950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/test/
--rw-r--r--   0 runner    (1001) docker     (123)     3294 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/test/BUILD.bazel
--rw-r--r--   0 runner    (1001) docker     (123)    72915 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/test/gmock-actions_test.cc
--rw-r--r--   0 runner    (1001) docker     (123)    12138 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/test/gmock-cardinalities_test.cc
--rw-r--r--   0 runner    (1001) docker     (123)    34994 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/test/gmock-function-mocker_test.cc
--rw-r--r--   0 runner    (1001) docker     (123)    28429 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/test/gmock-internal-utils_test.cc
--rw-r--r--   0 runner    (1001) docker     (123)    53878 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/test/gmock-matchers-arithmetic_test.cc
--rw-r--r--   0 runner    (1001) docker     (123)    77929 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/test/gmock-matchers-comparisons_test.cc
--rw-r--r--   0 runner    (1001) docker     (123)   101563 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/test/gmock-matchers-containers_test.cc
--rw-r--r--   0 runner    (1001) docker     (123)    61926 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/test/gmock-matchers-misc_test.cc
--rw-r--r--   0 runner    (1001) docker     (123)     6273 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/test/gmock-matchers_test.h
--rw-r--r--   0 runner    (1001) docker     (123)    53624 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/test/gmock-more-actions_test.cc
--rw-r--r--   0 runner    (1001) docker     (123)    15676 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/test/gmock-nice-strict_test.cc
--rw-r--r--   0 runner    (1001) docker     (123)     1977 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/test/gmock-port_test.cc
--rw-r--r--   0 runner    (1001) docker     (123)     8788 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/test/gmock-pp-string_test.cc
--rw-r--r--   0 runner    (1001) docker     (123)     3517 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/test/gmock-pp_test.cc
--rw-r--r--   0 runner    (1001) docker     (123)    74737 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/test/gmock-spec-builders_test.cc
--rw-r--r--   0 runner    (1001) docker     (123)     2491 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/test/gmock_all_test.cc
--rw-r--r--   0 runner    (1001) docker     (123)     3300 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/test/gmock_ex_test.cc
--rwxr-xr-x   0 runner    (1001) docker     (123)     4070 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/test/gmock_leak_test.py
--rw-r--r--   0 runner    (1001) docker     (123)     3284 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/test/gmock_leak_test_.cc
--rw-r--r--   0 runner    (1001) docker     (123)     1875 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/test/gmock_link2_test.cc
--rw-r--r--   0 runner    (1001) docker     (123)     1875 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/test/gmock_link_test.cc
--rw-r--r--   0 runner    (1001) docker     (123)    19569 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/test/gmock_link_test.h
--rwxr-xr-x   0 runner    (1001) docker     (123)     6334 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/test/gmock_output_test.py
--rw-r--r--   0 runner    (1001) docker     (123)     8709 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/test/gmock_output_test_.cc
--rw-r--r--   0 runner    (1001) docker     (123)    13632 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/test/gmock_output_test_golden.txt
--rw-r--r--   0 runner    (1001) docker     (123)     7249 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/test/gmock_stress_test.cc
--rw-r--r--   0 runner    (1001) docker     (123)     6414 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/test/gmock_test.cc
--rwxr-xr-x   0 runner    (1001) docker     (123)     3108 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googlemock/test/gmock_test_utils.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.862950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/
--rw-r--r--   0 runner    (1001) docker     (123)    12324 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)     8912 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/README.md
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.862950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/cmake/
--rw-r--r--   0 runner    (1001) docker     (123)      284 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/cmake/Config.cmake.in
--rw-r--r--   0 runner    (1001) docker     (123)      311 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/cmake/gtest.pc.in
--rw-r--r--   0 runner    (1001) docker     (123)      354 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/cmake/gtest_main.pc.in
--rw-r--r--   0 runner    (1001) docker     (123)    15289 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/cmake/internal_utils.cmake
--rw-r--r--   0 runner    (1001) docker     (123)      499 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/cmake/libgtest.la.in
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.862950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/docs/
--rw-r--r--   0 runner    (1001) docker     (123)      139 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/docs/README.md
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.302947 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/include/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.866950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/include/gtest/
--rw-r--r--   0 runner    (1001) docker     (123)     8503 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/include/gtest/gtest-assertion-result.h
--rw-r--r--   0 runner    (1001) docker     (123)    14910 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/include/gtest/gtest-death-test.h
--rw-r--r--   0 runner    (1001) docker     (123)    33067 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/include/gtest/gtest-matchers.h
--rw-r--r--   0 runner    (1001) docker     (123)     8146 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/include/gtest/gtest-message.h
--rw-r--r--   0 runner    (1001) docker     (123)    24008 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/include/gtest/gtest-param-test.h
--rw-r--r--   0 runner    (1001) docker     (123)    39697 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/include/gtest/gtest-printers.h
--rw-r--r--   0 runner    (1001) docker     (123)    12843 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/include/gtest/gtest-spi.h
--rw-r--r--   0 runner    (1001) docker     (123)     7164 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/include/gtest/gtest-test-part.h
--rw-r--r--   0 runner    (1001) docker     (123)    15889 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/include/gtest/gtest-typed-test.h
--rw-r--r--   0 runner    (1001) docker     (123)    91344 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/include/gtest/gtest.h
--rw-r--r--   0 runner    (1001) docker     (123)    12783 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/include/gtest/gtest_pred_impl.h
--rw-r--r--   0 runner    (1001) docker     (123)     2502 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/include/gtest/gtest_prod.h
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.866950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/include/gtest/internal/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.870950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/include/gtest/internal/custom/
--rw-r--r--   0 runner    (1001) docker     (123)     1269 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/include/gtest/internal/custom/README.md
--rw-r--r--   0 runner    (1001) docker     (123)     1873 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/include/gtest/internal/custom/gtest-port.h
--rw-r--r--   0 runner    (1001) docker     (123)     2094 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/include/gtest/internal/custom/gtest-printers.h
--rw-r--r--   0 runner    (1001) docker     (123)     1858 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/include/gtest/internal/custom/gtest.h
--rw-r--r--   0 runner    (1001) docker     (123)    13929 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/include/gtest/internal/gtest-death-test-internal.h
--rw-r--r--   0 runner    (1001) docker     (123)    10339 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/include/gtest/internal/gtest-filepath.h
--rw-r--r--   0 runner    (1001) docker     (123)    63489 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/include/gtest/internal/gtest-internal.h
--rw-r--r--   0 runner    (1001) docker     (123)    38172 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/include/gtest/internal/gtest-param-util.h
--rw-r--r--   0 runner    (1001) docker     (123)     4178 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/include/gtest/internal/gtest-port-arch.h
--rw-r--r--   0 runner    (1001) docker     (123)    92025 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/include/gtest/internal/gtest-port.h
--rw-r--r--   0 runner    (1001) docker     (123)     7323 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/include/gtest/internal/gtest-string.h
--rw-r--r--   0 runner    (1001) docker     (123)     6309 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/include/gtest/internal/gtest-type-util.h
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.874950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/samples/
--rw-r--r--   0 runner    (1001) docker     (123)     4327 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/samples/prime_tables.h
--rw-r--r--   0 runner    (1001) docker     (123)     2471 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/samples/sample1.cc
--rw-r--r--   0 runner    (1001) docker     (123)     1919 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/samples/sample1.h
--rw-r--r--   0 runner    (1001) docker     (123)     4961 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/samples/sample10_unittest.cc
--rw-r--r--   0 runner    (1001) docker     (123)     5108 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/samples/sample1_unittest.cc
--rw-r--r--   0 runner    (1001) docker     (123)     2258 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/samples/sample2.cc
--rw-r--r--   0 runner    (1001) docker     (123)     2981 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/samples/sample2.h
--rw-r--r--   0 runner    (1001) docker     (123)     3908 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/samples/sample2_unittest.cc
--rw-r--r--   0 runner    (1001) docker     (123)     5376 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/samples/sample3-inl.h
--rw-r--r--   0 runner    (1001) docker     (123)     5352 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/samples/sample3_unittest.cc
--rw-r--r--   0 runner    (1001) docker     (123)     2105 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/samples/sample4.cc
--rw-r--r--   0 runner    (1001) docker     (123)     2132 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/samples/sample4.h
--rw-r--r--   0 runner    (1001) docker     (123)     1995 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/samples/sample4_unittest.cc
--rw-r--r--   0 runner    (1001) docker     (123)     6578 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/samples/sample5_unittest.cc
--rw-r--r--   0 runner    (1001) docker     (123)     8858 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/samples/sample6_unittest.cc
--rw-r--r--   0 runner    (1001) docker     (123)     4616 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/samples/sample7_unittest.cc
--rw-r--r--   0 runner    (1001) docker     (123)     6210 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/samples/sample8_unittest.cc
--rw-r--r--   0 runner    (1001) docker     (123)     5834 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/samples/sample9_unittest.cc
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.874950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/src/
--rw-r--r--   0 runner    (1001) docker     (123)     2201 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/src/gtest-all.cc
--rw-r--r--   0 runner    (1001) docker     (123)     3009 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/src/gtest-assertion-result.cc
--rw-r--r--   0 runner    (1001) docker     (123)    62694 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/src/gtest-death-test.cc
--rw-r--r--   0 runner    (1001) docker     (123)    15588 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/src/gtest-filepath.cc
--rw-r--r--   0 runner    (1001) docker     (123)    47937 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/src/gtest-internal-inl.h
--rw-r--r--   0 runner    (1001) docker     (123)     3724 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/src/gtest-matchers.cc
--rw-r--r--   0 runner    (1001) docker     (123)    47941 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/src/gtest-port.cc
--rw-r--r--   0 runner    (1001) docker     (123)    18535 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/src/gtest-printers.cc
--rw-r--r--   0 runner    (1001) docker     (123)     4028 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/src/gtest-test-part.cc
--rw-r--r--   0 runner    (1001) docker     (123)     3823 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/src/gtest-typed-test.cc
--rw-r--r--   0 runner    (1001) docker     (123)   260182 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/src/gtest.cc
--rw-r--r--   0 runner    (1001) docker     (123)     2375 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/src/gtest_main.cc
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.894950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/
--rw-r--r--   0 runner    (1001) docker     (123)    15427 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/BUILD.bazel
--rwxr-xr-x   0 runner    (1001) docker     (123)     6926 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-break-on-failure-unittest.py
--rw-r--r--   0 runner    (1001) docker     (123)     3252 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-break-on-failure-unittest_.cc
--rwxr-xr-x   0 runner    (1001) docker     (123)    10424 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-catch-exceptions-test.py
--rw-r--r--   0 runner    (1001) docker     (123)     8380 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-catch-exceptions-test_.cc
--rwxr-xr-x   0 runner    (1001) docker     (123)     5054 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-color-test.py
--rw-r--r--   0 runner    (1001) docker     (123)     2503 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-color-test_.cc
--rw-r--r--   0 runner    (1001) docker     (123)    47815 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-death-test-test.cc
--rw-r--r--   0 runner    (1001) docker     (123)     3559 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-death-test_ex_test.cc
--rwxr-xr-x   0 runner    (1001) docker     (123)     4173 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-env-var-test.py
--rw-r--r--   0 runner    (1001) docker     (123)     3702 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-env-var-test_.cc
--rwxr-xr-x   0 runner    (1001) docker     (123)    14376 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-failfast-unittest.py
--rw-r--r--   0 runner    (1001) docker     (123)     5594 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-failfast-unittest_.cc
--rw-r--r--   0 runner    (1001) docker     (123)    23708 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-filepath-test.cc
--rwxr-xr-x   0 runner    (1001) docker     (123)    23285 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-filter-unittest.py
--rw-r--r--   0 runner    (1001) docker     (123)     3435 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-filter-unittest_.cc
--rw-r--r--   0 runner    (1001) docker     (123)     4889 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-global-environment-unittest.py
--rw-r--r--   0 runner    (1001) docker     (123)     2286 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-global-environment-unittest_.cc
--rw-r--r--   0 runner    (1001) docker     (123)     5829 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-json-outfiles-test.py
--rw-r--r--   0 runner    (1001) docker     (123)    27270 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-json-output-unittest.py
--rwxr-xr-x   0 runner    (1001) docker     (123)     6555 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-list-tests-unittest.py
--rw-r--r--   0 runner    (1001) docker     (123)     4743 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-list-tests-unittest_.cc
--rw-r--r--   0 runner    (1001) docker     (123)    24343 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-listener-test.cc
--rw-r--r--   0 runner    (1001) docker     (123)     5255 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-message-test.cc
--rw-r--r--   0 runner    (1001) docker     (123)     7977 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-options-test.cc
--rw-r--r--   0 runner    (1001) docker     (123)    42714 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-output-test-golden-lin.txt
--rwxr-xr-x   0 runner    (1001) docker     (123)    12645 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-output-test.py
--rw-r--r--   0 runner    (1001) docker     (123)    36184 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-output-test_.cc
--rw-r--r--   0 runner    (1001) docker     (123)     2398 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-param-test-invalid-name1-test.py
--rw-r--r--   0 runner    (1001) docker     (123)     1995 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-param-test-invalid-name1-test_.cc
--rw-r--r--   0 runner    (1001) docker     (123)     2352 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-param-test-invalid-name2-test.py
--rw-r--r--   0 runner    (1001) docker     (123)     2129 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-param-test-invalid-name2-test_.cc
--rw-r--r--   0 runner    (1001) docker     (123)    42922 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-param-test-test.cc
--rw-r--r--   0 runner    (1001) docker     (123)     2280 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-param-test-test.h
--rw-r--r--   0 runner    (1001) docker     (123)     2768 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-param-test2-test.cc
--rw-r--r--   0 runner    (1001) docker     (123)    41136 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-port-test.cc
--rw-r--r--   0 runner    (1001) docker     (123)    65253 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-printers-test.cc
--rwxr-xr-x   0 runner    (1001) docker     (123)     2294 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-setuptestsuite-test.py
--rw-r--r--   0 runner    (1001) docker     (123)     1936 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-setuptestsuite-test_.cc
--rwxr-xr-x   0 runner    (1001) docker     (123)    12701 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-shuffle-test.py
--rw-r--r--   0 runner    (1001) docker     (123)     3192 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-shuffle-test_.cc
--rw-r--r--   0 runner    (1001) docker     (123)     7834 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-test-part-test.cc
--rwxr-xr-x   0 runner    (1001) docker     (123)     5495 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-throw-on-failure-test.py
--rw-r--r--   0 runner    (1001) docker     (123)     3013 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-throw-on-failure-test_.cc
--rwxr-xr-x   0 runner    (1001) docker     (123)     2501 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-uninitialized-test.py
--rw-r--r--   0 runner    (1001) docker     (123)     1875 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/googletest-uninitialized-test_.cc
--rw-r--r--   0 runner    (1001) docker     (123)     1954 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest-typed-test2_test.cc
--rw-r--r--   0 runner    (1001) docker     (123)    14090 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest-typed-test_test.cc
--rw-r--r--   0 runner    (1001) docker     (123)     2393 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest-typed-test_test.h
--rw-r--r--   0 runner    (1001) docker     (123)    13047 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest-unittest-api_test.cc
--rw-r--r--   0 runner    (1001) docker     (123)     2239 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_all_test.cc
--rw-r--r--   0 runner    (1001) docker     (123)     3842 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_assert_by_exception_test.cc
--rw-r--r--   0 runner    (1001) docker     (123)     2939 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_dirs_test.cc
--rw-r--r--   0 runner    (1001) docker     (123)     6409 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_environment_test.cc
--rwxr-xr-x   0 runner    (1001) docker     (123)     6390 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_help_test.py
--rw-r--r--   0 runner    (1001) docker     (123)     2090 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_help_test_.cc
--rw-r--r--   0 runner    (1001) docker     (123)     2488 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_json_test_utils.py
--rw-r--r--   0 runner    (1001) docker     (123)     9497 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_list_output_unittest.py
--rw-r--r--   0 runner    (1001) docker     (123)     3197 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_list_output_unittest_.cc
--rw-r--r--   0 runner    (1001) docker     (123)     1839 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_main_unittest.cc
--rw-r--r--   0 runner    (1001) docker     (123)     2403 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_no_test_unittest.cc
--rw-r--r--   0 runner    (1001) docker     (123)    69752 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_pred_impl_unittest.cc
--rw-r--r--   0 runner    (1001) docker     (123)     4312 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_premature_exit_test.cc
--rw-r--r--   0 runner    (1001) docker     (123)     2147 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_prod_test.cc
--rw-r--r--   0 runner    (1001) docker     (123)     7698 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_repeat_test.cc
--rwxr-xr-x   0 runner    (1001) docker     (123)     2417 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_skip_check_output_test.py
--rwxr-xr-x   0 runner    (1001) docker     (123)     2231 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_skip_environment_check_output_test.py
--rw-r--r--   0 runner    (1001) docker     (123)     2070 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_skip_in_environment_setup_test.cc
--rw-r--r--   0 runner    (1001) docker     (123)     2001 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_skip_test.cc
--rw-r--r--   0 runner    (1001) docker     (123)     2173 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_sole_header_test.cc
--rw-r--r--   0 runner    (1001) docker     (123)     9369 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_stress_test.cc
--rw-r--r--   0 runner    (1001) docker     (123)     3871 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_test_macro_stack_footprint_test.cc
--rwxr-xr-x   0 runner    (1001) docker     (123)     8146 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_test_utils.py
--rwxr-xr-x   0 runner    (1001) docker     (123)     2495 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_testbridge_test.py
--rw-r--r--   0 runner    (1001) docker     (123)     1922 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_testbridge_test_.cc
--rw-r--r--   0 runner    (1001) docker     (123)     3395 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_throw_on_failure_ex_test.cc
--rw-r--r--   0 runner    (1001) docker     (123)   263843 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_unittest.cc
--rw-r--r--   0 runner    (1001) docker     (123)     1955 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_xml_outfile1_test_.cc
--rw-r--r--   0 runner    (1001) docker     (123)     2835 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_xml_outfile2_test_.cc
--rwxr-xr-x   0 runner    (1001) docker     (123)     5961 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_xml_outfiles_test.py
--rwxr-xr-x   0 runner    (1001) docker     (123)    23085 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_xml_output_unittest.py
--rw-r--r--   0 runner    (1001) docker     (123)     6434 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_xml_output_unittest_.cc
--rwxr-xr-x   0 runner    (1001) docker     (123)    10191 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/gtest_xml_test_utils.py
--rw-r--r--   0 runner    (1001) docker     (123)     1675 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/production.cc
--rw-r--r--   0 runner    (1001) docker     (123)     2131 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest/test/production.h
--rw-r--r--   0 runner    (1001) docker     (123)     1124 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/googletest/googletest_deps.bzl
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.898950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/include/
--rw-r--r--   0 runner    (1001) docker     (123)     1074 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/include/Definitions.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    13437 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/include/Expression.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     5878 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/include/Rational.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      834 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/include/Rules.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1702 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/include/Simplify.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     4087 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/include/Utils.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     4944 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/include/ZXDiagram.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      563 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/noxfile.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.898950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/src/
--rw-r--r--   0 runner    (1001) docker     (123)     3880 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/src/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)      550 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/src/Expression.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1808 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/src/Rational.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    10594 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/src/Rules.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2925 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/src/Simplify.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     4375 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/src/Utils.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    11332 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/src/ZXDiagram.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.898950 mqt.ddsim-1.17.3/extern/qfr/extern/zx/test/
--rw-r--r--   0 runner    (1001) docker     (123)     1251 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/test/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)     5711 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/test/test_expression.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2375 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/test/test_rational.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    18326 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/test/test_simplify.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     7260 2023-06-15 08:43:40.000000 mqt.ddsim-1.17.3/extern/qfr/extern/zx/test/test_zx.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.898950 mqt.ddsim-1.17.3/extern/qfr/include/
--rw-r--r--   0 runner    (1001) docker     (123)     2801 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/CircuitOptimizer.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2641 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/Definitions.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      890 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/Permutation.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    49204 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/QuantumComputation.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.902950 mqt.ddsim-1.17.3/extern/qfr/include/algorithms/
--rw-r--r--   0 runner    (1001) docker     (123)      896 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/algorithms/BernsteinVazirani.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      387 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/algorithms/Entanglement.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1904 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/algorithms/GoogleRandomCircuitSampling.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      919 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/algorithms/Grover.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      635 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/algorithms/QFT.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      678 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/algorithms/QPE.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      840 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/algorithms/RandomCliffordCircuit.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.902950 mqt.ddsim-1.17.3/extern/qfr/include/dd/
--rw-r--r--   0 runner    (1001) docker     (123)     2052 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/dd/FunctionalityConstruction.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    34812 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/dd/NoiseFunctionality.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    16472 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/dd/Operations.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1997 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/dd/Simulation.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.902950 mqt.ddsim-1.17.3/extern/qfr/include/ecc/
--rw-r--r--   0 runner    (1001) docker     (123)     3967 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/ecc/Ecc.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      750 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/ecc/Id.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     3100 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/ecc/Q18Surface.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      807 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/ecc/Q3Shor.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1403 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/ecc/Q5Laflamme.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1089 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/ecc/Q7Steane.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      909 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/ecc/Q9Shor.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2050 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/ecc/Q9Surface.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.906950 mqt.ddsim-1.17.3/extern/qfr/include/operations/
--rw-r--r--   0 runner    (1001) docker     (123)     3871 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/operations/ClassicControlledOperation.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     7437 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/operations/CompoundOperation.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1942 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/operations/Control.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     4541 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/operations/NonUnitaryOperation.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     7055 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/operations/OpType.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     5462 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/operations/Operation.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     3195 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/operations/StandardOperation.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     5428 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/operations/SymbolicOperation.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.306947 mqt.ddsim-1.17.3/extern/qfr/include/parsers/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.906950 mqt.ddsim-1.17.3/extern/qfr/include/parsers/qasm_parser/
--rw-r--r--   0 runner    (1001) docker     (123)     8341 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/parsers/qasm_parser/Parser.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1501 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/parsers/qasm_parser/Scanner.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     3560 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/parsers/qasm_parser/Token.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.906950 mqt.ddsim-1.17.3/extern/qfr/include/zx/
--rw-r--r--   0 runner    (1001) docker     (123)     2150 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/include/zx/FunctionalityConstruction.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.306947 mqt.ddsim-1.17.3/extern/qfr/mqt/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.906950 mqt.ddsim-1.17.3/extern/qfr/mqt/qfr/
--rw-r--r--   0 runner    (1001) docker     (123)     1229 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/mqt/qfr/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)      437 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/mqt/qfr/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     8285 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/mqt/qfr/bindings.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1328 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/mqt/qfr/pyqfr.pyi
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.906950 mqt.ddsim-1.17.3/extern/qfr/mqt/qfr/qiskit/
--rw-r--r--   0 runner    (1001) docker     (123)    10742 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/mqt/qfr/qiskit/QasmQobjExperiment.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    21420 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/mqt/qfr/qiskit/QuantumCircuit.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.910950 mqt.ddsim-1.17.3/extern/qfr/src/
--rw-r--r--   0 runner    (1001) docker     (123)     5944 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)    55762 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/CircuitOptimizer.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    38918 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/QuantumComputation.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.910950 mqt.ddsim-1.17.3/extern/qfr/src/algorithms/
--rw-r--r--   0 runner    (1001) docker     (123)     3625 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/algorithms/BernsteinVazirani.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      605 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/algorithms/Entanglement.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     5271 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/algorithms/GoogleRandomCircuitSampling.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3715 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/algorithms/Grover.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3604 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/algorithms/QFT.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     4955 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/algorithms/QPE.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    11499 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/algorithms/RandomCliffordCircuit.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.910950 mqt.ddsim-1.17.3/extern/qfr/src/dd/
--rw-r--r--   0 runner    (1001) docker     (123)     8365 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/dd/FunctionalityConstruction.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      390 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/dd/NoiseFunctionality.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     5752 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/dd/Operations.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    19845 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/dd/Simulation.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.910950 mqt.ddsim-1.17.3/extern/qfr/src/ecc/
--rw-r--r--   0 runner    (1001) docker     (123)     1394 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/ecc/Ecc.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     6624 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/ecc/Q18Surface.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     5419 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/ecc/Q3Shor.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     6613 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/ecc/Q5Laflamme.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     9974 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/ecc/Q7Steane.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     8372 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/ecc/Q9Shor.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     7649 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/ecc/Q9Surface.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.914950 mqt.ddsim-1.17.3/extern/qfr/src/operations/
--rw-r--r--   0 runner    (1001) docker     (123)    10801 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/operations/NonUnitaryOperation.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     7578 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/operations/Operation.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    16214 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/operations/StandardOperation.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    11134 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/operations/SymbolicOperation.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.914950 mqt.ddsim-1.17.3/extern/qfr/src/parsers/
--rw-r--r--   0 runner    (1001) docker     (123)     1444 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/parsers/GRCSParser.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     5374 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/parsers/QASMParser.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    11580 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/parsers/QCParser.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     9572 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/parsers/RealParser.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     9192 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/parsers/TFCParser.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.914950 mqt.ddsim-1.17.3/extern/qfr/src/parsers/qasm_parser/
--rw-r--r--   0 runner    (1001) docker     (123)    37792 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/parsers/qasm_parser/Parser.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    11981 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/parsers/qasm_parser/Scanner.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.914950 mqt.ddsim-1.17.3/extern/qfr/src/zx/
--rw-r--r--   0 runner    (1001) docker     (123)    19693 2023-06-15 08:43:26.000000 mqt.ddsim-1.17.3/extern/qfr/src/zx/FunctionalityConstruction.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.918950 mqt.ddsim-1.17.3/extern/taskflow/
--rw-r--r--   0 runner    (1001) docker     (123)       43 2023-06-15 08:43:25.000000 mqt.ddsim-1.17.3/extern/taskflow/.git
--rw-r--r--   0 runner    (1001) docker     (123)      110 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/.gitattributes
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.918950 mqt.ddsim-1.17.3/extern/taskflow/.github/
--rw-r--r--   0 runner    (1001) docker     (123)      108 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/.github/FUNDING.yml
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.918950 mqt.ddsim-1.17.3/extern/taskflow/.github/ISSUE_TEMPLATE/
--rw-r--r--   0 runner    (1001) docker     (123)      543 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/.github/ISSUE_TEMPLATE/bug_report.md
--rw-r--r--   0 runner    (1001) docker     (123)      208 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/.github/ISSUE_TEMPLATE/feature_request.md
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.918950 mqt.ddsim-1.17.3/extern/taskflow/.github/workflows/
--rw-r--r--   0 runner    (1001) docker     (123)     2363 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/.github/workflows/codeql-analysis.yml
--rw-r--r--   0 runner    (1001) docker     (123)     2163 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/.github/workflows/macos.yml
--rw-r--r--   0 runner    (1001) docker     (123)     2561 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/.github/workflows/ubuntu.yml
--rw-r--r--   0 runner    (1001) docker     (123)      763 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/.github/workflows/windows.yml
--rw-r--r--   0 runner    (1001) docker     (123)        7 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/.gitignore
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.918950 mqt.ddsim-1.17.3/extern/taskflow/.vscode/
--rw-r--r--   0 runner    (1001) docker     (123)      445 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/.vscode/c_cpp_properties.json
--rw-r--r--   0 runner    (1001) docker     (123)     1738 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/.vscode/settings.json
--rw-r--r--   0 runner    (1001) docker     (123)    14211 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)     1091 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/LICENSE
--rw-r--r--   0 runner    (1001) docker     (123)    17472 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/README.md
--rw-r--r--   0 runner    (1001) docker     (123)      458 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/TaskflowConfig.cmake.in
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.310947 mqt.ddsim-1.17.3/extern/taskflow/cmake/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.310947 mqt.ddsim-1.17.3/extern/taskflow/cmake/ComputeCpp/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.918950 mqt.ddsim-1.17.3/extern/taskflow/cmake/ComputeCpp/Modules/
--rw-r--r--   0 runner    (1001) docker     (123)     2875 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/cmake/ComputeCpp/Modules/ComputeCppCompilerChecks.cmake
--rw-r--r--   0 runner    (1001) docker     (123)      475 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/cmake/ComputeCpp/Modules/ComputeCppIRMap.cmake
--rw-r--r--   0 runner    (1001) docker     (123)    16648 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/cmake/ComputeCpp/Modules/FindComputeCpp.cmake
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.918950 mqt.ddsim-1.17.3/extern/taskflow/cmake/ComputeCpp/toolchains/
--rw-r--r--   0 runner    (1001) docker     (123)     2256 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/cmake/ComputeCpp/toolchains/arm-gcc-poky.cmake
--rw-r--r--   0 runner    (1001) docker     (123)      754 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/cmake/ComputeCpp/toolchains/gcc-generic.cmake
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.310947 mqt.ddsim-1.17.3/extern/taskflow/cmake/cuda/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.918950 mqt.ddsim-1.17.3/extern/taskflow/cmake/cuda/modules/
--rw-r--r--   0 runner    (1001) docker     (123)     2894 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/cmake/cuda/modules/FindcuBLAS.cmake
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.918950 mqt.ddsim-1.17.3/extern/taskflow/taskflow/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.922950 mqt.ddsim-1.17.3/extern/taskflow/taskflow/algorithm/
--rw-r--r--   0 runner    (1001) docker     (123)     2172 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/algorithm/critical.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    16653 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/algorithm/data_pipeline.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    15050 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/algorithm/find.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     4863 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/algorithm/for_each.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1139 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/algorithm/launch.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    14524 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/algorithm/partitioner.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    44892 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/algorithm/pipeline.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    12383 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/algorithm/reduce.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    17045 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/algorithm/scan.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    21372 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/algorithm/sort.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     5943 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/algorithm/transform.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.926950 mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/
--rw-r--r--   0 runner    (1001) docker     (123)     9629 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/async.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     5007 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/async_task.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1342 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/declarations.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      160 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/environment.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      728 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/error.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    54781 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/executor-module-opt.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    68326 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/executor.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    43647 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/flow_builder.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    24245 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/graph.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    10122 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/notifier.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    26126 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/observer.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     3441 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/semaphore.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    18519 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/task.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    15683 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/taskflow.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1067 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/topology.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    12210 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/tsq.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     6624 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/worker.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.930950 mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.930950 mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/algorithm/
--rw-r--r--   0 runner    (1001) docker     (123)     7536 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/algorithm/find.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     7858 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/algorithm/for_each.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1247 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/algorithm/matmul.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    17596 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/algorithm/merge.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    12265 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/algorithm/reduce.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    12734 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/algorithm/scan.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    14765 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/algorithm/sort.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     7304 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/algorithm/transform.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      975 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/algorithm/transpose.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    20589 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/cuda_capturer.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     9031 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/cuda_device.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1039 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/cuda_error.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     4358 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/cuda_execution_policy.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    20014 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/cuda_graph.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    20001 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/cuda_memory.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    12652 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/cuda_meta.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     7384 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/cuda_object.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    10931 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/cuda_optimizer.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     6191 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/cuda_stream.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     6399 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/cuda_task.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    28435 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/cudaflow.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.934950 mqt.ddsim-1.17.3/extern/taskflow/taskflow/dsl/
--rw-r--r--   0 runner    (1001) docker     (123)     1658 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/dsl/connection.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      327 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/dsl/dsl.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     3356 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/dsl/meta_macro.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1203 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/dsl/task_analyzer.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     4054 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/dsl/task_dsl.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1189 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/dsl/task_trait.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1418 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/dsl/tuple_utils.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     4177 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/dsl/type_list.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.934950 mqt.ddsim-1.17.3/extern/taskflow/taskflow/sycl/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.934950 mqt.ddsim-1.17.3/extern/taskflow/taskflow/sycl/algorithm/
--rw-r--r--   0 runner    (1001) docker     (123)    13320 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/sycl/algorithm/reduce.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2698 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/sycl/algorithm/sycl_for_each.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1232 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/sycl/algorithm/sycl_transform.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1818 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/sycl/sycl_execution_policy.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     5595 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/sycl/sycl_graph.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    14084 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/sycl/sycl_meta.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     4367 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/sycl/sycl_task.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    18861 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/sycl/syclflow.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     1134 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/taskflow.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.938950 mqt.ddsim-1.17.3/extern/taskflow/taskflow/utility/
--rw-r--r--   0 runner    (1001) docker     (123)      603 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/utility/iterator.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      426 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/utility/macros.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     3815 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/utility/math.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    19899 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/utility/object_pool.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     4239 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/utility/os.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    29321 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/utility/serializer.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      553 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/utility/singleton.hpp
--rw-r--r--   0 runner    (1001) docker     (123)    31329 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/utility/small_vector.hpp
--rw-r--r--   0 runner    (1001) docker     (123)      681 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/utility/stream.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     8689 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/utility/traits.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     5685 2023-06-15 08:43:46.000000 mqt.ddsim-1.17.3/extern/taskflow/taskflow/utility/uuid.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.942950 mqt.ddsim-1.17.3/include/
--rw-r--r--   0 runner    (1001) docker     (123)     3609 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/include/CircuitSimulator.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     3730 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/include/DeterministicNoiseSimulator.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2738 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/include/GroverSimulator.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     5187 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/include/HybridSchrodingerFeynmanSimulator.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     8325 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/include/PathSimulator.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     3905 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/include/ShorFastSimulator.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     5290 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/include/ShorSimulator.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     7745 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/include/Simulator.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     7759 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/include/StochasticNoiseSimulator.hpp
--rw-r--r--   0 runner    (1001) docker     (123)     2285 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/include/UnitarySimulator.hpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.310947 mqt.ddsim-1.17.3/mqt/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.946950 mqt.ddsim-1.17.3/mqt/ddsim/
--rw-r--r--   0 runner    (1001) docker     (123)      248 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/mqt/ddsim/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)      649 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/mqt/ddsim/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    14289 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/mqt/ddsim/bindings.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      286 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/mqt/ddsim/error.py
--rw-r--r--   0 runner    (1001) docker     (123)     6939 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/mqt/ddsim/hybridqasmsimulator.py
--rw-r--r--   0 runner    (1001) docker     (123)     2151 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/mqt/ddsim/hybridstatevectorsimulator.py
--rw-r--r--   0 runner    (1001) docker     (123)     3573 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/mqt/ddsim/job.py
--rw-r--r--   0 runner    (1001) docker     (123)    10564 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/mqt/ddsim/pathqasmsimulator.py
--rw-r--r--   0 runner    (1001) docker     (123)     2439 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/mqt/ddsim/pathstatevectorsimulator.py
--rw-r--r--   0 runner    (1001) docker     (123)     2218 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/mqt/ddsim/provider.py
--rw-r--r--   0 runner    (1001) docker     (123)     6321 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/mqt/ddsim/qasmsimulator.py
--rw-r--r--   0 runner    (1001) docker     (123)     2348 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/mqt/ddsim/statevectorsimulator.py
--rw-r--r--   0 runner    (1001) docker     (123)     7319 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/mqt/ddsim/unitarysimulator.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.942950 mqt.ddsim-1.17.3/mqt.ddsim.egg-info/
--rw-r--r--   0 runner    (1001) docker     (123)     7994 2023-06-15 08:44:13.000000 mqt.ddsim-1.17.3/mqt.ddsim.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)   202283 2023-06-15 08:44:13.000000 mqt.ddsim-1.17.3/mqt.ddsim.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (123)        1 2023-06-15 08:44:13.000000 mqt.ddsim-1.17.3/mqt.ddsim.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (123)      351 2023-06-15 08:44:13.000000 mqt.ddsim-1.17.3/mqt.ddsim.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (123)        4 2023-06-15 08:44:13.000000 mqt.ddsim-1.17.3/mqt.ddsim.egg-info/top_level.txt
--rw-r--r--   0 runner    (1001) docker     (123)     3106 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/noxfile.py
--rw-r--r--   0 runner    (1001) docker     (123)     4291 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/pyproject.toml
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.946950 mqt.ddsim-1.17.3/scripts/
--rw-r--r--   0 runner    (1001) docker     (123)      379 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/scripts/README.md
--rwxr-xr-x   0 runner    (1001) docker     (123)     6481 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/scripts/approximation.sh
--rwxr-xr-x   0 runner    (1001) docker     (123)     2864 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/scripts/hybrid_simulation.sh
--rwxr-xr-x   0 runner    (1001) docker     (123)      613 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/scripts/primebases_timing_shor.sh
--rw-r--r--   0 runner    (1001) docker     (123)       38 2023-06-15 08:44:13.958950 mqt.ddsim-1.17.3/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (123)     3603 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.950950 mqt.ddsim-1.17.3/src/
--rw-r--r--   0 runner    (1001) docker     (123)     2078 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/src/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)     9846 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/src/CircuitSimulator.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3124 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/src/DeterministicNoiseSimulator.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3471 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/src/GroverSimulator.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    12444 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/src/HybridSchrodingerFeynmanSimulator.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    19063 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/src/PathSimulator.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    17839 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/src/ShorFastSimulator.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    17044 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/src/ShorSimulator.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    12917 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/src/Simulator.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    17300 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/src/StochasticNoiseSimulator.cpp
--rw-r--r--   0 runner    (1001) docker     (123)      724 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/src/UnitarySimulator.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.950950 mqt.ddsim-1.17.3/test/
--rw-r--r--   0 runner    (1001) docker     (123)     2498 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (123)       57 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    10578 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/benchmark.cpp
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.954950 mqt.ddsim-1.17.3/test/circuits/
--rw-r--r--   0 runner    (1001) docker     (123)      966 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/circuits/inst_4x4_10_0.txt
--rw-r--r--   0 runner    (1001) docker     (123)      966 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/circuits/inst_4x4_10_1.txt
--rw-r--r--   0 runner    (1001) docker     (123)      966 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/circuits/inst_4x4_10_2.txt
--rw-r--r--   0 runner    (1001) docker     (123)       52 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/circuits/test_original.real
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.954950 mqt.ddsim-1.17.3/test/python/
--rw-r--r--   0 runner    (1001) docker     (123)     5091 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/python/generate_benchmarks.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.954950 mqt.ddsim-1.17.3/test/python/hybridsimulator/
--rw-r--r--   0 runner    (1001) docker     (123)     3788 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/python/hybridsimulator/test_hybrid_qasm_simulator.py
--rw-r--r--   0 runner    (1001) docker     (123)     1366 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/python/hybridsimulator/test_hybrid_standalone_simulator.py
--rw-r--r--   0 runner    (1001) docker     (123)     1534 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/python/hybridsimulator/test_hybrid_statevector_simulator.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.954950 mqt.ddsim-1.17.3/test/python/simulator/
--rw-r--r--   0 runner    (1001) docker     (123)      121 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/python/simulator/ghz_03.qasm
--rw-r--r--   0 runner    (1001) docker     (123)     1045 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/python/simulator/grover.py
--rw-r--r--   0 runner    (1001) docker     (123)     1272 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/python/simulator/test_multi_registers_convention.py
--rw-r--r--   0 runner    (1001) docker     (123)     5105 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/python/simulator/test_qasm_simulator.py
--rw-r--r--   0 runner    (1001) docker     (123)     3961 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/python/simulator/test_standalone_simulator.py
--rw-r--r--   0 runner    (1001) docker     (123)     1354 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/python/simulator/test_statevector_simulator.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.958950 mqt.ddsim-1.17.3/test/python/taskbasedsimulator/
--rw-r--r--   0 runner    (1001) docker     (123)     7527 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/python/taskbasedsimulator/benchmark.py
--rw-r--r--   0 runner    (1001) docker     (123)     1361 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/python/taskbasedsimulator/qiskit_O2_nonancilla.profile
--rw-r--r--   0 runner    (1001) docker     (123)     4418 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/python/taskbasedsimulator/test_path_sim_qasm_simulator.py
--rw-r--r--   0 runner    (1001) docker     (123)     2548 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/python/taskbasedsimulator/test_path_sim_standalone_simulator.py
--rw-r--r--   0 runner    (1001) docker     (123)     1958 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/python/taskbasedsimulator/test_path_sim_statevector_simulator.py
--rw-r--r--   0 runner    (1001) docker     (123)      570 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/python/test_provider.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-15 08:44:13.958950 mqt.ddsim-1.17.3/test/python/unitarysimulator/
--rw-r--r--   0 runner    (1001) docker     (123)     1743 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/python/unitarysimulator/test_standalone_unitary_simulator.py
--rw-r--r--   0 runner    (1001) docker     (123)     1485 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/python/unitarysimulator/test_unitary_simulator.py
--rw-r--r--   0 runner    (1001) docker     (123)    14169 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/test_circuit_sim.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    13542 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/test_det_noise_sim.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     2146 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/test_fast_shor_sim.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     1365 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/test_grover_sim.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     7939 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/test_hybridsim.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    10393 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/test_path_sim.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     4164 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/test_shor_sim.cpp
--rw-r--r--   0 runner    (1001) docker     (123)    20227 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/test_stoch_noise_sim.cpp
--rw-r--r--   0 runner    (1001) docker     (123)     3382 2023-06-15 08:43:20.000000 mqt.ddsim-1.17.3/test/test_unitary_sim.cpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:15.002712 mqt.ddsim-1.18.0/
+-rw-r--r--   0 runner    (1001) docker     (123)     2424 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/.clang-format
+-rw-r--r--   0 runner    (1001) docker     (123)     2523 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/.clang-tidy
+-rw-r--r--   0 runner    (1001) docker     (123)      125 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/.git_archival.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       32 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/.gitattributes
+-rw-r--r--   0 runner    (1001) docker     (123)      152 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/.gitignore
+-rw-r--r--   0 runner    (1001) docker     (123)      406 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/.gitmodules
+-rw-r--r--   0 runner    (1001) docker     (123)     2650 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/.pre-commit-config.yaml
+-rw-r--r--   0 runner    (1001) docker     (123)      271 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/.readthedocs.yaml
+-rw-r--r--   0 runner    (1001) docker     (123)     1348 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1122 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     1184 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/MANIFEST.in
+-rw-r--r--   0 runner    (1001) docker     (123)     7878 2023-06-17 10:29:15.002712 mqt.ddsim-1.18.0/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     5033 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/README.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.802711 mqt.ddsim-1.18.0/apps/
+-rw-r--r--   0 runner    (1001) docker     (123)     1207 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/apps/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     4729 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/apps/frqi.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     7605 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/apps/noise_aware.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2466 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/apps/primebases.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    13747 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/apps/simple.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2087 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/apps/vectors.cpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.798711 mqt.ddsim-1.18.0/extern/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.806711 mqt.ddsim-1.18.0/extern/cxxopts/
+-rw-r--r--   0 runner    (1001) docker     (123)      456 2023-06-17 10:28:44.000000 mqt.ddsim-1.18.0/extern/cxxopts/.clang-format
+-rw-r--r--   0 runner    (1001) docker     (123)       42 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/extern/cxxopts/.git
+-rw-r--r--   0 runner    (1001) docker     (123)      751 2023-06-17 10:28:44.000000 mqt.ddsim-1.18.0/extern/cxxopts/.gitignore
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.806711 mqt.ddsim-1.18.0/extern/cxxopts/.tipi/
+-rw-r--r--   0 runner    (1001) docker     (123)        3 2023-06-17 10:28:44.000000 mqt.ddsim-1.18.0/extern/cxxopts/.tipi/deps
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-06-17 10:28:44.000000 mqt.ddsim-1.18.0/extern/cxxopts/.tipi/opts
+-rw-r--r--   0 runner    (1001) docker     (123)     2493 2023-06-17 10:28:44.000000 mqt.ddsim-1.18.0/extern/cxxopts/.travis.yml
+-rw-r--r--   0 runner    (1001) docker     (123)      362 2023-06-17 10:28:44.000000 mqt.ddsim-1.18.0/extern/cxxopts/BUILD.bazel
+-rw-r--r--   0 runner    (1001) docker     (123)     4340 2023-06-17 10:28:44.000000 mqt.ddsim-1.18.0/extern/cxxopts/CHANGELOG.md
+-rw-r--r--   0 runner    (1001) docker     (123)     2996 2023-06-17 10:28:44.000000 mqt.ddsim-1.18.0/extern/cxxopts/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1232 2023-06-17 10:28:44.000000 mqt.ddsim-1.18.0/extern/cxxopts/INSTALL
+-rw-r--r--   0 runner    (1001) docker     (123)     1055 2023-06-17 10:28:44.000000 mqt.ddsim-1.18.0/extern/cxxopts/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     8511 2023-06-17 10:28:44.000000 mqt.ddsim-1.18.0/extern/cxxopts/README.md
+-rw-r--r--   0 runner    (1001) docker     (123)      512 2023-06-17 10:28:44.000000 mqt.ddsim-1.18.0/extern/cxxopts/WORKSPACE
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.806711 mqt.ddsim-1.18.0/extern/cxxopts/cmake/
+-rw-r--r--   0 runner    (1001) docker     (123)     7132 2023-06-17 10:28:44.000000 mqt.ddsim-1.18.0/extern/cxxopts/cmake/cxxopts.cmake
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.806711 mqt.ddsim-1.18.0/extern/cxxopts/include/
+-rw-r--r--   0 runner    (1001) docker     (123)     1221 2023-06-17 10:28:44.000000 mqt.ddsim-1.18.0/extern/cxxopts/include/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    57765 2023-06-17 10:28:44.000000 mqt.ddsim-1.18.0/extern/cxxopts/include/cxxopts.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.806711 mqt.ddsim-1.18.0/extern/cxxopts/packaging/
+-rw-r--r--   0 runner    (1001) docker     (123)      114 2023-06-17 10:28:44.000000 mqt.ddsim-1.18.0/extern/cxxopts/packaging/cxxopts-config.cmake.in
+-rw-r--r--   0 runner    (1001) docker     (123)      186 2023-06-17 10:28:44.000000 mqt.ddsim-1.18.0/extern/cxxopts/packaging/pkgconfig.pc.in
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.806711 mqt.ddsim-1.18.0/extern/cxxopts/src/
+-rw-r--r--   0 runner    (1001) docker     (123)        8 2023-06-17 10:28:44.000000 mqt.ddsim-1.18.0/extern/cxxopts/src/.gitignore
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.806711 mqt.ddsim-1.18.0/extern/cxxopts/src/.tipi/
+-rw-r--r--   0 runner    (1001) docker     (123)       32 2023-06-17 10:28:44.000000 mqt.ddsim-1.18.0/extern/cxxopts/src/.tipi/deps
+-rw-r--r--   0 runner    (1001) docker     (123)     1221 2023-06-17 10:28:44.000000 mqt.ddsim-1.18.0/extern/cxxopts/src/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     5916 2023-06-17 10:28:44.000000 mqt.ddsim-1.18.0/extern/cxxopts/src/example.cpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.806711 mqt.ddsim-1.18.0/extern/mqt-core/
+-rwxr-xr-x   0 runner    (1001) docker     (123)     1904 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.810711 mqt.ddsim-1.18.0/extern/mqt-core/cmake/
+-rw-r--r--   0 runner    (1001) docker     (123)      841 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/cmake/Cache.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)      427 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/cmake/CheckSubmodule.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)     2294 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/cmake/CompilerOptions.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)     5328 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/cmake/CompilerWarnings.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)     2844 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/cmake/FindGMP.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)      708 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/cmake/PackageAddTest.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)      718 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/cmake/PreventInSourceBuilds.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)     1834 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/cmake/Sanitizers.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)     2120 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/cmake/StandardProjectSettings.cmake
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.798711 mqt.ddsim-1.18.0/extern/mqt-core/extern/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.794711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.810711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.810711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/.circleci/
+-rw-r--r--   0 runner    (1001) docker     (123)     2409 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/.circleci/config.yml
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.810711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/.drone/
+-rwxr-xr-x   0 runner    (1001) docker     (123)       14 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/.drone/after-success.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)       14 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/.drone/before-install.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)       14 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/.drone/before-script.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)     1529 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/.drone/boost.sh
+-rw-r--r--   0 runner    (1001) docker     (123)     8443 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/.drone.star
+-rw-r--r--   0 runner    (1001) docker     (123)       80 2023-06-17 10:28:46.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/.git
+-rw-r--r--   0 runner    (1001) docker     (123)     3917 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/.gitattributes
+-rw-r--r--   0 runner    (1001) docker     (123)       24 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/.gitignore
+-rw-r--r--   0 runner    (1001) docker     (123)      530 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2647 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/README.md
+-rw-r--r--   0 runner    (1001) docker     (123)     2630 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/appveyor.yml
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.810711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/
+-rw-r--r--   0 runner    (1001) docker     (123)    36764 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/Jamfile.v2
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.814711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/architecture/
+-rw-r--r--   0 runner    (1001) docker     (123)        4 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/architecture/.gitignore
+-rw-r--r--   0 runner    (1001) docker     (123)      248 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/architecture/32.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      248 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/architecture/64.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      754 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/architecture/Jamfile.jam
+-rw-r--r--   0 runner    (1001) docker     (123)      427 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/architecture/arm.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      934 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/architecture/combined.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      268 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/architecture/loongarch.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      307 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/architecture/mips.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      485 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/architecture/power.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      254 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/architecture/riscv.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      263 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/architecture/s390x.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      284 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/architecture/sparc.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      634 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/architecture/x86.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      491 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/config.jam
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.834711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/
+-rw-r--r--   0 runner    (1001) docker     (123)      749 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_aggregate_bases_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      749 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_aggregate_nsdmi_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      749 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_alias_templates_11.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      733 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_aligned_new_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      729 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_attributes_11.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      749 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_binary_literals_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      757 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_capture_star_this_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      717 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_char8_t_20.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      769 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_conditional_explicit_20.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      725 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_constexpr_11.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      725 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_constexpr_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      725 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_constexpr_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      721 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_decltype_11.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      741 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_decltype_auto_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      753 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_deduction_guides_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      781 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_delegating_constructors_11.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      773 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_enumerator_attributes_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      729 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_exceptions_03.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      765 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_explicit_conversion_11.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      753 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_fold_expressions_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      749 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_generic_lambdas_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      781 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_guaranteed_copy_elision_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      725 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_hex_float_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      737 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_if_constexpr_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      777 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_impl_destroying_delete_20.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      789 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_impl_three_way_comparison_20.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      781 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_inheriting_constructors_11.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      781 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_inheriting_constructors_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      741 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_init_captures_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      757 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_initializer_lists_11.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      753 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_inline_variables_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      717 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lambdas_11.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      800 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_addressof_constexpr_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      852 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_allocator_traits_is_always_equal_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      733 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_any_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      743 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_apply_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      786 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_array_constexpr_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      757 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_as_const_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      828 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_atomic_is_always_lock_free_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      764 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_atomic_ref_20.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      768 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_bind_front_20.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      753 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_bit_cast_20.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      781 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_bool_constant_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      808 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_boyer_moore_searcher_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      741 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_byte_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      752 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_char8_t_20.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      748 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_chrono_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      768 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_chrono_udls_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      747 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_clamp_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      773 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_complex_udls_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      758 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_concepts_20.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      779 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_constexpr_misc_20.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      827 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_constexpr_swap_algorithms_20.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      789 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_destroying_delete_20.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      816 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_enable_shared_from_this_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      756 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_erase_if_20.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      793 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_exchange_function_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      763 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_execution_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      768 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_filesystem_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      753 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_gcd_lcm_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      825 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_generic_associative_lookup_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      827 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_generic_unordered_lookup_20.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      825 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_hardware_interference_size_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      861 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_has_unique_object_representations_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      743 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_hypot_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      846 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_incomplete_container_elements_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      789 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_integer_sequence_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      833 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_integral_constant_callable_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      752 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_invoke_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      777 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_is_aggregate_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      813 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_is_constant_evaluated_20.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      761 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_is_final_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      777 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_is_invocable_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      789 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_is_null_pointer_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      777 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_is_swappable_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      749 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_launder_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      822 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_list_remove_return_type_20.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      785 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_logical_traits_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      783 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_make_from_tuple_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      810 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_make_reverse_iterator_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      768 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_make_unique_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      781 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_map_try_emplace_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      811 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_math_special_functions_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      793 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_memory_resource_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      769 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_node_extract_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      830 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_nonmember_container_access_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      752 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_not_fn_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      782 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_null_iterators_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      758 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_optional_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      799 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_parallel_algorithm_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      789 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_quoted_string_io_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      751 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_ranges_20.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      808 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_raw_memory_algorithms_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      792 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_result_of_sfinae_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      835 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_robust_nonmodifying_seq_ops_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      751 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_sample_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      767 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_scoped_lock_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      778 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_shared_mutex_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      792 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_shared_ptr_arrays_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      804 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_shared_ptr_weak_type_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      802 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_shared_timed_mutex_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      768 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_string_udls_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      768 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_string_view_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      805 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_three_way_comparison_20.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      757 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_to_chars_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      841 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_transformation_trait_aliases_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      812 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_transparent_operators_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      808 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_transparent_operators_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      783 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_tuple_element_t_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      781 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_tuples_by_type_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      845 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_type_trait_variable_templates_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      803 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_uncaught_exceptions_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      831 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_unordered_map_try_emplace_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      753 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_variant_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      753 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_void_t_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      769 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_namespace_attributes_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      777 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_noexcept_function_type_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      773 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_nontype_template_args_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      813 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_nontype_template_parameter_auto_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      817 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_nontype_template_parameter_class_20.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      709 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_nsdmi_11.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      749 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_range_based_for_11.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      749 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_range_based_for_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      733 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_raw_strings_11.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      745 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_ref_qualifiers_11.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      773 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_return_type_deduction_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      705 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_rtti_03.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      757 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_rvalue_references_11.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      761 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_sized_deallocation_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      741 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_static_assert_11.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      741 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_static_assert_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      765 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_structured_bindings_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      777 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_template_template_args_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      777 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_threadsafe_static_init_11.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      761 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_unicode_characters_11.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      753 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_unicode_literals_11.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      773 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_user_defined_literals_11.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      761 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_variable_templates_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      761 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_variadic_templates_11.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      745 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_variadic_using_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    36893 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/test_case.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)   105382 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/configure
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.794711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.834711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.834711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.834711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/abi/
+-rw-r--r--   0 runner    (1001) docker     (123)     1002 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/abi/borland_prefix.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      280 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/abi/borland_suffix.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      819 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/abi/msvc_prefix.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      252 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/abi/msvc_suffix.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      700 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/abi_prefix.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      781 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/abi_suffix.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    11405 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/assert_cxx03.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    11520 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/assert_cxx11.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2396 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/assert_cxx14.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3174 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/assert_cxx17.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2948 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/assert_cxx20.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      989 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/assert_cxx98.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    17829 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/auto_link.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.838711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/
+-rw-r--r--   0 runner    (1001) docker     (123)    10760 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/borland.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    10085 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/clang.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2305 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/clang_version.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    11602 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/codegear.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1638 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/comeau.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     6038 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/common_edg.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      501 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/compaq_cxx.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    15493 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/cray.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      909 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/diab.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4626 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/digitalmars.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    12427 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/gcc.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4078 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/gcc_xml.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      822 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/greenhills.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     5000 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/hp_acc.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    22537 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/intel.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1030 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/kai.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     6408 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/metrowerks.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4811 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/mpw.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2095 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/nvcc.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     5156 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/pathscale.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      770 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/pgi.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      774 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/sgi_mipspro.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     7705 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/sunpro_cc.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     6149 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/vacpp.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    12588 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/visualc.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     8202 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/xlcpp.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4984 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/xlcpp_zos.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.842711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/detail/
+-rw-r--r--   0 runner    (1001) docker     (123)     8629 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/detail/cxx_composite.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3736 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/detail/posix_features.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     5356 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/detail/select_compiler_config.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4588 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/detail/select_platform_config.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4653 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/detail/select_stdlib_config.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    46059 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/detail/suffix.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      848 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/header_deprecated.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1120 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/helper_macros.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.842711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/no_tr1/
+-rw-r--r--   0 runner    (1001) docker     (123)      838 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/no_tr1/cmath.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      854 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/no_tr1/complex.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      878 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/no_tr1/functional.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      846 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/no_tr1/memory.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      854 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/no_tr1/utility.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.846711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/
+-rw-r--r--   0 runner    (1001) docker     (123)      888 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/aix.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      442 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/amigaos.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      600 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/beos.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2592 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/bsd.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      530 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/cloudabi.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      456 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/cray.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1872 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/cygwin.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      807 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/haiku.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2484 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/hpux.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      796 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/irix.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2850 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/linux.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2350 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/macos.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      773 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/qnxnto.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      841 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/solaris.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2621 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/symbian.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      749 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/vms.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    14836 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/vxworks.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      578 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/wasm.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2718 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/win32.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      789 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/zos.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1019 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/pragma_message.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3509 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/requires_threads.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.846711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/stdlib/
+-rw-r--r--   0 runner    (1001) docker     (123)    11403 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/stdlib/dinkumware.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2830 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/stdlib/libcomo.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     5867 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/stdlib/libcpp.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    15824 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/stdlib/libstdcpp3.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2235 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/stdlib/modena.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2836 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/stdlib/msl.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     6260 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/stdlib/roguewave.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     5061 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/stdlib/sgi.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     8585 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/stdlib/stlport.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2394 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/stdlib/vacpp.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1963 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/stdlib/xlcpp_zos.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     5365 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/user.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1820 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/warning_disable.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     8171 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/workaround.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2216 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    18497 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/cstdint.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4160 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/cxx11_char_types.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.846711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/detail/
+-rw-r--r--   0 runner    (1001) docker     (123)      353 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/detail/workaround.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     6362 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/limits.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1117 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/version.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      558 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/index.html
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.846711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/tools/
+-rw-r--r--   0 runner    (1001) docker     (123)      371 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/tools/Jamfile.v2
+-rw-r--r--   0 runner    (1001) docker     (123)     9935 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/tools/configure.in
+-rw-r--r--   0 runner    (1001) docker     (123)    27756 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/tools/generate.cpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.846711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.846711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/.circleci/
+-rw-r--r--   0 runner    (1001) docker     (123)    11257 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/.circleci/config.yml
+-rw-r--r--   0 runner    (1001) docker     (123)      706 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/.clang-format
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.850711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/.drone/
+-rwxr-xr-x   0 runner    (1001) docker     (123)       14 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/.drone/after-success.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)       14 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/.drone/before-install.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)       14 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/.drone/before-script.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)     1818 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/.drone/boost.sh
+-rw-r--r--   0 runner    (1001) docker     (123)    52843 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/.drone.star
+-rw-r--r--   0 runner    (1001) docker     (123)       88 2023-06-17 10:28:47.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/.git
+-rw-r--r--   0 runner    (1001) docker     (123)     3917 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/.gitattributes
+-rw-r--r--   0 runner    (1001) docker     (123)      366 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/.gitignore
+-rw-r--r--   0 runner    (1001) docker     (123)     1427 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1338 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     4710 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/README.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.850711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/config/
+-rw-r--r--   0 runner    (1001) docker     (123)     3218 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/config/Jamfile.v2
+-rw-r--r--   0 runner    (1001) docker     (123)      307 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/config/has_big_obj.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      395 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/config/has_constexpr_limits_cmd.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      350 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/config/has_eigen.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      271 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/config/has_f2c.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      510 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/config/has_float128.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      971 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/config/has_gmp.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      332 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/config/has_intel_quad.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1860 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/config/has_is_constant_evaluated.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1593 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/config/has_mpc.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1626 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/config/has_mpfi.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1273 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/config/has_mpfr.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      337 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/config/has_tommath.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      339 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/config/is_ci_sanitizer_run.cpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.854711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/
+-rw-r--r--   0 runner    (1001) docker     (123)     6015 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/Jamfile.v2
+-rw-r--r--   0 runner    (1001) docker     (123)     7923 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/big_seventh.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     5806 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/complex128_examples.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     9922 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/constexpr_float_arithmetic_examples.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1355 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/cpp_bin_float_import_export.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1384 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/cpp_bin_float_snips.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     5815 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/cpp_complex_examples.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1456 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/cpp_dec_float_snips.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1113 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/cpp_int_import_export.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     7525 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/cpp_int_mul_timing.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1627 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/cpp_int_snips.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      904 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/debug_adaptor_snips.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1487 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/eigen_example.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    15651 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/exercise_threading_log_agm.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4002 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/float128_snips.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    25152 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/floating_point_examples.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    22324 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/gauss_laguerre_quadrature.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2682 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/gmp_snips.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1842 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/hashing_examples.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    26773 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/hypergeometric_luke_algorithms.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     7357 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/integer_examples.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4693 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/logged_adaptor.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1367 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/mixed_integer_arithmetic.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     6574 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/mpc_examples.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1375 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/mpfi_snips.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     9370 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/mpfr_precision.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1323 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/mpfr_snips.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    13722 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/numeric_limits_snips.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    11319 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/random_snips.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1442 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/safe_prime.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    15503 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/scoped_precision_example.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    13893 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/standalone_bernoulli_tgamma.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1742 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/tommath_snips.cpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.794711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.794711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.862711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/
+-rw-r--r--   0 runner    (1001) docker     (123)      636 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/complex128.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    31669 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/complex_adaptor.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.862711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/concepts/
+-rw-r--r--   0 runner    (1001) docker     (123)     8625 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/concepts/mp_number_archetypes.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.862711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_bin_float/
+-rw-r--r--   0 runner    (1001) docker     (123)    26429 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_bin_float/io.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     5100 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_bin_float/transcendental.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)   105093 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_bin_float.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      446 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_complex.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)   167646 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_dec_float.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.862711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/
+-rw-r--r--   0 runner    (1001) docker     (123)    22328 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/add.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    14128 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/add_unsigned.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    42474 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/bitwise.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     5242 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/checked.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    19208 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/comparison.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     6805 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/cpp_int_config.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    27075 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/divide.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    12507 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/import_export.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4280 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/intel_intrinsics.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    26868 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/limits.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    12241 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/literals.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    62453 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/misc.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    45749 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/multiply.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     7244 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/serialize.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      928 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/value_pack.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)   103936 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    35019 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/debug_adaptor.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.870711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/
+-rw-r--r--   0 runner    (1001) docker     (123)      810 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/assert.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2004 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/atomic.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    10587 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/bitscan.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3737 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/check_cpp11_config.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2139 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/constexpr.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)   239455 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/default_ops.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1343 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/digits.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1772 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/dynamic_array.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2568 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/empty_value.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1360 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/endian.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)   121893 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/et_ops.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2660 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/float128_functions.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     9240 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/float_string_cvt.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3690 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/fpclassify.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.870711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/functions/
+-rw-r--r--   0 runner    (1001) docker     (123)    11774 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/functions/constants.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    27767 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/functions/pow.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    32274 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/functions/trig.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1946 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/functions/trunc.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    26407 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/generic_interconvert.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1415 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/hash.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    18164 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/integer_ops.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1101 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/itos.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     5048 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/min_max.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    34948 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/no_et_ops.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1869 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/no_exceptions_support.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    72522 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/number_base.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    51232 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/number_compare.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    13298 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/precision.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      730 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/rebind.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4625 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/standalone_config.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1456 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/static_array.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1446 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/string_helpers.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     6727 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/tables.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4325 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/ublas_interop.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     6223 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/uniform_int_distribution.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     6001 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/utype_helper.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    13883 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/eigen.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    37229 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/float128.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    12594 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/fwd.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)   146941 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/gmp.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    12039 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/integer.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    42804 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/logged_adaptor.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     6412 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/miller_rabin.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    61210 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/mpc.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)   115307 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/mpfi.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)   204893 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/mpfr.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)   120900 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/number.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      777 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/random.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    39529 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/rational_adaptor.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    37350 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/tommath.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.870711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/traits/
+-rw-r--r--   0 runner    (1001) docker     (123)     2480 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/traits/explicit_conversion.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      743 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/traits/extract_exponent_type.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2842 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/traits/is_backend.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1609 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/traits/is_byte_container.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      717 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/traits/is_complex.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1854 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/traits/is_convertible_arithmetic.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2533 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/traits/is_restricted_conversion.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      851 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/traits/is_variable_precision.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2896 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/traits/max_digits10.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2563 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/traits/std_integer_traits.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      621 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/traits/transcendental_reduction_type.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      558 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/index.html
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.874711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/
+-rw-r--r--   0 runner    (1001) docker     (123)    14642 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/Jamfile.v2
+-rw-r--r--   0 runner    (1001) docker     (123)    26000 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/arithmetic_backend.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4412 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/cpp_bin_float_conversion_performance.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     9520 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/delaunay_test.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2298 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/delaunay_test.log
+-rw-r--r--   0 runner    (1001) docker     (123)     7054 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/gcd_bench.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    34846 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/linpack-benchmark.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1876 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/miller_rabin_performance.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2481 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/miller_rabin_performance.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1649 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/miller_rabin_performance.log
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.878711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/miller_rabin_performance_files/
+-rw-r--r--   0 runner    (1001) docker     (123)      479 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/miller_rabin_performance_files/test01.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      426 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/miller_rabin_performance_files/test02.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      465 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/miller_rabin_performance_files/test03.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      465 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/miller_rabin_performance_files/test04.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      465 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/miller_rabin_performance_files/test05.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      467 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/miller_rabin_performance_files/test06.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      432 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/miller_rabin_performance_files/test07.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      448 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/miller_rabin_performance_files/test08.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      465 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/miller_rabin_performance_files/test09.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      528 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/miller_rabin_performance_files/test10.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      496 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/miller_rabin_performance_files/test11.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      449 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/miller_rabin_performance_files/test12.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     8314 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/mixed_equivalent_types_bench.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    33287 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test-gcc-linux.log
+-rw-r--r--   0 runner    (1001) docker     (123)    20844 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test-intel-linux.log
+-rw-r--r--   0 runner    (1001) docker     (123)    57569 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test-msvc-10.log
+-rw-r--r--   0 runner    (1001) docker     (123)     5781 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    26585 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)   138507 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test.log
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.886711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/
+-rw-r--r--   0 runner    (1001) docker     (123)      377 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test01.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      462 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test02.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      464 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test03.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      464 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test04.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      456 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test05.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      456 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test06.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      456 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test07.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      457 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test08.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1099 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test09.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      637 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test10.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      637 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test11.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      640 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test12.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      468 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test13.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      468 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      468 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test15.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      469 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test16.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      496 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      496 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test18.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      496 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test19.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      497 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test20.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      466 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test21.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      466 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test22.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      466 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test23.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      467 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test24.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      472 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test25.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      472 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test26.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      472 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test27.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      811 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test28.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      500 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test29.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      502 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test30.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      536 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test31.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      500 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test32.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      502 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test33.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      536 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test34.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      467 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test35.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      467 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test36.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      469 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test37.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      469 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test38.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      459 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test39.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      459 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test40.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      607 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test41.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      473 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test42.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      813 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test43.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      813 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test44.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      473 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test45.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      473 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test46.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      474 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test47.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      813 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test48.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      814 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test49.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      459 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test50.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      460 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test51.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3336 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/rational_bernoulli_allocations.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3751 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/rational_bernoulli_allocations.log
+-rw-r--r--   0 runner    (1001) docker     (123)     2054 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/rational_bernoulli_bench.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    25575 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/rational_bernoulli_bench.log
+-rw-r--r--   0 runner    (1001) docker     (123)     4054 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/rational_determinant_bench.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2424 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/rational_determinant_bench.log
+-rw-r--r--   0 runner    (1001) docker     (123)     1283 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/rational_zeta18_bench.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2877 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance-msvc-10.log
+-rw-r--r--   0 runner    (1001) docker     (123)     2719 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     6907 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    11229 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance.log
+-rw-r--r--   0 runner    (1001) docker     (123)      487 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_basic.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1693 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_bessel.cpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.894711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/
+-rw-r--r--   0 runner    (1001) docker     (123)      460 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_basic_1.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      448 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_basic_2.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      397 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_basic_3.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      397 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_basic_4.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      480 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_basic_5.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      447 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_basic_6.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      396 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_basic_7.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      396 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_basic_8.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1350 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_basic_9.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      676 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_01.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      733 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_02.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      726 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_03.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      780 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_04.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      438 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_05.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      481 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_06.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      456 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_07.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      456 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_08.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      469 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_09.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      469 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_10.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      441 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_11.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      492 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_12.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      455 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_13.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      438 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      481 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_15.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      456 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_16.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      456 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      439 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_18.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      439 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_19.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      442 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_01.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      493 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_02.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      456 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_03.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      439 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_04.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      482 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_05.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      391 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_06.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      457 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_07.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      460 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_08.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      442 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_09.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      442 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_10.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      445 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_11.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      496 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_12.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      459 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_13.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      442 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      485 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_15.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      392 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_16.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      460 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      460 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_18.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      443 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_19.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      443 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_nct_20.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      445 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_01.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      496 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_02.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      459 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_03.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      442 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_04.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      485 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_05.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      460 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_06.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      460 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_07.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      445 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_08.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      445 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_09.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      448 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_10.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      498 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_11.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      462 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_12.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      445 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_13.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      488 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_14.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      463 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_15.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      463 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_16.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      446 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_17.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      446 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_poly_18.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1474 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_nct.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1634 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_poly.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3716 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sqrt_bench.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1072 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/veronoi_performance.log
+-rw-r--r--   0 runner    (1001) docker     (123)     8396 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/voronoi_performance.cpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.894711 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/tools/
+-rw-r--r--   0 runner    (1001) docker     (123)     1790 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/tools/sincos.cpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.898711 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/
+-rw-r--r--   0 runner    (1001) docker     (123)      400 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/.cirrus.yml
+-rw-r--r--   0 runner    (1001) docker     (123)     2442 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/.clang-format
+-rw-r--r--   0 runner    (1001) docker     (123)     2241 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/.clang-tidy
+-rw-r--r--   0 runner    (1001) docker     (123)       69 2023-06-17 10:28:48.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/.git
+-rw-r--r--   0 runner    (1001) docker     (123)      608 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/.gitignore
+-rw-r--r--   0 runner    (1001) docker     (123)       77 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/.lgtm.yml
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.898711 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/.reuse/
+-rw-r--r--   0 runner    (1001) docker     (123)      275 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/.reuse/README.md
+-rw-r--r--   0 runner    (1001) docker     (123)      830 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/.reuse/dep5
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.898711 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/.reuse/templates/
+-rw-r--r--   0 runner    (1001) docker     (123)      349 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/.reuse/templates/json.jinja2
+-rw-r--r--   0 runner    (1001) docker     (123)      367 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/.reuse/templates/json_support.jinja2
+-rw-r--r--   0 runner    (1001) docker     (123)     2634 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/BUILD.bazel
+-rw-r--r--   0 runner    (1001) docker     (123)      410 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/CITATION.cff
+-rw-r--r--   0 runner    (1001) docker     (123)     7144 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)   304881 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/ChangeLog.md
+-rw-r--r--   0 runner    (1001) docker     (123)     1076 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/LICENSE.MIT
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.898711 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/LICENSES/
+-rw-r--r--   0 runner    (1001) docker     (123)    10280 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/LICENSES/Apache-2.0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1460 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/LICENSES/BSD-3-Clause.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    34670 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/LICENSES/GPL-3.0-only.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1078 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/LICENSES/MIT.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    13438 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/Makefile
+-rw-r--r--   0 runner    (1001) docker     (123)   110430 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/README.md
+-rw-r--r--   0 runner    (1001) docker     (123)       34 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/WORKSPACE.bazel
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.898711 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/cmake/
+-rw-r--r--   0 runner    (1001) docker     (123)    45191 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/cmake/ci.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)      710 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/cmake/config.cmake.in
+-rw-r--r--   0 runner    (1001) docker     (123)     3185 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/cmake/download_test_data.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)      709 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/cmake/nlohmann_jsonConfigVersion.cmake.in
+-rw-r--r--   0 runner    (1001) docker     (123)      126 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/cmake/pkg-config.pc.in
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.898711 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/cmake/scripts/
+-rw-r--r--   0 runner    (1001) docker     (123)      543 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/cmake/scripts/gen_bazel_build_file.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)    10468 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/cmake/test.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)      629 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/meson.build
+-rw-r--r--   0 runner    (1001) docker     (123)    19578 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/nlohmann_json.natvis
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.794711 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/single_include/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.898711 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/single_include/nlohmann/
+-rw-r--r--   0 runner    (1001) docker     (123)   914638 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/single_include/nlohmann/json.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     6340 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/single_include/nlohmann/json_fwd.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      608 2023-06-17 10:28:52.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/json/wsjcpp.yml
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.906711 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/
+-rw-r--r--   0 runner    (1001) docker     (123)     1271 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/.appveyor.yml
+-rw-r--r--   0 runner    (1001) docker     (123)      996 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/.clang-format
+-rw-r--r--   0 runner    (1001) docker     (123)     2605 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/.clang-tidy
+-rw-r--r--   0 runner    (1001) docker     (123)     2196 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/.cmake-format.yaml
+-rw-r--r--   0 runner    (1001) docker     (123)     1308 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/.codespell-ignore-lines
+-rw-r--r--   0 runner    (1001) docker     (123)       73 2023-06-17 10:28:49.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/.git
+-rw-r--r--   0 runner    (1001) docker     (123)       18 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/.gitattributes
+-rw-r--r--   0 runner    (1001) docker     (123)      502 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/.gitignore
+-rw-r--r--   0 runner    (1001) docker     (123)     3600 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/.pre-commit-config.yaml
+-rw-r--r--   0 runner    (1001) docker     (123)       62 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/.readthedocs.yml
+-rw-r--r--   0 runner    (1001) docker     (123)    12067 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1684 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)      247 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/MANIFEST.in
+-rw-r--r--   0 runner    (1001) docker     (123)     7686 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/README.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      688 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/SECURITY.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.794711 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.914711 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/
+-rw-r--r--   0 runner    (1001) docker     (123)    24334 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/attr.h
+-rw-r--r--   0 runner    (1001) docker     (123)     7750 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/buffer_info.h
+-rw-r--r--   0 runner    (1001) docker     (123)    67312 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/cast.h
+-rw-r--r--   0 runner    (1001) docker     (123)     8458 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/chrono.h
+-rw-r--r--   0 runner    (1001) docker     (123)      120 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/common.h
+-rw-r--r--   0 runner    (1001) docker     (123)     2096 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/complex.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.914711 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/detail/
+-rw-r--r--   0 runner    (1001) docker     (123)    28518 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/detail/class.h
+-rw-r--r--   0 runner    (1001) docker     (123)    53759 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/detail/common.h
+-rw-r--r--   0 runner    (1001) docker     (123)     5962 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/detail/descr.h
+-rw-r--r--   0 runner    (1001) docker     (123)    17859 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/detail/init.h
+-rw-r--r--   0 runner    (1001) docker     (123)    28221 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/detail/internals.h
+-rw-r--r--   0 runner    (1001) docker     (123)    48364 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/detail/type_caster_base.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1625 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/detail/typeid.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.914711 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/eigen/
+-rw-r--r--   0 runner    (1001) docker     (123)      378 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/eigen/common.h
+-rw-r--r--   0 runner    (1001) docker     (123)    32135 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/eigen/matrix.h
+-rw-r--r--   0 runner    (1001) docker     (123)    18442 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/eigen/tensor.h
+-rw-r--r--   0 runner    (1001) docker     (123)      316 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/eigen.h
+-rw-r--r--   0 runner    (1001) docker     (123)    13459 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/embed.h
+-rw-r--r--   0 runner    (1001) docker     (123)     4731 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/eval.h
+-rw-r--r--   0 runner    (1001) docker     (123)     5002 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/functional.h
+-rw-r--r--   0 runner    (1001) docker     (123)     8262 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/gil.h
+-rw-r--r--   0 runner    (1001) docker     (123)     8862 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/iostream.h
+-rw-r--r--   0 runner    (1001) docker     (123)    79725 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/numpy.h
+-rw-r--r--   0 runner    (1001) docker     (123)     9103 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/operators.h
+-rw-r--r--   0 runner    (1001) docker     (123)     2734 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/options.h
+-rw-r--r--   0 runner    (1001) docker     (123)   126708 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/pybind11.h
+-rw-r--r--   0 runner    (1001) docker     (123)    97610 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/pytypes.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.918711 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/stl/
+-rw-r--r--   0 runner    (1001) docker     (123)     4185 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/stl/filesystem.h
+-rw-r--r--   0 runner    (1001) docker     (123)    15477 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/stl.h
+-rw-r--r--   0 runner    (1001) docker     (123)    29897 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/stl_bind.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1929 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/type_caster_pyobject_ptr.h
+-rw-r--r--   0 runner    (1001) docker     (123)     2765 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/noxfile.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.918711 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/pybind11/
+-rw-r--r--   0 runner    (1001) docker     (123)      429 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/pybind11/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1544 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/pybind11/__main__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      233 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/pybind11/_version.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1207 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/pybind11/commands.py
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/pybind11/py.typed
+-rw-r--r--   0 runner    (1001) docker     (123)    17462 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/pybind11/setup_helpers.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2360 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/pyproject.toml
+-rw-r--r--   0 runner    (1001) docker     (123)     1452 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (123)     4877 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.926711 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/
+-rw-r--r--   0 runner    (1001) docker     (123)     2449 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/FindCatch.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)     3105 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/FindEigen3.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)    11190 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/FindPythonLibsNew.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)      817 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/JoinPaths.cmake
+-rwxr-xr-x   0 runner    (1001) docker     (123)     1423 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/check-style.sh
+-rw-r--r--   0 runner    (1001) docker     (123)      952 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/cmake_uninstall.cmake.in
+-rw-r--r--   0 runner    (1001) docker     (123)     1117 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/codespell_ignore_lines_from_errors.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1031 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/libsize.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     1311 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/make_changelog.py
+-rw-r--r--   0 runner    (1001) docker     (123)      196 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/pybind11.pc.in
+-rw-r--r--   0 runner    (1001) docker     (123)    14179 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/pybind11Common.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)     6930 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/pybind11Config.cmake.in
+-rw-r--r--   0 runner    (1001) docker     (123)     8960 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/pybind11NewTools.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)     8361 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/pybind11Tools.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)       94 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/pyproject.toml
+-rw-r--r--   0 runner    (1001) docker     (123)     2104 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/setup_global.py.in
+-rw-r--r--   0 runner    (1001) docker     (123)     1234 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/setup_main.py.in
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.926711 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11_json/
+-rw-r--r--   0 runner    (1001) docker     (123)       78 2023-06-17 10:28:50.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11_json/.git
+-rw-r--r--   0 runner    (1001) docker     (123)        8 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11_json/.gitignore
+-rw-r--r--   0 runner    (1001) docker     (123)     5062 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11_json/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1499 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11_json/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     4129 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11_json/README.md
+-rw-r--r--   0 runner    (1001) docker     (123)      173 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11_json/dev-environment.yml
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.798711 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11_json/include/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.926711 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11_json/include/pybind11_json/
+-rw-r--r--   0 runner    (1001) docker     (123)     7219 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11_json/include/pybind11_json/pybind11_json.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1213 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11_json/pybind11_jsonConfig.cmake.in
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.930711 mqt.ddsim-1.18.0/extern/mqt-core/include/
+-rw-r--r--   0 runner    (1001) docker     (123)     2816 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/CircuitOptimizer.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2183 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/Definitions.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      589 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/Permutation.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    44948 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/QuantumComputation.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.930711 mqt.ddsim-1.18.0/extern/mqt-core/include/algorithms/
+-rw-r--r--   0 runner    (1001) docker     (123)      639 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/algorithms/BernsteinVazirani.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      183 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/algorithms/Entanglement.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1539 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/algorithms/GoogleRandomCircuitSampling.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      645 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/algorithms/Grover.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      383 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/algorithms/QFT.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      418 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/algorithms/QPE.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      628 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/algorithms/RandomCliffordCircuit.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.938711 mqt.ddsim-1.18.0/extern/mqt-core/include/dd/
+-rw-r--r--   0 runner    (1001) docker     (123)     2626 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/dd/Complex.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3326 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/dd/ComplexCache.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     6538 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/dd/ComplexNumbers.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    18656 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/dd/ComplexTable.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     8023 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/dd/ComplexValue.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3016 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/dd/ComputeTable.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1561 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/dd/Control.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3102 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/dd/Definitions.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2550 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/dd/DensityNoiseTable.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3761 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/dd/Edge.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    32276 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/dd/Export.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2050 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/dd/FunctionalityConstruction.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    10434 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/dd/GateMatrixDefinitions.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    10703 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/dd/Node.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    29263 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/dd/NoiseFunctionality.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    14991 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/dd/Operations.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)   124668 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/dd/Package.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1810 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/dd/Simulation.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2126 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/dd/StochasticNoiseOperationTable.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2470 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/dd/ToffoliTable.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1968 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/dd/UnaryComputeTable.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    12543 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/dd/UniqueTable.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.942711 mqt.ddsim-1.18.0/extern/mqt-core/include/ecc/
+-rw-r--r--   0 runner    (1001) docker     (123)     3083 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/ecc/Ecc.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      499 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/ecc/Id.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2452 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/ecc/Q18Surface.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      558 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/ecc/Q3Shor.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1200 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/ecc/Q5Laflamme.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      881 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/ecc/Q7Steane.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      726 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/ecc/Q9Shor.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1800 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/ecc/Q9Surface.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.946711 mqt.ddsim-1.18.0/extern/mqt-core/include/operations/
+-rw-r--r--   0 runner    (1001) docker     (123)     3203 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/operations/ClassicControlledOperation.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     6226 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/operations/CompoundOperation.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1513 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/operations/Control.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    13265 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/operations/Expression.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4198 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/operations/NonUnitaryOperation.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     5696 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/operations/OpType.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4486 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/operations/Operation.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3047 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/operations/StandardOperation.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     5359 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/operations/SymbolicOperation.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.798711 mqt.ddsim-1.18.0/extern/mqt-core/include/parsers/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.946711 mqt.ddsim-1.18.0/extern/mqt-core/include/parsers/qasm_parser/
+-rw-r--r--   0 runner    (1001) docker     (123)     7044 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/parsers/qasm_parser/Parser.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1004 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/parsers/qasm_parser/Scanner.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2512 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/parsers/qasm_parser/Token.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.798711 mqt.ddsim-1.18.0/extern/mqt-core/include/python/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.946711 mqt.ddsim-1.18.0/extern/mqt-core/include/python/qiskit/
+-rw-r--r--   0 runner    (1001) docker     (123)      771 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/python/qiskit/QasmQobjExperiment.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1703 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/python/qiskit/QuantumCircuit.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.950711 mqt.ddsim-1.18.0/extern/mqt-core/include/zx/
+-rw-r--r--   0 runner    (1001) docker     (123)     1016 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/zx/Definitions.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1854 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/zx/FunctionalityConstruction.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     5874 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/zx/Rational.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      837 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/zx/Rules.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1685 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/zx/Simplify.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4333 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/zx/Utils.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     5133 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/include/zx/ZXDiagram.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.950711 mqt.ddsim-1.18.0/extern/mqt-core/src/
+-rw-r--r--   0 runner    (1001) docker     (123)     8730 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    45973 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/CircuitOptimizer.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    33022 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/QuantumComputation.cpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.950711 mqt.ddsim-1.18.0/extern/mqt-core/src/algorithms/
+-rw-r--r--   0 runner    (1001) docker     (123)     2868 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/algorithms/BernsteinVazirani.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      355 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/algorithms/Entanglement.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4313 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/algorithms/GoogleRandomCircuitSampling.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3133 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/algorithms/Grover.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2666 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/algorithms/QFT.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3874 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/algorithms/QPE.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    10007 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/algorithms/RandomCliffordCircuit.cpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.954712 mqt.ddsim-1.18.0/extern/mqt-core/src/dd/
+-rw-r--r--   0 runner    (1001) docker     (123)     7334 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/dd/FunctionalityConstruction.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      198 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/dd/NoiseFunctionality.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4674 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/dd/Operations.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    17049 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/dd/Simulation.cpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.954712 mqt.ddsim-1.18.0/extern/mqt-core/src/ecc/
+-rw-r--r--   0 runner    (1001) docker     (123)     1011 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/ecc/Ecc.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     5215 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/ecc/Q18Surface.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4568 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/ecc/Q3Shor.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     5405 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/ecc/Q5Laflamme.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     8201 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/ecc/Q7Steane.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     7023 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/ecc/Q9Shor.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     6100 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/ecc/Q9Surface.cpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.958711 mqt.ddsim-1.18.0/extern/mqt-core/src/operations/
+-rw-r--r--   0 runner    (1001) docker     (123)      485 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/operations/Expression.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     8745 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/operations/NonUnitaryOperation.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     5659 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/operations/Operation.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    13610 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/operations/StandardOperation.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    11259 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/operations/SymbolicOperation.cpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.958711 mqt.ddsim-1.18.0/extern/mqt-core/src/parsers/
+-rw-r--r--   0 runner    (1001) docker     (123)     1060 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/parsers/GRCSParser.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4620 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/parsers/QASMParser.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    10390 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/parsers/QCParser.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     8876 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/parsers/RealParser.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     8238 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/parsers/TFCParser.cpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.958711 mqt.ddsim-1.18.0/extern/mqt-core/src/parsers/qasm_parser/
+-rw-r--r--   0 runner    (1001) docker     (123)    31184 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/parsers/qasm_parser/Parser.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     8307 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/parsers/qasm_parser/Scanner.cpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.798711 mqt.ddsim-1.18.0/extern/mqt-core/src/python/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.958711 mqt.ddsim-1.18.0/extern/mqt-core/src/python/qiskit/
+-rw-r--r--   0 runner    (1001) docker     (123)     9577 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/python/qiskit/QasmQobjExperiment.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    18192 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/python/qiskit/QuantumCircuit.cpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.962711 mqt.ddsim-1.18.0/extern/mqt-core/src/zx/
+-rw-r--r--   0 runner    (1001) docker     (123)    15800 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/zx/FunctionalityConstruction.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1807 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/zx/Rational.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    10645 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/zx/Rules.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2829 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/zx/Simplify.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4310 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/zx/Utils.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    11412 2023-06-17 10:28:45.000000 mqt.ddsim-1.18.0/extern/mqt-core/src/zx/ZXDiagram.cpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.962711 mqt.ddsim-1.18.0/extern/taskflow/
+-rw-r--r--   0 runner    (1001) docker     (123)       43 2023-06-17 10:28:43.000000 mqt.ddsim-1.18.0/extern/taskflow/.git
+-rw-r--r--   0 runner    (1001) docker     (123)      110 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/taskflow/.gitattributes
+-rw-r--r--   0 runner    (1001) docker     (123)        7 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/taskflow/.gitignore
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.966711 mqt.ddsim-1.18.0/extern/taskflow/.vscode/
+-rw-r--r--   0 runner    (1001) docker     (123)      445 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/taskflow/.vscode/c_cpp_properties.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1738 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/taskflow/.vscode/settings.json
+-rw-r--r--   0 runner    (1001) docker     (123)    14211 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/taskflow/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1091 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/taskflow/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)    17472 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/taskflow/README.md
+-rw-r--r--   0 runner    (1001) docker     (123)      458 2023-06-17 10:28:53.000000 mqt.ddsim-1.18.0/extern/taskflow/TaskflowConfig.cmake.in
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.798711 mqt.ddsim-1.18.0/extern/taskflow/cmake/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.798711 mqt.ddsim-1.18.0/extern/taskflow/cmake/ComputeCpp/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.966711 mqt.ddsim-1.18.0/extern/taskflow/cmake/ComputeCpp/Modules/
+-rw-r--r--   0 runner    (1001) docker     (123)     2875 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/cmake/ComputeCpp/Modules/ComputeCppCompilerChecks.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)      475 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/cmake/ComputeCpp/Modules/ComputeCppIRMap.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)    16648 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/cmake/ComputeCpp/Modules/FindComputeCpp.cmake
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.966711 mqt.ddsim-1.18.0/extern/taskflow/cmake/ComputeCpp/toolchains/
+-rw-r--r--   0 runner    (1001) docker     (123)     2256 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/cmake/ComputeCpp/toolchains/arm-gcc-poky.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)      754 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/cmake/ComputeCpp/toolchains/gcc-generic.cmake
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.798711 mqt.ddsim-1.18.0/extern/taskflow/cmake/cuda/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.966711 mqt.ddsim-1.18.0/extern/taskflow/cmake/cuda/modules/
+-rw-r--r--   0 runner    (1001) docker     (123)     2894 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/cmake/cuda/modules/FindcuBLAS.cmake
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.966711 mqt.ddsim-1.18.0/extern/taskflow/taskflow/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.970712 mqt.ddsim-1.18.0/extern/taskflow/taskflow/algorithm/
+-rw-r--r--   0 runner    (1001) docker     (123)     2172 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/algorithm/critical.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    16653 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/algorithm/data_pipeline.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    15050 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/algorithm/find.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4863 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/algorithm/for_each.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1139 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/algorithm/launch.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    14524 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/algorithm/partitioner.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    44892 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/algorithm/pipeline.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    12383 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/algorithm/reduce.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    17045 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/algorithm/scan.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    21372 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/algorithm/sort.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     5943 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/algorithm/transform.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.978711 mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/
+-rw-r--r--   0 runner    (1001) docker     (123)     9629 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/async.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     5007 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/async_task.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1342 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/declarations.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      160 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/environment.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      728 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/error.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    54781 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/executor-module-opt.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    68326 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/executor.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    43647 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/flow_builder.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    24245 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/graph.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    10122 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/notifier.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    26126 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/observer.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3441 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/semaphore.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    18519 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/task.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    15683 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/taskflow.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1067 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/topology.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    12210 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/tsq.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     6624 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/worker.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.978711 mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.982712 mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/algorithm/
+-rw-r--r--   0 runner    (1001) docker     (123)     7536 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/algorithm/find.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     7858 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/algorithm/for_each.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1247 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/algorithm/matmul.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    17596 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/algorithm/merge.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    12265 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/algorithm/reduce.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    12734 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/algorithm/scan.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    14765 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/algorithm/sort.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     7304 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/algorithm/transform.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      975 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/algorithm/transpose.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    20589 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/cuda_capturer.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     9031 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/cuda_device.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1039 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/cuda_error.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4358 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/cuda_execution_policy.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    20014 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/cuda_graph.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    20001 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/cuda_memory.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    12652 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/cuda_meta.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     7384 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/cuda_object.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    10931 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/cuda_optimizer.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     6191 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/cuda_stream.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     6399 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/cuda_task.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    28435 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/cudaflow.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.986712 mqt.ddsim-1.18.0/extern/taskflow/taskflow/dsl/
+-rw-r--r--   0 runner    (1001) docker     (123)     1658 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/dsl/connection.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      327 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/dsl/dsl.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3356 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/dsl/meta_macro.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1203 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/dsl/task_analyzer.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4054 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/dsl/task_dsl.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1189 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/dsl/task_trait.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1418 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/dsl/tuple_utils.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4177 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/dsl/type_list.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.986712 mqt.ddsim-1.18.0/extern/taskflow/taskflow/sycl/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.986712 mqt.ddsim-1.18.0/extern/taskflow/taskflow/sycl/algorithm/
+-rw-r--r--   0 runner    (1001) docker     (123)    13320 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/sycl/algorithm/reduce.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2698 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/sycl/algorithm/sycl_for_each.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1232 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/sycl/algorithm/sycl_transform.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1818 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/sycl/sycl_execution_policy.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     5595 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/sycl/sycl_graph.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    14084 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/sycl/sycl_meta.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4367 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/sycl/sycl_task.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    18861 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/sycl/syclflow.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1134 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/taskflow.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.990712 mqt.ddsim-1.18.0/extern/taskflow/taskflow/utility/
+-rw-r--r--   0 runner    (1001) docker     (123)      603 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/utility/iterator.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      426 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/utility/macros.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3815 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/utility/math.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    19899 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/utility/object_pool.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4239 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/utility/os.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    29321 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/utility/serializer.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      553 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/utility/singleton.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    31329 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/utility/small_vector.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      681 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/utility/stream.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     8689 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/utility/traits.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     5685 2023-06-17 10:28:54.000000 mqt.ddsim-1.18.0/extern/taskflow/taskflow/utility/uuid.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.994711 mqt.ddsim-1.18.0/include/
+-rw-r--r--   0 runner    (1001) docker     (123)     3609 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/include/CircuitSimulator.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3730 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/include/DeterministicNoiseSimulator.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2738 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/include/GroverSimulator.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     5190 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/include/HybridSchrodingerFeynmanSimulator.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     8328 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/include/PathSimulator.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3905 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/include/ShorFastSimulator.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     5290 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/include/ShorSimulator.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     7745 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/include/Simulator.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     7759 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/include/StochasticNoiseSimulator.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2288 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/include/UnitarySimulator.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.802711 mqt.ddsim-1.18.0/mqt/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.998712 mqt.ddsim-1.18.0/mqt/ddsim/
+-rw-r--r--   0 runner    (1001) docker     (123)      248 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/mqt/ddsim/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      649 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/mqt/ddsim/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14303 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/mqt/ddsim/bindings.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      286 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/mqt/ddsim/error.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6939 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/mqt/ddsim/hybridqasmsimulator.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2151 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/mqt/ddsim/hybridstatevectorsimulator.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3573 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/mqt/ddsim/job.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10564 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/mqt/ddsim/pathqasmsimulator.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2439 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/mqt/ddsim/pathstatevectorsimulator.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2218 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/mqt/ddsim/provider.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6321 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/mqt/ddsim/qasmsimulator.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2348 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/mqt/ddsim/statevectorsimulator.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7319 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/mqt/ddsim/unitarysimulator.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.994711 mqt.ddsim-1.18.0/mqt.ddsim.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)     7878 2023-06-17 10:29:14.000000 mqt.ddsim-1.18.0/mqt.ddsim.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)    65526 2023-06-17 10:29:14.000000 mqt.ddsim-1.18.0/mqt.ddsim.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-06-17 10:29:14.000000 mqt.ddsim-1.18.0/mqt.ddsim.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      351 2023-06-17 10:29:14.000000 mqt.ddsim-1.18.0/mqt.ddsim.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        4 2023-06-17 10:29:14.000000 mqt.ddsim-1.18.0/mqt.ddsim.egg-info/top_level.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     3106 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/noxfile.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4291 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/pyproject.toml
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:14.998712 mqt.ddsim-1.18.0/scripts/
+-rw-r--r--   0 runner    (1001) docker     (123)      379 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/scripts/README.md
+-rwxr-xr-x   0 runner    (1001) docker     (123)     6481 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/scripts/approximation.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)     2864 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/scripts/hybrid_simulation.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)      613 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/scripts/primebases_timing_shor.sh
+-rw-r--r--   0 runner    (1001) docker     (123)       38 2023-06-17 10:29:15.002712 mqt.ddsim-1.18.0/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (123)     3603 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-17 10:29:15.002712 mqt.ddsim-1.18.0/src/
+-rw-r--r--   0 runner    (1001) docker     (123)     2088 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/src/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     9849 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/src/CircuitSimulator.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3124 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/src/DeterministicNoiseSimulator.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3471 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/src/GroverSimulator.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    12444 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/src/HybridSchrodingerFeynmanSimulator.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    19063 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/src/PathSimulator.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    17839 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/src/ShorFastSimulator.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    17044 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/src/ShorSimulator.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    12917 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/src/Simulator.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    17300 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/src/StochasticNoiseSimulator.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)      724 2023-06-17 10:28:38.000000 mqt.ddsim-1.18.0/src/UnitarySimulator.cpp
```

### Comparing `mqt.ddsim-1.17.3/.clang-format` & `mqt.ddsim-1.18.0/.clang-format`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/.clang-tidy` & `mqt.ddsim-1.18.0/.clang-tidy`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/.pre-commit-config.yaml` & `mqt.ddsim-1.18.0/.pre-commit-config.yaml`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/CMakeLists.txt` & `mqt.ddsim-1.18.0/CMakeLists.txt`

 * *Files 20% similar despite different names*

```diff
@@ -17,33 +17,30 @@
       FATAL_ERROR
         "${modulename} submodule not cloned properly. \
         Please run `git submodule update --init --recursive` \
         from the main project directory")
   endif()
 endmacro()
 
-check_submodule_present(qfr)
+if(NOT BUILD_DDSIM_TESTS)
+  set(BUILD_MQT_CORE_TESTS
+      OFF
+      CACHE BOOL "")
+endif()
+
+check_submodule_present(mqt-core)
 check_submodule_present(taskflow)
 
 add_subdirectory(src)
 
 option(BUILD_DDSIM_TESTS "Also build tests and benchmarks for DDSIM project"
        OFF)
 if(BUILD_DDSIM_TESTS)
-  check_submodule_present(qfr/extern/dd_package/extern/benchmark)
-
   enable_testing()
   include(GoogleTest)
-  if(NOT TARGET benchmark::benchmark_main)
-    set(BENCHMARK_ENABLE_TESTING
-        OFF
-        CACHE BOOL "Skip gbenchmark self tests")
-    add_subdirectory("extern/qfr/extern/dd_package/extern/benchmark"
-                     EXCLUDE_FROM_ALL)
-  endif()
   add_subdirectory(test)
 endif()
 
 if(CMAKE_PROJECT_NAME STREQUAL PROJECT_NAME)
   check_submodule_present(cxxopts)
   add_subdirectory(apps)
 endif()
```

### Comparing `mqt.ddsim-1.17.3/LICENSE` & `mqt.ddsim-1.18.0/LICENSE`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/PKG-INFO` & `mqt.ddsim-1.18.0/PKG-INFO`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: mqt.ddsim
-Version: 1.17.3
+Version: 1.18.0
 Summary: A quantum simulator based on decision diagrams written in C++
 Author-email: Stefan Hillmich <stefan.hillmich@jku.at>, Lukas Burgholzer <lukas.burgholzer@jku.at>
 License: MIT License
         
         Copyright (c) 2021 Stefan Hillmich, Lukas Burgholzer, Thomas Grurl, and Robert Wille
         
         Permission is hereby granted, free of charge, to any person obtaining a copy
@@ -69,15 +69,15 @@
   </picture>
 </p>
 
 # MQT DDSIM - A quantum circuit simulator based on decision diagrams written in C++
 
 A tool for classical quantum circuit simulation by the [Chair for Design Automation](https://www.cda.cit.tum.de/) at the [Technical University of Munich](https://www.tum.de/).
 QCEC is part of the Munich Quantum Toolkit (MQT; formerly known as JKQ and developed by the [Institute for Integrated Circuits](https://iic.jku.at/eda/) at the [Johannes Kepler University Linz](https://jku.at)).
-It builds upon [our quantum functionality representation (QFR)](https://github.com/cda-tum/qfr) and [our decision diagram (DD) package](https://github.com/cda-tum/dd_package.git).
+It builds upon [MQT Core](https://github.com/cda-tum/mqt-core).
 
 **Detailed documentation on all available formats, options, and algorithms is available at [ReadTheDocs](https://ddsim.readthedocs.io/en/latest/).**
 
 If you have any questions, feel free to contact us via [quantum.cda@xcit.tum.de](mailto:quantum.cda@xcit.tum.de) or by creating an [issue](https://github.com/cda-tum/ddsim/issues) on GitHub.
 
 ## Getting Started
```

### Comparing `mqt.ddsim-1.17.3/README.md` & `mqt.ddsim-1.18.0/README.md`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,15 @@
   </picture>
 </p>
 
 # MQT DDSIM - A quantum circuit simulator based on decision diagrams written in C++
 
 A tool for classical quantum circuit simulation by the [Chair for Design Automation](https://www.cda.cit.tum.de/) at the [Technical University of Munich](https://www.tum.de/).
 QCEC is part of the Munich Quantum Toolkit (MQT; formerly known as JKQ and developed by the [Institute for Integrated Circuits](https://iic.jku.at/eda/) at the [Johannes Kepler University Linz](https://jku.at)).
-It builds upon [our quantum functionality representation (QFR)](https://github.com/cda-tum/qfr) and [our decision diagram (DD) package](https://github.com/cda-tum/dd_package.git).
+It builds upon [MQT Core](https://github.com/cda-tum/mqt-core).
 
 **Detailed documentation on all available formats, options, and algorithms is available at [ReadTheDocs](https://ddsim.readthedocs.io/en/latest/).**
 
 If you have any questions, feel free to contact us via [quantum.cda@xcit.tum.de](mailto:quantum.cda@xcit.tum.de) or by creating an [issue](https://github.com/cda-tum/ddsim/issues) on GitHub.
 
 ## Getting Started
```

### Comparing `mqt.ddsim-1.17.3/apps/CMakeLists.txt` & `mqt.ddsim-1.18.0/apps/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/apps/frqi.cpp` & `mqt.ddsim-1.18.0/apps/frqi.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/apps/noise_aware.cpp` & `mqt.ddsim-1.18.0/apps/noise_aware.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/apps/primebases.cpp` & `mqt.ddsim-1.18.0/apps/primebases.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/apps/simple.cpp` & `mqt.ddsim-1.18.0/apps/simple.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/apps/vectors.cpp` & `mqt.ddsim-1.18.0/apps/vectors.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/cxxopts/.gitignore` & `mqt.ddsim-1.18.0/extern/cxxopts/.gitignore`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/cxxopts/.travis.yml` & `mqt.ddsim-1.18.0/extern/cxxopts/.travis.yml`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/cxxopts/CHANGELOG.md` & `mqt.ddsim-1.18.0/extern/cxxopts/CHANGELOG.md`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/cxxopts/CMakeLists.txt` & `mqt.ddsim-1.18.0/extern/cxxopts/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/cxxopts/INSTALL` & `mqt.ddsim-1.18.0/extern/cxxopts/INSTALL`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/cxxopts/LICENSE` & `mqt.ddsim-1.18.0/extern/cxxopts/LICENSE`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/cxxopts/README.md` & `mqt.ddsim-1.18.0/extern/cxxopts/README.md`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/cxxopts/WORKSPACE` & `mqt.ddsim-1.18.0/extern/cxxopts/WORKSPACE`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/cxxopts/cmake/cxxopts.cmake` & `mqt.ddsim-1.18.0/extern/cxxopts/cmake/cxxopts.cmake`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/cxxopts/include/CMakeLists.txt` & `mqt.ddsim-1.18.0/extern/cxxopts/include/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/cxxopts/include/cxxopts.hpp` & `mqt.ddsim-1.18.0/extern/cxxopts/include/cxxopts.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/cxxopts/src/CMakeLists.txt` & `mqt.ddsim-1.18.0/extern/cxxopts/src/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/cxxopts/src/example.cpp` & `mqt.ddsim-1.18.0/extern/cxxopts/src/example.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/cmake/CompilerOptions.cmake` & `mqt.ddsim-1.18.0/extern/mqt-core/cmake/CompilerOptions.cmake`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/cmake/CompilerWarnings.cmake` & `mqt.ddsim-1.18.0/extern/mqt-core/cmake/CompilerWarnings.cmake`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/cmake/PackageAddTest.cmake` & `mqt.ddsim-1.18.0/extern/mqt-core/cmake/PackageAddTest.cmake`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/cmake/PreventInSourceBuilds.cmake` & `mqt.ddsim-1.18.0/extern/mqt-core/cmake/PreventInSourceBuilds.cmake`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/cmake/Sanitizers.cmake` & `mqt.ddsim-1.18.0/extern/mqt-core/cmake/Sanitizers.cmake`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/cmake/StandardProjectSettings.cmake` & `mqt.ddsim-1.18.0/extern/mqt-core/cmake/StandardProjectSettings.cmake`

 * *Files 0% similar despite different names*

```diff
@@ -17,15 +17,15 @@
 set_property(GLOBAL PROPERTY CXX_EXTENSIONS OFF)
 
 # Generate compile_commands.json to make it easier to work with clang based tools
 set(CMAKE_EXPORT_COMPILE_COMMANDS
     ON
     CACHE BOOL "Export compile commands" FORCE)
 
-option(ENABLE_IPO "Enable Interprocedural Optimization, aka Link Time Optimization (LTO)" ON)
+option(ENABLE_IPO "Enable Interprocedural Optimization, aka Link Time Optimization (LTO)" OFF)
 if(ENABLE_IPO)
   include(CheckIPOSupported)
   check_ipo_supported(RESULT ipo_supported OUTPUT ipo_output)
   # enable inter-procedural optimization if it is supported
   if(ipo_supported)
     set(CMAKE_INTERPROCEDURAL_OPTIMIZATION
         TRUE
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/Complex.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/dd/Complex.hpp`

 * *Files 15% similar despite different names*

```diff
@@ -1,88 +1,86 @@
-/*
- * This file is part of the MQT DD Package which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum_dd/ for more information.
- */
-
-#ifndef DD_PACKAGE_COMPLEX_HPP
-#define DD_PACKAGE_COMPLEX_HPP
+#pragma once
 
 #include "ComplexTable.hpp"
 #include "ComplexValue.hpp"
 
 #include <cstddef>
 #include <iostream>
 #include <utility>
 
 namespace dd {
-    using CTEntry = ComplexTable<>::Entry;
-
-    struct Complex {
-        CTEntry* r;
-        CTEntry* i;
-
-        static Complex zero; // NOLINT(readability-identifier-naming,cppcoreguidelines-avoid-non-const-global-variables) automatic renaming does not work reliably, so skip linting
-        static Complex one;  // NOLINT(readability-identifier-naming,cppcoreguidelines-avoid-non-const-global-variables) automatic renaming does not work reliably, so skip linting
-
-        void setVal(const Complex& c) const {
-            r->value = CTEntry::val(c.r);
-            i->value = CTEntry::val(c.i);
-        }
-
-        [[nodiscard]] inline bool approximatelyEquals(const Complex& c) const {
-            return CTEntry::approximatelyEquals(r, c.r) && CTEntry::approximatelyEquals(i, c.i);
-        };
-
-        [[nodiscard]] inline bool exactlyZero() const {
-            return CTEntry::exactlyZero(r) && CTEntry::exactlyZero(i);
-        };
-
-        [[nodiscard]] inline bool exactlyOne() const {
-            return CTEntry::exactlyOne(r) && CTEntry::exactlyZero(i);
-        };
-
-        [[nodiscard]] inline bool approximatelyZero() const {
-            return CTEntry::approximatelyZero(r) && CTEntry::approximatelyZero(i);
-        }
-
-        [[nodiscard]] inline bool approximatelyOne() const {
-            return CTEntry::approximatelyOne(r) && CTEntry::approximatelyZero(i);
-        }
-
-        inline bool operator==(const Complex& other) const {
-            return r == other.r && i == other.i;
-        }
-
-        inline bool operator!=(const Complex& other) const {
-            return !operator==(other);
-        }
-
-        [[nodiscard]] std::string toString(bool formatted = true, int precision = -1) const {
-            return ComplexValue::toString(CTEntry::val(r), CTEntry::val(i), formatted, precision);
-        }
-
-        void writeBinary(std::ostream& os) const {
-            CTEntry::writeBinary(r, os);
-            CTEntry::writeBinary(i, os);
-        }
-    };
-
-    inline std::ostream& operator<<(std::ostream& os, const Complex& c) {
-        return os << c.toString();
-    }
+using CTEntry = ComplexTable<>::Entry;
 
-    inline Complex Complex::zero{&ComplexTable<>::zero, &ComplexTable<>::zero}; // NOLINT(cppcoreguidelines-avoid-non-const-global-variables)
-    inline Complex Complex::one{&ComplexTable<>::one, &ComplexTable<>::zero};   // NOLINT(cppcoreguidelines-avoid-non-const-global-variables)
+struct Complex {
+  CTEntry* r;
+  CTEntry* i;
+
+  // NOLINTNEXTLINE(readability-identifier-naming,cppcoreguidelines-avoid-non-const-global-variables)
+  static Complex zero;
+  // NOLINTNEXTLINE(readability-identifier-naming,cppcoreguidelines-avoid-non-const-global-variables)
+  static Complex one;
+
+  void setVal(const Complex& c) const {
+    r->value = CTEntry::val(c.r);
+    i->value = CTEntry::val(c.i);
+  }
+
+  [[nodiscard]] inline bool approximatelyEquals(const Complex& c) const {
+    return CTEntry::approximatelyEquals(r, c.r) &&
+           CTEntry::approximatelyEquals(i, c.i);
+  };
+
+  [[nodiscard]] inline bool exactlyZero() const {
+    return CTEntry::exactlyZero(r) && CTEntry::exactlyZero(i);
+  };
+
+  [[nodiscard]] inline bool exactlyOne() const {
+    return CTEntry::exactlyOne(r) && CTEntry::exactlyZero(i);
+  };
+
+  [[nodiscard]] inline bool approximatelyZero() const {
+    return CTEntry::approximatelyZero(r) && CTEntry::approximatelyZero(i);
+  }
+
+  [[nodiscard]] inline bool approximatelyOne() const {
+    return CTEntry::approximatelyOne(r) && CTEntry::approximatelyZero(i);
+  }
+
+  inline bool operator==(const Complex& other) const {
+    return r == other.r && i == other.i;
+  }
+
+  inline bool operator!=(const Complex& other) const {
+    return !operator==(other);
+  }
+
+  [[nodiscard]] std::string toString(bool formatted = true,
+                                     int precision = -1) const {
+    return ComplexValue::toString(CTEntry::val(r), CTEntry::val(i), formatted,
+                                  precision);
+  }
+
+  void writeBinary(std::ostream& os) const {
+    CTEntry::writeBinary(r, os);
+    CTEntry::writeBinary(i, os);
+  }
+};
+
+inline std::ostream& operator<<(std::ostream& os, const Complex& c) {
+  return os << c.toString();
+}
+
+// NOLINTNEXTLINE(readability-identifier-naming,cppcoreguidelines-avoid-non-const-global-variables)
+inline Complex Complex::zero{&ComplexTable<>::zero, &ComplexTable<>::zero};
+// NOLINTNEXTLINE(readability-identifier-naming,cppcoreguidelines-avoid-non-const-global-variables)
+inline Complex Complex::one{&ComplexTable<>::one, &ComplexTable<>::zero};
 } // namespace dd
 
 namespace std {
-    template<>
-    struct hash<dd::Complex> {
-        std::size_t operator()(dd::Complex const& c) const noexcept {
-            auto h1 = dd::murmur64(reinterpret_cast<std::size_t>(c.r));
-            auto h2 = dd::murmur64(reinterpret_cast<std::size_t>(c.i));
-            return dd::combineHash(h1, h2);
-        }
-    };
+template <> struct hash<dd::Complex> {
+  std::size_t operator()(dd::Complex const& c) const noexcept {
+    auto h1 = dd::murmur64(reinterpret_cast<std::size_t>(c.r));
+    auto h2 = dd::murmur64(reinterpret_cast<std::size_t>(c.i));
+    return dd::combineHash(h1, h2);
+  }
+};
 } // namespace std
-
-#endif //DD_PACKAGE_COMPLEX_HPP
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/ComplexNumbers.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/dd/ComplexNumbers.hpp`

 * *Files 14% similar despite different names*

```diff
@@ -1,252 +1,237 @@
-/*
- * This file is part of the MQT DD Package which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum_dd/ for more information.
- */
-
-#ifndef DDcomplex_H
-#define DDcomplex_H
+#pragma once
 
 #include "Complex.hpp"
 #include "ComplexCache.hpp"
 #include "ComplexTable.hpp"
 #include "ComplexValue.hpp"
 #include "Definitions.hpp"
 
 #include <cassert>
 #include <cmath>
 #include <cstdlib>
 
 namespace dd {
-    struct ComplexNumbers {
-        ComplexTable<> complexTable{};
-        ComplexCache<> complexCache{};
-
-        ComplexNumbers()  = default;
-        ~ComplexNumbers() = default;
-
-        void clear() {
-            complexTable.clear();
-            complexCache.clear();
-        }
-
-        static void setTolerance(fp tol) {
-            ComplexTable<>::setTolerance(tol);
-        }
-
-        // operations on complex numbers
-        // meanings are self-evident from the names
-        static void add(Complex& r, const Complex& a, const Complex& b) {
-            assert(r != Complex::zero);
-            assert(r != Complex::one);
-            r.r->value = CTEntry::val(a.r) + CTEntry::val(b.r);
-            r.i->value = CTEntry::val(a.i) + CTEntry::val(b.i);
-        }
-        static void sub(Complex& r, const Complex& a, const Complex& b) {
-            assert(r != Complex::zero);
-            assert(r != Complex::one);
-            r.r->value = CTEntry::val(a.r) - CTEntry::val(b.r);
-            r.i->value = CTEntry::val(a.i) - CTEntry::val(b.i);
-        }
-        static void mul(Complex& r, const Complex& a, const Complex& b) {
-            assert(r != Complex::zero);
-            assert(r != Complex::one);
-            if (a.approximatelyOne()) {
-                r.setVal(b);
-            } else if (b.approximatelyOne()) {
-                r.setVal(a);
-            } else if (a.approximatelyZero() || b.approximatelyZero()) {
-                r.r->value = 0.;
-                r.i->value = 0.;
-            } else {
-                const auto ar = CTEntry::val(a.r);
-                const auto ai = CTEntry::val(a.i);
-                const auto br = CTEntry::val(b.r);
-                const auto bi = CTEntry::val(b.i);
-
-                r.r->value = ar * br - ai * bi;
-                r.i->value = ar * bi + ai * br;
-            }
-        }
-        static void div(Complex& r, const Complex& a, const Complex& b) {
-            assert(r != Complex::zero);
-            assert(r != Complex::one);
-            if (a.approximatelyEquals(b)) {
-                r.r->value = 1.;
-                r.i->value = 0.;
-            } else if (b.approximatelyOne()) {
-                r.setVal(a);
-            } else {
-                const auto ar = CTEntry::val(a.r);
-                const auto ai = CTEntry::val(a.i);
-                const auto br = CTEntry::val(b.r);
-                const auto bi = CTEntry::val(b.i);
-
-                const auto cmag = br * br + bi * bi;
-
-                r.r->value = (ar * br + ai * bi) / cmag;
-                r.i->value = (ai * br - ar * bi) / cmag;
-            }
-        }
-        static inline fp mag2(const Complex& a) {
-            auto ar = CTEntry::val(a.r);
-            auto ai = CTEntry::val(a.i);
-
-            return ar * ar + ai * ai;
-        }
-        static inline fp mag(const Complex& a) {
-            return std::sqrt(mag2(a));
-        }
-        static inline fp arg(const Complex& a) {
-            auto ar = CTEntry::val(a.r);
-            auto ai = CTEntry::val(a.i);
-            return std::atan2(ai, ar);
-        }
-        static Complex conj(const Complex& a) {
-            auto ret = a;
-            ret.i    = CTEntry::flipPointerSign(a.i);
-            return ret;
-        }
-        static Complex neg(const Complex& a) {
-            auto ret = a;
-            ret.i    = CTEntry::flipPointerSign(a.i);
-            ret.r    = CTEntry::flipPointerSign(a.r);
-            return ret;
-        }
-
-        inline Complex addCached(const Complex& a, const Complex& b) {
-            auto c = getCached();
-            add(c, a, b);
-            return c;
-        }
-
-        inline Complex subCached(const Complex& a, const Complex& b) {
-            auto c = getCached();
-            sub(c, a, b);
-            return c;
-        }
-
-        inline Complex mulCached(const Complex& a, const Complex& b) {
-            auto c = getCached();
-            mul(c, a, b);
-            return c;
-        }
-
-        inline Complex divCached(const Complex& a, const Complex& b) {
-            auto c = getCached();
-            div(c, a, b);
-            return c;
-        }
-
-        // lookup a complex value in the complex table; if not found add it
-        Complex lookup(const Complex& c) {
-            if (c == Complex::zero) {
-                return Complex::zero;
-            }
-            if (c == Complex::one) {
-                return Complex::one;
-            }
-
-            auto valr = CTEntry::val(c.r);
-            auto vali = CTEntry::val(c.i);
-            return lookup(valr, vali);
-        }
-        Complex lookup(const std::complex<fp>& c) {
-            return lookup(c.real(), c.imag());
-        }
-        Complex lookup(const fp& r, const fp& i) {
-            Complex ret{};
-
-            auto signR = std::signbit(r);
-            if (signR) {
-                auto absr = std::abs(r);
-                // if absolute value is close enough to zero, just return the zero entry (avoiding -0.0)
-                if (absr < decltype(complexTable)::tolerance()) {
-                    ret.r = &decltype(complexTable)::zero;
-                } else {
-                    ret.r = CTEntry::getNegativePointer(complexTable.lookup(absr));
-                }
-            } else {
-                ret.r = complexTable.lookup(r);
-            }
-
-            auto signI = std::signbit(i);
-            if (signI) {
-                auto absi = std::abs(i);
-                // if absolute value is close enough to zero, just return the zero entry (avoiding -0.0)
-                if (absi < decltype(complexTable)::tolerance()) {
-                    ret.i = &decltype(complexTable)::zero;
-                } else {
-                    ret.i = CTEntry::getNegativePointer(complexTable.lookup(absi));
-                }
-            } else {
-                ret.i = complexTable.lookup(i);
-            }
-
-            return ret;
-        }
-        inline Complex lookup(const ComplexValue& c) { return lookup(c.r, c.i); }
-
-        // reference counting and garbage collection
-        static void incRef(const Complex& c) {
-            // `zero` and `one` are static and never altered
-            if (c != Complex::zero && c != Complex::one) {
-                ComplexTable<>::incRef(c.r);
-                ComplexTable<>::incRef(c.i);
-            }
-        }
-        static void decRef(const Complex& c) {
-            // `zero` and `one` are static and never altered
-            if (c != Complex::zero && c != Complex::one) {
-                ComplexTable<>::decRef(c.r);
-                ComplexTable<>::decRef(c.i);
-            }
-        }
-        std::size_t garbageCollect(bool force = false) {
-            return complexTable.garbageCollect(force);
-        }
-
-        // provide (temporary) cached complex number
-        inline Complex getTemporary() {
-            return complexCache.getTemporaryComplex();
-        }
-
-        inline Complex getTemporary(const fp& r, const fp& i) {
-            auto c     = complexCache.getTemporaryComplex();
-            c.r->value = r;
-            c.i->value = i;
-            return c;
-        }
-
-        inline Complex getTemporary(const ComplexValue& c) {
-            return getTemporary(c.r, c.i);
-        }
-
-        inline Complex getCached() {
-            return complexCache.getCachedComplex();
-        }
-
-        inline Complex getCached(const fp& r, const fp& i) {
-            auto c     = complexCache.getCachedComplex();
-            c.r->value = r;
-            c.i->value = i;
-            return c;
-        }
-
-        inline Complex getCached(const ComplexValue& c) {
-            return getCached(c.r, c.i);
-        }
-
-        inline Complex getCached(const std::complex<fp>& c) {
-            return getCached(c.real(), c.imag());
-        }
-
-        void returnToCache(Complex& c) {
-            complexCache.returnToCache(c);
-        }
-
-        [[nodiscard]] std::size_t cacheCount() const {
-            return complexCache.getCount();
-        }
-    };
+struct ComplexNumbers {
+  ComplexTable<> complexTable{};
+  ComplexCache<> complexCache{};
+
+  ComplexNumbers() = default;
+  ~ComplexNumbers() = default;
+
+  void clear() {
+    complexTable.clear();
+    complexCache.clear();
+  }
+
+  static void setTolerance(fp tol) { ComplexTable<>::setTolerance(tol); }
+
+  // operations on complex numbers
+  // meanings are self-evident from the names
+  static void add(Complex& r, const Complex& a, const Complex& b) {
+    assert(r != Complex::zero);
+    assert(r != Complex::one);
+    r.r->value = CTEntry::val(a.r) + CTEntry::val(b.r);
+    r.i->value = CTEntry::val(a.i) + CTEntry::val(b.i);
+  }
+  static void sub(Complex& r, const Complex& a, const Complex& b) {
+    assert(r != Complex::zero);
+    assert(r != Complex::one);
+    r.r->value = CTEntry::val(a.r) - CTEntry::val(b.r);
+    r.i->value = CTEntry::val(a.i) - CTEntry::val(b.i);
+  }
+  static void mul(Complex& r, const Complex& a, const Complex& b) {
+    assert(r != Complex::zero);
+    assert(r != Complex::one);
+    if (a.approximatelyOne()) {
+      r.setVal(b);
+    } else if (b.approximatelyOne()) {
+      r.setVal(a);
+    } else if (a.approximatelyZero() || b.approximatelyZero()) {
+      r.r->value = 0.;
+      r.i->value = 0.;
+    } else {
+      const auto ar = CTEntry::val(a.r);
+      const auto ai = CTEntry::val(a.i);
+      const auto br = CTEntry::val(b.r);
+      const auto bi = CTEntry::val(b.i);
+
+      r.r->value = ar * br - ai * bi;
+      r.i->value = ar * bi + ai * br;
+    }
+  }
+  static void div(Complex& r, const Complex& a, const Complex& b) {
+    assert(r != Complex::zero);
+    assert(r != Complex::one);
+    if (a.approximatelyEquals(b)) {
+      r.r->value = 1.;
+      r.i->value = 0.;
+    } else if (b.approximatelyOne()) {
+      r.setVal(a);
+    } else {
+      const auto ar = CTEntry::val(a.r);
+      const auto ai = CTEntry::val(a.i);
+      const auto br = CTEntry::val(b.r);
+      const auto bi = CTEntry::val(b.i);
+
+      const auto cmag = br * br + bi * bi;
+
+      r.r->value = (ar * br + ai * bi) / cmag;
+      r.i->value = (ai * br - ar * bi) / cmag;
+    }
+  }
+  static inline fp mag2(const Complex& a) {
+    auto ar = CTEntry::val(a.r);
+    auto ai = CTEntry::val(a.i);
+
+    return ar * ar + ai * ai;
+  }
+  static inline fp mag(const Complex& a) { return std::sqrt(mag2(a)); }
+  static inline fp arg(const Complex& a) {
+    auto ar = CTEntry::val(a.r);
+    auto ai = CTEntry::val(a.i);
+    return std::atan2(ai, ar);
+  }
+  static Complex conj(const Complex& a) {
+    auto ret = a;
+    ret.i = CTEntry::flipPointerSign(a.i);
+    return ret;
+  }
+  static Complex neg(const Complex& a) {
+    auto ret = a;
+    ret.i = CTEntry::flipPointerSign(a.i);
+    ret.r = CTEntry::flipPointerSign(a.r);
+    return ret;
+  }
+
+  inline Complex addCached(const Complex& a, const Complex& b) {
+    auto c = getCached();
+    add(c, a, b);
+    return c;
+  }
+
+  inline Complex subCached(const Complex& a, const Complex& b) {
+    auto c = getCached();
+    sub(c, a, b);
+    return c;
+  }
+
+  inline Complex mulCached(const Complex& a, const Complex& b) {
+    auto c = getCached();
+    mul(c, a, b);
+    return c;
+  }
+
+  inline Complex divCached(const Complex& a, const Complex& b) {
+    auto c = getCached();
+    div(c, a, b);
+    return c;
+  }
+
+  // lookup a complex value in the complex table; if not found add it
+  Complex lookup(const Complex& c) {
+    if (c == Complex::zero) {
+      return Complex::zero;
+    }
+    if (c == Complex::one) {
+      return Complex::one;
+    }
+
+    auto valr = CTEntry::val(c.r);
+    auto vali = CTEntry::val(c.i);
+    return lookup(valr, vali);
+  }
+  Complex lookup(const std::complex<fp>& c) {
+    return lookup(c.real(), c.imag());
+  }
+  Complex lookup(const fp& r, const fp& i) {
+    Complex ret{};
+
+    auto signR = std::signbit(r);
+    if (signR) {
+      auto absr = std::abs(r);
+      // if absolute value is close enough to zero, just return the zero entry
+      // (avoiding -0.0)
+      if (absr < decltype(complexTable)::tolerance()) {
+        ret.r = &decltype(complexTable)::zero;
+      } else {
+        ret.r = CTEntry::getNegativePointer(complexTable.lookup(absr));
+      }
+    } else {
+      ret.r = complexTable.lookup(r);
+    }
+
+    auto signI = std::signbit(i);
+    if (signI) {
+      auto absi = std::abs(i);
+      // if absolute value is close enough to zero, just return the zero entry
+      // (avoiding -0.0)
+      if (absi < decltype(complexTable)::tolerance()) {
+        ret.i = &decltype(complexTable)::zero;
+      } else {
+        ret.i = CTEntry::getNegativePointer(complexTable.lookup(absi));
+      }
+    } else {
+      ret.i = complexTable.lookup(i);
+    }
+
+    return ret;
+  }
+  inline Complex lookup(const ComplexValue& c) { return lookup(c.r, c.i); }
+
+  // reference counting and garbage collection
+  static void incRef(const Complex& c) {
+    // `zero` and `one` are static and never altered
+    if (c != Complex::zero && c != Complex::one) {
+      ComplexTable<>::incRef(c.r);
+      ComplexTable<>::incRef(c.i);
+    }
+  }
+  static void decRef(const Complex& c) {
+    // `zero` and `one` are static and never altered
+    if (c != Complex::zero && c != Complex::one) {
+      ComplexTable<>::decRef(c.r);
+      ComplexTable<>::decRef(c.i);
+    }
+  }
+  std::size_t garbageCollect(bool force = false) {
+    return complexTable.garbageCollect(force);
+  }
+
+  // provide (temporary) cached complex number
+  inline Complex getTemporary() { return complexCache.getTemporaryComplex(); }
+
+  inline Complex getTemporary(const fp& r, const fp& i) {
+    auto c = complexCache.getTemporaryComplex();
+    c.r->value = r;
+    c.i->value = i;
+    return c;
+  }
+
+  inline Complex getTemporary(const ComplexValue& c) {
+    return getTemporary(c.r, c.i);
+  }
+
+  inline Complex getCached() { return complexCache.getCachedComplex(); }
+
+  inline Complex getCached(const fp& r, const fp& i) {
+    auto c = complexCache.getCachedComplex();
+    c.r->value = r;
+    c.i->value = i;
+    return c;
+  }
+
+  inline Complex getCached(const ComplexValue& c) {
+    return getCached(c.r, c.i);
+  }
+
+  inline Complex getCached(const std::complex<fp>& c) {
+    return getCached(c.real(), c.imag());
+  }
+
+  void returnToCache(Complex& c) { complexCache.returnToCache(c); }
+
+  [[nodiscard]] std::size_t cacheCount() const {
+    return complexCache.getCount();
+  }
+};
 } // namespace dd
-#endif
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/ComplexTable.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/dd/ComplexTable.hpp`

 * *Files 12% similar despite different names*

```diff
@@ -1,14 +1,8 @@
-/*
- * This file is part of the MQT DD Package which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum_dd/ for more information.
- */
-
-#ifndef DD_PACKAGE_COMPLEXTABLE_HPP
-#define DD_PACKAGE_COMPLEXTABLE_HPP
+#pragma once
 
 #include "Definitions.hpp"
 
 #include <algorithm>
 #include <array>
 #include <cassert>
 #include <cmath>
@@ -19,575 +13,608 @@
 #include <limits>
 #include <map>
 #include <stdexcept>
 #include <string>
 #include <vector>
 
 namespace dd {
-    template<std::size_t NBUCKET = 65537, std::size_t INITIAL_ALLOCATION_SIZE = 2048, std::size_t GROWTH_FACTOR = 2, std::size_t INITIAL_GC_LIMIT = 65536>
-    class ComplexTable {
-    public:
-        struct Entry {
-            fp       value{};
-            Entry*   next{};
-            RefCount refCount{};
-
-            ///
-            /// The sign of number is encoded in the least significant bit of its entry pointer
-            /// If not handled properly, this causes misaligned access
-            /// These routines allow to obtain safe pointers
-            ///
-            [[nodiscard]] static inline Entry* getAlignedPointer(const Entry* e) {
-                return reinterpret_cast<Entry*>(reinterpret_cast<std::uintptr_t>(e) & ~static_cast<std::uintptr_t>(1U));
-            }
-
-            [[nodiscard]] static inline Entry* getNegativePointer(const Entry* e) {
-                return reinterpret_cast<Entry*>(reinterpret_cast<std::uintptr_t>(e) | static_cast<std::uintptr_t>(1U));
-            }
-
-            [[nodiscard]] static inline bool exactlyZero(const Entry* e) {
-                return (e == &ComplexTable<NBUCKET, INITIAL_ALLOCATION_SIZE, GROWTH_FACTOR, INITIAL_GC_LIMIT>::zero);
-            }
-
-            [[nodiscard]] static inline bool exactlyOne(const Entry* e) {
-                return (e == &ComplexTable<NBUCKET, INITIAL_ALLOCATION_SIZE, GROWTH_FACTOR, INITIAL_GC_LIMIT>::one);
-            }
-
-            [[nodiscard]] static inline Entry* flipPointerSign(const Entry* e) {
-                if (e == &ComplexTable<NBUCKET, INITIAL_ALLOCATION_SIZE, GROWTH_FACTOR, INITIAL_GC_LIMIT>::zero) {
-                    // No point in flipping the sign of 0
-                    return reinterpret_cast<Entry*>(reinterpret_cast<std::uintptr_t>(e));
-                }
-                return reinterpret_cast<Entry*>(reinterpret_cast<std::uintptr_t>(e) ^ static_cast<std::uintptr_t>(1U));
-            }
-
-            [[nodiscard]] static inline bool isNegativePointer(const Entry* e) {
-                return (reinterpret_cast<std::uintptr_t>(e) & static_cast<std::uintptr_t>(1U)) != 0U;
-            }
-
-            [[nodiscard]] static inline fp val(const Entry* e) {
-                if (isNegativePointer(e)) {
-                    return -getAlignedPointer(e)->value;
-                }
-                return e->value;
-            }
-
-            [[nodiscard]] static inline RefCount ref(const Entry* e) {
-                if (isNegativePointer(e)) {
-                    return -getAlignedPointer(e)->refCount;
-                }
-                return e->refCount;
-            }
-
-            [[nodiscard]] static constexpr bool approximatelyEquals(const Entry* left, const Entry* right) {
-                return left == right || approximatelyEquals(val(left), val(right));
-            }
-            [[nodiscard]] static constexpr bool approximatelyEquals(const fp left, const fp right) {
-                // NOLINTNEXTLINE(clang-diagnostic-float-equal) equivalence check is a shortcut before check with tolerance
-                return left == right || std::abs(left - right) <= TOLERANCE;
-            }
-
-            [[nodiscard]] static constexpr bool approximatelyZero(const Entry* e) {
-                return e == &zero || approximatelyZero(val(e));
-            }
-            [[nodiscard]] static constexpr bool approximatelyZero(const fp e) {
-                return std::abs(e) <= TOLERANCE;
-            }
-
-            [[nodiscard]] static constexpr bool approximatelyOne(const Entry* e) {
-                return e == &one || approximatelyOne(val(e));
-            }
-            [[nodiscard]] static constexpr bool approximatelyOne(fp e) {
-                return approximatelyEquals(e, 1.0);
-            }
-
-            static void writeBinary(const Entry* e, std::ostream& os) {
-                auto temp = val(e);
-                os.write(reinterpret_cast<const char*>(&temp), sizeof(decltype(temp)));
-            }
-        };
-
-        static inline Entry zero{0., nullptr, 1};         // NOLINT(readability-identifier-naming,cppcoreguidelines-avoid-non-const-global-variables) automatic renaming does not work reliably, so skip linting
-        static inline Entry sqrt2_2{SQRT2_2, nullptr, 1}; // NOLINT(readability-identifier-naming,cppcoreguidelines-avoid-non-const-global-variables) automatic renaming does not work reliably, so skip linting
-        static inline Entry one{1., nullptr, 1};          // NOLINT(readability-identifier-naming,cppcoreguidelines-avoid-non-const-global-variables) automatic renaming does not work reliably, so skip linting
-
-        ComplexTable() {
-            // add 1/2 to the complex table and increase its ref count (so that it is not collected)
-            lookup(0.5L)->refCount++;
-        }
-
-        ~ComplexTable() = default;
-
-        static fp tolerance() {
-            return TOLERANCE;
-        }
-
-        static void setTolerance(fp tol) {
-            TOLERANCE = tol;
-        }
-
-        static constexpr std::int64_t MASK = NBUCKET - 1;
-
-        // linear (clipped) hash function
-        static constexpr std::int64_t hash(const fp val) {
-            assert(val >= 0);
-            auto key = static_cast<std::int64_t>(std::nearbyint(val * MASK));
-            return std::min<std::int64_t>(key, MASK);
-        }
-
-        // access functions
-        [[nodiscard]] std::size_t getCount() const { return count; }
-
-        [[nodiscard]] std::size_t getPeakCount() const { return peakCount; }
-
-        [[nodiscard]] std::size_t getAllocations() const { return allocations; }
-
-        [[nodiscard]] std::size_t getGrowthFactor() const { return GROWTH_FACTOR; }
-
-        [[nodiscard]] const auto& getTable() const { return table; }
-
-        [[nodiscard]] bool availableEmpty() const { return available == nullptr; };
-
-        Entry* lookup(const fp& val) {
-            assert(!std::isnan(val));
-            assert(val >= 0); // required anyway for the hash function
-            ++lookups;
-            if (Entry::approximatelyZero(val)) {
-                ++hits;
-                return &zero;
-            }
-
-            if (Entry::approximatelyOne(val)) {
-                ++hits;
-                return &one;
-            }
-
-            if (Entry::approximatelyEquals(val, SQRT2_2)) {
-                ++hits;
-                return &sqrt2_2;
-            }
-
-            assert(val - TOLERANCE >= 0); // should be handle above as special case
-
-            const auto lowerKey = hash(val - TOLERANCE);
-            const auto upperKey = hash(val + TOLERANCE);
-
-            if (upperKey == lowerKey) {
-                ++findOrInserts;
-                return findOrInsert(lowerKey, val);
-            }
-
-            // code below is to properly handle border cases |----(-|-)----|
-            // in case a value close to a border is looked up,
-            // only the last entry in the lower bucket and the first entry in the upper bucket need to be checked
-
-            const auto key = hash(val);
-
-            Entry* pLower; // NOLINT(cppcoreguidelines-init-variables)
-            Entry* pUpper; // NOLINT(cppcoreguidelines-init-variables)
-            if (lowerKey != key) {
-                pLower = tailTable[static_cast<std::size_t>(lowerKey)];
-                pUpper = table[static_cast<std::size_t>(key)];
-                ++lowerNeighbors;
-            } else {
-                pLower = tailTable[static_cast<std::size_t>(key)];
-                pUpper = table[static_cast<std::size_t>(upperKey)];
-                ++upperNeighbors;
-            }
-
-            bool lowerMatchFound = (pLower != nullptr && Entry::approximatelyEquals(val, pLower->value));
-            bool upperMatchFound = (pUpper != nullptr && Entry::approximatelyEquals(val, pUpper->value));
-
-            if (lowerMatchFound && upperMatchFound) {
-                ++hits;
-                const auto diffToLower = std::abs(pLower->value - val);
-                const auto diffToUpper = std::abs(pUpper->value - val);
-                // val is actually closer to p_lower than to p_upper
-                if (diffToLower < diffToUpper) {
-                    return pLower;
-                }
-                return pUpper;
-            }
-
-            if (lowerMatchFound) {
-                ++hits;
-                return pLower;
-            }
-
-            if (upperMatchFound) {
-                ++hits;
-                return pUpper;
-            }
-
-            // value was not found in the table -> get a new entry and add it to the central bucket
-            Entry* entry = insert(key, val);
-            return entry;
-        }
-
-        [[nodiscard]] Entry* getEntry() {
-            // an entry is available on the stack
-            if (!availableEmpty()) {
-                Entry* entry = available;
-                available    = entry->next;
-                // returned entries could have a ref count != 0
-                entry->refCount = 0;
-                return entry;
-            }
-
-            // new chunk has to be allocated
-            if (chunkIt == chunkEndIt) {
-                chunks.emplace_back(allocationSize);
-                allocations += allocationSize;
-                allocationSize *= GROWTH_FACTOR;
-                chunkID++;
-                chunkIt    = chunks[chunkID].begin();
-                chunkEndIt = chunks[chunkID].end();
-            }
-
-            auto entry = &(*chunkIt);
-            ++chunkIt;
-            return entry;
-        }
-
-        void returnEntry(Entry* entry) {
-            entry->next = available;
-            available   = entry;
-        }
-
-        // increment reference count for corresponding entry
-        static void incRef(Entry* entry) {
-            // get valid pointer
-            auto entryPtr = Entry::getAlignedPointer(entry);
-
-            if (entryPtr == nullptr) {
-                return;
-            }
-
-            // important (static) numbers are never altered
-            if (entryPtr != &one && entryPtr != &zero && entryPtr != &sqrt2_2) {
-                if (entryPtr->refCount == std::numeric_limits<RefCount>::max()) {
-                    std::clog << "[WARN] MAXREFCNT reached for " << entryPtr->value << ". Number will never be collected." << std::endl;
-                    return;
-                }
-
-                // increase reference count
-                entryPtr->refCount++;
-            }
-        }
-
-        // decrement reference count for corresponding entry
-        static void decRef(Entry* entry) {
-            // get valid pointer
-            auto entryPtr = Entry::getAlignedPointer(entry);
-
-            if (entryPtr == nullptr) {
-                return;
-            }
-
-            // important (static) numbers are never altered
-            if (entryPtr != &one && entryPtr != &zero && entryPtr != &sqrt2_2) {
-                if (entryPtr->refCount == std::numeric_limits<RefCount>::max()) {
-                    return;
-                }
-                if (entryPtr->refCount == 0) {
-                    throw std::runtime_error("In ComplexTable: RefCount of entry " + std::to_string(entryPtr->value) + " is zero before decrement");
-                }
-
-                // decrease reference count
-                entryPtr->refCount--;
-            }
-        }
-
-        [[nodiscard]] bool possiblyNeedsCollection() const { return count >= gcLimit; }
-
-        std::size_t garbageCollect(bool force = false) {
-            gcCalls++;
-            // nothing to be done if garbage collection is not forced, and the limit has not been reached,
-            // or the current count is minimal (the complex table always contains at least 0.5)
-            if ((!force && count < gcLimit) || count <= 1) {
-                return 0;
-            }
-
-            gcRuns++;
-            std::size_t collected = 0;
-            std::size_t remaining = 0;
-            for (std::size_t key = 0; key < table.size(); ++key) {
-                Entry* p     = table[key];
-                Entry* lastp = nullptr;
-                while (p != nullptr) {
-                    if (p->refCount == 0) {
-                        Entry* next = p->next;
-                        if (lastp == nullptr) {
-                            table[key] = next;
-                        } else {
-                            lastp->next = next;
-                        }
-                        returnEntry(p);
-                        p = next;
-                        collected++;
-                    } else {
-                        lastp = p;
-                        p     = p->next;
-                        remaining++;
-                    }
-                    tailTable[key] = lastp;
-                }
-            }
-            // The garbage collection limit changes dynamically depending on the number of remaining (active) nodes.
-            // If it were not changed, garbage collection would run through the complete table on each successive call
-            // once the number of remaining entries reaches the garbage collection limit. It is increased whenever the
-            // number of remaining entries is rather close to the garbage collection threshold and decreased if the
-            // number of remaining entries is much lower than the current limit.
-            if (remaining > gcLimit / 10 * 9) {
-                gcLimit = remaining + INITIAL_GC_LIMIT;
-            } else if (remaining < gcLimit / 128) {
-                gcLimit /= 2;
-            }
-            count = remaining;
-            return collected;
-        }
-
-        void clear() {
-            // clear table buckets
-            for (auto& bucket: table) {
-                bucket = nullptr;
-            }
-            for (auto& entry: tailTable) {
-                entry = nullptr;
-            }
-
-            // clear available stack
-            available = nullptr;
-
-            // release memory of all but the first chunk TODO: it could be desirable to keep the memory
-            while (chunkID > 0) {
-                chunks.pop_back();
-                chunkID--;
-            }
-            // restore initial chunk setting
-            chunkIt        = chunks[0].begin();
-            chunkEndIt     = chunks[0].end();
-            allocationSize = INITIAL_ALLOCATION_SIZE * GROWTH_FACTOR;
-            allocations    = INITIAL_ALLOCATION_SIZE;
-
-            for (auto& entry: chunks[0]) {
-                entry.refCount = 0;
-            }
-
-            count     = 0;
-            peakCount = 0;
-
-            collisions       = 0;
-            insertCollisions = 0;
-            hits             = 0;
-            findOrInserts    = 0;
-            lookups          = 0;
-            inserts          = 0;
-            lowerNeighbors   = 0;
-            upperNeighbors   = 0;
-
-            gcCalls = 0;
-            gcRuns  = 0;
-            gcLimit = INITIAL_GC_LIMIT;
-        };
-
-        void print() {
-            const auto precision = std::cout.precision();
-            std::cout.precision(std::numeric_limits<dd::fp>::max_digits10);
-            for (std::size_t key = 0; key < table.size(); ++key) {
-                auto p = table[key];
-                if (p != nullptr) {
-                    std::cout << key << ": "
-                              << "\n";
-                }
-
-                while (p != nullptr) {
-                    std::cout << "\t\t" << p->value << " " << reinterpret_cast<std::uintptr_t>(p) << " " << p->refCount << "\n";
-                    p = p->next;
-                }
-
-                if (table[key] != nullptr) {
-                    std::cout << "\n";
-                }
-            }
-            std::cout.precision(precision);
-        }
-
-        [[nodiscard]] fp hitRatio() const { return static_cast<fp>(hits) / static_cast<fp>(lookups); }
-
-        [[nodiscard]] fp colRatio() const { return static_cast<fp>(collisions) / static_cast<fp>(lookups); }
-
-        std::map<std::string, std::size_t, std::less<>> getStatistics() {
-            return {
-                    {"hits", hits},
-                    {"collisions", collisions},
-                    {"lookups", lookups},
-                    {"inserts", inserts},
-                    {"insertCollisions", insertCollisions},
-                    {"findOrInserts", findOrInserts},
-                    {"upperNeighbors", upperNeighbors},
-                    {"lowerNeighbors", lowerNeighbors},
-                    {"gcCalls", gcCalls},
-                    {"gcRuns", gcRuns},
-            };
-        }
+template <std::size_t NBUCKET = 65537,
+          std::size_t INITIAL_ALLOCATION_SIZE = 2048,
+          std::size_t GROWTH_FACTOR = 2, std::size_t INITIAL_GC_LIMIT = 65536>
+class ComplexTable {
+public:
+  struct Entry {
+    fp value{};
+    Entry* next{};
+    RefCount refCount{};
+
+    ///
+    /// The sign of number is encoded in the least significant bit of its entry
+    /// pointer If not handled properly, this causes misaligned access These
+    /// routines allow to obtain safe pointers
+    ///
+    [[nodiscard]] static inline Entry* getAlignedPointer(const Entry* e) {
+      return reinterpret_cast<Entry*>(reinterpret_cast<std::uintptr_t>(e) &
+                                      ~static_cast<std::uintptr_t>(1U));
+    }
+
+    [[nodiscard]] static inline Entry* getNegativePointer(const Entry* e) {
+      return reinterpret_cast<Entry*>(reinterpret_cast<std::uintptr_t>(e) |
+                                      static_cast<std::uintptr_t>(1U));
+    }
+
+    [[nodiscard]] static inline bool exactlyZero(const Entry* e) {
+      return (e == &ComplexTable<NBUCKET, INITIAL_ALLOCATION_SIZE,
+                                 GROWTH_FACTOR, INITIAL_GC_LIMIT>::zero);
+    }
+
+    [[nodiscard]] static inline bool exactlyOne(const Entry* e) {
+      return (e == &ComplexTable<NBUCKET, INITIAL_ALLOCATION_SIZE,
+                                 GROWTH_FACTOR, INITIAL_GC_LIMIT>::one);
+    }
+
+    [[nodiscard]] static inline Entry* flipPointerSign(const Entry* e) {
+      if (e == &ComplexTable<NBUCKET, INITIAL_ALLOCATION_SIZE, GROWTH_FACTOR,
+                             INITIAL_GC_LIMIT>::zero) {
+        // No point in flipping the sign of 0
+        return reinterpret_cast<Entry*>(reinterpret_cast<std::uintptr_t>(e));
+      }
+      return reinterpret_cast<Entry*>(reinterpret_cast<std::uintptr_t>(e) ^
+                                      static_cast<std::uintptr_t>(1U));
+    }
+
+    [[nodiscard]] static inline bool isNegativePointer(const Entry* e) {
+      return (reinterpret_cast<std::uintptr_t>(e) &
+              static_cast<std::uintptr_t>(1U)) != 0U;
+    }
+
+    [[nodiscard]] static inline fp val(const Entry* e) {
+      if (isNegativePointer(e)) {
+        return -getAlignedPointer(e)->value;
+      }
+      return e->value;
+    }
+
+    [[nodiscard]] static inline RefCount ref(const Entry* e) {
+      if (isNegativePointer(e)) {
+        return -getAlignedPointer(e)->refCount;
+      }
+      return e->refCount;
+    }
+
+    [[nodiscard]] static constexpr bool
+    approximatelyEquals(const Entry* left, const Entry* right) {
+      return left == right || approximatelyEquals(val(left), val(right));
+    }
+    [[nodiscard]] static constexpr bool approximatelyEquals(const fp left,
+                                                            const fp right) {
+      // equivalence check is a shortcut before check with tolerance
+      // NOLINTNEXTLINE(clang-diagnostic-float-equal)
+      return left == right || std::abs(left - right) <= TOLERANCE;
+    }
+
+    [[nodiscard]] static constexpr bool approximatelyZero(const Entry* e) {
+      return e == &zero || approximatelyZero(val(e));
+    }
+    [[nodiscard]] static constexpr bool approximatelyZero(const fp e) {
+      return std::abs(e) <= TOLERANCE;
+    }
+
+    [[nodiscard]] static constexpr bool approximatelyOne(const Entry* e) {
+      return e == &one || approximatelyOne(val(e));
+    }
+    [[nodiscard]] static constexpr bool approximatelyOne(fp e) {
+      return approximatelyEquals(e, 1.0);
+    }
+
+    static void writeBinary(const Entry* e, std::ostream& os) {
+      auto temp = val(e);
+      os.write(reinterpret_cast<const char*>(&temp), sizeof(decltype(temp)));
+    }
+  };
+
+  // NOLINTNEXTLINE(readability-identifier-naming,cppcoreguidelines-avoid-non-const-global-variables)
+  static inline Entry zero{0., nullptr, 1};
+  // NOLINTNEXTLINE(readability-identifier-naming,cppcoreguidelines-avoid-non-const-global-variables)
+  static inline Entry sqrt2_2{SQRT2_2, nullptr, 1};
+  // NOLINTNEXTLINE(readability-identifier-naming,cppcoreguidelines-avoid-non-const-global-variables)
+  static inline Entry one{1., nullptr, 1};
+
+  ComplexTable() {
+    // add 1/2 to the complex table and increase its ref count (so that it is
+    // not collected)
+    lookup(0.5L)->refCount++;
+  }
+
+  ~ComplexTable() = default;
+
+  static fp tolerance() { return TOLERANCE; }
+
+  static void setTolerance(fp tol) { TOLERANCE = tol; }
+
+  static constexpr std::int64_t MASK = NBUCKET - 1;
+
+  // linear (clipped) hash function
+  static constexpr std::int64_t hash(const fp val) {
+    assert(val >= 0);
+    auto key = static_cast<std::int64_t>(std::nearbyint(val * MASK));
+    return std::min<std::int64_t>(key, MASK);
+  }
+
+  // access functions
+  [[nodiscard]] std::size_t getCount() const { return count; }
+
+  [[nodiscard]] std::size_t getPeakCount() const { return peakCount; }
+
+  [[nodiscard]] std::size_t getAllocations() const { return allocations; }
+
+  [[nodiscard]] std::size_t getGrowthFactor() const { return GROWTH_FACTOR; }
+
+  [[nodiscard]] const auto& getTable() const { return table; }
+
+  [[nodiscard]] bool availableEmpty() const { return available == nullptr; };
+
+  Entry* lookup(const fp& val) {
+    assert(!std::isnan(val));
+    assert(val >= 0); // required anyway for the hash function
+    ++lookups;
+    if (Entry::approximatelyZero(val)) {
+      ++hits;
+      return &zero;
+    }
+
+    if (Entry::approximatelyOne(val)) {
+      ++hits;
+      return &one;
+    }
+
+    if (Entry::approximatelyEquals(val, SQRT2_2)) {
+      ++hits;
+      return &sqrt2_2;
+    }
+
+    assert(val - TOLERANCE >= 0); // should be handle above as special case
+
+    const auto lowerKey = hash(val - TOLERANCE);
+    const auto upperKey = hash(val + TOLERANCE);
+
+    if (upperKey == lowerKey) {
+      ++findOrInserts;
+      return findOrInsert(lowerKey, val);
+    }
+
+    // code below is to properly handle border cases |----(-|-)----|
+    // in case a value close to a border is looked up,
+    // only the last entry in the lower bucket and the first entry in the upper
+    // bucket need to be checked
+
+    const auto key = hash(val);
+
+    Entry* pLower; // NOLINT(cppcoreguidelines-init-variables)
+    Entry* pUpper; // NOLINT(cppcoreguidelines-init-variables)
+    if (lowerKey != key) {
+      pLower = tailTable[static_cast<std::size_t>(lowerKey)];
+      pUpper = table[static_cast<std::size_t>(key)];
+      ++lowerNeighbors;
+    } else {
+      pLower = tailTable[static_cast<std::size_t>(key)];
+      pUpper = table[static_cast<std::size_t>(upperKey)];
+      ++upperNeighbors;
+    }
+
+    bool lowerMatchFound =
+        (pLower != nullptr && Entry::approximatelyEquals(val, pLower->value));
+    bool upperMatchFound =
+        (pUpper != nullptr && Entry::approximatelyEquals(val, pUpper->value));
+
+    if (lowerMatchFound && upperMatchFound) {
+      ++hits;
+      const auto diffToLower = std::abs(pLower->value - val);
+      const auto diffToUpper = std::abs(pUpper->value - val);
+      // val is actually closer to p_lower than to p_upper
+      if (diffToLower < diffToUpper) {
+        return pLower;
+      }
+      return pUpper;
+    }
+
+    if (lowerMatchFound) {
+      ++hits;
+      return pLower;
+    }
+
+    if (upperMatchFound) {
+      ++hits;
+      return pUpper;
+    }
+
+    // value was not found in the table -> get a new entry and add it to the
+    // central bucket
+    Entry* entry = insert(key, val);
+    return entry;
+  }
+
+  [[nodiscard]] Entry* getEntry() {
+    // an entry is available on the stack
+    if (!availableEmpty()) {
+      Entry* entry = available;
+      available = entry->next;
+      // returned entries could have a ref count != 0
+      entry->refCount = 0;
+      return entry;
+    }
+
+    // new chunk has to be allocated
+    if (chunkIt == chunkEndIt) {
+      chunks.emplace_back(allocationSize);
+      allocations += allocationSize;
+      allocationSize *= GROWTH_FACTOR;
+      chunkID++;
+      chunkIt = chunks[chunkID].begin();
+      chunkEndIt = chunks[chunkID].end();
+    }
+
+    auto entry = &(*chunkIt);
+    ++chunkIt;
+    return entry;
+  }
+
+  void returnEntry(Entry* entry) {
+    entry->next = available;
+    available = entry;
+  }
+
+  // increment reference count for corresponding entry
+  static void incRef(Entry* entry) {
+    // get valid pointer
+    auto entryPtr = Entry::getAlignedPointer(entry);
+
+    if (entryPtr == nullptr) {
+      return;
+    }
+
+    // important (static) numbers are never altered
+    if (entryPtr != &one && entryPtr != &zero && entryPtr != &sqrt2_2) {
+      if (entryPtr->refCount == std::numeric_limits<RefCount>::max()) {
+        std::clog << "[WARN] MAXREFCNT reached for " << entryPtr->value
+                  << ". Number will never be collected." << std::endl;
+        return;
+      }
+
+      // increase reference count
+      entryPtr->refCount++;
+    }
+  }
+
+  // decrement reference count for corresponding entry
+  static void decRef(Entry* entry) {
+    // get valid pointer
+    auto entryPtr = Entry::getAlignedPointer(entry);
+
+    if (entryPtr == nullptr) {
+      return;
+    }
+
+    // important (static) numbers are never altered
+    if (entryPtr != &one && entryPtr != &zero && entryPtr != &sqrt2_2) {
+      if (entryPtr->refCount == std::numeric_limits<RefCount>::max()) {
+        return;
+      }
+      if (entryPtr->refCount == 0) {
+        throw std::runtime_error("In ComplexTable: RefCount of entry " +
+                                 std::to_string(entryPtr->value) +
+                                 " is zero before decrement");
+      }
+
+      // decrease reference count
+      entryPtr->refCount--;
+    }
+  }
+
+  [[nodiscard]] bool possiblyNeedsCollection() const {
+    return count >= gcLimit;
+  }
+
+  std::size_t garbageCollect(bool force = false) {
+    gcCalls++;
+    // nothing to be done if garbage collection is not forced, and the limit has
+    // not been reached, or the current count is minimal (the complex table
+    // always contains at least 0.5)
+    if ((!force && count < gcLimit) || count <= 1) {
+      return 0;
+    }
+
+    gcRuns++;
+    std::size_t collected = 0;
+    std::size_t remaining = 0;
+    for (std::size_t key = 0; key < table.size(); ++key) {
+      Entry* p = table[key];
+      Entry* lastp = nullptr;
+      while (p != nullptr) {
+        if (p->refCount == 0) {
+          Entry* next = p->next;
+          if (lastp == nullptr) {
+            table[key] = next;
+          } else {
+            lastp->next = next;
+          }
+          returnEntry(p);
+          p = next;
+          collected++;
+        } else {
+          lastp = p;
+          p = p->next;
+          remaining++;
+        }
+        tailTable[key] = lastp;
+      }
+    }
+    // The garbage collection limit changes dynamically depending on the number
+    // of remaining (active) nodes. If it were not changed, garbage collection
+    // would run through the complete table on each successive call once the
+    // number of remaining entries reaches the garbage collection limit. It is
+    // increased whenever the number of remaining entries is rather close to the
+    // garbage collection threshold and decreased if the number of remaining
+    // entries is much lower than the current limit.
+    if (remaining > gcLimit / 10 * 9) {
+      gcLimit = remaining + INITIAL_GC_LIMIT;
+    } else if (remaining < gcLimit / 128) {
+      gcLimit /= 2;
+    }
+    count = remaining;
+    return collected;
+  }
+
+  void clear() {
+    // clear table buckets
+    for (auto& bucket : table) {
+      bucket = nullptr;
+    }
+    for (auto& entry : tailTable) {
+      entry = nullptr;
+    }
+
+    // clear available stack
+    available = nullptr;
+
+    // release memory of all but the first chunk TODO: it could be desirable to
+    // keep the memory
+    while (chunkID > 0) {
+      chunks.pop_back();
+      chunkID--;
+    }
+    // restore initial chunk setting
+    chunkIt = chunks[0].begin();
+    chunkEndIt = chunks[0].end();
+    allocationSize = INITIAL_ALLOCATION_SIZE * GROWTH_FACTOR;
+    allocations = INITIAL_ALLOCATION_SIZE;
+
+    for (auto& entry : chunks[0]) {
+      entry.refCount = 0;
+    }
+
+    count = 0;
+    peakCount = 0;
+
+    collisions = 0;
+    insertCollisions = 0;
+    hits = 0;
+    findOrInserts = 0;
+    lookups = 0;
+    inserts = 0;
+    lowerNeighbors = 0;
+    upperNeighbors = 0;
+
+    gcCalls = 0;
+    gcRuns = 0;
+    gcLimit = INITIAL_GC_LIMIT;
+  };
+
+  void print() {
+    const auto precision = std::cout.precision();
+    std::cout.precision(std::numeric_limits<dd::fp>::max_digits10);
+    for (std::size_t key = 0; key < table.size(); ++key) {
+      auto p = table[key];
+      if (p != nullptr) {
+        std::cout << key << ": "
+                  << "\n";
+      }
+
+      while (p != nullptr) {
+        std::cout << "\t\t" << p->value << " "
+                  << reinterpret_cast<std::uintptr_t>(p) << " " << p->refCount
+                  << "\n";
+        p = p->next;
+      }
+
+      if (table[key] != nullptr) {
+        std::cout << "\n";
+      }
+    }
+    std::cout.precision(precision);
+  }
+
+  [[nodiscard]] fp hitRatio() const {
+    return static_cast<fp>(hits) / static_cast<fp>(lookups);
+  }
+
+  [[nodiscard]] fp colRatio() const {
+    return static_cast<fp>(collisions) / static_cast<fp>(lookups);
+  }
+
+  std::map<std::string, std::size_t, std::less<>> getStatistics() {
+    return {
+        {"hits", hits},
+        {"collisions", collisions},
+        {"lookups", lookups},
+        {"inserts", inserts},
+        {"insertCollisions", insertCollisions},
+        {"findOrInserts", findOrInserts},
+        {"upperNeighbors", upperNeighbors},
+        {"lowerNeighbors", lowerNeighbors},
+        {"gcCalls", gcCalls},
+        {"gcRuns", gcRuns},
+    };
+  }
 
-        std::ostream& printStatistics(std::ostream& os = std::cout) {
-            // clang-format off
+  std::ostream& printStatistics(std::ostream& os = std::cout) {
+    // clang-format off
             os << "hits: " << hits
                << ", collisions: " << collisions
                << ", looks: " << lookups
                << ", inserts: " << inserts
                << ", insertCollisions: " << insertCollisions
                << ", findOrInserts: " << findOrInserts
                << ", upperNeighbors: " << upperNeighbors
                << ", lowerNeighbors: " << lowerNeighbors
                << ", hitRatio: " << hitRatio()
                << ", colRatio: " << colRatio()
                << ", gc calls: " << gcCalls
                << ", gc runs: " << gcRuns
                << "\n";
-            // clang-format on
-            return os;
-        }
-
-        std::ostream& printBucketDistribution(std::ostream& os = std::cout) {
-            for (auto bucket: table) {
-                if (bucket == nullptr) {
-                    os << "0\n";
-                    continue;
-                }
-                std::size_t bucketCount = 0;
-                while (bucket != nullptr) {
-                    ++bucketCount;
-                    bucket = bucket->next;
-                }
-                os << bucketCount << "\n";
-            }
-            os << std::endl;
-            return os;
-        }
-
-    private:
-        using Bucket = Entry*;
-        using Table  = std::array<Bucket, NBUCKET>;
-
-        Table table{};
-
-        std::array<Entry*, NBUCKET> tailTable{};
-
-        // table lookup statistics
-        std::size_t collisions       = 0;
-        std::size_t insertCollisions = 0;
-        std::size_t hits             = 0;
-        std::size_t findOrInserts    = 0;
-        std::size_t lookups          = 0;
-        std::size_t inserts          = 0;
-        std::size_t lowerNeighbors   = 0;
-        std::size_t upperNeighbors   = 0;
-
-        // numerical tolerance to be used for floating point values
-        static inline fp TOLERANCE = std::numeric_limits<dd::fp>::epsilon() * 1024; // NOLINT(cppcoreguidelines-avoid-non-const-global-variables,readability-identifier-naming)
-
-        Entry*                                available{};
-        std::vector<std::vector<Entry>>       chunks{1, std::vector<Entry>{INITIAL_ALLOCATION_SIZE}};
-        std::size_t                           chunkID{};
-        typename std::vector<Entry>::iterator chunkIt{chunks.at(0).begin()};
-        typename std::vector<Entry>::iterator chunkEndIt{chunks.at(0).end()};
-        std::size_t                           allocationSize{INITIAL_ALLOCATION_SIZE * GROWTH_FACTOR};
-
-        std::size_t allocations = INITIAL_ALLOCATION_SIZE;
-        std::size_t count       = 0;
-        std::size_t peakCount   = 0;
-
-        // garbage collection
-        std::size_t gcCalls = 0;
-        std::size_t gcRuns  = 0;
-        std::size_t gcLimit = 100000;
-
-        inline Entry* findOrInsert(const std::int64_t key, const fp val) {
-            [[maybe_unused]] const fp valTol = val + TOLERANCE;
-
-            Entry* curr = table[static_cast<std::size_t>(key)];
-            Entry* prev = nullptr;
-
-            while (curr != nullptr && curr->value <= valTol) {
-                if (Entry::approximatelyEquals(curr->value, val)) {
-                    // check if val is actually closer to the next element in the list (if there is one)
-                    if (curr->next != nullptr) {
-                        const auto& next = curr->next;
-                        // potential candidate in range
-                        if (valTol >= next->value) {
-                            const auto diffToCurr = std::abs(curr->value - val);
-                            const auto diffToNext = std::abs(next->value - val);
-                            // val is actually closer to next than to curr
-                            if (diffToNext < diffToCurr) {
-                                ++hits;
-                                return next;
-                            }
-                        }
-                    }
-                    ++hits;
-                    return curr;
-                }
-                ++collisions;
-                prev = curr;
-                curr = curr->next;
-            }
-
-            ++inserts;
-            Entry* entry = getEntry();
-            entry->value = val;
-
-            if (prev == nullptr) {
-                // table bucket is empty
-                table[static_cast<std::size_t>(key)] = entry;
-            } else {
-                prev->next = entry;
-            }
-            entry->next = curr;
-            if (curr == nullptr) {
-                tailTable[static_cast<std::size_t>(key)] = entry;
-            }
-            count++;
-            peakCount = std::max(peakCount, count);
-            return entry;
-        }
-
-        /**
-         * Inserts a value into the bucket indexed by key. This function assumes no element within TOLERANCE is
-         * present in the bucket.
-         * @param key index to the bucket
-         * @param val value to be inserted
-         * @return pointer to the inserted entry
-         */
-        inline Entry* insert(const std::int64_t key, const fp val) {
-            ++inserts;
-            Entry* entry = getEntry();
-            entry->value = val;
-
-            Entry* curr = table[static_cast<std::size_t>(key)];
-            Entry* prev = nullptr;
-
-            while (curr != nullptr && curr->value <= val) {
-                ++insertCollisions;
-                prev = curr;
-                curr = curr->next;
-            }
-
-            if (prev == nullptr) {
-                // table bucket is empty
-                table[static_cast<std::size_t>(key)] = entry;
-            } else {
-                prev->next = entry;
-            }
-            entry->next = curr;
-            if (curr == nullptr) {
-                tailTable[static_cast<std::size_t>(key)] = entry;
-            }
-            count++;
-            peakCount = std::max(peakCount, count);
-            return entry;
-        }
-    };
+    // clang-format on
+    return os;
+  }
+
+  std::ostream& printBucketDistribution(std::ostream& os = std::cout) {
+    for (auto bucket : table) {
+      if (bucket == nullptr) {
+        os << "0\n";
+        continue;
+      }
+      std::size_t bucketCount = 0;
+      while (bucket != nullptr) {
+        ++bucketCount;
+        bucket = bucket->next;
+      }
+      os << bucketCount << "\n";
+    }
+    os << std::endl;
+    return os;
+  }
+
+private:
+  using Bucket = Entry*;
+  using Table = std::array<Bucket, NBUCKET>;
+
+  Table table{};
+
+  std::array<Entry*, NBUCKET> tailTable{};
+
+  // table lookup statistics
+  std::size_t collisions = 0;
+  std::size_t insertCollisions = 0;
+  std::size_t hits = 0;
+  std::size_t findOrInserts = 0;
+  std::size_t lookups = 0;
+  std::size_t inserts = 0;
+  std::size_t lowerNeighbors = 0;
+  std::size_t upperNeighbors = 0;
+
+  // numerical tolerance to be used for floating point values
+  // NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables,readability-identifier-naming)
+  static inline fp TOLERANCE = std::numeric_limits<dd::fp>::epsilon() * 1024;
+
+  Entry* available{};
+  std::vector<std::vector<Entry>> chunks{
+      1, std::vector<Entry>{INITIAL_ALLOCATION_SIZE}};
+  std::size_t chunkID{};
+  typename std::vector<Entry>::iterator chunkIt{chunks.at(0).begin()};
+  typename std::vector<Entry>::iterator chunkEndIt{chunks.at(0).end()};
+  std::size_t allocationSize{INITIAL_ALLOCATION_SIZE * GROWTH_FACTOR};
+
+  std::size_t allocations = INITIAL_ALLOCATION_SIZE;
+  std::size_t count = 0;
+  std::size_t peakCount = 0;
+
+  // garbage collection
+  std::size_t gcCalls = 0;
+  std::size_t gcRuns = 0;
+  std::size_t gcLimit = 100000;
+
+  inline Entry* findOrInsert(const std::int64_t key, const fp val) {
+    [[maybe_unused]] const fp valTol = val + TOLERANCE;
+
+    Entry* curr = table[static_cast<std::size_t>(key)];
+    Entry* prev = nullptr;
+
+    while (curr != nullptr && curr->value <= valTol) {
+      if (Entry::approximatelyEquals(curr->value, val)) {
+        // check if val is actually closer to the next element in the list (if
+        // there is one)
+        if (curr->next != nullptr) {
+          const auto& next = curr->next;
+          // potential candidate in range
+          if (valTol >= next->value) {
+            const auto diffToCurr = std::abs(curr->value - val);
+            const auto diffToNext = std::abs(next->value - val);
+            // val is actually closer to next than to curr
+            if (diffToNext < diffToCurr) {
+              ++hits;
+              return next;
+            }
+          }
+        }
+        ++hits;
+        return curr;
+      }
+      ++collisions;
+      prev = curr;
+      curr = curr->next;
+    }
+
+    ++inserts;
+    Entry* entry = getEntry();
+    entry->value = val;
+
+    if (prev == nullptr) {
+      // table bucket is empty
+      table[static_cast<std::size_t>(key)] = entry;
+    } else {
+      prev->next = entry;
+    }
+    entry->next = curr;
+    if (curr == nullptr) {
+      tailTable[static_cast<std::size_t>(key)] = entry;
+    }
+    count++;
+    peakCount = std::max(peakCount, count);
+    return entry;
+  }
+
+  /**
+   * Inserts a value into the bucket indexed by key. This function assumes no
+   * element within TOLERANCE is present in the bucket.
+   * @param key index to the bucket
+   * @param val value to be inserted
+   * @return pointer to the inserted entry
+   */
+  inline Entry* insert(const std::int64_t key, const fp val) {
+    ++inserts;
+    Entry* entry = getEntry();
+    entry->value = val;
+
+    Entry* curr = table[static_cast<std::size_t>(key)];
+    Entry* prev = nullptr;
+
+    while (curr != nullptr && curr->value <= val) {
+      ++insertCollisions;
+      prev = curr;
+      curr = curr->next;
+    }
+
+    if (prev == nullptr) {
+      // table bucket is empty
+      table[static_cast<std::size_t>(key)] = entry;
+    } else {
+      prev->next = entry;
+    }
+    entry->next = curr;
+    if (curr == nullptr) {
+      tailTable[static_cast<std::size_t>(key)] = entry;
+    }
+    count++;
+    peakCount = std::max(peakCount, count);
+    return entry;
+  }
+};
 } // namespace dd
-#endif //DD_PACKAGE_COMPLEXTABLE_HPP
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/ComplexValue.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/dd/ComplexValue.hpp`

 * *Files 13% similar despite different names*

```diff
@@ -1,14 +1,8 @@
-/*
- * This file is part of the MQT DD Package which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum_dd/ for more information.
- */
-
-#ifndef DD_PACKAGE_COMPLEXVALUE_HPP
-#define DD_PACKAGE_COMPLEXVALUE_HPP
+#pragma once
 
 #include "ComplexTable.hpp"
 #include "Definitions.hpp"
 
 #include <algorithm>
 #include <cmath>
 #include <cstddef>
@@ -16,239 +10,251 @@
 #include <iomanip>
 #include <iostream>
 #include <sstream>
 #include <string>
 #include <utility>
 
 namespace dd {
-    struct ComplexValue {
-        fp r, i;
-
-        [[nodiscard]] constexpr bool approximatelyEquals(const ComplexValue& c) const {
-            return ComplexTable<>::Entry::approximatelyEquals(r, c.r) &&
-                   ComplexTable<>::Entry::approximatelyEquals(i, c.i);
-        }
-
-        [[nodiscard]] constexpr bool approximatelyZero() const {
-            return ComplexTable<>::Entry::approximatelyZero(r) &&
-                   ComplexTable<>::Entry::approximatelyZero(i);
-        }
-
-        [[nodiscard]] constexpr bool approximatelyOne() const {
-            return ComplexTable<>::Entry::approximatelyOne(r) &&
-                   ComplexTable<>::Entry::approximatelyZero(i);
-        }
-
-        constexpr bool operator==(const ComplexValue& other) const {
-            // NOLINTNEXTLINE(clang-diagnostic-float-equal)
-            return r == other.r && i == other.i;
-        }
+struct ComplexValue {
+  fp r, i;
 
-        constexpr bool operator!=(const ComplexValue& other) const {
-            return !operator==(other);
-        }
-
-        void readBinary(std::istream& is) {
-            is.read(reinterpret_cast<char*>(&r), sizeof(decltype(r)));
-            is.read(reinterpret_cast<char*>(&i), sizeof(decltype(i)));
-        }
+  [[nodiscard]] constexpr bool
+  approximatelyEquals(const ComplexValue& c) const {
+    return ComplexTable<>::Entry::approximatelyEquals(r, c.r) &&
+           ComplexTable<>::Entry::approximatelyEquals(i, c.i);
+  }
+
+  [[nodiscard]] constexpr bool approximatelyZero() const {
+    return ComplexTable<>::Entry::approximatelyZero(r) &&
+           ComplexTable<>::Entry::approximatelyZero(i);
+  }
+
+  [[nodiscard]] constexpr bool approximatelyOne() const {
+    return ComplexTable<>::Entry::approximatelyOne(r) &&
+           ComplexTable<>::Entry::approximatelyZero(i);
+  }
+
+  constexpr bool operator==(const ComplexValue& other) const {
+    // NOLINTNEXTLINE(clang-diagnostic-float-equal)
+    return r == other.r && i == other.i;
+  }
+
+  constexpr bool operator!=(const ComplexValue& other) const {
+    return !operator==(other);
+  }
+
+  void readBinary(std::istream& is) {
+    is.read(reinterpret_cast<char*>(&r), sizeof(decltype(r)));
+    is.read(reinterpret_cast<char*>(&i), sizeof(decltype(i)));
+  }
+
+  void writeBinary(std::ostream& os) const {
+    os.write(reinterpret_cast<const char*>(&r), sizeof(decltype(r)));
+    os.write(reinterpret_cast<const char*>(&i), sizeof(decltype(i)));
+  }
+
+  void fromString(const std::string& realStr, std::string imagStr) {
+    const fp real = realStr.empty() ? 0. : std::stod(realStr);
+
+    imagStr.erase(remove(imagStr.begin(), imagStr.end(), ' '), imagStr.end());
+    imagStr.erase(remove(imagStr.begin(), imagStr.end(), 'i'), imagStr.end());
+    if (imagStr == "+" || imagStr == "-") {
+      imagStr = imagStr + "1";
+    }
+    const fp imag = imagStr.empty() ? 0. : std::stod(imagStr);
+    r = {real};
+    i = {imag};
+  }
+
+  static auto
+  getLowestFraction(const double x,
+                    const std::uint64_t maxDenominator = 1U << 10,
+                    const fp tol = dd::ComplexTable<>::tolerance()) {
+    assert(x >= 0.);
+
+    std::pair<std::uint64_t, std::uint64_t> lowerBound{0U, 1U};
+    std::pair<std::uint64_t, std::uint64_t> upperBound{1U, 0U};
+
+    while ((lowerBound.second <= maxDenominator) &&
+           (upperBound.second <= maxDenominator)) {
+      auto num = lowerBound.first + upperBound.first;
+      auto den = lowerBound.second + upperBound.second;
+      auto median = static_cast<fp>(num) / static_cast<fp>(den);
+      if (std::abs(x - median) <= tol) {
+        if (den <= maxDenominator) {
+          return std::pair{num, den};
+        }
+        if (upperBound.second > lowerBound.second) {
+          return upperBound;
+        }
+        return lowerBound;
+      }
+      if (x > median) {
+        lowerBound = {num, den};
+      } else {
+        upperBound = {num, den};
+      }
+    }
+    if (lowerBound.second > maxDenominator) {
+      return upperBound;
+    }
+    return lowerBound;
+  }
 
-        void writeBinary(std::ostream& os) const {
-            os.write(reinterpret_cast<const char*>(&r), sizeof(decltype(r)));
-            os.write(reinterpret_cast<const char*>(&i), sizeof(decltype(i)));
-        }
+  static void printFormatted(std::ostream& os, fp num, bool imaginary = false) {
+    if (std::abs(num) <= ComplexTable<>::tolerance()) {
+      os << (std::signbit(num) ? "-" : "+") << "0" << (imaginary ? "i" : "");
+      return;
+    }
 
-        void fromString(const std::string& realStr, std::string imagStr) {
-            fp real = realStr.empty() ? 0. : std::stod(realStr);
+    const auto absnum = std::abs(num);
+    auto fraction = getLowestFraction(absnum);
+    auto approx =
+        static_cast<fp>(fraction.first) / static_cast<fp>(fraction.second);
+    auto error = std::abs(absnum - approx);
+
+    if (error <= ComplexTable<>::tolerance()) { // suitable fraction a/b found
+      const std::string sign = std::signbit(num) ? "-" : (imaginary ? "+" : "");
+
+      if (fraction.first == 1U && fraction.second == 1U) {
+        os << sign << (imaginary ? "i" : "1");
+      } else if (fraction.second == 1U) {
+        os << sign << fraction.first << (imaginary ? "i" : "");
+      } else if (fraction.first == 1U) {
+        os << sign << (imaginary ? "i" : "1") << "/" << fraction.second;
+      } else {
+        os << sign << fraction.first << (imaginary ? "i" : "") << "/"
+           << fraction.second;
+      }
 
-            imagStr.erase(remove(imagStr.begin(), imagStr.end(), ' '), imagStr.end());
-            imagStr.erase(remove(imagStr.begin(), imagStr.end(), 'i'), imagStr.end());
-            if (imagStr == "+" || imagStr == "-") {
-                imagStr = imagStr + "1";
-            }
-            fp imag = imagStr.empty() ? 0. : std::stod(imagStr);
-            r       = {real};
-            i       = {imag};
-        }
+      return;
+    }
 
-        static auto getLowestFraction(const double x, const std::uint64_t maxDenominator = 1U << 10, const fp tol = dd::ComplexTable<>::tolerance()) {
-            assert(x >= 0.);
+    const auto abssqrt = absnum / SQRT2_2;
+    fraction = getLowestFraction(abssqrt);
+    approx = static_cast<fp>(fraction.first) / static_cast<fp>(fraction.second);
+    error = std::abs(abssqrt - approx);
+
+    if (error <= ComplexTable<>::tolerance()) { // suitable fraction a/(b *
+                                                // sqrt(2)) found
+      const std::string sign = std::signbit(num) ? "-" : (imaginary ? "+" : "");
+
+      if (fraction.first == 1U && fraction.second == 1U) {
+        os << sign << (imaginary ? "i" : "1") << "/2";
+      } else if (fraction.second == 1U) {
+        os << sign << fraction.first << (imaginary ? "i" : "") << "/2";
+      } else if (fraction.first == 1U) {
+        os << sign << (imaginary ? "i" : "1") << "/(" << fraction.second
+           << "2)";
+      } else {
+        os << sign << fraction.first << (imaginary ? "i" : "") << "/("
+           << fraction.second << "2)";
+      }
+      return;
+    }
 
-            std::pair<std::uint64_t, std::uint64_t> lowerBound{0U, 1U};
-            std::pair<std::uint64_t, std::uint64_t> upperBound{1U, 0U};
+    const auto abspi = absnum / PI;
+    fraction = getLowestFraction(abspi);
+    approx = static_cast<fp>(fraction.first) / static_cast<fp>(fraction.second);
+    error = std::abs(abspi - approx);
+
+    if (error <= ComplexTable<>::tolerance()) { // suitable fraction a/b  found
+      const std::string sign = std::signbit(num) ? "-" : (imaginary ? "+" : "");
+      const std::string imagUnit = imaginary ? "i" : "";
+
+      if (fraction.first == 1U && fraction.second == 1U) {
+        os << sign << "" << imagUnit;
+      } else if (fraction.second == 1U) {
+        os << sign << fraction.first << "" << imagUnit;
+      } else if (fraction.first == 1U) {
+        os << sign << "" << imagUnit << "/" << fraction.second;
+      } else {
+        os << sign << fraction.first << "" << imagUnit << "/"
+           << fraction.second;
+      }
+      return;
+    }
 
-            while ((lowerBound.second <= maxDenominator) && (upperBound.second <= maxDenominator)) {
-                auto num    = lowerBound.first + upperBound.first;
-                auto den    = lowerBound.second + upperBound.second;
-                auto median = static_cast<fp>(num) / static_cast<fp>(den);
-                if (std::abs(x - median) <= tol) {
-                    if (den <= maxDenominator) {
-                        return std::pair{num, den};
-                    }
-                    if (upperBound.second > lowerBound.second) {
-                        return upperBound;
-                    }
-                    return lowerBound;
-                }
-                if (x > median) {
-                    lowerBound = {num, den};
-                } else {
-                    upperBound = {num, den};
-                }
-            }
-            if (lowerBound.second > maxDenominator) {
-                return upperBound;
-            }
-            return lowerBound;
-        }
+    if (imaginary) { // default
+      os << (std::signbit(num) ? "" : "+") << num << "i";
+    } else {
+      os << num;
+    }
+  }
 
-        static void printFormatted(std::ostream& os, fp num, bool imaginary = false) {
-            if (std::abs(num) <= ComplexTable<>::tolerance()) {
-                os << (std::signbit(num) ? "-" : "+") << "0" << (imaginary ? "i" : "");
-                return;
-            }
-
-            const auto absnum   = std::abs(num);
-            auto       fraction = getLowestFraction(absnum);
-            auto       approx   = static_cast<fp>(fraction.first) / static_cast<fp>(fraction.second);
-            auto       error    = std::abs(absnum - approx);
-
-            if (error <= ComplexTable<>::tolerance()) { // suitable fraction a/b found
-                const std::string sign = std::signbit(num) ? "-" : (imaginary ? "+" : "");
-
-                if (fraction.first == 1U && fraction.second == 1U) {
-                    os << sign << (imaginary ? "i" : "1");
-                } else if (fraction.second == 1U) {
-                    os << sign << fraction.first << (imaginary ? "i" : "");
-                } else if (fraction.first == 1U) {
-                    os << sign << (imaginary ? "i" : "1") << "/" << fraction.second;
-                } else {
-                    os << sign << fraction.first << (imaginary ? "i" : "") << "/" << fraction.second;
-                }
-
-                return;
-            }
-
-            const auto abssqrt = absnum / SQRT2_2;
-            fraction           = getLowestFraction(abssqrt);
-            approx             = static_cast<fp>(fraction.first) / static_cast<fp>(fraction.second);
-            error              = std::abs(abssqrt - approx);
-
-            if (error <= ComplexTable<>::tolerance()) { // suitable fraction a/(b * sqrt(2)) found
-                const std::string sign = std::signbit(num) ? "-" : (imaginary ? "+" : "");
-
-                if (fraction.first == 1U && fraction.second == 1U) {
-                    os << sign << (imaginary ? "i" : "1") << "/2";
-                } else if (fraction.second == 1U) {
-                    os << sign << fraction.first << (imaginary ? "i" : "") << "/2";
-                } else if (fraction.first == 1U) {
-                    os << sign << (imaginary ? "i" : "1") << "/(" << fraction.second << "2)";
-                } else {
-                    os << sign << fraction.first << (imaginary ? "i" : "") << "/(" << fraction.second << "2)";
-                }
-                return;
-            }
-
-            const auto abspi = absnum / PI;
-            fraction         = getLowestFraction(abspi);
-            approx           = static_cast<fp>(fraction.first) / static_cast<fp>(fraction.second);
-            error            = std::abs(abspi - approx);
-
-            if (error <= ComplexTable<>::tolerance()) { // suitable fraction a/b  found
-                const std::string sign     = std::signbit(num) ? "-" : (imaginary ? "+" : "");
-                const std::string imagUnit = imaginary ? "i" : "";
-
-                if (fraction.first == 1U && fraction.second == 1U) {
-                    os << sign << "" << imagUnit;
-                } else if (fraction.second == 1U) {
-                    os << sign << fraction.first << "" << imagUnit;
-                } else if (fraction.first == 1U) {
-                    os << sign << "" << imagUnit << "/" << fraction.second;
-                } else {
-                    os << sign << fraction.first << "" << imagUnit << "/" << fraction.second;
-                }
-                return;
-            }
-
-            if (imaginary) { // default
-                os << (std::signbit(num) ? "" : "+") << num << "i";
-            } else {
-                os << num;
-            }
-        }
+  static std::string toString(const fp& real, const fp& imag,
+                              bool formatted = true, int precision = -1) {
+    std::ostringstream ss{};
 
-        static std::string toString(const fp& real, const fp& imag, bool formatted = true, int precision = -1) {
-            std::ostringstream ss{};
+    if (precision >= 0) {
+      ss << std::setprecision(precision);
+    }
+    const auto tol = ComplexTable<>::tolerance();
 
-            if (precision >= 0) {
-                ss << std::setprecision(precision);
-            }
-            const auto tol = ComplexTable<>::tolerance();
-
-            if (std::abs(real) <= tol && std::abs(imag) <= tol) {
-                return "0";
-            }
-
-            if (std::abs(real) > tol) {
-                if (formatted) {
-                    printFormatted(ss, real);
-                } else {
-                    ss << real;
-                }
-            }
-            if (std::abs(imag) > tol) {
-                if (formatted) {
-                    if (std::abs(real - imag) <= tol) {
-                        ss << "(1+i)";
-                        return ss.str();
-                    }
-                    if (std::abs(real + imag) <= tol) {
-                        ss << "(1-i)";
-                        return ss.str();
-                    }
-                    printFormatted(ss, imag, true);
-                } else {
-                    if (std::abs(real) <= tol) {
-                        ss << imag;
-                    } else {
-                        if (imag > 0.) {
-                            ss << "+";
-                        }
-                        ss << imag;
-                    }
-                    ss << "i";
-                }
-            }
+    if (std::abs(real) <= tol && std::abs(imag) <= tol) {
+      return "0";
+    }
 
-            return ss.str();
+    if (std::abs(real) > tol) {
+      if (formatted) {
+        printFormatted(ss, real);
+      } else {
+        ss << real;
+      }
+    }
+    if (std::abs(imag) > tol) {
+      if (formatted) {
+        if (std::abs(real - imag) <= tol) {
+          ss << "(1+i)";
+          return ss.str();
+        }
+        if (std::abs(real + imag) <= tol) {
+          ss << "(1-i)";
+          return ss.str();
+        }
+        printFormatted(ss, imag, true);
+      } else {
+        if (std::abs(real) <= tol) {
+          ss << imag;
+        } else {
+          if (imag > 0.) {
+            ss << "+";
+          }
+          ss << imag;
         }
+        ss << "i";
+      }
+    }
 
-        explicit operator auto() const { return std::complex<dd::fp>{r, i}; }
-
-        ComplexValue& operator+=(const ComplexValue& rhs) {
-            r += rhs.r;
-            i += rhs.i;
-            return *this;
-        }
+    return ss.str();
+  }
 
-        friend ComplexValue operator+(ComplexValue lhs, const ComplexValue& rhs) {
-            lhs += rhs;
-            return lhs;
-        }
-    };
+  explicit operator auto() const { return std::complex<dd::fp>{r, i}; }
 
-    inline std::ostream& operator<<(std::ostream& os, const ComplexValue& c) {
-        return os << ComplexValue::toString(c.r, c.i);
-    }
+  ComplexValue& operator+=(const ComplexValue& rhs) {
+    r += rhs.r;
+    i += rhs.i;
+    return *this;
+  }
+
+  friend ComplexValue operator+(ComplexValue lhs, const ComplexValue& rhs) {
+    lhs += rhs;
+    return lhs;
+  }
+};
+
+inline std::ostream& operator<<(std::ostream& os, const ComplexValue& c) {
+  return os << ComplexValue::toString(c.r, c.i);
+}
 } // namespace dd
 
 namespace std {
-    template<>
-    struct hash<dd::ComplexValue> {
-        std::size_t operator()(dd::ComplexValue const& c) const noexcept {
-            auto h1 = dd::murmur64(static_cast<std::size_t>(std::round(c.r / dd::ComplexTable<>::tolerance())));
-            auto h2 = dd::murmur64(static_cast<std::size_t>(std::round(c.i / dd::ComplexTable<>::tolerance())));
-            return dd::combineHash(h1, h2);
-        }
-    };
+template <> struct hash<dd::ComplexValue> {
+  std::size_t operator()(dd::ComplexValue const& c) const noexcept {
+    auto h1 = dd::murmur64(static_cast<std::size_t>(
+        std::round(c.r / dd::ComplexTable<>::tolerance())));
+    auto h2 = dd::murmur64(static_cast<std::size_t>(
+        std::round(c.i / dd::ComplexTable<>::tolerance())));
+    return dd::combineHash(h1, h2);
+  }
+};
 } // namespace std
-#endif //DD_PACKAGE_COMPLEXVALUE_HPP
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/ComputeTable.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/dd/ComputeTable.hpp`

 * *Files 15% similar despite different names*

```diff
@@ -1,103 +1,106 @@
-/*
- * This file is part of the MQT DD Package which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum_dd/ for more information.
- */
-
-#ifndef DDpackage_COMPUTETABLE_HPP
-#define DDpackage_COMPUTETABLE_HPP
+#pragma once
 
 #include "Definitions.hpp"
 #include "Node.hpp"
 
 #include <array>
 #include <cstddef>
 #include <iostream>
 #include <utility>
 
 namespace dd {
 
-    /// Data structure for caching computed results
-    /// \tparam LeftOperandType type of the operation's left operand
-    /// \tparam RightOperandType type of the operation's right operand
-    /// \tparam ResultType type of the operation's result
-    /// \tparam NBUCKET number of hash buckets to use (has to be a power of two)
-    template<class LeftOperandType, class RightOperandType, class ResultType, std::size_t NBUCKET = 16384>
-    class ComputeTable {
-    public:
-        ComputeTable() = default;
-
-        struct Entry {
-            LeftOperandType  leftOperand;
-            RightOperandType rightOperand;
-            ResultType       result;
-        };
-
-        static constexpr std::size_t MASK = NBUCKET - 1;
-
-        static std::size_t hash(const LeftOperandType& leftOperand, const RightOperandType& rightOperand) {
-            const auto h1   = std::hash<LeftOperandType>{}(leftOperand);
-            const auto h2   = std::hash<RightOperandType>{}(rightOperand);
-            const auto hash = dd::combineHash(h1, h2);
-            return hash & MASK;
-        }
-
-        // access functions
-        [[nodiscard]] const auto& getTable() const { return table; }
-
-        void insert(const LeftOperandType& leftOperand, const RightOperandType& rightOperand, const ResultType& result) {
-            const auto key = hash(leftOperand, rightOperand);
-            table[key]     = {leftOperand, rightOperand, result};
-            ++count;
-        }
-
-        ResultType lookup(const LeftOperandType& leftOperand, const RightOperandType& rightOperand, [[maybe_unused]] const bool useDensityMatrix = false) {
-            ResultType result{};
-            lookups++;
-            const auto key   = hash(leftOperand, rightOperand);
-            auto&      entry = table[key];
-            if (entry.result.p == nullptr) {
-                return result;
-            }
-            if (entry.leftOperand != leftOperand) {
-                return result;
-            }
-            if (entry.rightOperand != rightOperand) {
-                return result;
-            }
-
-            if constexpr (std::is_same_v<RightOperandType, dEdge>) {
-                // Since density matrices are reduced representations of matrices, a density matrix may not be returned when a matrix is required and vice versa
-                if (dNode::isDensityMatrixNode(entry.result.p->flags) != useDensityMatrix) {
-                    return result;
-                }
-            }
-            hits++;
-            return entry.result;
-        }
-
-        void clear() {
-            if (count > 0) {
-                for (auto& entry: table) {
-                    entry.result.p = nullptr;
-                }
-                count = 0;
-            }
-        }
-
-        [[nodiscard]] fp hitRatio() const { return static_cast<fp>(hits) / static_cast<fp>(lookups); }
-
-        std::ostream& printStatistics(std::ostream& os = std::cout) {
-            os << "hits: " << hits << ", looks: " << lookups << ", ratio: " << hitRatio() << std::endl;
-            return os;
-        }
-
-    private:
-        std::array<Entry, NBUCKET> table{};
-        // compute table lookup statistics
-        std::size_t hits    = 0;
-        std::size_t lookups = 0;
-        std::size_t count   = 0;
-    };
+/// Data structure for caching computed results
+/// \tparam LeftOperandType type of the operation's left operand
+/// \tparam RightOperandType type of the operation's right operand
+/// \tparam ResultType type of the operation's result
+/// \tparam NBUCKET number of hash buckets to use (has to be a power of two)
+template <class LeftOperandType, class RightOperandType, class ResultType,
+          std::size_t NBUCKET = 16384>
+class ComputeTable {
+public:
+  ComputeTable() = default;
+
+  struct Entry {
+    LeftOperandType leftOperand;
+    RightOperandType rightOperand;
+    ResultType result;
+  };
+
+  static constexpr std::size_t MASK = NBUCKET - 1;
+
+  static std::size_t hash(const LeftOperandType& leftOperand,
+                          const RightOperandType& rightOperand) {
+    const auto h1 = std::hash<LeftOperandType>{}(leftOperand);
+    const auto h2 = std::hash<RightOperandType>{}(rightOperand);
+    const auto hash = dd::combineHash(h1, h2);
+    return hash & MASK;
+  }
+
+  // access functions
+  [[nodiscard]] const auto& getTable() const { return table; }
+
+  void insert(const LeftOperandType& leftOperand,
+              const RightOperandType& rightOperand, const ResultType& result) {
+    const auto key = hash(leftOperand, rightOperand);
+    table[key] = {leftOperand, rightOperand, result};
+    ++count;
+  }
+
+  ResultType lookup(const LeftOperandType& leftOperand,
+                    const RightOperandType& rightOperand,
+                    [[maybe_unused]] const bool useDensityMatrix = false) {
+    ResultType result{};
+    lookups++;
+    const auto key = hash(leftOperand, rightOperand);
+    auto& entry = table[key];
+    if (entry.result.p == nullptr) {
+      return result;
+    }
+    if (entry.leftOperand != leftOperand) {
+      return result;
+    }
+    if (entry.rightOperand != rightOperand) {
+      return result;
+    }
+
+    if constexpr (std::is_same_v<RightOperandType, dEdge>) {
+      // Since density matrices are reduced representations of matrices, a
+      // density matrix may not be returned when a matrix is required and vice
+      // versa
+      if (dNode::isDensityMatrixNode(entry.result.p->flags) !=
+          useDensityMatrix) {
+        return result;
+      }
+    }
+    hits++;
+    return entry.result;
+  }
+
+  void clear() {
+    if (count > 0) {
+      for (auto& entry : table) {
+        entry.result.p = nullptr;
+      }
+      count = 0;
+    }
+  }
+
+  [[nodiscard]] fp hitRatio() const {
+    return static_cast<fp>(hits) / static_cast<fp>(lookups);
+  }
+
+  std::ostream& printStatistics(std::ostream& os = std::cout) {
+    os << "hits: " << hits << ", looks: " << lookups
+       << ", ratio: " << hitRatio() << std::endl;
+    return os;
+  }
+
+private:
+  std::array<Entry, NBUCKET> table{};
+  // compute table lookup statistics
+  std::size_t hits = 0;
+  std::size_t lookups = 0;
+  std::size_t count = 0;
+};
 } // namespace dd
-
-#endif //DDpackage_COMPUTETABLE_HPP
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/Control.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/dd/Control.hpp`

 * *Files 25% similar despite different names*

```diff
@@ -1,64 +1,59 @@
-/*
- * This file is part of the MQT DD Package which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum_dd/ for more information.
- */
-
-#ifndef DD_PACKAGE_CONTROL_HPP
-#define DD_PACKAGE_CONTROL_HPP
+#pragma once
 
 #include "Definitions.hpp"
 
 #include <set>
 
 namespace dd {
-    struct Control {
-        enum class Type : bool { pos = true,    // NOLINT(readability-identifier-naming)
-                                 neg = false }; // NOLINT(readability-identifier-naming)
-
-        Qubit qubit{};
-        Type  type = Type::pos;
-    };
-
-    inline bool operator<(const Control& lhs, const Control& rhs) {
-        return lhs.qubit < rhs.qubit || (lhs.qubit == rhs.qubit && lhs.type < rhs.type);
-    }
-
-    inline bool operator==(const Control& lhs, const Control& rhs) {
-        return lhs.qubit == rhs.qubit && lhs.type == rhs.type;
-    }
-
-    inline bool operator!=(const Control& lhs, const Control& rhs) {
-        return !(lhs == rhs);
-    }
-
-    // this allows a set of controls to be indexed by a `Qubit`
-    struct CompareControl {
-        using is_transparent [[maybe_unused]] = void;
-
-        inline bool operator()(const Control& lhs, const Control& rhs) const {
-            return lhs < rhs;
-        }
-
-        inline bool operator()(Qubit lhs, const Control& rhs) const {
-            return lhs < rhs.qubit;
-        }
-
-        inline bool operator()(const Control& lhs, Qubit rhs) const {
-            return lhs.qubit < rhs;
-        }
-    };
-    using Controls = std::set<Control, CompareControl>;
-
-    inline namespace literals {
-        // NOLINTNEXTLINE(google-runtime-int) User-defined literals require unsigned long long int
-        inline Control operator""_pc(unsigned long long int q) {
-            return {static_cast<Qubit>(q)};
-        }
-        // NOLINTNEXTLINE(google-runtime-int) User-defined literals require unsigned long long int
-        inline Control operator""_nc(unsigned long long int q) {
-            return {static_cast<Qubit>(q), Control::Type::neg};
-        }
-    } // namespace literals
+struct Control {
+  enum class Type : bool {
+    pos = true, // NOLINT(readability-identifier-naming)
+    neg = false // NOLINT(readability-identifier-naming)
+  };
+
+  Qubit qubit{};
+  Type type = Type::pos;
+};
+
+inline bool operator<(const Control& lhs, const Control& rhs) {
+  return lhs.qubit < rhs.qubit ||
+         (lhs.qubit == rhs.qubit && lhs.type < rhs.type);
+}
+
+inline bool operator==(const Control& lhs, const Control& rhs) {
+  return lhs.qubit == rhs.qubit && lhs.type == rhs.type;
+}
+
+inline bool operator!=(const Control& lhs, const Control& rhs) {
+  return !(lhs == rhs);
+}
+
+// this allows a set of controls to be indexed by a `Qubit`
+struct CompareControl {
+  using is_transparent [[maybe_unused]] = void;
+
+  inline bool operator()(const Control& lhs, const Control& rhs) const {
+    return lhs < rhs;
+  }
+
+  inline bool operator()(Qubit lhs, const Control& rhs) const {
+    return lhs < rhs.qubit;
+  }
+
+  inline bool operator()(const Control& lhs, Qubit rhs) const {
+    return lhs.qubit < rhs;
+  }
+};
+using Controls = std::set<Control, CompareControl>;
+
+inline namespace literals {
+// NOLINTNEXTLINE(google-runtime-int) User-defined literals require ull
+inline Control operator""_pc(unsigned long long int q) {
+  return {static_cast<Qubit>(q)};
+}
+// NOLINTNEXTLINE(google-runtime-int) User-defined literals require ull
+inline Control operator""_nc(unsigned long long int q) {
+  return {static_cast<Qubit>(q), Control::Type::neg};
+}
+} // namespace literals
 } // namespace dd
-
-#endif //DD_PACKAGE_CONTROL_HPP
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/Definitions.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/dd/Definitions.hpp`

 * *Files 25% similar despite different names*

```diff
@@ -1,107 +1,97 @@
-/*
- * This file is part of the MQT DD Package which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum_dd/ for more information.
- */
-
-#ifndef DDpackage_DATATYPES_HPP
-#define DDpackage_DATATYPES_HPP
+#pragma once
 
 #include <complex>
 #include <cstdint>
 #include <type_traits>
 #include <unordered_map>
 #include <utility>
 #include <vector>
 
 namespace dd {
-    // integer type used for indexing qubits
-    // needs to be a signed type to encode -1 as the index for the terminal
-    // std::int8_t can address up to 128 qubits as [0, ..., 127]
-    using Qubit = std::int8_t;
-    static_assert(std::is_signed_v<Qubit>, "Type Qubit must be signed.");
-
-    // integer type used for specifying numbers of qubits
-    using QubitCount = std::make_unsigned<Qubit>::type;
-
-    // integer type used for reference counting
-    // 32bit suffice for a max ref count of around 4 billion
-    using RefCount = std::uint32_t;
-    static_assert(std::is_unsigned_v<RefCount>, "RefCount should be unsigned.");
-
-    // floating point type to use
-    using fp = double;
-    static_assert(std::is_floating_point_v<fp>, "fp should be a floating point type (float, *double*, long double)");
-
-    // logic radix
-    static constexpr std::uint8_t RADIX = 2;
-    // max no. of edges = RADIX^2
-    static constexpr std::uint8_t NEDGE = RADIX * RADIX;
-
-    enum class BasisStates {
-        zero,  // NOLINT(readability-identifier-naming)
-        one,   // NOLINT(readability-identifier-naming)
-        plus,  // NOLINT(readability-identifier-naming)
-        minus, // NOLINT(readability-identifier-naming)
-        right, // NOLINT(readability-identifier-naming)
-        left   // NOLINT(readability-identifier-naming)
-    };
-
-    static constexpr fp SQRT2_2 = static_cast<fp>(0.707106781186547524400844362104849039284835937688474036588L);
-    static constexpr fp PI      = static_cast<fp>(3.141592653589793238462643383279502884197169399375105820974L);
-    static constexpr fp PI_2    = static_cast<fp>(1.570796326794896619231321691639751442098584699687552910487L);
-    static constexpr fp PI_4    = static_cast<fp>(0.785398163397448309615660845819875721049292349843776455243L);
-
-    using CVec = std::vector<std::complex<fp>>;
-    using CMat = std::vector<CVec>;
-
-    // use hash maps for representing sparse vectors of probabilities
-    using ProbabilityVector = std::unordered_map<std::size_t, fp>;
-
-    static constexpr std::uint64_t SERIALIZATION_VERSION = 1;
-
-    // 64bit mixing hash (from MurmurHash3, https://github.com/aappleby/smhasher/blob/master/src/MurmurHash3.cpp)
-    constexpr std::size_t murmur64(std::size_t k) {
-        k ^= k >> 33;
-        k *= 0xff51afd7ed558ccdULL;
-        k ^= k >> 33;
-        k *= 0xc4ceb9fe1a85ec53ULL;
-        k ^= k >> 33;
-        return k;
-    }
-
-    // combine two 64bit hashes into one 64bit hash (boost::hash_combine, https://www.boost.org/LICENSE_1_0.txt)
-    constexpr std::size_t combineHash(std::size_t lhs, std::size_t rhs) {
-        lhs ^= rhs + 0x9e3779b97f4a7c15ULL + (lhs << 6) + (lhs >> 2);
-        return lhs;
-    }
-
-    // alternative hash combinator (from Google's city hash, https://github.com/google/cityhash/blob/master/COPYING)
-    //    constexpr std::size_t combineHash(std::size_t lhs, std::size_t rhs) {
-    //        const std::size_t kMul = 0x9ddfea08eb382d69ULL;
-    //        std::size_t a = (lhs ^ rhs) * kMul;
-    //        a ^= (a >> 47);
-    //        std::size_t b = (rhs ^ a) * kMul;
-    //        b ^= (b >> 47);
-    //        b *= kMul;
-    //        return b;
-    //    }
-
-    // calculates the Units in Last Place (ULP) distance of two floating point numbers
-    [[maybe_unused]] static std::size_t ulpDistance(fp a, fp b) {
-        // NOLINTNEXTLINE(clang-diagnostic-float-equal)
-        if (a == b) {
-            return 0;
-        }
-
-        std::size_t ulps   = 1;
-        fp          nextFP = std::nextafter(a, b);
-        // NOLINTNEXTLINE(clang-diagnostic-float-equal)
-        while (nextFP != b) {
-            ulps++;
-            nextFP = std::nextafter(nextFP, b);
-        }
-        return ulps;
-    }
-
+// integer type used for indexing qubits
+// needs to be a signed type to encode -1 as the index for the terminal
+// std::int8_t can address up to 128 qubits as [0, ..., 127]
+using Qubit = std::int8_t;
+static_assert(std::is_signed_v<Qubit>, "Type Qubit must be signed.");
+
+// integer type used for specifying numbers of qubits
+using QubitCount = std::make_unsigned<Qubit>::type;
+
+// integer type used for reference counting
+// 32bit suffice for a max ref count of around 4 billion
+using RefCount = std::uint32_t;
+static_assert(std::is_unsigned_v<RefCount>, "RefCount should be unsigned.");
+
+// floating point type to use
+using fp = double;
+static_assert(
+    std::is_floating_point_v<fp>,
+    "fp should be a floating point type (float, *double*, long double)");
+
+// logic radix
+static constexpr std::uint8_t RADIX = 2;
+// max no. of edges = RADIX^2
+static constexpr std::uint8_t NEDGE = RADIX * RADIX;
+
+enum class BasisStates {
+  zero,  // NOLINT(readability-identifier-naming)
+  one,   // NOLINT(readability-identifier-naming)
+  plus,  // NOLINT(readability-identifier-naming)
+  minus, // NOLINT(readability-identifier-naming)
+  right, // NOLINT(readability-identifier-naming)
+  left   // NOLINT(readability-identifier-naming)
+};
+
+static constexpr fp SQRT2_2 = static_cast<fp>(
+    0.707106781186547524400844362104849039284835937688474036588L);
+static constexpr fp PI = static_cast<fp>(
+    3.141592653589793238462643383279502884197169399375105820974L);
+static constexpr fp PI_2 = static_cast<fp>(
+    1.570796326794896619231321691639751442098584699687552910487L);
+static constexpr fp PI_4 = static_cast<fp>(
+    0.785398163397448309615660845819875721049292349843776455243L);
+
+using CVec = std::vector<std::complex<fp>>;
+using CMat = std::vector<CVec>;
+
+// use hash maps for representing sparse vectors of probabilities
+using ProbabilityVector = std::unordered_map<std::size_t, fp>;
+
+static constexpr std::uint64_t SERIALIZATION_VERSION = 1;
+
+// 64bit mixing hash (from MurmurHash3,
+// https://github.com/aappleby/smhasher/blob/master/src/MurmurHash3.cpp)
+constexpr std::size_t murmur64(std::size_t k) {
+  k ^= k >> 33;
+  k *= 0xff51afd7ed558ccdULL;
+  k ^= k >> 33;
+  k *= 0xc4ceb9fe1a85ec53ULL;
+  k ^= k >> 33;
+  return k;
+}
+
+// combine two 64bit hashes into one 64bit hash (boost::hash_combine,
+// https://www.boost.org/LICENSE_1_0.txt)
+constexpr std::size_t combineHash(std::size_t lhs, std::size_t rhs) {
+  lhs ^= rhs + 0x9e3779b97f4a7c15ULL + (lhs << 6) + (lhs >> 2);
+  return lhs;
+}
+
+// calculates the Units in Last Place (ULP) distance of two floating point
+// numbers
+[[maybe_unused]] static std::size_t ulpDistance(fp a, fp b) {
+  // NOLINTNEXTLINE(clang-diagnostic-float-equal)
+  if (a == b) {
+    return 0;
+  }
+
+  std::size_t ulps = 1;
+  fp nextFP = std::nextafter(a, b);
+  // NOLINTNEXTLINE(clang-diagnostic-float-equal)
+  while (nextFP != b) {
+    ulps++;
+    nextFP = std::nextafter(nextFP, b);
+  }
+  return ulps;
+}
 } // namespace dd
-#endif //DDpackage_DATATYPES_HPP
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/DensityNoiseTable.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/dd/DensityNoiseTable.hpp`

 * *Files 22% similar despite different names*

```diff
@@ -1,98 +1,97 @@
-/*
- * This file is part of the MQT DD Package which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum_dd/ for more information.
- */
-
-#ifndef DDpackage_NOISECOMPUTETABLE_HPP
-#define DDpackage_NOISECOMPUTETABLE_HPP
+#pragma once
 
 #include "Definitions.hpp"
 
 #include <array>
 #include <cstddef>
 #include <iostream>
 #include <utility>
 
 namespace dd {
 
-    /// Data structure for caching computed results of noise operations
-    /// \tparam OperandType type of the operation's operand
-    /// \tparam ResultType type of the operation's result
-    /// \tparam NBUCKET number of hash buckets to use (has to be a power of two)
-    template<class OperandType, class ResultType, std::size_t NBUCKET = 32768>
-    class DensityNoiseTable { //todo Inherent from UnaryComputerTable
-    public:
-        DensityNoiseTable() = default;
-
-        struct Entry {
-            OperandType            operand;
-            ResultType             result;
-            std::vector<dd::Qubit> usedQubits;
-        };
-
-        static constexpr size_t MASK = NBUCKET - 1;
-
-        // access functions
-        [[nodiscard]] const auto& getTable() const { return table; }
-
-        static std::size_t hash(const OperandType& a, const std::vector<Qubit>& usedQubits) {
-            std::size_t i = 0;
-            for (const auto qubit: usedQubits) {
-                i = (i << 3U) + i * static_cast<std::size_t>(qubit) + static_cast<std::size_t>(qubit);
-            }
-            return (std::hash<OperandType>{}(a) + i) & MASK;
-        }
-
-        void insert(const OperandType& operand, const ResultType& result, const std::vector<Qubit>& usedQubits) {
-            const auto key   = hash(operand, usedQubits);
-            auto&      entry = table[key];
-            entry.result     = result;
-            entry.operand    = operand;
-            entry.usedQubits = usedQubits;
-            ++count;
-        }
-
-        ResultType lookup(const OperandType& operand, const std::vector<Qubit>& usedQubits) {
-            ResultType result{};
-            lookups++;
-            const auto key   = hash(operand, usedQubits);
-            auto&      entry = table[key];
-            if (entry.result.p == nullptr) {
-                return result;
-            }
-            if (entry.operand != operand) {
-                return result;
-            }
-            if (entry.usedQubits != usedQubits) {
-                return result;
-            }
-            hits++;
-            return entry.result;
-        }
-
-        void clear() {
-            if (count > 0) {
-                for (auto& entry: table) {
-                    entry.result.p = nullptr;
-                }
-                count = 0;
-            }
-        }
-
-        [[nodiscard]] fp hitRatio() const { return static_cast<fp>(hits) / static_cast<fp>(lookups); }
-
-        std::ostream& printStatistics(std::ostream& os = std::cout) {
-            os << "hits: " << hits << ", looks: " << lookups << ", ratio: " << hitRatio() << std::endl;
-            return os;
-        }
-
-    private:
-        std::array<Entry, NBUCKET> table{};
-        // compute table lookup statistics
-        std::size_t hits    = 0;
-        std::size_t lookups = 0;
-        std::size_t count   = 0;
-    };
+/// Data structure for caching computed results of noise operations
+/// \tparam OperandType type of the operation's operand
+/// \tparam ResultType type of the operation's result
+/// \tparam NBUCKET number of hash buckets to use (has to be a power of two)
+template <class OperandType, class ResultType, std::size_t NBUCKET = 32768>
+class DensityNoiseTable { // todo Inherent from UnaryComputerTable
+public:
+  DensityNoiseTable() = default;
+
+  struct Entry {
+    OperandType operand;
+    ResultType result;
+    std::vector<dd::Qubit> usedQubits;
+  };
+
+  static constexpr size_t MASK = NBUCKET - 1;
+
+  // access functions
+  [[nodiscard]] const auto& getTable() const { return table; }
+
+  static std::size_t hash(const OperandType& a,
+                          const std::vector<Qubit>& usedQubits) {
+    std::size_t i = 0;
+    for (const auto qubit : usedQubits) {
+      i = (i << 3U) + i * static_cast<std::size_t>(qubit) +
+          static_cast<std::size_t>(qubit);
+    }
+    return (std::hash<OperandType>{}(a) + i) & MASK;
+  }
+
+  void insert(const OperandType& operand, const ResultType& result,
+              const std::vector<Qubit>& usedQubits) {
+    const auto key = hash(operand, usedQubits);
+    auto& entry = table[key];
+    entry.result = result;
+    entry.operand = operand;
+    entry.usedQubits = usedQubits;
+    ++count;
+  }
+
+  ResultType lookup(const OperandType& operand,
+                    const std::vector<Qubit>& usedQubits) {
+    ResultType result{};
+    lookups++;
+    const auto key = hash(operand, usedQubits);
+    auto& entry = table[key];
+    if (entry.result.p == nullptr) {
+      return result;
+    }
+    if (entry.operand != operand) {
+      return result;
+    }
+    if (entry.usedQubits != usedQubits) {
+      return result;
+    }
+    hits++;
+    return entry.result;
+  }
+
+  void clear() {
+    if (count > 0) {
+      for (auto& entry : table) {
+        entry.result.p = nullptr;
+      }
+      count = 0;
+    }
+  }
+
+  [[nodiscard]] fp hitRatio() const {
+    return static_cast<fp>(hits) / static_cast<fp>(lookups);
+  }
+
+  std::ostream& printStatistics(std::ostream& os = std::cout) {
+    os << "hits: " << hits << ", looks: " << lookups
+       << ", ratio: " << hitRatio() << std::endl;
+    return os;
+  }
+
+private:
+  std::array<Entry, NBUCKET> table{};
+  // compute table lookup statistics
+  std::size_t hits = 0;
+  std::size_t lookups = 0;
+  std::size_t count = 0;
+};
 } // namespace dd
-
-#endif //DDpackage_NOISECOMPUTETABLE_HPP
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/Export.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/dd/Export.hpp`

 * *Files 6% similar despite different names*

```diff
@@ -1,14 +1,8 @@
-/*
- * This file is part of the MQT DD Package which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum_dd/ for more information.
- */
-
-#ifndef DDexport_H
-#define DDexport_H
+#pragma once
 
 #include "Complex.hpp"
 #include "ComplexNumbers.hpp"
 #include "Definitions.hpp"
 #include "Edge.hpp"
 #include "Package.hpp"
 
@@ -26,810 +20,960 @@
 #include <string>
 #include <unordered_map>
 #include <unordered_set>
 #include <vector>
 
 namespace dd {
 
-    inline std::string colorFromPhase(const Complex& a) {
-        auto phase = dd::ComplexNumbers::arg(a) / (2 * dd::PI);
-        if (phase < 0) {
-            phase += 1.;
-        }
-        std::ostringstream oss{};
-        oss << std::fixed << std::setprecision(3) << phase << " " << 0.667 << " " << 0.75;
-        return oss.str();
-    }
-
-    inline fp thicknessFromMagnitude(const Complex& a) {
-        return 3.0 * std::max(dd::ComplexNumbers::mag(a), 0.10);
-    }
-
-    static void printPhaseFormatted(std::ostream& os, fp r) {
-        const auto tol = dd::ComplexTable<>::tolerance();
-
-        r /= dd::PI;
-        // special case treatment for +-i
-        os << "(" << (std::signbit(r) ? "-" : "") << "i";
-
-        const auto absr     = std::abs(r);
-        auto       fraction = ComplexValue::getLowestFraction(absr);
-        auto       approx   = static_cast<fp>(fraction.first) / static_cast<fp>(fraction.second);
-        auto       error    = std::abs(absr - approx);
-
-        if (error < tol) { // suitable fraction a/b found
-            if (fraction.first == 1U && fraction.second == 1U) {
-                os << ")";
-            } else if (fraction.second == 1U) {
-                os << " " << fraction.first << ")";
-            } else if (fraction.first == 1U) {
-                os << "/" << fraction.second << ")";
-            } else {
-                os << " " << fraction.first << "/" << fraction.second << ")";
-            }
-            return;
-        }
-
-        auto abssqrt = absr / SQRT2_2;
-        fraction     = ComplexValue::getLowestFraction(abssqrt);
-        approx       = static_cast<fp>(fraction.first) / static_cast<fp>(fraction.second);
-        error        = std::abs(abssqrt - approx);
-
-        if (error < tol) { // suitable fraction a/(b * sqrt(2)) found
-            if (fraction.first == 1U && fraction.second == 1U) {
-                os << "/2)";
-            } else if (fraction.second == 1U) {
-                os << " " << fraction.first << "/2)";
-            } else if (fraction.first == 1U) {
-                os << "/(" << fraction.second << "2))";
-            } else {
-                os << " " << fraction.first << "/(" << fraction.second << "2))";
-            }
-            return;
-        }
-
-        auto abspi = absr / PI;
-        fraction   = ComplexValue::getLowestFraction(abspi);
-        approx     = static_cast<fp>(fraction.first) / static_cast<fp>(fraction.second);
-        error      = std::abs(abspi - approx);
-
-        if (error < tol) { // suitable fraction a/b  found
-            if (fraction.first == 1U && fraction.second == 1U) {
-                os << " )";
-            } else if (fraction.second == 1U) {
-                os << " " << fraction.first << ")";
-            } else if (fraction.first == 1U) {
-                os << " /" << fraction.second << ")";
-            } else {
-                os << " " << fraction.first << "/" << fraction.second << ")";
-            }
-            return;
-        }
-
-        // default
-        os << " " << absr << ")";
-    }
-
-    inline std::string conditionalFormat(const Complex& a, bool formatAsPolar = true) {
-        if (!formatAsPolar) {
-            return a.toString();
-        }
-
-        const auto mag   = ComplexNumbers::mag(a);
-        const auto phase = ComplexNumbers::arg(a);
-
-        if (std::abs(mag) < ComplexTable<>::tolerance()) {
-            return "0";
-        }
-
-        std::ostringstream ss{};
-        // magnitude is (almost) 1
-        if (std::abs(mag - 1) < ComplexTable<>::tolerance()) {
-            if (std::abs(phase) < ComplexTable<>::tolerance()) {
-                return "1";
-            }
-            if (std::abs(phase - dd::PI_2) < ComplexTable<>::tolerance()) {
-                return "i";
-            }
-            if (std::abs(phase + dd::PI_2) < ComplexTable<>::tolerance()) {
-                return "-i";
-            }
-            if (std::abs(std::abs(phase) - dd::PI) < ComplexTable<>::tolerance()) {
-                return "-1";
-            }
-            printPhaseFormatted(ss, phase);
-            return ss.str();
-        }
-
-        if (std::abs(std::abs(phase) - dd::PI) < ComplexTable<>::tolerance()) {
-            ss << "-";
-            dd::ComplexValue::printFormatted(ss, mag);
-            return ss.str();
-        }
-        if (std::abs(phase) < ComplexTable<>::tolerance()) {
-            dd::ComplexValue::printFormatted(ss, mag);
-            return ss.str();
-        }
-
-        dd::ComplexValue::printFormatted(ss, mag);
-        ss << " ";
-        printPhaseFormatted(ss, phase);
-
-        return ss.str();
-    }
-
-    template<class Edge>
-    static std::ostream& header(const Edge& e, std::ostream& os, bool edgeLabels, bool formatAsPolar = true) {
-        os << "digraph \"DD\" {graph[];node[shape=plain];edge[arrowhead=none]\n";
-        os << "root [label=\"\",shape=point,style=invis]\n";
-        os << "t [label=<<font point-size=\"20\">1</font>>,shape=box,tooltip=\"1\",width=0.3,height=0.3]\n";
-        auto toplabel = (reinterpret_cast<std::uintptr_t>(e.p) & 0x001fffffU) >> 1U;
-        os << "root->";
-        if (e.isTerminal()) {
-            os << "t";
-        } else {
-            os << toplabel;
-        }
-        os << "[penwidth=\"" << thicknessFromMagnitude(e.w) << "\",tooltip=\"" << conditionalFormat(e.w, formatAsPolar) << "\"";
-        if (!e.w.approximatelyOne()) {
-            os << ",style=dashed";
-        }
-        if (edgeLabels) {
-            os << ",label=<<font point-size=\"8\">&nbsp;" << conditionalFormat(e.w, formatAsPolar) << "</font>>";
-        }
-
-        os << "]\n";
-
-        return os;
-    }
-    template<class Edge>
-    static std::ostream& coloredHeader(const Edge& e, std::ostream& os, bool edgeLabels, bool formatAsPolar = true) {
-        os << "digraph \"DD\" {graph[];node[shape=plain];edge[arrowhead=none]\n";
-        os << "root [label=\"\",shape=point,style=invis]\n";
-        os << "t [label=<<font point-size=\"20\">1</font>>,shape=box,tooltip=\"1\",width=0.3,height=0.3]\n";
-
-        auto toplabel = (reinterpret_cast<std::uintptr_t>(e.p) & 0x001fffffU) >> 1U;
-        auto mag      = thicknessFromMagnitude(e.w);
-        auto color    = colorFromPhase(e.w);
-        os << "root->";
-        if (e.isTerminal()) {
-            os << "t";
-        } else {
-            os << toplabel;
-        }
-        os << "[penwidth=\"" << mag << "\",tooltip=\"" << conditionalFormat(e.w, formatAsPolar) << "\",color=\"" << color << "\"";
-        if (edgeLabels) {
-            os << ",label=<<font point-size=\"8\">&nbsp;" << conditionalFormat(e.w, formatAsPolar) << "</font>>";
-        }
-        os << "]\n";
-        return os;
-    }
-    template<class Edge>
-    static std::ostream& memoryHeader(const Edge& e, std::ostream& os, bool edgeLabels) {
-        os << "digraph \"DD\" {graph[];node[shape=plain];edge[arrowhead=none]\n";
-        os << "root [label=\"\",shape=point,style=invis]\n";
-        os << "t [label=<<font point-size=\"20\">1</font>>,shape=box,tooltip=\"1\",width=0.3,height=0.3]\n";
-
-        auto toplabel = (reinterpret_cast<std::uintptr_t>(e.p) & 0x001fffffU) >> 1U;
-        auto mag      = thicknessFromMagnitude(e.w);
-        auto color    = colorFromPhase(e.w);
-        os << "root->";
-        if (e.isTerminal()) {
-            os << "t";
-        } else {
-            os << toplabel;
-        }
-        os << "[penwidth=\"" << mag << "\",tooltip=\"" << e.w.toString(false, 4) << "\" color=\"" << color << "\"";
-        if (edgeLabels) {
-            os << ",label=<<font point-size=\"8\">&nbsp;[";
-            if (e.w == Complex::zero) {
-                os << "0";
-            } else if (e.w == Complex::one) {
-                os << "1";
-            } else {
-                if (e.w.r == &ComplexTable<>::zero) {
-                    os << "0";
-                } else if (e.w.r == &ComplexTable<>::sqrt2_2) {
-                    os << "\xe2\x88\x9a\xc2\xbd";
-                } else if (e.w.r == &ComplexTable<>::one) {
-                    os << "1";
-                } else {
-                    os << std::hex << reinterpret_cast<std::uintptr_t>(e.w.r) << std::dec;
-                }
-                os << " ";
-                if (e.w.i == &ComplexTable<>::zero) {
-                    os << "0";
-                } else if (e.w.i == &ComplexTable<>::sqrt2_2) {
-                    os << "\xe2\x88\x9a\xc2\xbd";
-                } else if (e.w.i == &ComplexTable<>::one) {
-                    os << "1";
-                } else {
-                    os << std::hex << reinterpret_cast<std::uintptr_t>(e.w.i) << std::dec;
-                }
-            }
-            os << "]</font>>";
-        }
-        os << "]\n";
-        return os;
-    }
-
-    [[maybe_unused]] static std::ostream& modernNode(const mEdge& e, std::ostream& os, bool formatAsPolar = true) {
-        auto nodelabel = (reinterpret_cast<std::uintptr_t>(e.p) & 0x001fffffU) >> 1U; // this allows for 2^20 (roughly 1e6) unique nodes
-        os << nodelabel << "[label=<";
-        os << R"(<font point-size="10"><table border="1" cellspacing="0" cellpadding="2" style="rounded">)";
-        os << R"(<tr><td colspan="2" rowspan="2" port="0" href="javascript:;" border="0" tooltip=")" << conditionalFormat(e.p->e[0].w, formatAsPolar) << "\">" << (e.p->e[0].w.approximatelyZero() ? "&nbsp;0 " : "<font color=\"white\">&nbsp;0 </font>")
-           << R"(</td><td sides="R"></td><td sides="L"></td>)"
-           << R"(<td colspan="2" rowspan="2" port="1" href="javascript:;" border="0" tooltip=")" << conditionalFormat(e.p->e[1].w, formatAsPolar) << "\">" << (e.p->e[1].w.approximatelyZero() ? "&nbsp;0 " : "<font color=\"white\">&nbsp;0 </font>") << R"(</td></tr>)";
-        os << R"(<tr><td sides="R"></td><td sides="L"></td></tr>)";
-        os << R"(<tr><td colspan="2" sides="B"></td><td colspan="2" rowspan="2" border="0"><font point-size="24">q<sub><font point-size="16">)" << static_cast<std::size_t>(e.p->v) << R"(</font></sub></font></td><td colspan="2" sides="B"></td></tr>)";
-        os << R"(<tr><td sides="T" colspan="2"></td><td sides="T" colspan="2"></td></tr>)";
-        os << R"(<tr><td colspan="2" rowspan="2" port="2" href="javascript:;" border="0" tooltip=")" << conditionalFormat(e.p->e[2].w, formatAsPolar) << "\">" << (e.p->e[2].w.approximatelyZero() ? "&nbsp;0 " : "<font color=\"white\">&nbsp;0 </font>")
-           << R"(</td><td sides="R"></td><td sides="L"></td>)"
-           << R"(<td colspan="2" rowspan="2" port="3" href="javascript:;" border="0" tooltip=")" << conditionalFormat(e.p->e[3].w, formatAsPolar) << "\">" << (e.p->e[3].w.approximatelyZero() ? "&nbsp;0 " : "<font color=\"white\">&nbsp;0 </font>") << "</td></tr>";
-        os << R"(<tr><td sides="R"></td><td sides="L"></td></tr>)";
-        os << "</table></font>>,tooltip=\"q" << static_cast<std::size_t>(e.p->v) << "\"]\n";
-        return os;
-    }
-    [[maybe_unused]] static std::ostream& modernNode(const vEdge& e, std::ostream& os, bool formatAsPolar = true) {
-        auto nodelabel = (reinterpret_cast<std::uintptr_t>(e.p) & 0x001fffffU) >> 1U; // this allows for 2^20 (roughly 1e6) unique nodes
-        os << nodelabel << "[label=<";
-        os << R"(<font point-size="8"><table border="1" cellspacing="0" cellpadding="0" style="rounded">)";
-        os << R"(<tr><td colspan="2" border="0" cellpadding="1"><font point-size="20">q<sub><font point-size="12">)" << static_cast<std::size_t>(e.p->v) << R"(</font></sub></font></td></tr><tr>)";
-        os << R"(<td height="6" width="14" port="0" tooltip=")" << conditionalFormat(e.p->e[0].w, formatAsPolar) << R"(" href="javascript:;" sides="RT">)" << (e.p->e[0].w.approximatelyZero() ? "&nbsp;0 " : R"(<font color="white">&nbsp;0 </font>)") << "</td>";
-        os << R"(<td height="6" width="14" port="1" tooltip=")" << conditionalFormat(e.p->e[1].w, formatAsPolar) << R"(" href="javascript:;" sides="LT">)" << (e.p->e[1].w.approximatelyZero() ? "&nbsp;0 " : R"(<font color="white">&nbsp;0 </font>)") << "</td>";
-        os << "</tr></table></font>>,tooltip=\"q" << static_cast<std::size_t>(e.p->v) << "\"]\n";
-        return os;
-    }
-    [[maybe_unused]] static std::ostream& classicNode(const mEdge& e, std::ostream& os, bool formatAsPolar = true) {
-        auto nodelabel = (reinterpret_cast<std::uintptr_t>(e.p) & 0x001fffffU) >> 1U; // this allows for 2^20 (roughly 1e6) unique nodes
-        os << nodelabel << "[shape=circle, width=0.53, fixedsize=true, label=<";
-        os << R"(<font point-size="6"><table border="0" cellspacing="0" cellpadding="0">)";
-        os << R"(<tr><td colspan="4"><font point-size="18">q<sub><font point-size="10">)" << static_cast<std::size_t>(e.p->v) << R"(</font></sub></font></td></tr><tr>)";
-        os << R"(<td port="0" tooltip=")" << conditionalFormat(e.p->e[0].w, formatAsPolar) << R"(" href="javascript:;">)";
-        if (e.p->e[0].w.approximatelyZero()) {
-            os << R"(<font point-size="8">&nbsp;0 </font>)";
-        } else {
-            os << R"(<font color="white">&nbsp;0 </font>)";
-        }
-        os << "</td>";
-        os << "<td></td><td></td>";
-        os << R"(<td port="3" tooltip=")" << conditionalFormat(e.p->e[3].w, formatAsPolar) << R"(" href="javascript:;">)";
-        if (e.p->e[3].w.approximatelyZero()) {
-            os << R"(<font point-size="8">&nbsp;0 </font>)";
-        } else {
-            os << R"(<font color="white">&nbsp;0 </font>)";
-        }
-        os << "</td>";
-        os << "</tr><tr><td></td>";
-        os << R"(<td port="1" tooltip=")" << conditionalFormat(e.p->e[1].w, formatAsPolar) << R"(" href="javascript:;">)";
-        if (e.p->e[1].w.approximatelyZero()) {
-            os << R"(<font point-size="8">&nbsp;0 </font>)";
-        } else {
-            os << R"(<font color="white">&nbsp;0 </font>)";
-        }
-        os << "</td>";
-        os << R"(<td port="2" tooltip=")" << conditionalFormat(e.p->e[2].w, formatAsPolar) << R"(" href="javascript:;">)";
-        if (e.p->e[2].w.approximatelyZero()) {
-            os << R"(<font point-size="8">&nbsp;0 </font>)";
-        } else {
-            os << R"(<font color="white">&nbsp;0 </font>)";
-        }
-        os << "</td>";
-        os << "<td></td></tr></table></font>>,tooltip=\"q" << static_cast<std::size_t>(e.p->v) << "\"]\n";
-        return os;
-    }
-    [[maybe_unused]] static std::ostream& classicNode(const vEdge& e, std::ostream& os, bool formatAsPolar = true) {
-        auto nodelabel = (reinterpret_cast<std::uintptr_t>(e.p) & 0x001fffffU) >> 1U; // this allows for 2^20 (roughly 1e6) unique nodes
-        os << nodelabel << "[shape=circle, width=0.46, fixedsize=true, label=<";
-        os << R"(<font point-size="6"><table border="0" cellspacing="0" cellpadding="0">)";
-        os << R"(<tr><td colspan="2"><font point-size="18">q<sub><font point-size="10">)" << static_cast<std::size_t>(e.p->v) << R"(</font></sub></font></td></tr><tr>)";
-        os << R"(<td port="0" tooltip=")" << conditionalFormat(e.p->e[0].w, formatAsPolar) << R"(" href="javascript:;">)";
-        if (e.p->e[0].w.approximatelyZero()) {
-            os << R"(<font point-size="10">&nbsp;0 </font>)";
-        } else {
-            os << R"(<font color="white">&nbsp;0 </font>)";
-        }
-        os << "</td>";
-        os << R"(<td port="1" tooltip=")" << conditionalFormat(e.p->e[1].w, formatAsPolar) << R"(" href="javascript:;">)";
-        if (e.p->e[1].w.approximatelyZero()) {
-            os << R"(<font point-size="10">&nbsp;0 </font>)";
-        } else {
-            os << R"(<font color="white">&nbsp;0 </font>)";
-        }
-        os << "</td>";
-        os << "</tr></table></font>>,tooltip=\"q" << static_cast<std::size_t>(e.p->v) << "\"]\n";
-        return os;
-    }
-    template<class Edge>
-    static std::ostream& memoryNode(const Edge& e, std::ostream& os) {
-        constexpr std::size_t n         = std::tuple_size_v<decltype(e.p->e)>;
-        auto                  nodelabel = (reinterpret_cast<std::uintptr_t>(e.p) & 0x001fffffU) >> 1U; // this allows for 2^20 (roughly 1e6) unique nodes
-        os << nodelabel << "[label=<";
-        os << R"(<font point-size="10"><table border="1" cellspacing="0" cellpadding="2" style="rounded">)";
-        os << R"(<tr><td colspan=")" << n << R"(" border="1" sides="B">)" << std::hex << reinterpret_cast<std::uintptr_t>(e.p) << std::dec << " ref: " << e.p->ref << "</td></tr>";
-        os << "<tr>";
-        for (std::size_t i = 0; i < n; ++i) {
-            os << "<td port=\"" << i << R"(" href="javascript:;" border="0" tooltip=")" << e.p->e[i].w.toString(false, 4) << "\">";
-            if (e.p->e[i] == Edge::zero) {
-                os << "&nbsp;0 "
-                      "";
-            } else {
-                os << "<font color=\"white\">&nbsp;0 </font>";
-            }
-            os << "</td>";
-        }
-        os << "</tr>";
-        os << "</table></font>>,tooltip=\"" << std::hex << reinterpret_cast<std::uintptr_t>(e.p) << "\"]\n"
-           << std::dec;
-        return os;
-    }
-
-    [[maybe_unused]] static std::ostream& bwEdge(const mEdge& from, const mEdge& to, std::uint16_t idx, std::ostream& os, bool edgeLabels = false, bool classic = false, bool formatAsPolar = true) {
-        auto fromlabel = (reinterpret_cast<std::uintptr_t>(from.p) & 0x001fffffU) >> 1U;
-        auto tolabel   = (reinterpret_cast<std::uintptr_t>(to.p) & 0x001fffffU) >> 1U;
-
-        os << fromlabel << ":" << idx << ":";
-        if (classic) {
-            if (idx == 0) {
-                os << "sw";
-            } else if (idx == 1 || idx == 2) {
-                os << "s";
-            } else {
-                os << "se";
-            }
-        } else {
-            if (idx == 0) {
-                os << "sw";
-            } else if (idx == 1) {
-                os << "se";
-            } else {
-                os << 's';
-            }
-        }
-        os << "->";
-        if (to.isTerminal()) {
-            os << "t";
-        } else {
-            os << tolabel;
-        }
-
-        auto mag = thicknessFromMagnitude(to.w);
-        os << "[penwidth=\"" << mag << "\",tooltip=\"" << conditionalFormat(to.w, formatAsPolar) << "\"";
-        if (!to.w.approximatelyOne()) {
-            os << ",style=dashed";
-        }
-        if (edgeLabels) {
-            os << ",label=<<font point-size=\"8\">&nbsp;" << conditionalFormat(to.w, formatAsPolar) << "</font>>";
-        }
-        os << "]\n";
-
-        return os;
-    }
-    [[maybe_unused]] static std::ostream& bwEdge(const vEdge& from, const vEdge& to, std::uint16_t idx, std::ostream& os, bool edgeLabels = false, [[maybe_unused]] bool classic = false, bool formatAsPolar = true) {
-        auto fromlabel = (reinterpret_cast<std::uintptr_t>(from.p) & 0x001fffffU) >> 1U;
-        auto tolabel   = (reinterpret_cast<std::uintptr_t>(to.p) & 0x001fffffU) >> 1U;
-
-        os << fromlabel << ":" << idx << ":";
-        os << (idx == 0 ? "sw" : "se") << "->";
-        if (to.isTerminal()) {
-            os << "t";
-        } else {
-            os << tolabel;
-        }
-
-        auto mag = thicknessFromMagnitude(to.w);
-        os << "[penwidth=\"" << mag << "\",tooltip=\"" << conditionalFormat(to.w, formatAsPolar) << "\"";
-        if (!to.w.approximatelyOne()) {
-            os << ",style=dashed";
-        }
-        if (edgeLabels) {
-            os << ",label=<<font point-size=\"8\">&nbsp;" << conditionalFormat(to.w, formatAsPolar) << "</font>>";
-        }
-        os << "]\n";
-
-        return os;
-    }
-    [[maybe_unused]] static std::ostream& coloredEdge(const mEdge& from, const mEdge& to, std::uint16_t idx, std::ostream& os, bool edgeLabels = false, bool classic = false, bool formatAsPolar = true) {
-        auto fromlabel = (reinterpret_cast<std::uintptr_t>(from.p) & 0x001fffffU) >> 1U;
-        auto tolabel   = (reinterpret_cast<std::uintptr_t>(to.p) & 0x001fffffU) >> 1U;
-
-        os << fromlabel << ":" << idx << ":";
-        if (classic) {
-            if (idx == 0) {
-                os << "sw";
-            } else if (idx == 1 || idx == 2) {
-                os << "s";
-            } else {
-                os << "se";
-            }
-        } else {
-            if (idx == 0) {
-                os << "sw";
-            } else if (idx == 1) {
-                os << "se";
-            } else {
-                os << 's';
-            }
-        }
-        os << "->";
-        if (to.isTerminal()) {
-            os << "t";
-        } else {
-            os << tolabel;
-        }
-
-        auto mag   = thicknessFromMagnitude(to.w);
-        auto color = colorFromPhase(to.w);
-        os << "[penwidth=\"" << mag << "\",tooltip=\"" << conditionalFormat(to.w, formatAsPolar) << "\" color=\"" << color << "\"";
-        if (edgeLabels) {
-            os << ",label=<<font point-size=\"8\">&nbsp;" << conditionalFormat(to.w, formatAsPolar) << "</font>>";
-        }
-        os << "]\n";
-
-        return os;
-    }
-    [[maybe_unused]] static std::ostream& coloredEdge(const vEdge& from, const vEdge& to, std::uint16_t idx, std::ostream& os, bool edgeLabels = false, [[maybe_unused]] bool classic = false, bool formatAsPolar = true) {
-        auto fromlabel = (reinterpret_cast<std::uintptr_t>(from.p) & 0x001fffffU) >> 1U;
-        auto tolabel   = (reinterpret_cast<std::uintptr_t>(to.p) & 0x001fffffU) >> 1U;
-
-        os << fromlabel << ":" << idx << ":";
-        os << (idx == 0 ? "sw" : "se") << "->";
-        if (to.isTerminal()) {
-            os << "t";
-        } else {
-            os << tolabel;
-        }
-
-        auto mag   = thicknessFromMagnitude(to.w);
-        auto color = colorFromPhase(to.w);
-        os << "[penwidth=\"" << mag << "\",tooltip=\"" << conditionalFormat(to.w, formatAsPolar) << "\" color=\"" << color << "\"";
-        if (edgeLabels) {
-            os << ",label=<<font point-size=\"8\">&nbsp;" << conditionalFormat(to.w, formatAsPolar) << "</font>>";
-        }
-        os << "]\n";
-
-        return os;
-    }
-    template<class Edge>
-    static std::ostream& memoryEdge(const Edge& from, const Edge& to, std::uint16_t idx, std::ostream& os, bool edgeLabels = false) {
-        auto fromlabel = (reinterpret_cast<std::uintptr_t>(from.p) & 0x001fffffU) >> 1U;
-        auto tolabel   = (reinterpret_cast<std::uintptr_t>(to.p) & 0x001fffffU) >> 1U;
-
-        os << fromlabel << ":" << idx << ":s->";
-        if (to.isTerminal()) {
-            os << "t";
-        } else {
-            os << tolabel;
-        }
-
-        auto mag   = thicknessFromMagnitude(to.w);
-        auto color = colorFromPhase(to.w);
-        os << "[penwidth=\"" << mag << "\",tooltip=\"" << to.w.toString(false, 4) << "\" color=\"" << color << "\"";
-        if (edgeLabels) {
-            os << ",label=<<font point-size=\"8\">&nbsp;[";
-            if (to.w == Complex::one) {
-                os << "1";
-            } else {
-                if (to.w.r == &ComplexTable<>::zero) {
-                    os << "0";
-                } else if (to.w.r == &ComplexTable<>::sqrt2_2) {
-                    os << "\xe2\x88\x9a\xc2\xbd";
-                } else if (to.w.r == &ComplexTable<>::one) {
-                    os << "1";
-                } else {
-                    os << std::hex << reinterpret_cast<std::uintptr_t>(to.w.r) << std::dec;
-                }
-                os << " ";
-                if (to.w.i == &ComplexTable<>::zero) {
-                    os << "0";
-                } else if (to.w.i == &ComplexTable<>::sqrt2_2) {
-                    os << "\xe2\x88\x9a\xc2\xbd";
-                } else if (to.w.i == &ComplexTable<>::one) {
-                    os << "1";
-                } else {
-                    os << std::hex << reinterpret_cast<std::uintptr_t>(to.w.i) << std::dec;
-                }
-            }
-            os << "]</font>>";
+inline std::string colorFromPhase(const Complex& a) {
+  auto phase = dd::ComplexNumbers::arg(a) / (2 * dd::PI);
+  if (phase < 0) {
+    phase += 1.;
+  }
+  std::ostringstream oss{};
+  oss << std::fixed << std::setprecision(3) << phase << " " << 0.667 << " "
+      << 0.75;
+  return oss.str();
+}
+
+inline fp thicknessFromMagnitude(const Complex& a) {
+  return 3.0 * std::max(dd::ComplexNumbers::mag(a), 0.10);
+}
+
+static void printPhaseFormatted(std::ostream& os, fp r) {
+  const auto tol = dd::ComplexTable<>::tolerance();
+
+  r /= dd::PI;
+  // special case treatment for +-i
+  os << "(" << (std::signbit(r) ? "-" : "") << "i";
+
+  const auto absr = std::abs(r);
+  auto fraction = ComplexValue::getLowestFraction(absr);
+  auto approx =
+      static_cast<fp>(fraction.first) / static_cast<fp>(fraction.second);
+  auto error = std::abs(absr - approx);
+
+  if (error < tol) { // suitable fraction a/b found
+    if (fraction.first == 1U && fraction.second == 1U) {
+      os << ")";
+    } else if (fraction.second == 1U) {
+      os << " " << fraction.first << ")";
+    } else if (fraction.first == 1U) {
+      os << "/" << fraction.second << ")";
+    } else {
+      os << " " << fraction.first << "/" << fraction.second << ")";
+    }
+    return;
+  }
+
+  auto abssqrt = absr / SQRT2_2;
+  fraction = ComplexValue::getLowestFraction(abssqrt);
+  approx = static_cast<fp>(fraction.first) / static_cast<fp>(fraction.second);
+  error = std::abs(abssqrt - approx);
+
+  if (error < tol) { // suitable fraction a/(b * sqrt(2)) found
+    if (fraction.first == 1U && fraction.second == 1U) {
+      os << "/2)";
+    } else if (fraction.second == 1U) {
+      os << " " << fraction.first << "/2)";
+    } else if (fraction.first == 1U) {
+      os << "/(" << fraction.second << "2))";
+    } else {
+      os << " " << fraction.first << "/(" << fraction.second << "2))";
+    }
+    return;
+  }
+
+  auto abspi = absr / PI;
+  fraction = ComplexValue::getLowestFraction(abspi);
+  approx = static_cast<fp>(fraction.first) / static_cast<fp>(fraction.second);
+  error = std::abs(abspi - approx);
+
+  if (error < tol) { // suitable fraction a/b  found
+    if (fraction.first == 1U && fraction.second == 1U) {
+      os << " )";
+    } else if (fraction.second == 1U) {
+      os << " " << fraction.first << ")";
+    } else if (fraction.first == 1U) {
+      os << " /" << fraction.second << ")";
+    } else {
+      os << " " << fraction.first << "/" << fraction.second << ")";
+    }
+    return;
+  }
+
+  // default
+  os << " " << absr << ")";
+}
+
+inline std::string conditionalFormat(const Complex& a,
+                                     bool formatAsPolar = true) {
+  if (!formatAsPolar) {
+    return a.toString();
+  }
+
+  const auto mag = ComplexNumbers::mag(a);
+  const auto phase = ComplexNumbers::arg(a);
+
+  if (std::abs(mag) < ComplexTable<>::tolerance()) {
+    return "0";
+  }
+
+  std::ostringstream ss{};
+  // magnitude is (almost) 1
+  if (std::abs(mag - 1) < ComplexTable<>::tolerance()) {
+    if (std::abs(phase) < ComplexTable<>::tolerance()) {
+      return "1";
+    }
+    if (std::abs(phase - dd::PI_2) < ComplexTable<>::tolerance()) {
+      return "i";
+    }
+    if (std::abs(phase + dd::PI_2) < ComplexTable<>::tolerance()) {
+      return "-i";
+    }
+    if (std::abs(std::abs(phase) - dd::PI) < ComplexTable<>::tolerance()) {
+      return "-1";
+    }
+    printPhaseFormatted(ss, phase);
+    return ss.str();
+  }
+
+  if (std::abs(std::abs(phase) - dd::PI) < ComplexTable<>::tolerance()) {
+    ss << "-";
+    dd::ComplexValue::printFormatted(ss, mag);
+    return ss.str();
+  }
+  if (std::abs(phase) < ComplexTable<>::tolerance()) {
+    dd::ComplexValue::printFormatted(ss, mag);
+    return ss.str();
+  }
+
+  dd::ComplexValue::printFormatted(ss, mag);
+  ss << " ";
+  printPhaseFormatted(ss, phase);
+
+  return ss.str();
+}
+
+template <class Edge>
+static std::ostream& header(const Edge& e, std::ostream& os, bool edgeLabels,
+                            bool formatAsPolar = true) {
+  os << "digraph \"DD\" {graph[];node[shape=plain];edge[arrowhead=none]\n";
+  os << "root [label=\"\",shape=point,style=invis]\n";
+  os << "t [label=<<font "
+        "point-size=\"20\">1</"
+        "font>>,shape=box,tooltip=\"1\",width=0.3,height=0.3]\n";
+  auto toplabel = (reinterpret_cast<std::uintptr_t>(e.p) & 0x001fffffU) >> 1U;
+  os << "root->";
+  if (e.isTerminal()) {
+    os << "t";
+  } else {
+    os << toplabel;
+  }
+  os << "[penwidth=\"" << thicknessFromMagnitude(e.w) << "\",tooltip=\""
+     << conditionalFormat(e.w, formatAsPolar) << "\"";
+  if (!e.w.approximatelyOne()) {
+    os << ",style=dashed";
+  }
+  if (edgeLabels) {
+    os << ",label=<<font point-size=\"8\">&nbsp;"
+       << conditionalFormat(e.w, formatAsPolar) << "</font>>";
+  }
+
+  os << "]\n";
+
+  return os;
+}
+template <class Edge>
+static std::ostream& coloredHeader(const Edge& e, std::ostream& os,
+                                   bool edgeLabels, bool formatAsPolar = true) {
+  os << "digraph \"DD\" {graph[];node[shape=plain];edge[arrowhead=none]\n";
+  os << "root [label=\"\",shape=point,style=invis]\n";
+  os << "t [label=<<font "
+        "point-size=\"20\">1</"
+        "font>>,shape=box,tooltip=\"1\",width=0.3,height=0.3]\n";
+
+  auto toplabel = (reinterpret_cast<std::uintptr_t>(e.p) & 0x001fffffU) >> 1U;
+  auto mag = thicknessFromMagnitude(e.w);
+  auto color = colorFromPhase(e.w);
+  os << "root->";
+  if (e.isTerminal()) {
+    os << "t";
+  } else {
+    os << toplabel;
+  }
+  os << "[penwidth=\"" << mag << "\",tooltip=\""
+     << conditionalFormat(e.w, formatAsPolar) << "\",color=\"" << color << "\"";
+  if (edgeLabels) {
+    os << ",label=<<font point-size=\"8\">&nbsp;"
+       << conditionalFormat(e.w, formatAsPolar) << "</font>>";
+  }
+  os << "]\n";
+  return os;
+}
+template <class Edge>
+static std::ostream& memoryHeader(const Edge& e, std::ostream& os,
+                                  bool edgeLabels) {
+  os << "digraph \"DD\" {graph[];node[shape=plain];edge[arrowhead=none]\n";
+  os << "root [label=\"\",shape=point,style=invis]\n";
+  os << "t [label=<<font "
+        "point-size=\"20\">1</"
+        "font>>,shape=box,tooltip=\"1\",width=0.3,height=0.3]\n";
+
+  auto toplabel = (reinterpret_cast<std::uintptr_t>(e.p) & 0x001fffffU) >> 1U;
+  auto mag = thicknessFromMagnitude(e.w);
+  auto color = colorFromPhase(e.w);
+  os << "root->";
+  if (e.isTerminal()) {
+    os << "t";
+  } else {
+    os << toplabel;
+  }
+  os << "[penwidth=\"" << mag << "\",tooltip=\"" << e.w.toString(false, 4)
+     << "\" color=\"" << color << "\"";
+  if (edgeLabels) {
+    os << ",label=<<font point-size=\"8\">&nbsp;[";
+    if (e.w == Complex::zero) {
+      os << "0";
+    } else if (e.w == Complex::one) {
+      os << "1";
+    } else {
+      if (e.w.r == &ComplexTable<>::zero) {
+        os << "0";
+      } else if (e.w.r == &ComplexTable<>::sqrt2_2) {
+        os << "\xe2\x88\x9a\xc2\xbd";
+      } else if (e.w.r == &ComplexTable<>::one) {
+        os << "1";
+      } else {
+        os << std::hex << reinterpret_cast<std::uintptr_t>(e.w.r) << std::dec;
+      }
+      os << " ";
+      if (e.w.i == &ComplexTable<>::zero) {
+        os << "0";
+      } else if (e.w.i == &ComplexTable<>::sqrt2_2) {
+        os << "\xe2\x88\x9a\xc2\xbd";
+      } else if (e.w.i == &ComplexTable<>::one) {
+        os << "1";
+      } else {
+        os << std::hex << reinterpret_cast<std::uintptr_t>(e.w.i) << std::dec;
+      }
+    }
+    os << "]</font>>";
+  }
+  os << "]\n";
+  return os;
+}
+
+[[maybe_unused]] static std::ostream&
+modernNode(const mEdge& e, std::ostream& os, bool formatAsPolar = true) {
+  auto nodelabel = (reinterpret_cast<std::uintptr_t>(e.p) & 0x001fffffU) >>
+                   1U; // this allows for 2^20 (roughly 1e6) unique nodes
+  os << nodelabel << "[label=<";
+  os << R"(<font point-size="10"><table border="1" cellspacing="0" cellpadding="2" style="rounded">)";
+  os << R"(<tr><td colspan="2" rowspan="2" port="0" href="javascript:;" border="0" tooltip=")"
+     << conditionalFormat(e.p->e[0].w, formatAsPolar) << "\">"
+     << (e.p->e[0].w.approximatelyZero()
+             ? "&nbsp;0 "
+             : "<font color=\"white\">&nbsp;0 </font>")
+     << R"(</td><td sides="R"></td><td sides="L"></td>)"
+     << R"(<td colspan="2" rowspan="2" port="1" href="javascript:;" border="0" tooltip=")"
+     << conditionalFormat(e.p->e[1].w, formatAsPolar) << "\">"
+     << (e.p->e[1].w.approximatelyZero()
+             ? "&nbsp;0 "
+             : "<font color=\"white\">&nbsp;0 </font>")
+     << R"(</td></tr>)";
+  os << R"(<tr><td sides="R"></td><td sides="L"></td></tr>)";
+  os << R"(<tr><td colspan="2" sides="B"></td><td colspan="2" rowspan="2" border="0"><font point-size="24">q<sub><font point-size="16">)"
+     << static_cast<std::size_t>(e.p->v)
+     << R"(</font></sub></font></td><td colspan="2" sides="B"></td></tr>)";
+  os << R"(<tr><td sides="T" colspan="2"></td><td sides="T" colspan="2"></td></tr>)";
+  os << R"(<tr><td colspan="2" rowspan="2" port="2" href="javascript:;" border="0" tooltip=")"
+     << conditionalFormat(e.p->e[2].w, formatAsPolar) << "\">"
+     << (e.p->e[2].w.approximatelyZero()
+             ? "&nbsp;0 "
+             : "<font color=\"white\">&nbsp;0 </font>")
+     << R"(</td><td sides="R"></td><td sides="L"></td>)"
+     << R"(<td colspan="2" rowspan="2" port="3" href="javascript:;" border="0" tooltip=")"
+     << conditionalFormat(e.p->e[3].w, formatAsPolar) << "\">"
+     << (e.p->e[3].w.approximatelyZero()
+             ? "&nbsp;0 "
+             : "<font color=\"white\">&nbsp;0 </font>")
+     << "</td></tr>";
+  os << R"(<tr><td sides="R"></td><td sides="L"></td></tr>)";
+  os << "</table></font>>,tooltip=\"q" << static_cast<std::size_t>(e.p->v)
+     << "\"]\n";
+  return os;
+}
+[[maybe_unused]] static std::ostream&
+modernNode(const vEdge& e, std::ostream& os, bool formatAsPolar = true) {
+  auto nodelabel = (reinterpret_cast<std::uintptr_t>(e.p) & 0x001fffffU) >>
+                   1U; // this allows for 2^20 (roughly 1e6) unique nodes
+  os << nodelabel << "[label=<";
+  os << R"(<font point-size="8"><table border="1" cellspacing="0" cellpadding="0" style="rounded">)";
+  os << R"(<tr><td colspan="2" border="0" cellpadding="1"><font point-size="20">q<sub><font point-size="12">)"
+     << static_cast<std::size_t>(e.p->v)
+     << R"(</font></sub></font></td></tr><tr>)";
+  os << R"(<td height="6" width="14" port="0" tooltip=")"
+     << conditionalFormat(e.p->e[0].w, formatAsPolar)
+     << R"(" href="javascript:;" sides="RT">)"
+     << (e.p->e[0].w.approximatelyZero()
+             ? "&nbsp;0 "
+             : R"(<font color="white">&nbsp;0 </font>)")
+     << "</td>";
+  os << R"(<td height="6" width="14" port="1" tooltip=")"
+     << conditionalFormat(e.p->e[1].w, formatAsPolar)
+     << R"(" href="javascript:;" sides="LT">)"
+     << (e.p->e[1].w.approximatelyZero()
+             ? "&nbsp;0 "
+             : R"(<font color="white">&nbsp;0 </font>)")
+     << "</td>";
+  os << "</tr></table></font>>,tooltip=\"q" << static_cast<std::size_t>(e.p->v)
+     << "\"]\n";
+  return os;
+}
+[[maybe_unused]] static std::ostream&
+classicNode(const mEdge& e, std::ostream& os, bool formatAsPolar = true) {
+  auto nodelabel = (reinterpret_cast<std::uintptr_t>(e.p) & 0x001fffffU) >>
+                   1U; // this allows for 2^20 (roughly 1e6) unique nodes
+  os << nodelabel << "[shape=circle, width=0.53, fixedsize=true, label=<";
+  os << R"(<font point-size="6"><table border="0" cellspacing="0" cellpadding="0">)";
+  os << R"(<tr><td colspan="4"><font point-size="18">q<sub><font point-size="10">)"
+     << static_cast<std::size_t>(e.p->v)
+     << R"(</font></sub></font></td></tr><tr>)";
+  os << R"(<td port="0" tooltip=")"
+     << conditionalFormat(e.p->e[0].w, formatAsPolar)
+     << R"(" href="javascript:;">)";
+  if (e.p->e[0].w.approximatelyZero()) {
+    os << R"(<font point-size="8">&nbsp;0 </font>)";
+  } else {
+    os << R"(<font color="white">&nbsp;0 </font>)";
+  }
+  os << "</td>";
+  os << "<td></td><td></td>";
+  os << R"(<td port="3" tooltip=")"
+     << conditionalFormat(e.p->e[3].w, formatAsPolar)
+     << R"(" href="javascript:;">)";
+  if (e.p->e[3].w.approximatelyZero()) {
+    os << R"(<font point-size="8">&nbsp;0 </font>)";
+  } else {
+    os << R"(<font color="white">&nbsp;0 </font>)";
+  }
+  os << "</td>";
+  os << "</tr><tr><td></td>";
+  os << R"(<td port="1" tooltip=")"
+     << conditionalFormat(e.p->e[1].w, formatAsPolar)
+     << R"(" href="javascript:;">)";
+  if (e.p->e[1].w.approximatelyZero()) {
+    os << R"(<font point-size="8">&nbsp;0 </font>)";
+  } else {
+    os << R"(<font color="white">&nbsp;0 </font>)";
+  }
+  os << "</td>";
+  os << R"(<td port="2" tooltip=")"
+     << conditionalFormat(e.p->e[2].w, formatAsPolar)
+     << R"(" href="javascript:;">)";
+  if (e.p->e[2].w.approximatelyZero()) {
+    os << R"(<font point-size="8">&nbsp;0 </font>)";
+  } else {
+    os << R"(<font color="white">&nbsp;0 </font>)";
+  }
+  os << "</td>";
+  os << "<td></td></tr></table></font>>,tooltip=\"q"
+     << static_cast<std::size_t>(e.p->v) << "\"]\n";
+  return os;
+}
+[[maybe_unused]] static std::ostream&
+classicNode(const vEdge& e, std::ostream& os, bool formatAsPolar = true) {
+  auto nodelabel = (reinterpret_cast<std::uintptr_t>(e.p) & 0x001fffffU) >>
+                   1U; // this allows for 2^20 (roughly 1e6) unique nodes
+  os << nodelabel << "[shape=circle, width=0.46, fixedsize=true, label=<";
+  os << R"(<font point-size="6"><table border="0" cellspacing="0" cellpadding="0">)";
+  os << R"(<tr><td colspan="2"><font point-size="18">q<sub><font point-size="10">)"
+     << static_cast<std::size_t>(e.p->v)
+     << R"(</font></sub></font></td></tr><tr>)";
+  os << R"(<td port="0" tooltip=")"
+     << conditionalFormat(e.p->e[0].w, formatAsPolar)
+     << R"(" href="javascript:;">)";
+  if (e.p->e[0].w.approximatelyZero()) {
+    os << R"(<font point-size="10">&nbsp;0 </font>)";
+  } else {
+    os << R"(<font color="white">&nbsp;0 </font>)";
+  }
+  os << "</td>";
+  os << R"(<td port="1" tooltip=")"
+     << conditionalFormat(e.p->e[1].w, formatAsPolar)
+     << R"(" href="javascript:;">)";
+  if (e.p->e[1].w.approximatelyZero()) {
+    os << R"(<font point-size="10">&nbsp;0 </font>)";
+  } else {
+    os << R"(<font color="white">&nbsp;0 </font>)";
+  }
+  os << "</td>";
+  os << "</tr></table></font>>,tooltip=\"q" << static_cast<std::size_t>(e.p->v)
+     << "\"]\n";
+  return os;
+}
+template <class Edge>
+static std::ostream& memoryNode(const Edge& e, std::ostream& os) {
+  constexpr std::size_t n = std::tuple_size_v<decltype(e.p->e)>;
+  auto nodelabel = (reinterpret_cast<std::uintptr_t>(e.p) & 0x001fffffU) >>
+                   1U; // this allows for 2^20 (roughly 1e6) unique nodes
+  os << nodelabel << "[label=<";
+  os << R"(<font point-size="10"><table border="1" cellspacing="0" cellpadding="2" style="rounded">)";
+  os << R"(<tr><td colspan=")" << n << R"(" border="1" sides="B">)" << std::hex
+     << reinterpret_cast<std::uintptr_t>(e.p) << std::dec
+     << " ref: " << e.p->ref << "</td></tr>";
+  os << "<tr>";
+  for (std::size_t i = 0; i < n; ++i) {
+    os << "<td port=\"" << i << R"(" href="javascript:;" border="0" tooltip=")"
+       << e.p->e[i].w.toString(false, 4) << "\">";
+    if (e.p->e[i] == Edge::zero) {
+      os << "&nbsp;0 "
+            "";
+    } else {
+      os << "<font color=\"white\">&nbsp;0 </font>";
+    }
+    os << "</td>";
+  }
+  os << "</tr>";
+  os << "</table></font>>,tooltip=\"" << std::hex
+     << reinterpret_cast<std::uintptr_t>(e.p) << "\"]\n"
+     << std::dec;
+  return os;
+}
+
+[[maybe_unused]] static std::ostream&
+bwEdge(const mEdge& from, const mEdge& to, std::uint16_t idx, std::ostream& os,
+       bool edgeLabels = false, bool classic = false,
+       bool formatAsPolar = true) {
+  auto fromlabel =
+      (reinterpret_cast<std::uintptr_t>(from.p) & 0x001fffffU) >> 1U;
+  auto tolabel = (reinterpret_cast<std::uintptr_t>(to.p) & 0x001fffffU) >> 1U;
+
+  os << fromlabel << ":" << idx << ":";
+  if (classic) {
+    if (idx == 0) {
+      os << "sw";
+    } else if (idx == 1 || idx == 2) {
+      os << "s";
+    } else {
+      os << "se";
+    }
+  } else {
+    if (idx == 0) {
+      os << "sw";
+    } else if (idx == 1) {
+      os << "se";
+    } else {
+      os << 's';
+    }
+  }
+  os << "->";
+  if (to.isTerminal()) {
+    os << "t";
+  } else {
+    os << tolabel;
+  }
+
+  auto mag = thicknessFromMagnitude(to.w);
+  os << "[penwidth=\"" << mag << "\",tooltip=\""
+     << conditionalFormat(to.w, formatAsPolar) << "\"";
+  if (!to.w.approximatelyOne()) {
+    os << ",style=dashed";
+  }
+  if (edgeLabels) {
+    os << ",label=<<font point-size=\"8\">&nbsp;"
+       << conditionalFormat(to.w, formatAsPolar) << "</font>>";
+  }
+  os << "]\n";
+
+  return os;
+}
+[[maybe_unused]] static std::ostream&
+bwEdge(const vEdge& from, const vEdge& to, std::uint16_t idx, std::ostream& os,
+       bool edgeLabels = false, [[maybe_unused]] bool classic = false,
+       bool formatAsPolar = true) {
+  auto fromlabel =
+      (reinterpret_cast<std::uintptr_t>(from.p) & 0x001fffffU) >> 1U;
+  auto tolabel = (reinterpret_cast<std::uintptr_t>(to.p) & 0x001fffffU) >> 1U;
+
+  os << fromlabel << ":" << idx << ":";
+  os << (idx == 0 ? "sw" : "se") << "->";
+  if (to.isTerminal()) {
+    os << "t";
+  } else {
+    os << tolabel;
+  }
+
+  auto mag = thicknessFromMagnitude(to.w);
+  os << "[penwidth=\"" << mag << "\",tooltip=\""
+     << conditionalFormat(to.w, formatAsPolar) << "\"";
+  if (!to.w.approximatelyOne()) {
+    os << ",style=dashed";
+  }
+  if (edgeLabels) {
+    os << ",label=<<font point-size=\"8\">&nbsp;"
+       << conditionalFormat(to.w, formatAsPolar) << "</font>>";
+  }
+  os << "]\n";
+
+  return os;
+}
+[[maybe_unused]] static std::ostream&
+coloredEdge(const mEdge& from, const mEdge& to, std::uint16_t idx,
+            std::ostream& os, bool edgeLabels = false, bool classic = false,
+            bool formatAsPolar = true) {
+  auto fromlabel =
+      (reinterpret_cast<std::uintptr_t>(from.p) & 0x001fffffU) >> 1U;
+  auto tolabel = (reinterpret_cast<std::uintptr_t>(to.p) & 0x001fffffU) >> 1U;
+
+  os << fromlabel << ":" << idx << ":";
+  if (classic) {
+    if (idx == 0) {
+      os << "sw";
+    } else if (idx == 1 || idx == 2) {
+      os << "s";
+    } else {
+      os << "se";
+    }
+  } else {
+    if (idx == 0) {
+      os << "sw";
+    } else if (idx == 1) {
+      os << "se";
+    } else {
+      os << 's';
+    }
+  }
+  os << "->";
+  if (to.isTerminal()) {
+    os << "t";
+  } else {
+    os << tolabel;
+  }
+
+  auto mag = thicknessFromMagnitude(to.w);
+  auto color = colorFromPhase(to.w);
+  os << "[penwidth=\"" << mag << "\",tooltip=\""
+     << conditionalFormat(to.w, formatAsPolar) << "\" color=\"" << color
+     << "\"";
+  if (edgeLabels) {
+    os << ",label=<<font point-size=\"8\">&nbsp;"
+       << conditionalFormat(to.w, formatAsPolar) << "</font>>";
+  }
+  os << "]\n";
+
+  return os;
+}
+[[maybe_unused]] static std::ostream&
+coloredEdge(const vEdge& from, const vEdge& to, std::uint16_t idx,
+            std::ostream& os, bool edgeLabels = false,
+            [[maybe_unused]] bool classic = false, bool formatAsPolar = true) {
+  auto fromlabel =
+      (reinterpret_cast<std::uintptr_t>(from.p) & 0x001fffffU) >> 1U;
+  auto tolabel = (reinterpret_cast<std::uintptr_t>(to.p) & 0x001fffffU) >> 1U;
+
+  os << fromlabel << ":" << idx << ":";
+  os << (idx == 0 ? "sw" : "se") << "->";
+  if (to.isTerminal()) {
+    os << "t";
+  } else {
+    os << tolabel;
+  }
+
+  auto mag = thicknessFromMagnitude(to.w);
+  auto color = colorFromPhase(to.w);
+  os << "[penwidth=\"" << mag << "\",tooltip=\""
+     << conditionalFormat(to.w, formatAsPolar) << "\" color=\"" << color
+     << "\"";
+  if (edgeLabels) {
+    os << ",label=<<font point-size=\"8\">&nbsp;"
+       << conditionalFormat(to.w, formatAsPolar) << "</font>>";
+  }
+  os << "]\n";
+
+  return os;
+}
+template <class Edge>
+static std::ostream& memoryEdge(const Edge& from, const Edge& to,
+                                std::uint16_t idx, std::ostream& os,
+                                bool edgeLabels = false) {
+  auto fromlabel =
+      (reinterpret_cast<std::uintptr_t>(from.p) & 0x001fffffU) >> 1U;
+  auto tolabel = (reinterpret_cast<std::uintptr_t>(to.p) & 0x001fffffU) >> 1U;
+
+  os << fromlabel << ":" << idx << ":s->";
+  if (to.isTerminal()) {
+    os << "t";
+  } else {
+    os << tolabel;
+  }
+
+  auto mag = thicknessFromMagnitude(to.w);
+  auto color = colorFromPhase(to.w);
+  os << "[penwidth=\"" << mag << "\",tooltip=\"" << to.w.toString(false, 4)
+     << "\" color=\"" << color << "\"";
+  if (edgeLabels) {
+    os << ",label=<<font point-size=\"8\">&nbsp;[";
+    if (to.w == Complex::one) {
+      os << "1";
+    } else {
+      if (to.w.r == &ComplexTable<>::zero) {
+        os << "0";
+      } else if (to.w.r == &ComplexTable<>::sqrt2_2) {
+        os << "\xe2\x88\x9a\xc2\xbd";
+      } else if (to.w.r == &ComplexTable<>::one) {
+        os << "1";
+      } else {
+        os << std::hex << reinterpret_cast<std::uintptr_t>(to.w.r) << std::dec;
+      }
+      os << " ";
+      if (to.w.i == &ComplexTable<>::zero) {
+        os << "0";
+      } else if (to.w.i == &ComplexTable<>::sqrt2_2) {
+        os << "\xe2\x88\x9a\xc2\xbd";
+      } else if (to.w.i == &ComplexTable<>::one) {
+        os << "1";
+      } else {
+        os << std::hex << reinterpret_cast<std::uintptr_t>(to.w.i) << std::dec;
+      }
+    }
+    os << "]</font>>";
+  }
+  os << "]\n";
+
+  return os;
+}
+
+template <class Edge>
+static void toDot(const Edge& e, std::ostream& os, bool colored = true,
+                  bool edgeLabels = false, bool classic = false,
+                  bool memory = false, bool formatAsPolar = true) {
+  std::ostringstream oss{};
+  // header, root and terminal declaration
+
+  if (memory) {
+    memoryHeader(e, oss, edgeLabels);
+  } else if (colored) {
+    coloredHeader(e, oss, edgeLabels, formatAsPolar);
+  } else {
+    header(e, oss, edgeLabels, formatAsPolar);
+  }
+
+  std::unordered_set<decltype(e.p)> nodes{};
+
+  auto priocmp = [](const Edge* left, const Edge* right) {
+    return left->p->v < right->p->v;
+  };
+
+  std::priority_queue<const Edge*, std::vector<const Edge*>, decltype(priocmp)>
+      q(priocmp);
+  q.push(&e);
+
+  // bfs until finished
+  while (!q.empty()) {
+    auto node = q.top();
+    q.pop();
+
+    // base case
+    if (node->isTerminal()) {
+      continue;
+    }
+
+    // check if node has already been processed
+    auto ret = nodes.emplace(node->p);
+    if (!ret.second) {
+      continue;
+    }
+
+    // node definition as HTML-like label (href="javascript:;" is used as
+    // workaround to make tooltips work)
+    if (memory) {
+      memoryNode(*node, oss);
+    } else if (classic) {
+      classicNode(*node, oss, formatAsPolar);
+    } else {
+      modernNode(*node, oss, formatAsPolar);
+    }
+
+    // iterate over edges in reverse to guarantee correct proceossing order
+    for (auto i = static_cast<std::int16_t>(node->p->e.size() - 1); i >= 0;
+         --i) {
+      auto& edge = node->p->e[static_cast<std::size_t>(i)];
+      if ((!memory && edge.w.approximatelyZero()) || edge.w == Complex::zero) {
+        // potentially add zero stubs here
+        continue;
+      }
+
+      // non-zero edge to be included
+      q.push(&edge);
+
+      if (memory) {
+        memoryEdge(*node, edge, static_cast<std::uint16_t>(i), oss, edgeLabels);
+      } else if (colored) {
+        coloredEdge(*node, edge, static_cast<std::uint16_t>(i), oss, edgeLabels,
+                    classic, formatAsPolar);
+      } else {
+        bwEdge(*node, edge, static_cast<std::uint16_t>(i), oss, edgeLabels,
+               classic, formatAsPolar);
+      }
+    }
+  }
+  oss << "}\n";
+
+  os << oss.str() << std::flush;
+}
+
+template <class Edge>
+[[maybe_unused]] static void
+export2Dot(Edge basic, const std::string& outputFilename, bool colored = true,
+           bool edgeLabels = false, bool classic = false, bool memory = false,
+           bool show = true, bool formatAsPolar = true) {
+  std::ofstream init(outputFilename);
+  toDot(basic, init, colored, edgeLabels, classic, memory, formatAsPolar);
+  init.close();
+
+  if (show) {
+    std::ostringstream oss;
+    oss << "dot -Tsvg " << outputFilename << " -o "
+        << outputFilename.substr(0, outputFilename.find_last_of('.')) << ".svg";
+    const auto str =
+        oss.str(); // required to avoid immediate deallocation of temporary
+    std::system(str.c_str());
+  }
+}
+
+///
+/// Serialization
+/// Note: do not rely on the binary format being portable across different
+/// architectures/platforms
+///
+
+[[maybe_unused]] static void serialize(const vEdge& basic, std::ostream& os,
+                                       bool writeBinary = false) {
+  if (writeBinary) {
+    os.write(reinterpret_cast<const char*>(&SERIALIZATION_VERSION),
+             sizeof(decltype(SERIALIZATION_VERSION)));
+    basic.w.writeBinary(os);
+  } else {
+    os << SERIALIZATION_VERSION << "\n";
+    os << basic.w.toString(false, 16) << "\n";
+  }
+  std::int64_t nextIndex = 0;
+  std::unordered_map<vNode*, std::int64_t> nodeIndex{};
+
+  // POST ORDER TRAVERSAL USING ONE STACK
+  // https://www.geeksforgeeks.org/iterative-postorder-traversal-using-stack/
+  std::stack<const vEdge*> stack{};
+
+  const auto* node = &basic;
+  if (!node->isTerminal()) {
+    // NOLINTNEXTLINE(cppcoreguidelines-avoid-do-while)
+    do {
+      while (node != nullptr && !node->isTerminal()) {
+        for (auto i = static_cast<std::size_t>(RADIX - 1); i > 0; --i) {
+          auto& edge = node->p->e.at(i);
+          if (edge.isTerminal()) {
+            continue;
+          }
+          if (edge.w.approximatelyZero()) {
+            continue;
+          }
+          if (nodeIndex.find(edge.p) != nodeIndex.end()) {
+            continue;
+          }
+
+          // non-zero edge to be included
+          stack.push(&edge);
+        }
+        stack.push(node);
+        node = &node->p->e[0]; // NOLINT(readability-container-data-pointer)
+      }
+      node = stack.top();
+      stack.pop();
+
+      bool hasChild = false;
+      for (auto i = 1U; i < RADIX && !hasChild; ++i) {
+        auto& edge = node->p->e.at(i);
+        if (edge.w.approximatelyZero()) {
+          continue;
+        }
+        if (nodeIndex.find(edge.p) != nodeIndex.end()) {
+          continue;
+        }
+        if (!stack.empty()) {
+          hasChild = edge.p == stack.top()->p;
+        }
+      }
+
+      if (hasChild) {
+        const auto* const temp = stack.top();
+        stack.pop();
+        stack.push(node);
+        node = temp;
+      } else {
+        if (nodeIndex.find(node->p) != nodeIndex.end()) {
+          node = nullptr;
+          continue;
         }
-        os << "]\n";
+        nodeIndex[node->p] = nextIndex;
+        nextIndex++;
 
-        return os;
-    }
-
-    template<class Edge>
-    static void toDot(const Edge& e, std::ostream& os, bool colored = true, bool edgeLabels = false, bool classic = false, bool memory = false, bool formatAsPolar = true) {
-        std::ostringstream oss{};
-        // header, root and terminal declaration
-
-        if (memory) {
-            memoryHeader(e, oss, edgeLabels);
-        } else if (colored) {
-            coloredHeader(e, oss, edgeLabels, formatAsPolar);
-        } else {
-            header(e, oss, edgeLabels, formatAsPolar);
-        }
-
-        std::unordered_set<decltype(e.p)> nodes{};
-
-        auto priocmp = [](const Edge* left, const Edge* right) { return left->p->v < right->p->v; };
-
-        std::priority_queue<const Edge*, std::vector<const Edge*>, decltype(priocmp)> q(priocmp);
-        q.push(&e);
-
-        // bfs until finished
-        while (!q.empty()) {
-            auto node = q.top();
-            q.pop();
-
-            // base case
-            if (node->isTerminal()) {
-                continue;
-            }
-
-            // check if node has already been processed
-            auto ret = nodes.emplace(node->p);
-            if (!ret.second) {
-                continue;
-            }
-
-            // node definition as HTML-like label (href="javascript:;" is used as workaround to make tooltips work)
-            if (memory) {
-                memoryNode(*node, oss);
-            } else if (classic) {
-                classicNode(*node, oss, formatAsPolar);
-            } else {
-                modernNode(*node, oss, formatAsPolar);
-            }
-
-            // iterate over edges in reverse to guarantee correct proceossing order
-            for (auto i = static_cast<std::int16_t>(node->p->e.size() - 1); i >= 0; --i) {
-                auto& edge = node->p->e[static_cast<std::size_t>(i)];
-                if ((!memory && edge.w.approximatelyZero()) || edge.w == Complex::zero) {
-                    // potentially add zero stubs here
-                    continue;
-                }
-
-                // non-zero edge to be included
-                q.push(&edge);
-
-                if (memory) {
-                    memoryEdge(*node, edge, static_cast<std::uint16_t>(i), oss, edgeLabels);
-                } else if (colored) {
-                    coloredEdge(*node, edge, static_cast<std::uint16_t>(i), oss, edgeLabels, classic, formatAsPolar);
-                } else {
-                    bwEdge(*node, edge, static_cast<std::uint16_t>(i), oss, edgeLabels, classic, formatAsPolar);
-                }
-            }
-        }
-        oss << "}\n";
-
-        os << oss.str() << std::flush;
-    }
-
-    template<class Edge>
-    [[maybe_unused]] static void export2Dot(Edge basic, const std::string& outputFilename, bool colored = true, bool edgeLabels = false, bool classic = false, bool memory = false, bool show = true, bool formatAsPolar = true) {
-        std::ofstream init(outputFilename);
-        toDot(basic, init, colored, edgeLabels, classic, memory, formatAsPolar);
-        init.close();
-
-        if (show) {
-            std::ostringstream oss;
-            oss << "dot -Tsvg " << outputFilename << " -o " << outputFilename.substr(0, outputFilename.find_last_of('.')) << ".svg";
-            auto                  str = oss.str(); // required to avoid immediate deallocation of temporary
-            [[maybe_unused]] auto rc  = std::system(str.c_str());
-        }
-    }
-
-    ///
-    /// Serialization
-    /// Note: do not rely on the binary format being portable across different architectures/platforms
-    ///
-
-    [[maybe_unused]] static void serialize(const vEdge& basic, std::ostream& os, bool writeBinary = false) {
-        if (writeBinary) {
-            os.write(reinterpret_cast<const char*>(&SERIALIZATION_VERSION), sizeof(decltype(SERIALIZATION_VERSION)));
-            basic.w.writeBinary(os);
-        } else {
-            os << SERIALIZATION_VERSION << "\n";
-            os << basic.w.toString(false, 16) << "\n";
-        }
-        std::int64_t                             nextIndex = 0;
-        std::unordered_map<vNode*, std::int64_t> nodeIndex{};
-
-        // POST ORDER TRAVERSAL USING ONE STACK   https://www.geeksforgeeks.org/iterative-postorder-traversal-using-stack/
-        std::stack<const vEdge*> stack{};
-
-        const auto* node = &basic;
-        if (!node->isTerminal()) {
-            do {
-                while (node != nullptr && !node->isTerminal()) {
-                    for (auto i = static_cast<std::size_t>(RADIX - 1); i > 0; --i) {
-                        auto& edge = node->p->e.at(i);
-                        if (edge.isTerminal()) {
-                            continue;
-                        }
-                        if (edge.w.approximatelyZero()) {
-                            continue;
-                        }
-                        if (nodeIndex.find(edge.p) != nodeIndex.end()) {
-                            continue;
-                        }
-
-                        // non-zero edge to be included
-                        stack.push(&edge);
-                    }
-                    stack.push(node);
-                    node = &node->p->e[0]; // NOLINT(readability-container-data-pointer)
-                }
-                node = stack.top();
-                stack.pop();
-
-                bool hasChild = false;
-                for (auto i = 1U; i < RADIX && !hasChild; ++i) {
-                    auto& edge = node->p->e.at(i);
-                    if (edge.w.approximatelyZero()) {
-                        continue;
-                    }
-                    if (nodeIndex.find(edge.p) != nodeIndex.end()) {
-                        continue;
-                    }
-                    if (!stack.empty()) {
-                        hasChild = edge.p == stack.top()->p;
-                    }
-                }
-
-                if (hasChild) {
-                    const auto* const temp = stack.top();
-                    stack.pop();
-                    stack.push(node);
-                    node = temp;
-                } else {
-                    if (nodeIndex.find(node->p) != nodeIndex.end()) {
-                        node = nullptr;
-                        continue;
-                    }
-                    nodeIndex[node->p] = nextIndex;
-                    nextIndex++;
-
-                    if (writeBinary) {
-                        os.write(reinterpret_cast<const char*>(&nodeIndex[node->p]), sizeof(decltype(nodeIndex[node->p])));
-                        os.write(reinterpret_cast<const char*>(&node->p->v), sizeof(decltype(node->p->v)));
-
-                        // iterate over edges in reverse to guarantee correct processing order
-                        for (auto i = 0U; i < RADIX; ++i) {
-                            auto&        edge    = node->p->e.at(i);
-                            std::int64_t edgeIdx = edge.isTerminal() ? -1 : nodeIndex[edge.p];
-                            os.write(reinterpret_cast<const char*>(&edgeIdx), sizeof(decltype(edgeIdx)));
-                            edge.w.writeBinary(os);
-                        }
-                    } else {
-                        os << nodeIndex[node->p] << " " << static_cast<std::size_t>(node->p->v);
-
-                        // iterate over edges in reverse to guarantee correct processing order
-                        for (auto i = 0U; i < RADIX; ++i) {
-                            os << " (";
-                            auto& edge = node->p->e.at(i);
-                            if (!edge.w.approximatelyZero()) {
-                                const std::int64_t edgeIdx = edge.isTerminal() ? -1 : nodeIndex[edge.p];
-                                os << edgeIdx << " " << edge.w.toString(false, 16);
-                            }
-                            os << ")";
-                        }
-                        os << "\n";
-                    }
-                    node = nullptr;
-                }
-            } while (!stack.empty());
-        }
-    }
-
-    static void serializeMatrix(const mEdge& basic, std::int64_t& idx, std::unordered_map<mNode*, std::int64_t>& nodeIndex, std::unordered_set<mNode*>& visited, std::ostream& os, bool writeBinary = false) {
-        if (!basic.isTerminal()) {
-            for (auto& e: basic.p->e) {
-                if (auto [iter, success] = visited.insert(e.p); success) {
-                    serializeMatrix(e, idx, nodeIndex, visited, os, writeBinary);
-                }
-            }
-
-            if (nodeIndex.find(basic.p) == nodeIndex.end()) {
-                nodeIndex[basic.p] = idx;
-                ++idx;
-            }
-
-            if (writeBinary) {
-                os.write(reinterpret_cast<const char*>(&nodeIndex[basic.p]), sizeof(decltype(nodeIndex[basic.p])));
-                os.write(reinterpret_cast<const char*>(&basic.p->v), sizeof(decltype(basic.p->v)));
-
-                // iterate over edges in reverse to guarantee correct processing order
-                for (auto& edge: basic.p->e) {
-                    std::int64_t edgeIdx = edge.isTerminal() ? -1 : nodeIndex[edge.p];
-                    os.write(reinterpret_cast<const char*>(&edgeIdx), sizeof(decltype(edgeIdx)));
-                    edge.w.writeBinary(os);
-                }
-            } else {
-                os << nodeIndex[basic.p] << " " << static_cast<std::size_t>(basic.p->v);
-
-                // iterate over edges in reverse to guarantee correct processing order
-                for (auto& edge: basic.p->e) {
-                    os << " (";
-                    if (!edge.w.approximatelyZero()) {
-                        const std::int64_t edgeIdx = edge.isTerminal() ? -1 : nodeIndex[edge.p];
-                        os << edgeIdx << " " << edge.w.toString(false, 16);
-                    }
-                    os << ")";
-                }
-                os << "\n";
-            }
-        }
-    }
-    [[maybe_unused]] static void serialize(const mEdge& basic, std::ostream& os, bool writeBinary = false) {
         if (writeBinary) {
-            os.write(reinterpret_cast<const char*>(&SERIALIZATION_VERSION), sizeof(decltype(SERIALIZATION_VERSION)));
-            basic.w.writeBinary(os);
-        } else {
-            os << SERIALIZATION_VERSION << "\n";
-            os << basic.w.toString(false, std::numeric_limits<dd::fp>::max_digits10) << "\n";
-        }
-        std::int64_t                             idx = 0;
-        std::unordered_map<mNode*, std::int64_t> nodeIndex{};
-        std::unordered_set<mNode*>               visited{};
-        serializeMatrix(basic, idx, nodeIndex, visited, os, writeBinary);
-    }
-    template<class Edge>
-    static void serialize(const Edge& basic, const std::string& outputFilename, bool writeBinary = false) {
-        std::ofstream ofs = std::ofstream(outputFilename, std::ios::binary);
-
-        if (!ofs.good()) {
-            throw std::invalid_argument("Cannot open file: " + outputFilename);
-        }
-
-        serialize(basic, ofs, writeBinary);
-    }
-
-    template<typename Edge>
-    static void exportEdgeWeights(const Edge& edge, std::ostream& stream) {
-        struct Priocmp {
-            bool operator()(const Edge* left, const Edge* right) {
-                return left->p->v < right->p->v;
-            }
-        };
-        stream << std::showpos << CTEntry::val(edge.w.r) << CTEntry::val(edge.w.i) << std::noshowpos << "i\n";
-
-        std::unordered_set<decltype(edge.p)> nodes{};
-
-        std::priority_queue<const Edge*, std::vector<const Edge*>, Priocmp> q;
-        q.push(&edge);
-
-        // bfs until finished
-        while (!q.empty()) {
-            auto edgePtr = q.top();
-            q.pop();
-
-            // base case
-            if (edgePtr->isTerminal()) {
-                continue;
-            }
-
-            // check if edgePtr has already been processed
-            if (auto ret = nodes.emplace(edgePtr->p); !ret.second) {
-                continue;
-            }
-
-            // iterate over edges in reverse to guarantee correct proceossing order
-            for (auto i = static_cast<std::int16_t>(edgePtr->p->e.size() - 1); i >= 0; --i) {
-                auto& child = edgePtr->p->e[static_cast<std::size_t>(i)];
-                if (child.w.approximatelyZero()) {
-                    // potentially add zero stubs here
-                    continue;
-                }
-
-                // non-zero child to be included
-                q.push(&child);
-                stream << std::showpos << CTEntry::val(child.w.r) << CTEntry::val(child.w.i) << std::noshowpos << "i\n";
-            }
-        }
+          os.write(reinterpret_cast<const char*>(&nodeIndex[node->p]),
+                   sizeof(decltype(nodeIndex[node->p])));
+          os.write(reinterpret_cast<const char*>(&node->p->v),
+                   sizeof(decltype(node->p->v)));
+
+          // iterate over edges in reverse to guarantee correct processing order
+          for (auto i = 0U; i < RADIX; ++i) {
+            auto& edge = node->p->e.at(i);
+            std::int64_t edgeIdx = edge.isTerminal() ? -1 : nodeIndex[edge.p];
+            os.write(reinterpret_cast<const char*>(&edgeIdx),
+                     sizeof(decltype(edgeIdx)));
+            edge.w.writeBinary(os);
+          }
+        } else {
+          os << nodeIndex[node->p] << " "
+             << static_cast<std::size_t>(node->p->v);
+
+          // iterate over edges in reverse to guarantee correct processing order
+          for (auto i = 0U; i < RADIX; ++i) {
+            os << " (";
+            auto& edge = node->p->e.at(i);
+            if (!edge.w.approximatelyZero()) {
+              const std::int64_t edgeIdx =
+                  edge.isTerminal() ? -1 : nodeIndex[edge.p];
+              os << edgeIdx << " " << edge.w.toString(false, 16);
+            }
+            os << ")";
+          }
+          os << "\n";
+        }
+        node = nullptr;
+      }
+    } while (!stack.empty());
+  }
+}
+
+static void serializeMatrix(const mEdge& basic, std::int64_t& idx,
+                            std::unordered_map<mNode*, std::int64_t>& nodeIndex,
+                            std::unordered_set<mNode*>& visited,
+                            std::ostream& os, bool writeBinary = false) {
+  if (!basic.isTerminal()) {
+    for (auto& e : basic.p->e) {
+      if (visited.insert(e.p).second) {
+        serializeMatrix(e, idx, nodeIndex, visited, os, writeBinary);
+      }
+    }
+
+    if (nodeIndex.find(basic.p) == nodeIndex.end()) {
+      nodeIndex[basic.p] = idx;
+      ++idx;
+    }
+
+    if (writeBinary) {
+      os.write(reinterpret_cast<const char*>(&nodeIndex[basic.p]),
+               sizeof(decltype(nodeIndex[basic.p])));
+      os.write(reinterpret_cast<const char*>(&basic.p->v),
+               sizeof(decltype(basic.p->v)));
+
+      // iterate over edges in reverse to guarantee correct processing order
+      for (auto& edge : basic.p->e) {
+        std::int64_t edgeIdx = edge.isTerminal() ? -1 : nodeIndex[edge.p];
+        os.write(reinterpret_cast<const char*>(&edgeIdx),
+                 sizeof(decltype(edgeIdx)));
+        edge.w.writeBinary(os);
+      }
+    } else {
+      os << nodeIndex[basic.p] << " " << static_cast<std::size_t>(basic.p->v);
+
+      // iterate over edges in reverse to guarantee correct processing order
+      for (auto& edge : basic.p->e) {
+        os << " (";
+        if (!edge.w.approximatelyZero()) {
+          const std::int64_t edgeIdx =
+              edge.isTerminal() ? -1 : nodeIndex[edge.p];
+          os << edgeIdx << " " << edge.w.toString(false, 16);
+        }
+        os << ")";
+      }
+      os << "\n";
+    }
+  }
+}
+[[maybe_unused]] static void serialize(const mEdge& basic, std::ostream& os,
+                                       bool writeBinary = false) {
+  if (writeBinary) {
+    os.write(reinterpret_cast<const char*>(&SERIALIZATION_VERSION),
+             sizeof(decltype(SERIALIZATION_VERSION)));
+    basic.w.writeBinary(os);
+  } else {
+    os << SERIALIZATION_VERSION << "\n";
+    os << basic.w.toString(false, std::numeric_limits<dd::fp>::max_digits10)
+       << "\n";
+  }
+  std::int64_t idx = 0;
+  std::unordered_map<mNode*, std::int64_t> nodeIndex{};
+  std::unordered_set<mNode*> visited{};
+  serializeMatrix(basic, idx, nodeIndex, visited, os, writeBinary);
+}
+template <class Edge>
+static void serialize(const Edge& basic, const std::string& outputFilename,
+                      bool writeBinary = false) {
+  std::ofstream ofs = std::ofstream(outputFilename, std::ios::binary);
+
+  if (!ofs.good()) {
+    throw std::invalid_argument("Cannot open file: " + outputFilename);
+  }
+
+  serialize(basic, ofs, writeBinary);
+}
+
+template <typename Edge>
+static void exportEdgeWeights(const Edge& edge, std::ostream& stream) {
+  struct Priocmp {
+    bool operator()(const Edge* left, const Edge* right) {
+      return left->p->v < right->p->v;
+    }
+  };
+  stream << std::showpos << CTEntry::val(edge.w.r) << CTEntry::val(edge.w.i)
+         << std::noshowpos << "i\n";
+
+  std::unordered_set<decltype(edge.p)> nodes{};
+
+  std::priority_queue<const Edge*, std::vector<const Edge*>, Priocmp> q;
+  q.push(&edge);
+
+  // bfs until finished
+  while (!q.empty()) {
+    auto edgePtr = q.top();
+    q.pop();
+
+    // base case
+    if (edgePtr->isTerminal()) {
+      continue;
+    }
+
+    // check if edgePtr has already been processed
+    if (auto ret = nodes.emplace(edgePtr->p); !ret.second) {
+      continue;
+    }
+
+    // iterate over edges in reverse to guarantee correct proceossing order
+    for (auto i = static_cast<std::int16_t>(edgePtr->p->e.size() - 1); i >= 0;
+         --i) {
+      auto& child = edgePtr->p->e[static_cast<std::size_t>(i)];
+      if (child.w.approximatelyZero()) {
+        // potentially add zero stubs here
+        continue;
+      }
+
+      // non-zero child to be included
+      q.push(&child);
+      stream << std::showpos << CTEntry::val(child.w.r)
+             << CTEntry::val(child.w.i) << std::noshowpos << "i\n";
     }
+  }
+}
 
 } // namespace dd
-
-#endif //DDexport_H
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/GateMatrixDefinitions.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/dd/GateMatrixDefinitions.hpp`

 * *Files 22% similar despite different names*

```diff
@@ -1,188 +1,228 @@
-/*
- * This file is part of the MQT DD Package which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum_dd/ for more information.
- */
-
-#ifndef DD_PACKAGE_GATEMATRIXDEFINITIONS_H
-#define DD_PACKAGE_GATEMATRIXDEFINITIONS_H
+#pragma once
 
 #include "ComplexValue.hpp"
 #include "Definitions.hpp"
 
 #include <array>
 #include <cmath>
 
 namespace dd {
-    // Complex constants
-    // NOLINTBEGIN(readability-identifier-naming) As these constants are used by other projects, we keep the naming
-    constexpr ComplexValue complex_one       = {1., 0.};
-    constexpr ComplexValue complex_mone      = {-1., 0.};
-    constexpr ComplexValue complex_zero      = {0., 0.};
-    constexpr ComplexValue complex_i         = {0., 1.};
-    constexpr ComplexValue complex_mi        = {0., -1.};
-    constexpr ComplexValue complex_SQRT2_2   = {SQRT2_2, 0.};
-    constexpr ComplexValue complex_mSQRT2_2  = {-SQRT2_2, 0.};
-    constexpr ComplexValue complex_iSQRT2_2  = {0., SQRT2_2};
-    constexpr ComplexValue complex_miSQRT2_2 = {0., -SQRT2_2};
-    constexpr ComplexValue complex_1plusi    = {SQRT2_2, SQRT2_2};
-    constexpr ComplexValue complex_1minusi   = {SQRT2_2, -SQRT2_2};
-    constexpr ComplexValue complex_1plusi_2  = {0.5, 0.5};
-    constexpr ComplexValue complex_1minusi_2 = {0.5, -0.5};
-
-    // Gate matrices
-    using GateMatrix = std::array<ComplexValue, NEDGE>;
-    constexpr GateMatrix Imat{complex_one, complex_zero, complex_zero, complex_one};
-    constexpr GateMatrix Hmat{complex_SQRT2_2, complex_SQRT2_2, complex_SQRT2_2, complex_mSQRT2_2};
-    constexpr GateMatrix Xmat{complex_zero, complex_one, complex_one, complex_zero};
-    constexpr GateMatrix Ymat{complex_zero, complex_mi, complex_i, complex_zero};
-    constexpr GateMatrix Zmat{complex_one, complex_zero, complex_zero, complex_mone};
-    constexpr GateMatrix Smat{complex_one, complex_zero, complex_zero, complex_i};
-    constexpr GateMatrix Sdagmat{complex_one, complex_zero, complex_zero, complex_mi};
-    constexpr GateMatrix Tmat{complex_one, complex_zero, complex_zero, complex_1plusi};
-    constexpr GateMatrix Tdagmat{complex_one, complex_zero, complex_zero, complex_1minusi};
-    constexpr GateMatrix SXmat{complex_1plusi_2, complex_1minusi_2, complex_1minusi_2, complex_1plusi_2};
-    constexpr GateMatrix SXdagmat{complex_1minusi_2, complex_1plusi_2, complex_1plusi_2, complex_1minusi_2};
-    constexpr GateMatrix Vmat{complex_SQRT2_2, complex_miSQRT2_2, complex_miSQRT2_2, complex_SQRT2_2};
-    constexpr GateMatrix Vdagmat{complex_SQRT2_2, complex_iSQRT2_2, complex_iSQRT2_2, complex_SQRT2_2};
-
-    inline GateMatrix U3mat(fp lambda, fp phi, fp theta) {
-        return GateMatrix{{{std::cos(theta / 2.), 0.},
-                           {-std::cos(lambda) * std::sin(theta / 2.), -std::sin(lambda) * std::sin(theta / 2.)},
-                           {std::cos(phi) * std::sin(theta / 2.), std::sin(phi) * std::sin(theta / 2.)},
-                           {std::cos(lambda + phi) * std::cos(theta / 2.), std::sin(lambda + phi) * std::cos(theta / 2.)}}};
-    }
-
-    inline GateMatrix U2mat(fp lambda, fp phi) {
-        return GateMatrix{complex_SQRT2_2,
-                          {-std::cos(lambda) * SQRT2_2, -std::sin(lambda) * SQRT2_2},
-                          {std::cos(phi) * SQRT2_2, std::sin(phi) * SQRT2_2},
-                          {std::cos(lambda + phi) * SQRT2_2, std::sin(lambda + phi) * SQRT2_2}};
-    }
-
-    inline GateMatrix Phasemat(fp lambda) {
-        return GateMatrix{complex_one, complex_zero, complex_zero, {std::cos(lambda), std::sin(lambda)}};
-    }
-
-    inline GateMatrix RXmat(fp lambda) {
-        return GateMatrix{{{std::cos(lambda / 2.), 0.},
-                           {0., -std::sin(lambda / 2.)},
-                           {0., -std::sin(lambda / 2.)},
-                           {std::cos(lambda / 2.), 0.}}};
-    }
-
-    inline GateMatrix RYmat(fp lambda) {
-        return GateMatrix{{{std::cos(lambda / 2.), 0.},
-                           {-std::sin(lambda / 2.), 0.},
-                           {std::sin(lambda / 2.), 0.},
-                           {std::cos(lambda / 2.), 0.}}};
-    }
-
-    inline GateMatrix RZmat(fp lambda) {
-        return GateMatrix{{{std::cos(lambda / 2.), -std::sin(lambda / 2.)},
-                           complex_zero,
-                           complex_zero,
-                           {std::cos(lambda / 2.), std::sin(lambda / 2.)}}};
-    }
-
-    using TwoQubitGateMatrix = std::array<std::array<ComplexValue, NEDGE>, NEDGE>;
-    constexpr TwoQubitGateMatrix CXmat{{{complex_one, complex_zero, complex_zero, complex_zero},
-                                        {complex_zero, complex_one, complex_zero, complex_zero},
-                                        {complex_zero, complex_zero, complex_zero, complex_one},
-                                        {complex_zero, complex_zero, complex_one, complex_zero}}};
-
-    constexpr TwoQubitGateMatrix CZmat{{{complex_one, complex_zero, complex_zero, complex_zero},
-                                        {complex_zero, complex_one, complex_zero, complex_zero},
-                                        {complex_zero, complex_zero, complex_one, complex_zero},
-                                        {complex_zero, complex_zero, complex_zero, complex_mone}}};
-
-    constexpr TwoQubitGateMatrix SWAPmat{{{complex_one, complex_zero, complex_zero, complex_zero},
-                                          {complex_zero, complex_zero, complex_one, complex_zero},
-                                          {complex_zero, complex_one, complex_zero, complex_zero},
-                                          {complex_zero, complex_zero, complex_zero, complex_one}}};
-
-    constexpr TwoQubitGateMatrix iSWAPmat{{{complex_one, complex_zero, complex_zero, complex_zero},
-                                           {complex_zero, complex_zero, complex_i, complex_zero},
-                                           {complex_zero, complex_i, complex_zero, complex_zero},
-                                           {complex_zero, complex_zero, complex_zero, complex_one}}};
-
-    constexpr TwoQubitGateMatrix iSWAPinvmat{{{complex_one, complex_zero, complex_zero, complex_zero},
-                                              {complex_zero, complex_zero, complex_mi, complex_zero},
-                                              {complex_zero, complex_mi, complex_zero, complex_zero},
-                                              {complex_zero, complex_zero, complex_zero, complex_one}}};
-
-    constexpr TwoQubitGateMatrix ECRmat{{{complex_zero, complex_zero, complex_SQRT2_2, complex_iSQRT2_2},
-                                         {complex_zero, complex_zero, complex_iSQRT2_2, complex_SQRT2_2},
-                                         {complex_SQRT2_2, complex_miSQRT2_2, complex_zero, complex_zero},
-                                         {complex_miSQRT2_2, complex_SQRT2_2, complex_zero, complex_zero}}};
-
-    constexpr TwoQubitGateMatrix DCXmat{{{complex_one, complex_zero, complex_zero, complex_zero},
-                                         {complex_zero, complex_zero, complex_zero, complex_one},
-                                         {complex_zero, complex_one, complex_zero, complex_zero},
-                                         {complex_zero, complex_zero, complex_one, complex_zero}}};
-
-    inline TwoQubitGateMatrix RXXmat(const fp theta) {
-        const auto cosTheta = std::cos(theta / 2.);
-        const auto sinTheta = std::sin(theta / 2.);
-
-        return TwoQubitGateMatrix{{{ComplexValue{cosTheta, 0.}, complex_zero, complex_zero, ComplexValue{0., -sinTheta}},
-                                   {complex_zero, ComplexValue{cosTheta, 0.}, ComplexValue{0., -sinTheta}, complex_zero},
-                                   {complex_zero, ComplexValue{0., -sinTheta}, ComplexValue{cosTheta, 0.}, complex_zero},
-                                   {ComplexValue{0., -sinTheta}, complex_zero, complex_zero, ComplexValue{cosTheta, 0.}}}};
-    }
-
-    inline TwoQubitGateMatrix RYYmat(const fp theta) {
-        const auto cosTheta = std::cos(theta / 2.);
-        const auto sinTheta = std::sin(theta / 2.);
-
-        return TwoQubitGateMatrix{{{ComplexValue{cosTheta, 0.}, complex_zero, complex_zero, ComplexValue{0., sinTheta}},
-                                   {complex_zero, ComplexValue{cosTheta, 0.}, ComplexValue{0., -sinTheta}, complex_zero},
-                                   {complex_zero, ComplexValue{0., -sinTheta}, ComplexValue{cosTheta, 0.}, complex_zero},
-                                   {ComplexValue{0., sinTheta}, complex_zero, complex_zero, ComplexValue{cosTheta, 0.}}}};
-    }
-
-    inline TwoQubitGateMatrix RZZmat(const fp theta) {
-        const auto cosTheta = std::cos(theta / 2.);
-        const auto sinTheta = std::sin(theta / 2.);
-
-        return TwoQubitGateMatrix{{{ComplexValue{cosTheta, -sinTheta}, complex_zero, complex_zero, complex_zero},
-                                   {complex_zero, ComplexValue{cosTheta, sinTheta}, complex_zero, complex_zero},
-                                   {complex_zero, complex_zero, ComplexValue{cosTheta, sinTheta}, complex_zero},
-                                   {complex_zero, complex_zero, complex_zero, ComplexValue{cosTheta, -sinTheta}}}};
-    }
-
-    inline TwoQubitGateMatrix RZXmat(const fp theta) {
-        const auto cosTheta = std::cos(theta / 2.);
-        const auto sinTheta = std::sin(theta / 2.);
-
-        return TwoQubitGateMatrix{{{ComplexValue{cosTheta, 0.}, ComplexValue{0., -sinTheta}, complex_zero, complex_zero},
-                                   {ComplexValue{0., -sinTheta}, ComplexValue{cosTheta, 0.}, complex_zero, complex_zero},
-                                   {complex_zero, complex_zero, ComplexValue{cosTheta, 0.}, ComplexValue{0., sinTheta}},
-                                   {complex_zero, complex_zero, ComplexValue{0., sinTheta}, ComplexValue{cosTheta, 0.}}}};
-    }
-
-    inline TwoQubitGateMatrix XXMinusYYmat(const fp theta, const fp beta = 0.) {
-        const auto cosTheta = std::cos(theta / 2.);
-        const auto sinTheta = std::sin(theta / 2.);
-        const auto cosBeta  = std::cos(beta);
-        const auto sinBeta  = std::sin(beta);
-
-        return TwoQubitGateMatrix{{{ComplexValue{cosTheta, 0.}, complex_zero, complex_zero, ComplexValue{sinBeta * sinTheta, -cosBeta * sinTheta}},
-                                   {complex_zero, complex_one, complex_zero, complex_zero},
-                                   {complex_zero, complex_zero, complex_one, complex_zero},
-                                   {ComplexValue{-sinBeta * sinTheta, -cosBeta * sinTheta}, complex_zero, complex_zero, ComplexValue{cosTheta, 0.}}}};
-    }
-
-    inline TwoQubitGateMatrix XXPlusYYmat(const fp theta, const fp beta = 0.) {
-        const auto cosTheta = std::cos(theta / 2.);
-        const auto sinTheta = std::sin(theta / 2.);
-        const auto cosBeta  = std::cos(beta);
-        const auto sinBeta  = std::sin(beta);
-
-        return TwoQubitGateMatrix{{{complex_one, complex_zero, complex_zero, complex_zero},
-                                   {complex_zero, ComplexValue{cosTheta, 0.}, ComplexValue{sinBeta * sinTheta, -cosBeta * sinTheta}, complex_zero},
-                                   {complex_zero, ComplexValue{-sinBeta * sinTheta, -cosBeta * sinTheta}, ComplexValue{cosTheta, 0.}, complex_zero},
-                                   {complex_zero, complex_zero, complex_zero, complex_one}}};
-    }
-    // NOLINTEND(readability-identifier-naming)
+// Complex constants
+// NOLINTBEGIN(readability-identifier-naming) As these constants are used by
+// other projects, we keep the naming
+constexpr ComplexValue complex_one = {1., 0.};
+constexpr ComplexValue complex_mone = {-1., 0.};
+constexpr ComplexValue complex_zero = {0., 0.};
+constexpr ComplexValue complex_i = {0., 1.};
+constexpr ComplexValue complex_mi = {0., -1.};
+constexpr ComplexValue complex_SQRT2_2 = {SQRT2_2, 0.};
+constexpr ComplexValue complex_mSQRT2_2 = {-SQRT2_2, 0.};
+constexpr ComplexValue complex_iSQRT2_2 = {0., SQRT2_2};
+constexpr ComplexValue complex_miSQRT2_2 = {0., -SQRT2_2};
+constexpr ComplexValue complex_1plusi = {SQRT2_2, SQRT2_2};
+constexpr ComplexValue complex_1minusi = {SQRT2_2, -SQRT2_2};
+constexpr ComplexValue complex_1plusi_2 = {0.5, 0.5};
+constexpr ComplexValue complex_1minusi_2 = {0.5, -0.5};
+
+// Gate matrices
+using GateMatrix = std::array<ComplexValue, NEDGE>;
+constexpr GateMatrix Imat{complex_one, complex_zero, complex_zero, complex_one};
+constexpr GateMatrix Hmat{complex_SQRT2_2, complex_SQRT2_2, complex_SQRT2_2,
+                          complex_mSQRT2_2};
+constexpr GateMatrix Xmat{complex_zero, complex_one, complex_one, complex_zero};
+constexpr GateMatrix Ymat{complex_zero, complex_mi, complex_i, complex_zero};
+constexpr GateMatrix Zmat{complex_one, complex_zero, complex_zero,
+                          complex_mone};
+constexpr GateMatrix Smat{complex_one, complex_zero, complex_zero, complex_i};
+constexpr GateMatrix Sdagmat{complex_one, complex_zero, complex_zero,
+                             complex_mi};
+constexpr GateMatrix Tmat{complex_one, complex_zero, complex_zero,
+                          complex_1plusi};
+constexpr GateMatrix Tdagmat{complex_one, complex_zero, complex_zero,
+                             complex_1minusi};
+constexpr GateMatrix SXmat{complex_1plusi_2, complex_1minusi_2,
+                           complex_1minusi_2, complex_1plusi_2};
+constexpr GateMatrix SXdagmat{complex_1minusi_2, complex_1plusi_2,
+                              complex_1plusi_2, complex_1minusi_2};
+constexpr GateMatrix Vmat{complex_SQRT2_2, complex_miSQRT2_2, complex_miSQRT2_2,
+                          complex_SQRT2_2};
+constexpr GateMatrix Vdagmat{complex_SQRT2_2, complex_iSQRT2_2,
+                             complex_iSQRT2_2, complex_SQRT2_2};
+
+inline GateMatrix U3mat(fp lambda, fp phi, fp theta) {
+  return GateMatrix{{{std::cos(theta / 2.), 0.},
+                     {-std::cos(lambda) * std::sin(theta / 2.),
+                      -std::sin(lambda) * std::sin(theta / 2.)},
+                     {std::cos(phi) * std::sin(theta / 2.),
+                      std::sin(phi) * std::sin(theta / 2.)},
+                     {std::cos(lambda + phi) * std::cos(theta / 2.),
+                      std::sin(lambda + phi) * std::cos(theta / 2.)}}};
+}
+
+inline GateMatrix U2mat(fp lambda, fp phi) {
+  return GateMatrix{
+      complex_SQRT2_2,
+      {-std::cos(lambda) * SQRT2_2, -std::sin(lambda) * SQRT2_2},
+      {std::cos(phi) * SQRT2_2, std::sin(phi) * SQRT2_2},
+      {std::cos(lambda + phi) * SQRT2_2, std::sin(lambda + phi) * SQRT2_2}};
+}
+
+inline GateMatrix Phasemat(fp lambda) {
+  return GateMatrix{complex_one,
+                    complex_zero,
+                    complex_zero,
+                    {std::cos(lambda), std::sin(lambda)}};
+}
+
+inline GateMatrix RXmat(fp lambda) {
+  return GateMatrix{{{std::cos(lambda / 2.), 0.},
+                     {0., -std::sin(lambda / 2.)},
+                     {0., -std::sin(lambda / 2.)},
+                     {std::cos(lambda / 2.), 0.}}};
+}
+
+inline GateMatrix RYmat(fp lambda) {
+  return GateMatrix{{{std::cos(lambda / 2.), 0.},
+                     {-std::sin(lambda / 2.), 0.},
+                     {std::sin(lambda / 2.), 0.},
+                     {std::cos(lambda / 2.), 0.}}};
+}
+
+inline GateMatrix RZmat(fp lambda) {
+  return GateMatrix{{{std::cos(lambda / 2.), -std::sin(lambda / 2.)},
+                     complex_zero,
+                     complex_zero,
+                     {std::cos(lambda / 2.), std::sin(lambda / 2.)}}};
+}
+
+using TwoQubitGateMatrix = std::array<std::array<ComplexValue, NEDGE>, NEDGE>;
+constexpr TwoQubitGateMatrix CXmat{
+    {{complex_one, complex_zero, complex_zero, complex_zero},
+     {complex_zero, complex_one, complex_zero, complex_zero},
+     {complex_zero, complex_zero, complex_zero, complex_one},
+     {complex_zero, complex_zero, complex_one, complex_zero}}};
+
+constexpr TwoQubitGateMatrix CZmat{
+    {{complex_one, complex_zero, complex_zero, complex_zero},
+     {complex_zero, complex_one, complex_zero, complex_zero},
+     {complex_zero, complex_zero, complex_one, complex_zero},
+     {complex_zero, complex_zero, complex_zero, complex_mone}}};
+
+constexpr TwoQubitGateMatrix SWAPmat{
+    {{complex_one, complex_zero, complex_zero, complex_zero},
+     {complex_zero, complex_zero, complex_one, complex_zero},
+     {complex_zero, complex_one, complex_zero, complex_zero},
+     {complex_zero, complex_zero, complex_zero, complex_one}}};
+
+constexpr TwoQubitGateMatrix iSWAPmat{
+    {{complex_one, complex_zero, complex_zero, complex_zero},
+     {complex_zero, complex_zero, complex_i, complex_zero},
+     {complex_zero, complex_i, complex_zero, complex_zero},
+     {complex_zero, complex_zero, complex_zero, complex_one}}};
+
+constexpr TwoQubitGateMatrix iSWAPinvmat{
+    {{complex_one, complex_zero, complex_zero, complex_zero},
+     {complex_zero, complex_zero, complex_mi, complex_zero},
+     {complex_zero, complex_mi, complex_zero, complex_zero},
+     {complex_zero, complex_zero, complex_zero, complex_one}}};
+
+constexpr TwoQubitGateMatrix ECRmat{
+    {{complex_zero, complex_zero, complex_SQRT2_2, complex_iSQRT2_2},
+     {complex_zero, complex_zero, complex_iSQRT2_2, complex_SQRT2_2},
+     {complex_SQRT2_2, complex_miSQRT2_2, complex_zero, complex_zero},
+     {complex_miSQRT2_2, complex_SQRT2_2, complex_zero, complex_zero}}};
+
+constexpr TwoQubitGateMatrix DCXmat{
+    {{complex_one, complex_zero, complex_zero, complex_zero},
+     {complex_zero, complex_zero, complex_zero, complex_one},
+     {complex_zero, complex_one, complex_zero, complex_zero},
+     {complex_zero, complex_zero, complex_one, complex_zero}}};
+
+inline TwoQubitGateMatrix RXXmat(const fp theta) {
+  const auto cosTheta = std::cos(theta / 2.);
+  const auto sinTheta = std::sin(theta / 2.);
+
+  return TwoQubitGateMatrix{{{ComplexValue{cosTheta, 0.}, complex_zero,
+                              complex_zero, ComplexValue{0., -sinTheta}},
+                             {complex_zero, ComplexValue{cosTheta, 0.},
+                              ComplexValue{0., -sinTheta}, complex_zero},
+                             {complex_zero, ComplexValue{0., -sinTheta},
+                              ComplexValue{cosTheta, 0.}, complex_zero},
+                             {ComplexValue{0., -sinTheta}, complex_zero,
+                              complex_zero, ComplexValue{cosTheta, 0.}}}};
+}
+
+inline TwoQubitGateMatrix RYYmat(const fp theta) {
+  const auto cosTheta = std::cos(theta / 2.);
+  const auto sinTheta = std::sin(theta / 2.);
+
+  return TwoQubitGateMatrix{{{ComplexValue{cosTheta, 0.}, complex_zero,
+                              complex_zero, ComplexValue{0., sinTheta}},
+                             {complex_zero, ComplexValue{cosTheta, 0.},
+                              ComplexValue{0., -sinTheta}, complex_zero},
+                             {complex_zero, ComplexValue{0., -sinTheta},
+                              ComplexValue{cosTheta, 0.}, complex_zero},
+                             {ComplexValue{0., sinTheta}, complex_zero,
+                              complex_zero, ComplexValue{cosTheta, 0.}}}};
+}
+
+inline TwoQubitGateMatrix RZZmat(const fp theta) {
+  const auto cosTheta = std::cos(theta / 2.);
+  const auto sinTheta = std::sin(theta / 2.);
+
+  return TwoQubitGateMatrix{{{ComplexValue{cosTheta, -sinTheta}, complex_zero,
+                              complex_zero, complex_zero},
+                             {complex_zero, ComplexValue{cosTheta, sinTheta},
+                              complex_zero, complex_zero},
+                             {complex_zero, complex_zero,
+                              ComplexValue{cosTheta, sinTheta}, complex_zero},
+                             {complex_zero, complex_zero, complex_zero,
+                              ComplexValue{cosTheta, -sinTheta}}}};
+}
+
+inline TwoQubitGateMatrix RZXmat(const fp theta) {
+  const auto cosTheta = std::cos(theta / 2.);
+  const auto sinTheta = std::sin(theta / 2.);
+
+  return TwoQubitGateMatrix{
+      {{ComplexValue{cosTheta, 0.}, ComplexValue{0., -sinTheta}, complex_zero,
+        complex_zero},
+       {ComplexValue{0., -sinTheta}, ComplexValue{cosTheta, 0.}, complex_zero,
+        complex_zero},
+       {complex_zero, complex_zero, ComplexValue{cosTheta, 0.},
+        ComplexValue{0., sinTheta}},
+       {complex_zero, complex_zero, ComplexValue{0., sinTheta},
+        ComplexValue{cosTheta, 0.}}}};
+}
+
+inline TwoQubitGateMatrix XXMinusYYmat(const fp theta, const fp beta = 0.) {
+  const auto cosTheta = std::cos(theta / 2.);
+  const auto sinTheta = std::sin(theta / 2.);
+  const auto cosBeta = std::cos(beta);
+  const auto sinBeta = std::sin(beta);
+
+  return TwoQubitGateMatrix{
+      {{ComplexValue{cosTheta, 0.}, complex_zero, complex_zero,
+        ComplexValue{sinBeta * sinTheta, -cosBeta * sinTheta}},
+       {complex_zero, complex_one, complex_zero, complex_zero},
+       {complex_zero, complex_zero, complex_one, complex_zero},
+       {ComplexValue{-sinBeta * sinTheta, -cosBeta * sinTheta}, complex_zero,
+        complex_zero, ComplexValue{cosTheta, 0.}}}};
+}
+
+inline TwoQubitGateMatrix XXPlusYYmat(const fp theta, const fp beta = 0.) {
+  const auto cosTheta = std::cos(theta / 2.);
+  const auto sinTheta = std::sin(theta / 2.);
+  const auto cosBeta = std::cos(beta);
+  const auto sinBeta = std::sin(beta);
+
+  return TwoQubitGateMatrix{
+      {{complex_one, complex_zero, complex_zero, complex_zero},
+       {complex_zero, ComplexValue{cosTheta, 0.},
+        ComplexValue{sinBeta * sinTheta, -cosBeta * sinTheta}, complex_zero},
+       {complex_zero, ComplexValue{-sinBeta * sinTheta, -cosBeta * sinTheta},
+        ComplexValue{cosTheta, 0.}, complex_zero},
+       {complex_zero, complex_zero, complex_zero, complex_one}}};
+}
+// NOLINTEND(readability-identifier-naming)
 } // namespace dd
-#endif //DD_PACKAGE_GATEMATRIXDEFINITIONS_H
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/Node.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/dd/Node.hpp`

 * *Files 12% similar despite different names*

```diff
@@ -1,230 +1,300 @@
-/*
-* This file is part of the MQT DD Package which is released under the MIT license.
-* See file README.md or go to https://www.cda.cit.tum.de/research/quantum_dd/ for more information.
-*/
-
 #pragma once
 
 #include "Complex.hpp"
 #include "ComplexValue.hpp"
 #include "Definitions.hpp"
 #include "Edge.hpp"
 
 #include <array>
 #include <cstddef>
 #include <utility>
 
 namespace dd {
-    // NOLINTNEXTLINE(readability-identifier-naming)
-    struct vNode {
-        std::array<Edge<vNode>, RADIX> e{};    // edges out of this node
-        vNode*                         next{}; // used to link nodes in unique table
-        RefCount                       ref{};  // reference count
-        Qubit                          v{};    // variable index (nonterminal) value (-1 for terminal)
-
-        static vNode            terminalNode;            // NOLINT(cppcoreguidelines-avoid-non-const-global-variables)
-        constexpr static vNode* terminal{&terminalNode}; // NOLINT(cppcoreguidelines-avoid-non-const-global-variables,readability-identifier-naming)
-
-        static constexpr bool isTerminal(const vNode* p) { return p == terminal; }
-    };
-    using vEdge       = Edge<vNode>;
-    using vCachedEdge = CachedEdge<vNode>;
-
-    // NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
-    inline vNode vNode::terminalNode{{{{nullptr, Complex::zero}, {nullptr, Complex::zero}}}, nullptr, 0U, -1};
-
-    // NOLINTNEXTLINE(readability-identifier-naming)
-    struct mNode {
-        std::array<Edge<mNode>, NEDGE> e{};    // edges out of this node
-        mNode*                         next{}; // used to link nodes in unique table
-        RefCount                       ref{};  // reference count
-        Qubit                          v{};    // variable index (nonterminal) value (-1 for terminal)
-        std::uint8_t                   flags = 0;
-        // 32 = marks a node with is symmetric.
-        // 16 = marks a node resembling identity
-        // 8 = marks a reduced dm node,
-        // 4 = marks a dm (tmp flag),
-        // 2 = mark first path edge (tmp flag),
-        // 1 = mark path is conjugated (tmp flag))
-
-        static mNode            terminalNode;            // NOLINT(cppcoreguidelines-avoid-non-const-global-variables)
-        constexpr static mNode* terminal{&terminalNode}; // NOLINT(cppcoreguidelines-avoid-non-const-global-variables,readability-identifier-naming)
-
-        static constexpr bool isTerminal(const mNode* p) { return p == terminal; }
-
-        [[nodiscard]] inline bool isIdentity() const { return (flags & static_cast<std::uint8_t>(16U)) != 0; }
-        [[nodiscard]] inline bool isSymmetric() const { return (flags & static_cast<std::uint8_t>(32U)) != 0; }
-
-        inline void setIdentity(bool identity) {
-            if (identity) {
-                flags = (flags | static_cast<std::uint8_t>(16U));
-            } else {
-                flags = (flags & static_cast<std::uint8_t>(~16U));
-            }
-        }
-        inline void setSymmetric(bool symmetric) {
-            if (symmetric) {
-                flags = (flags | static_cast<std::uint8_t>(32U));
-            } else {
-                flags = (flags & static_cast<std::uint8_t>(~32U));
-            }
-        }
-    };
-    using mEdge       = Edge<mNode>;
-    using mCachedEdge = CachedEdge<mNode>;
-
-    // NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
-    inline mNode mNode::terminalNode{{{{nullptr, Complex::zero}, {nullptr, Complex::zero}, {nullptr, Complex::zero}, {nullptr, Complex::zero}}}, nullptr, 0U, -1, 32 + 16};
-
-    // NOLINTNEXTLINE(readability-identifier-naming)
-    struct dNode {
-        std::array<Edge<dNode>, NEDGE> e{};    // edges out of this node
-        dNode*                         next{}; // used to link nodes in unique table
-        RefCount                       ref{};  // reference count
-        Qubit                          v{};    // variable index (nonterminal) value (-1 for terminal)
-        std::uint8_t                   flags = 0;
-        // 32 = marks a node with is symmetric.
-        // 16 = marks a node resembling identity
-        // 8 = marks a reduced dm node,
-        // 4 = marks a dm (tmp flag),
-        // 2 = mark first path edge (tmp flag),
-        // 1 = mark path is conjugated (tmp flag))
-
-        static dNode            terminalNode;            // NOLINT(cppcoreguidelines-avoid-non-const-global-variables)
-        constexpr static dNode* terminal{&terminalNode}; // NOLINT(cppcoreguidelines-avoid-non-const-global-variables,readability-identifier-naming)
-        static constexpr bool   isTerminal(const dNode* p) { return p == terminal; }
-
-        [[nodiscard]] [[maybe_unused]] static inline bool tempDensityMatrixFlagsEqual(const std::uint8_t a, const std::uint8_t b) { return getDensityMatrixTempFlags(a) == getDensityMatrixTempFlags(b); }
-
-        [[nodiscard]] static inline bool isConjugateTempFlagSet(const std::uintptr_t p) { return (p & (1ULL << 0)) != 0U; }
-        [[nodiscard]] static inline bool isNonReduceTempFlagSet(const std::uintptr_t p) { return (p & (1ULL << 1)) != 0U; }
-        [[nodiscard]] static inline bool isDensityMatrixTempFlagSet(const std::uintptr_t p) { return (p & (1ULL << 2)) != 0U; }
-        [[nodiscard]] static inline bool isDensityMatrixNode(const std::uintptr_t p) { return (p & (1ULL << 3)) != 0U; }
-
-        [[nodiscard]] [[maybe_unused]] static inline bool isConjugateTempFlagSet(const dNode* p) { return isConjugateTempFlagSet(reinterpret_cast<std::uintptr_t>(p)); }
-        [[nodiscard]] [[maybe_unused]] static inline bool isNonReduceTempFlagSet(const dNode* p) { return isNonReduceTempFlagSet(reinterpret_cast<std::uintptr_t>(p)); }
-        [[nodiscard]] [[maybe_unused]] static inline bool isDensityMatrixTempFlagSet(const dNode* p) { return isDensityMatrixTempFlagSet(reinterpret_cast<std::uintptr_t>(p)); }
-        [[nodiscard]] [[maybe_unused]] static inline bool isDensityMatrixNode(const dNode* p) { return isDensityMatrixNode(reinterpret_cast<std::uintptr_t>(p)); }
-
-        static inline void setConjugateTempFlagTrue(dNode*& p) { p = reinterpret_cast<dNode*>(reinterpret_cast<std::uintptr_t>(p) | (1ULL << 0)); }
-        static inline void setNonReduceTempFlagTrue(dNode*& p) { p = reinterpret_cast<dNode*>(reinterpret_cast<std::uintptr_t>(p) | (1ULL << 1)); }
-        static inline void setDensityMatTempFlagTrue(dNode*& p) { p = reinterpret_cast<dNode*>(reinterpret_cast<std::uintptr_t>(p) | (1ULL << 2)); }
-        static inline void alignDensityNode(dNode*& p) { p = reinterpret_cast<dNode*>(reinterpret_cast<std::uintptr_t>(p) & (~7ULL)); }
-
-        [[nodiscard]] static inline std::uintptr_t getDensityMatrixTempFlags(dNode*& p) { return getDensityMatrixTempFlags(reinterpret_cast<std::uintptr_t>(p)); }
-        [[nodiscard]] static inline std::uintptr_t getDensityMatrixTempFlags(const std::uintptr_t a) { return a & (7ULL); }
-
-        void unsetTempDensityMatrixFlags() { flags = flags & static_cast<std::uint8_t>(~7U); }
-
-        inline void setDensityMatrixNodeFlag(bool densityMatrix) {
-            if (densityMatrix) {
-                flags = (flags | static_cast<std::uint8_t>(8U));
-            } else {
-                flags = (flags & static_cast<std::uint8_t>(~8U));
-            }
-        }
-
-        static inline std::uint8_t alignDensityNodeNode(dNode*& p) {
-            const auto flags = static_cast<std::uint8_t>(getDensityMatrixTempFlags(p));
-            alignDensityNode(p);
-
-            if (p == nullptr || p->v <= -1) {
-                return 0;
-            }
-
-            if (isNonReduceTempFlagSet(flags) && !isConjugateTempFlagSet(flags)) {
-                // first edge paths are not modified and the property is inherited by all child paths
-                return flags;
-            }
-            if (!isConjugateTempFlagSet(flags)) {
-                // Conjugate the second edge (i.e. negate the complex part of the second edge)
-                p->e[2].w.i = dd::CTEntry::flipPointerSign(p->e[2].w.i);
-                setConjugateTempFlagTrue(p->e[2].p);
-                // Mark the first edge
-                setNonReduceTempFlagTrue(p->e[1].p);
-
-                for (auto& edge: p->e) {
-                    setDensityMatTempFlagTrue(edge.p);
-                }
-
-            } else {
-                std::swap(p->e[2], p->e[1]);
-                for (auto& edge: p->e) {
-                    // Conjugate all edges
-                    edge.w.i = dd::CTEntry::flipPointerSign(edge.w.i);
-                    setConjugateTempFlagTrue(edge.p);
-                    setDensityMatTempFlagTrue(edge.p);
-                }
-            }
-            return flags;
-        }
-
-        static inline void getAlignedNodeRevertModificationsOnSubEdges(dNode* p) {
-            // Before I do anything else, I must align the pointer
-            alignDensityNode(p);
-
-            for (auto& edge: p->e) {
-                // remove the set properties from the node pointers of edge.p->e
-                alignDensityNode(edge.p);
-            }
-
-            if (isNonReduceTempFlagSet(p->flags) && !isConjugateTempFlagSet(p->flags)) {
-                // first edge paths are not modified I only have to remove the first edge property
-                ;
-
-            } else if (!isConjugateTempFlagSet(p->flags)) {
-                // Conjugate the second edge (i.e. negate the complex part of the second edge)
-                p->e[2].w.i = dd::CTEntry::flipPointerSign(p->e[2].w.i);
-
-            } else {
-                for (auto& edge: p->e) {
-                    // Align all nodes and conjugate the weights
-                    edge.w.i = dd::CTEntry::flipPointerSign(edge.w.i);
-                }
-                std::swap(p->e[2], p->e[1]);
-            }
-        }
-
-        static inline void applyDmChangesToNode(dNode*& p) {
-            // Align the node pointers
-            if (isDensityMatrixTempFlagSet(p)) {
-                auto tmp = alignDensityNodeNode(p);
-                assert(getDensityMatrixTempFlags(p->flags) == 0);
-                p->flags = p->flags | tmp;
-            }
-        }
-
-        static inline void revertDmChangesToNode(dNode*& p) {
-            // Align the node pointers
-            if (isDensityMatrixTempFlagSet(p->flags)) {
-                getAlignedNodeRevertModificationsOnSubEdges(p);
-                p->unsetTempDensityMatrixFlags();
-            }
-        }
-    };
-    using dEdge       = Edge<dNode>;
-    using dCachedEdge = CachedEdge<dNode>;
-    // NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
-    inline dNode dNode::terminalNode{{{{nullptr, Complex::zero}, {nullptr, Complex::zero}, {nullptr, Complex::zero}, {nullptr, Complex::zero}}}, nullptr, 0, -1, 0};
-
-    // NOLINTNEXTLINE(clang-diagnostic-unused-function) It's used but clang-tidy in our CI complains...
-    static inline dEdge densityFromMatrixEdge(const mEdge& e) {
-        return dEdge{reinterpret_cast<dNode*>(e.p), e.w};
+// NOLINTNEXTLINE(readability-identifier-naming)
+struct vNode {
+  std::array<Edge<vNode>, RADIX> e{}; // edges out of this node
+  vNode* next{};                      // used to link nodes in unique table
+  RefCount ref{};                     // reference count
+  Qubit v{}; // variable index (nonterminal) value (-1 for terminal)
+
+  // NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
+  static vNode terminalNode;
+  // NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables,readability-identifier-naming)
+  constexpr static vNode* terminal{&terminalNode};
+
+  static constexpr bool isTerminal(const vNode* p) { return p == terminal; }
+};
+using vEdge = Edge<vNode>;
+using vCachedEdge = CachedEdge<vNode>;
+
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
+inline vNode vNode::terminalNode{
+    {{{nullptr, Complex::zero}, {nullptr, Complex::zero}}}, nullptr, 0U, -1};
+
+// NOLINTNEXTLINE(readability-identifier-naming)
+struct mNode {
+  std::array<Edge<mNode>, NEDGE> e{}; // edges out of this node
+  mNode* next{};                      // used to link nodes in unique table
+  RefCount ref{};                     // reference count
+  Qubit v{}; // variable index (nonterminal) value (-1 for terminal)
+  std::uint8_t flags = 0;
+  // 32 = marks a node with is symmetric.
+  // 16 = marks a node resembling identity
+  // 8 = marks a reduced dm node,
+  // 4 = marks a dm (tmp flag),
+  // 2 = mark first path edge (tmp flag),
+  // 1 = mark path is conjugated (tmp flag))
+
+  // NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
+  static mNode terminalNode;
+  // NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables,readability-identifier-naming)
+  constexpr static mNode* terminal{&terminalNode};
+
+  static constexpr bool isTerminal(const mNode* p) { return p == terminal; }
+
+  [[nodiscard]] inline bool isIdentity() const {
+    return (flags & static_cast<std::uint8_t>(16U)) != 0;
+  }
+  [[nodiscard]] inline bool isSymmetric() const {
+    return (flags & static_cast<std::uint8_t>(32U)) != 0;
+  }
+
+  inline void setIdentity(bool identity) {
+    if (identity) {
+      flags = (flags | static_cast<std::uint8_t>(16U));
+    } else {
+      flags = (flags & static_cast<std::uint8_t>(~16U));
+    }
+  }
+  inline void setSymmetric(bool symmetric) {
+    if (symmetric) {
+      flags = (flags | static_cast<std::uint8_t>(32U));
+    } else {
+      flags = (flags & static_cast<std::uint8_t>(~32U));
+    }
+  }
+};
+using mEdge = Edge<mNode>;
+using mCachedEdge = CachedEdge<mNode>;
+
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
+inline mNode mNode::terminalNode{{{{nullptr, Complex::zero},
+                                   {nullptr, Complex::zero},
+                                   {nullptr, Complex::zero},
+                                   {nullptr, Complex::zero}}},
+                                 nullptr,
+                                 0U,
+                                 -1,
+                                 32 + 16};
+
+// NOLINTNEXTLINE(readability-identifier-naming)
+struct dNode {
+  std::array<Edge<dNode>, NEDGE> e{}; // edges out of this node
+  dNode* next{};                      // used to link nodes in unique table
+  RefCount ref{};                     // reference count
+  Qubit v{}; // variable index (nonterminal) value (-1 for terminal)
+  std::uint8_t flags = 0;
+  // 32 = marks a node with is symmetric.
+  // 16 = marks a node resembling identity
+  // 8 = marks a reduced dm node,
+  // 4 = marks a dm (tmp flag),
+  // 2 = mark first path edge (tmp flag),
+  // 1 = mark path is conjugated (tmp flag))
+
+  // NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
+  static dNode terminalNode;
+  // NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables,readability-identifier-naming)
+  constexpr static dNode* terminal{&terminalNode};
+  static constexpr bool isTerminal(const dNode* p) { return p == terminal; }
+
+  [[nodiscard]] [[maybe_unused]] static inline bool
+  tempDensityMatrixFlagsEqual(const std::uint8_t a, const std::uint8_t b) {
+    return getDensityMatrixTempFlags(a) == getDensityMatrixTempFlags(b);
+  }
+
+  [[nodiscard]] static inline bool
+  isConjugateTempFlagSet(const std::uintptr_t p) {
+    return (p & (1ULL << 0)) != 0U;
+  }
+  [[nodiscard]] static inline bool
+  isNonReduceTempFlagSet(const std::uintptr_t p) {
+    return (p & (1ULL << 1)) != 0U;
+  }
+  [[nodiscard]] static inline bool
+  isDensityMatrixTempFlagSet(const std::uintptr_t p) {
+    return (p & (1ULL << 2)) != 0U;
+  }
+  [[nodiscard]] static inline bool isDensityMatrixNode(const std::uintptr_t p) {
+    return (p & (1ULL << 3)) != 0U;
+  }
+
+  [[nodiscard]] [[maybe_unused]] static inline bool
+  isConjugateTempFlagSet(const dNode* p) {
+    return isConjugateTempFlagSet(reinterpret_cast<std::uintptr_t>(p));
+  }
+  [[nodiscard]] [[maybe_unused]] static inline bool
+  isNonReduceTempFlagSet(const dNode* p) {
+    return isNonReduceTempFlagSet(reinterpret_cast<std::uintptr_t>(p));
+  }
+  [[nodiscard]] [[maybe_unused]] static inline bool
+  isDensityMatrixTempFlagSet(const dNode* p) {
+    return isDensityMatrixTempFlagSet(reinterpret_cast<std::uintptr_t>(p));
+  }
+  [[nodiscard]] [[maybe_unused]] static inline bool
+  isDensityMatrixNode(const dNode* p) {
+    return isDensityMatrixNode(reinterpret_cast<std::uintptr_t>(p));
+  }
+
+  static inline void setConjugateTempFlagTrue(dNode*& p) {
+    p = reinterpret_cast<dNode*>(reinterpret_cast<std::uintptr_t>(p) |
+                                 (1ULL << 0));
+  }
+  static inline void setNonReduceTempFlagTrue(dNode*& p) {
+    p = reinterpret_cast<dNode*>(reinterpret_cast<std::uintptr_t>(p) |
+                                 (1ULL << 1));
+  }
+  static inline void setDensityMatTempFlagTrue(dNode*& p) {
+    p = reinterpret_cast<dNode*>(reinterpret_cast<std::uintptr_t>(p) |
+                                 (1ULL << 2));
+  }
+  static inline void alignDensityNode(dNode*& p) {
+    p = reinterpret_cast<dNode*>(reinterpret_cast<std::uintptr_t>(p) & (~7ULL));
+  }
+
+  [[nodiscard]] static inline std::uintptr_t
+  getDensityMatrixTempFlags(dNode*& p) {
+    return getDensityMatrixTempFlags(reinterpret_cast<std::uintptr_t>(p));
+  }
+  [[nodiscard]] static inline std::uintptr_t
+  getDensityMatrixTempFlags(const std::uintptr_t a) {
+    return a & (7ULL);
+  }
+
+  void unsetTempDensityMatrixFlags() {
+    flags = flags & static_cast<std::uint8_t>(~7U);
+  }
+
+  inline void setDensityMatrixNodeFlag(bool densityMatrix) {
+    if (densityMatrix) {
+      flags = (flags | static_cast<std::uint8_t>(8U));
+    } else {
+      flags = (flags & static_cast<std::uint8_t>(~8U));
+    }
+  }
+
+  static inline std::uint8_t alignDensityNodeNode(dNode*& p) {
+    const auto flags = static_cast<std::uint8_t>(getDensityMatrixTempFlags(p));
+    alignDensityNode(p);
+
+    if (p == nullptr || p->v <= -1) {
+      return 0;
+    }
+
+    if (isNonReduceTempFlagSet(flags) && !isConjugateTempFlagSet(flags)) {
+      // first edge paths are not modified and the property is inherited by all
+      // child paths
+      return flags;
+    }
+    if (!isConjugateTempFlagSet(flags)) {
+      // Conjugate the second edge (i.e. negate the complex part of the second
+      // edge)
+      p->e[2].w.i = dd::CTEntry::flipPointerSign(p->e[2].w.i);
+      setConjugateTempFlagTrue(p->e[2].p);
+      // Mark the first edge
+      setNonReduceTempFlagTrue(p->e[1].p);
+
+      for (auto& edge : p->e) {
+        setDensityMatTempFlagTrue(edge.p);
+      }
+
+    } else {
+      std::swap(p->e[2], p->e[1]);
+      for (auto& edge : p->e) {
+        // Conjugate all edges
+        edge.w.i = dd::CTEntry::flipPointerSign(edge.w.i);
+        setConjugateTempFlagTrue(edge.p);
+        setDensityMatTempFlagTrue(edge.p);
+      }
+    }
+    return flags;
+  }
+
+  static inline void getAlignedNodeRevertModificationsOnSubEdges(dNode* p) {
+    // Before I do anything else, I must align the pointer
+    alignDensityNode(p);
+
+    for (auto& edge : p->e) {
+      // remove the set properties from the node pointers of edge.p->e
+      alignDensityNode(edge.p);
+    }
+
+    if (isNonReduceTempFlagSet(p->flags) && !isConjugateTempFlagSet(p->flags)) {
+      // first edge paths are not modified I only have to remove the first edge
+      // property
+      ;
+
+    } else if (!isConjugateTempFlagSet(p->flags)) {
+      // Conjugate the second edge (i.e. negate the complex part of the second
+      // edge)
+      p->e[2].w.i = dd::CTEntry::flipPointerSign(p->e[2].w.i);
+
+    } else {
+      for (auto& edge : p->e) {
+        // Align all nodes and conjugate the weights
+        edge.w.i = dd::CTEntry::flipPointerSign(edge.w.i);
+      }
+      std::swap(p->e[2], p->e[1]);
+    }
+  }
+
+  static inline void applyDmChangesToNode(dNode*& p) {
+    // Align the node pointers
+    if (isDensityMatrixTempFlagSet(p)) {
+      auto tmp = alignDensityNodeNode(p);
+      assert(getDensityMatrixTempFlags(p->flags) == 0);
+      p->flags = p->flags | tmp;
+    }
+  }
+
+  static inline void revertDmChangesToNode(dNode*& p) {
+    // Align the node pointers
+    if (isDensityMatrixTempFlagSet(p->flags)) {
+      getAlignedNodeRevertModificationsOnSubEdges(p);
+      p->unsetTempDensityMatrixFlags();
     }
+  }
+};
+using dEdge = Edge<dNode>;
+using dCachedEdge = CachedEdge<dNode>;
+// NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
+inline dNode dNode::terminalNode{{{{nullptr, Complex::zero},
+                                   {nullptr, Complex::zero},
+                                   {nullptr, Complex::zero},
+                                   {nullptr, Complex::zero}}},
+                                 nullptr,
+                                 0,
+                                 -1,
+                                 0};
+
+// It's used but clang-tidy in our CI complains...
+// NOLINTNEXTLINE(clang-diagnostic-unused-function)
+static inline dEdge densityFromMatrixEdge(const mEdge& e) {
+  return dEdge{reinterpret_cast<dNode*>(e.p), e.w};
+}
 
 } // namespace dd
 
 namespace std {
-    template<>
-    struct hash<dd::dEdge> {
-        std::size_t operator()(dd::dEdge const& e) const noexcept {
-            const auto h1 = dd::murmur64(reinterpret_cast<std::size_t>(e.p));
-            const auto h2 = std::hash<dd::Complex>{}(e.w);
-            assert(e.p != nullptr);
-            assert((dd::dNode::isDensityMatrixTempFlagSet(e.p)) == false);
-            const auto h3  = std::hash<std::uint8_t>{}(static_cast<std::uint8_t>(dd::dNode::getDensityMatrixTempFlags(e.p->flags)));
-            const auto tmp = dd::combineHash(h1, h2);
-            return dd::combineHash(tmp, h3);
-        }
-    };
+template <> struct hash<dd::dEdge> {
+  std::size_t operator()(dd::dEdge const& e) const noexcept {
+    const auto h1 = dd::murmur64(reinterpret_cast<std::size_t>(e.p));
+    const auto h2 = std::hash<dd::Complex>{}(e.w);
+    assert(e.p != nullptr);
+    assert((dd::dNode::isDensityMatrixTempFlagSet(e.p)) == false);
+    const auto h3 = std::hash<std::uint8_t>{}(static_cast<std::uint8_t>(
+        dd::dNode::getDensityMatrixTempFlags(e.p->flags)));
+    const auto tmp = dd::combineHash(h1, h2);
+    return dd::combineHash(tmp, h3);
+  }
+};
 } // namespace std
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/Package.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/dd/Package.hpp`

 * *Files 10% similar despite different names*

```diff
@@ -1,14 +1,8 @@
-/*
-* This file is part of the MQT DD Package which is released under the MIT license.
-* See file README.md or go to https://www.cda.cit.tum.de/research/quantum_dd/ for more information.
-*/
-
-#ifndef DDpackage_H
-#define DDpackage_H
+#pragma once
 
 #include "Complex.hpp"
 #include "ComplexCache.hpp"
 #include "ComplexNumbers.hpp"
 #include "ComplexTable.hpp"
 #include "ComplexValue.hpp"
 #include "ComputeTable.hpp"
@@ -45,3290 +39,3654 @@
 #include <string>
 #include <type_traits>
 #include <unordered_map>
 #include <unordered_set>
 #include <vector>
 
 namespace dd {
-    struct DDPackageConfig {
-        //Note the order of parameters here must be the *same* as in the template definition.
-        static constexpr std::size_t UT_VEC_NBUCKET                 = 32768U;
-        static constexpr std::size_t UT_VEC_INITIAL_ALLOCATION_SIZE = 2048U;
-        static constexpr std::size_t UT_MAT_NBUCKET                 = 32768U;
-        static constexpr std::size_t UT_MAT_INITIAL_ALLOCATION_SIZE = 2048U;
-        static constexpr std::size_t CT_VEC_ADD_NBUCKET             = 16384U;
-        static constexpr std::size_t CT_MAT_ADD_NBUCKET             = 16384U;
-        static constexpr std::size_t CT_MAT_TRANS_NBUCKET           = 4096U;
-        static constexpr std::size_t CT_MAT_CONJ_TRANS_NBUCKET      = 4096U;
-        static constexpr std::size_t CT_MAT_VEC_MULT_NBUCKET        = 16384U;
-        static constexpr std::size_t CT_MAT_MAT_MULT_NBUCKET        = 16384U;
-        static constexpr std::size_t CT_VEC_KRON_NBUCKET            = 4096U;
-        static constexpr std::size_t CT_MAT_KRON_NBUCKET            = 4096U;
-        static constexpr std::size_t CT_VEC_INNER_PROD_NBUCKET      = 4096U;
-        static constexpr std::size_t CT_DM_NOISE_NBUCKET            = 1U;
-        static constexpr std::size_t UT_DM_NBUCKET                  = 1U;
-        static constexpr std::size_t UT_DM_INITIAL_ALLOCATION_SIZE  = 1U;
-        static constexpr std::size_t CT_DM_DM_MULT_NBUCKET          = 1U;
-        static constexpr std::size_t CT_DM_ADD_NBUCKET              = 1U;
-
-        // The number of different quantum operations. I.e., the number of operations defined in the QFR OpType.hpp
-        // This parameter is required to initialize the StochasticNoiseOperationTable.hpp
-        static constexpr std::size_t STOCHASTIC_CACHE_OPS = 1;
-    };
-
-    template<class Config = DDPackageConfig>
-    class Package {
-        static_assert(std::is_base_of_v<DDPackageConfig, Config>, "Config must be derived from DDPackageConfig");
-        ///
-        /// Complex number handling
-        ///
-    public:
-        ComplexNumbers cn{};
-
-        ///
-        /// Construction, destruction, information and reset
-        ///
-
-        static constexpr std::size_t MAX_POSSIBLE_QUBITS = static_cast<std::make_unsigned_t<Qubit>>(std::numeric_limits<Qubit>::max()) + 1U;
-        static constexpr std::size_t DEFAULT_QUBITS      = 128;
-        explicit Package(std::size_t nq = DEFAULT_QUBITS):
-            nqubits(nq) {
-            resize(nq);
-        };
-        ~Package()                      = default;
-        Package(const Package& package) = delete;
-
-        Package& operator=(const Package& package) = delete;
-
-        // resize the package instance
-        void resize(std::size_t nq) {
-            if (nq > MAX_POSSIBLE_QUBITS) {
-                throw std::invalid_argument("Requested too many qubits from package. Qubit datatype only allows up to " +
-                                            std::to_string(MAX_POSSIBLE_QUBITS) + " qubits, while " +
-                                            std::to_string(nq) + " were requested. Please recompile the package with a wider Qubit type!");
-            }
-            nqubits = nq;
-            vUniqueTable.resize(nqubits);
-            mUniqueTable.resize(nqubits);
-            dUniqueTable.resize(nqubits);
-            stochasticNoiseOperationCache.resize(nqubits);
-            idTable.resize(nqubits);
-        }
-
-        // reset package state
-        void reset() {
-            clearUniqueTables();
-            clearComputeTables();
-            cn.clear();
-        }
-
-        // getter for qubits
-        [[nodiscard]] auto qubits() const { return nqubits; }
-
-    private:
-        std::size_t nqubits;
-
-        ///
-        /// Vector nodes, edges and quantum states
-        ///
-    public:
-        vEdge normalize(const vEdge& e, bool cached) {
-            auto zero = std::array{e.p->e[0].w.approximatelyZero(), e.p->e[1].w.approximatelyZero()};
-
-            // make sure to release cached numbers approximately zero, but not exactly zero
-            if (cached) {
-                for (auto i = 0U; i < RADIX; i++) {
-                    if (zero[i] && e.p->e[i].w != Complex::zero) {
-                        cn.returnToCache(e.p->e[i].w);
-                        e.p->e[i] = vEdge::zero;
-                    }
-                }
-            }
-
-            if (zero[0]) {
-                // all equal to zero
-                if (zero[1]) {
-                    if (!cached && !e.isTerminal()) {
-                        // If it is not a cached computation, the node has to be put back into the chain
-                        vUniqueTable.returnNode(e.p);
-                    }
-                    return vEdge::zero;
-                }
-
-                auto  r = e;
-                auto& w = r.p->e[1].w;
-                if (cached && !w.exactlyOne()) {
-                    r.w = w;
-                } else {
-                    r.w = cn.lookup(w);
-                }
-                w = Complex::one;
-                return r;
-            }
-
-            if (zero[1]) {
-                auto  r = e;
-                auto& w = r.p->e[0].w;
-                if (cached && !w.exactlyOne()) {
-                    r.w = w;
-                } else {
-                    r.w = cn.lookup(w);
-                }
-                w = Complex::one;
-                return r;
-            }
-
-            const auto mag0         = ComplexNumbers::mag2(e.p->e[0].w);
-            const auto mag1         = ComplexNumbers::mag2(e.p->e[1].w);
-            const auto norm2        = mag0 + mag1;
-            const auto mag2Max      = (mag0 + ComplexTable<>::tolerance() >= mag1) ? mag0 : mag1;
-            const auto argMax       = (mag0 + ComplexTable<>::tolerance() >= mag1) ? 0 : 1;
-            const auto norm         = std::sqrt(norm2);
-            const auto magMax       = std::sqrt(mag2Max);
-            const auto commonFactor = norm / magMax;
-
-            auto  r   = e;
-            auto& max = r.p->e[static_cast<std::size_t>(argMax)];
-            if (cached && !max.w.exactlyOne()) {
-                r.w = max.w;
-                r.w.r->value *= commonFactor;
-                r.w.i->value *= commonFactor;
-            } else {
-                r.w = cn.lookup(CTEntry::val(max.w.r) * commonFactor, CTEntry::val(max.w.i) * commonFactor);
-                if (r.w.approximatelyZero()) {
-                    return vEdge::zero;
-                }
-            }
-
-            max.w = cn.lookup(magMax / norm, 0.);
-            if (max.w == Complex::zero) {
-                max = vEdge::zero;
-            }
-
-            const auto argMin = (argMax + 1) % 2;
-            auto&      min    = r.p->e[static_cast<std::size_t>(argMin)];
-            if (cached) {
-                cn.returnToCache(min.w);
-                ComplexNumbers::div(min.w, min.w, r.w);
-                min.w = cn.lookup(min.w);
-            } else {
-                auto c = cn.getTemporary();
-                ComplexNumbers::div(c, min.w, r.w);
-                min.w = cn.lookup(c);
-            }
-            if (min.w == Complex::zero) {
-                min = vEdge::zero;
-            }
-
-            return r;
-        }
-
-        dEdge makeZeroDensityOperator(QubitCount n) {
-            auto f = dEdge::one;
-            for (std::size_t p = 0; p < n; p++) {
-                f = makeDDNode(static_cast<Qubit>(p), std::array{f, dEdge::zero, dEdge::zero, dEdge::zero});
-            }
-            return f;
-        }
-
-        // generate |0...0> with n qubits
-        vEdge makeZeroState(QubitCount n, std::size_t start = 0) {
-            if (n + start > nqubits) {
-                throw std::runtime_error{"Requested state with " +
-                                         std::to_string(n + start) +
-                                         " qubits, but current package configuration only supports up to " +
-                                         std::to_string(nqubits) +
-                                         " qubits. Please allocate a larger package instance."};
-            }
-            auto f = vEdge::one;
-            for (std::size_t p = start; p < n + start; p++) {
-                f = makeDDNode(static_cast<Qubit>(p), std::array{f, vEdge::zero});
-            }
-            return f;
-        }
-        // generate computational basis state |i> with n qubits
-        vEdge makeBasisState(QubitCount n, const std::vector<bool>& state, std::size_t start = 0) {
-            if (n + start > nqubits) {
-                throw std::runtime_error{"Requested state with " +
-                                         std::to_string(n + start) +
-                                         " qubits, but current package configuration only supports up to " +
-                                         std::to_string(nqubits) +
-                                         " qubits. Please allocate a larger package instance."};
-            }
-            auto f = vEdge::one;
-            for (std::size_t p = start; p < n + start; ++p) {
-                if (!state[p]) {
-                    f = makeDDNode(static_cast<Qubit>(p), std::array{f, vEdge::zero});
-                } else {
-                    f = makeDDNode(static_cast<Qubit>(p), std::array{vEdge::zero, f});
-                }
-            }
-            return f;
-        }
-        // generate general basis state with n qubits
-        vEdge makeBasisState(QubitCount n, const std::vector<BasisStates>& state, std::size_t start = 0) {
-            if (n + start > nqubits) {
-                throw std::runtime_error{"Requested state with " +
-                                         std::to_string(n + start) +
-                                         " qubits, but current package configuration only supports up to " +
-                                         std::to_string(nqubits) +
-                                         " qubits. Please allocate a larger package instance."};
-            }
-            if (state.size() < n) {
-                throw std::runtime_error("Insufficient qubit states provided. Requested " + std::to_string(n) + ", but received " + std::to_string(state.size()));
-            }
-
-            auto f = vEdge::one;
-            for (std::size_t p = start; p < n + start; ++p) {
-                switch (state[p]) {
-                    case BasisStates::zero:
-                        f = makeDDNode(static_cast<Qubit>(p), std::array{f, vEdge::zero});
-                        break;
-                    case BasisStates::one:
-                        f = makeDDNode(static_cast<Qubit>(p), std::array{vEdge::zero, f});
-                        break;
-                    case BasisStates::plus:
-                        f = makeDDNode(static_cast<Qubit>(p), std::array<vEdge, RADIX>{{{f.p, cn.lookup(dd::SQRT2_2, 0)}, {f.p, cn.lookup(dd::SQRT2_2, 0)}}});
-                        break;
-                    case BasisStates::minus:
-                        f = makeDDNode(static_cast<Qubit>(p), std::array<vEdge, RADIX>{{{f.p, cn.lookup(dd::SQRT2_2, 0)}, {f.p, cn.lookup(-dd::SQRT2_2, 0)}}});
-                        break;
-                    case BasisStates::right:
-                        f = makeDDNode(static_cast<Qubit>(p), std::array<vEdge, RADIX>{{{f.p, cn.lookup(dd::SQRT2_2, 0)}, {f.p, cn.lookup(0, dd::SQRT2_2)}}});
-                        break;
-                    case BasisStates::left:
-                        f = makeDDNode(static_cast<Qubit>(p), std::array<vEdge, RADIX>{{{f.p, cn.lookup(dd::SQRT2_2, 0)}, {f.p, cn.lookup(0, -dd::SQRT2_2)}}});
-                        break;
-                }
-            }
-            return f;
-        }
-
-        // generate the decision diagram from an arbitrary state vector
-        vEdge makeStateFromVector(const CVec& stateVector) {
-            if (stateVector.empty()) {
-                return vEdge::one;
-            }
-            const auto& length = stateVector.size();
-            if ((length & (length - 1)) != 0) {
-                throw std::invalid_argument("State vector must have a length of a power of two.");
-            }
-
-            if (length == 1) {
-                return vEdge::terminal(cn.lookup(stateVector[0]));
-            }
-
-            [[maybe_unused]] const auto before = cn.cacheCount();
-
-            const auto level = static_cast<Qubit>(std::log2(length) - 1);
-            auto       state = makeStateFromVector(stateVector.begin(), stateVector.end(), level);
-
-            // the recursive function makes use of the cache, so we have to clean it up
-            if (state.w != Complex::zero) {
-                cn.returnToCache(state.w);
-                state.w = cn.lookup(state.w);
-            }
-
-            [[maybe_unused]] const auto after = cn.cacheCount();
-            assert(after == before);
-            return state;
-        }
-
-        /**
-            Converts a given matrix to a decision diagram
-            @param matrix A complex matrix to convert to a DD.
-            @return An mEdge that represents the DD.
-            @throws std::invalid_argument If the given matrix is not square or its length is not a power of two.
-        **/
-        mEdge makeDDFromMatrix(const CMat& matrix) {
-            if (matrix.empty()) {
-                return mEdge::one;
-            }
-
-            const auto& length = matrix.size();
-            if ((length & (length - 1)) != 0) {
-                throw std::invalid_argument("Matrix must have a length of a power of two.");
-            }
-
-            const auto& width = matrix[0].size();
-            if (length != width) {
-                throw std::invalid_argument("Matrix must be square.");
-            }
-
-            if (length == 1) {
-                return mEdge::terminal(cn.lookup(matrix[0][0]));
-            }
-
-            [[maybe_unused]] const auto before = cn.cacheCount();
-
-            const auto level = static_cast<Qubit>(std::log2(length) - 1);
-
-            auto matrixDD = makeDDFromMatrix(matrix, level, 0, length, 0, width);
-
-            if (matrixDD.w != Complex::zero) {
-                cn.returnToCache(matrixDD.w);
-                matrixDD.w = cn.lookup(matrixDD.w);
-            }
-
-            [[maybe_unused]] const auto after = cn.cacheCount();
-            assert(after == before);
-            return matrixDD;
-        }
-
-        ///
-        /// Matrix nodes, edges and quantum gates
-        ///
-        template<class Node>
-        Edge<Node> normalize(const Edge<Node>& e, bool cached) {
-            if constexpr (std::is_same_v<Node, mNode> || std::is_same_v<Node, dNode>) {
-                auto argmax = -1;
-
-                auto zero = std::array{e.p->e[0].w.approximatelyZero(),
-                                       e.p->e[1].w.approximatelyZero(),
-                                       e.p->e[2].w.approximatelyZero(),
-                                       e.p->e[3].w.approximatelyZero()};
-
-                // make sure to release cached numbers approximately zero, but not exactly zero
-                if (cached) {
-                    for (auto i = 0U; i < NEDGE; i++) {
-                        if (zero[i] && e.p->e[i].w != Complex::zero) {
-                            cn.returnToCache(e.p->e[i].w);
-                            e.p->e[i] = Edge<Node>::zero;
-                        }
-                    }
-                }
-
-                fp   max  = 0;
-                auto maxc = Complex::one;
-                // determine max amplitude
-                for (auto i = 0U; i < NEDGE; ++i) {
-                    if (zero[i]) {
-                        continue;
-                    }
-                    if (argmax == -1) {
-                        argmax = static_cast<decltype(argmax)>(i);
-                        max    = ComplexNumbers::mag2(e.p->e[i].w);
-                        maxc   = e.p->e[i].w;
-                    } else {
-                        auto mag = ComplexNumbers::mag2(e.p->e[i].w);
-                        if (mag - max > ComplexTable<>::tolerance()) {
-                            argmax = static_cast<decltype(argmax)>(i);
-                            max    = mag;
-                            maxc   = e.p->e[i].w;
-                        }
-                    }
-                }
-
-                // all equal to zero
-                if (argmax == -1) {
-                    if (!cached && !e.isTerminal()) {
-                        // If it is not a cached computation, the node has to be put back into the chain
-                        getUniqueTable<Node>().returnNode(e.p);
-                    }
-                    return Edge<Node>::zero;
-                }
-
-                auto r = e;
-                // divide each entry by max
-                for (auto i = 0U; i < NEDGE; ++i) {
-                    if (static_cast<decltype(argmax)>(i) == argmax) {
-                        if (cached) {
-                            if (r.w.exactlyOne()) {
-                                r.w = maxc;
-                            } else {
-                                ComplexNumbers::mul(r.w, r.w, maxc);
-                            }
-                        } else {
-                            if (r.w.exactlyOne()) {
-                                r.w = maxc;
-                            } else {
-                                auto c = cn.getTemporary();
-                                ComplexNumbers::mul(c, r.w, maxc);
-                                r.w = cn.lookup(c);
-                            }
-                        }
-                        r.p->e[i].w = Complex::one;
-                    } else {
-                        if (zero[i]) {
-                            if (cached && r.p->e[i].w != Complex::zero) {
-                                cn.returnToCache(r.p->e[i].w);
-                            }
-                            r.p->e[i] = Edge<Node>::zero;
-                            continue;
-                        }
-                        if (cached && !zero[i] && !r.p->e[i].w.exactlyOne()) {
-                            cn.returnToCache(r.p->e[i].w);
-                        }
-                        if (r.p->e[i].w.approximatelyOne()) {
-                            r.p->e[i].w = Complex::one;
-                        }
-                        auto c = cn.getTemporary();
-                        ComplexNumbers::div(c, r.p->e[i].w, maxc);
-                        r.p->e[i].w = cn.lookup(c);
-                    }
-                }
-                return r;
-            }
-        }
-
-        // build matrix representation for a single gate on an n-qubit circuit
-        mEdge makeGateDD(const std::array<ComplexValue, NEDGE>& mat, QubitCount n, Qubit target, std::size_t start = 0) {
-            return makeGateDD(mat, n, Controls{}, target, start);
-        }
-        mEdge makeGateDD(const std::array<ComplexValue, NEDGE>& mat, QubitCount n, const Control& control, Qubit target, std::size_t start = 0) {
-            return makeGateDD(mat, n, Controls{control}, target, start);
-        }
-        mEdge makeGateDD(const std::array<ComplexValue, NEDGE>& mat, QubitCount n, const Controls& controls, Qubit target, std::size_t start = 0) {
-            if (n + start > nqubits) {
-                throw std::runtime_error{"Requested gate with " +
-                                         std::to_string(n + start) +
-                                         " qubits, but current package configuration only supports up to " +
-                                         std::to_string(nqubits) +
-                                         " qubits. Please allocate a larger package instance."};
-            }
-            std::array<mEdge, NEDGE> em{};
-            auto                     it = controls.begin();
-            for (auto i = 0U; i < NEDGE; ++i) {
-                // NOLINTNEXTLINE(clang-diagnostic-float-equal) it has to be really zero
-                if (mat[i].r == 0 && mat[i].i == 0) {
-                    em[i] = mEdge::zero;
-                } else {
-                    em[i] = mEdge::terminal(cn.lookup(mat[i]));
-                }
-            }
-
-            //process lines below target
-            auto z = static_cast<Qubit>(start);
-            for (; z < target; z++) {
-                for (auto i1 = 0U; i1 < RADIX; i1++) {
-                    for (auto i2 = 0U; i2 < RADIX; i2++) {
-                        auto i = i1 * RADIX + i2;
-                        if (it != controls.end() && it->qubit == z) {
-                            if (it->type == Control::Type::neg) { // neg. control
-                                em[i] = makeDDNode(z, std::array{em[i], mEdge::zero, mEdge::zero, (i1 == i2) ? makeIdent(static_cast<Qubit>(start), static_cast<Qubit>(z - 1)) : mEdge::zero});
-                            } else { // pos. control
-                                em[i] = makeDDNode(z, std::array{(i1 == i2) ? makeIdent(static_cast<Qubit>(start), static_cast<Qubit>(z - 1)) : mEdge::zero, mEdge::zero, mEdge::zero, em[i]});
-                            }
-                        } else { // not connected
-                            em[i] = makeDDNode(z, std::array{em[i], mEdge::zero, mEdge::zero, em[i]});
-                        }
-                    }
-                }
-                if (it != controls.end() && it->qubit == z) {
-                    ++it;
-                }
-            }
-
-            // target line
-            auto e = makeDDNode(z, em);
-
-            //process lines above target
-            for (; z < static_cast<Qubit>(n - 1 + start); z++) {
-                auto q = static_cast<Qubit>(z + 1);
-                if (it != controls.end() && it->qubit == q) {
-                    if (it->type == Control::Type::neg) { // neg. control
-                        e = makeDDNode(q, std::array{e, mEdge::zero, mEdge::zero, makeIdent(static_cast<Qubit>(start), static_cast<Qubit>(q - 1))});
-                    } else { // pos. control
-                        e = makeDDNode(q, std::array{makeIdent(static_cast<Qubit>(start), static_cast<Qubit>(q - 1)), mEdge::zero, mEdge::zero, e});
-                    }
-                    ++it;
-                } else { // not connected
-                    e = makeDDNode(q, std::array{e, mEdge::zero, mEdge::zero, e});
-                }
-            }
-            return e;
-        }
-
-        /**
-        Creates the DD for a two-qubit gate
-        @param mat Matrix representation of the gate
-        @param n Number of qubits in the circuit
-        @param target0 First target qubit
-        @param target1 Second target qubit
-        @param start Start index for the DD
-        @return DD representing the gate
-        @throws std::runtime_error if the number of qubits is larger than the package configuration
-        **/
-        mEdge makeTwoQubitGateDD(const std::array<std::array<ComplexValue, NEDGE>, NEDGE>& mat, const QubitCount n, const Qubit target0, const Qubit target1, const std::size_t start = 0) {
-            // sanity check
-            if (n + start > nqubits) {
-                throw std::runtime_error{"Requested gate with " +
-                                         std::to_string(n + start) +
-                                         " qubits, but current package configuration only supports up to " +
-                                         std::to_string(nqubits) +
-                                         " qubits. Please allocate a larger package instance."};
-            }
-
-            // create terminal edge matrix
-            std::array<std::array<mEdge, NEDGE>, NEDGE> em{};
-            for (auto i1 = 0U; i1 < NEDGE; i1++) {
-                const auto& matRow = mat.at(i1);
-                auto&       emRow  = em.at(i1);
-                for (auto i2 = 0U; i2 < NEDGE; i2++) {
-                    const auto& matEntry = matRow.at(i2);
-                    auto&       emEntry  = emRow.at(i2);
-                    // NOLINTNEXTLINE(clang-diagnostic-float-equal) it has to be really zero
-                    if (matEntry.r == 0 && matEntry.i == 0) {
-                        emEntry = mEdge::zero;
-                    } else {
-                        emEntry = mEdge::terminal(cn.lookup(matEntry));
-                    }
-                }
-            }
-
-            // process lines below smaller target (by creating identity structures)
-            auto       z             = static_cast<Qubit>(start);
-            const auto smallerTarget = std::min(target0, target1);
-            for (; z < smallerTarget; ++z) {
-                for (auto& row: em) {
-                    for (auto& entry: row) {
-                        entry = makeDDNode(z, std::array{entry, mEdge::zero, mEdge::zero, entry});
-                    }
-                }
-            }
-
-            // process the smaller target by taking the 16 submatrices and appropriately combining them into four DDs.
-            std::array<mEdge, NEDGE> em0{};
-            for (std::size_t row = 0; row < RADIX; ++row) {
-                for (std::size_t col = 0; col < RADIX; ++col) {
-                    std::array<mEdge, NEDGE> local{};
-                    if (target0 > target1) {
-                        for (std::size_t i = 0; i < RADIX; ++i) {
-                            for (std::size_t j = 0; j < RADIX; ++j) {
-                                local.at(i * RADIX + j) = em.at(row * RADIX + i).at(col * RADIX + j);
-                            }
-                        }
-                    } else {
-                        for (std::size_t i = 0; i < RADIX; ++i) {
-                            for (std::size_t j = 0; j < RADIX; ++j) {
-                                local.at(i * RADIX + j) = em.at(i * RADIX + row).at(j * RADIX + col);
-                            }
-                        }
-                    }
-                    em0.at(row * RADIX + col) = makeDDNode(z, local);
-                }
-            }
-
-            // process lines between the two targets (by creating identity structures)
-            for (++z; z < std::max(target0, target1); ++z) {
-                for (auto& entry: em0) {
-                    entry = makeDDNode(z, std::array{entry, mEdge::zero, mEdge::zero, entry});
-                }
-            }
-
-            // process the larger target by combining the four DDs from the smaller target
-            auto e = makeDDNode(z, em0);
-
-            // process lines above the larger target (by creating identity structures)
-            for (++z; z < static_cast<Qubit>(n + start); ++z) {
-                e = makeDDNode(z, std::array{e, mEdge::zero, mEdge::zero, e});
-            }
-
-            return e;
-        }
-
-        mEdge makeSWAPDD(const QubitCount n, const Qubit target0, const Qubit target1, const std::size_t start = 0) {
-            return makeTwoQubitGateDD(SWAPmat, n, target0, target1, start);
-        }
-        mEdge makeSWAPDD(const QubitCount n, const Controls& controls, const Qubit target0, const Qubit target1, const std::size_t start = 0) {
-            auto c = controls;
-            c.insert(Control{target0});
-            mEdge e = makeGateDD(Xmat, n, c, target1, start);
-            c.erase(Control{target0});
-            c.insert(Control{target1});
-            e = multiply(e, multiply(makeGateDD(Xmat, n, c, target0, start), e));
-            return e;
-        }
-
-        mEdge makePeresDD(const QubitCount n, const Controls& controls, const Qubit target0, const Qubit target1, const std::size_t start = 0) {
-            auto c = controls;
-            c.insert(Control{target1});
-            mEdge e = makeGateDD(Xmat, n, c, target0, start);
-            e       = multiply(makeGateDD(Xmat, n, controls, target1, start), e);
-            return e;
-        }
-
-        mEdge makePeresdagDD(const QubitCount n, const Controls& controls, const Qubit target0, const Qubit target1, const std::size_t start = 0) {
-            mEdge e = makeGateDD(Xmat, n, controls, target1, start);
-            auto  c = controls;
-            c.insert(Control{target1});
-            e = multiply(makeGateDD(Xmat, n, c, target0, start), e);
-            return e;
-        }
-
-        mEdge makeiSWAPDD(const QubitCount n, const Qubit target0, const Qubit target1, const std::size_t start = 0) {
-            return makeTwoQubitGateDD(iSWAPmat, n, target0, target1, start);
-        }
-        mEdge makeiSWAPDD(const QubitCount n, const Controls& controls, const Qubit target0, const Qubit target1, const std::size_t start = 0) {
-            mEdge e = makeGateDD(Smat, n, controls, target1, start);              // S q[1]
-            e       = multiply(e, makeGateDD(Smat, n, controls, target0, start)); // S q[0]
-            e       = multiply(e, makeGateDD(Hmat, n, controls, target0, start)); // H q[0]
-            auto c  = controls;
-            c.insert(Control{target0});
-            e = multiply(e, makeGateDD(Xmat, n, c, target1, start)); // CX q[0], q[1]
-            c.erase(Control{target0});
-            c.insert(Control{target1});
-            e = multiply(e, makeGateDD(Xmat, n, c, target0, start));        // CX q[1], q[0]
-            e = multiply(e, makeGateDD(Hmat, n, controls, target1, start)); // H q[1]
-            return e;
-        }
-
-        mEdge makeiSWAPinvDD(const QubitCount n, const Qubit target0, const Qubit target1, const std::size_t start = 0) {
-            return makeTwoQubitGateDD(iSWAPinvmat, n, target0, target1, start);
-        }
-        mEdge makeiSWAPinvDD(const QubitCount n, const Controls& controls, const Qubit target0, const Qubit target1, const std::size_t start = 0) {
-            mEdge e = makeGateDD(Hmat, n, controls, target1, start); // H q[1]
-            auto  c = controls;
-            c.insert(Control{target1});
-            e = multiply(e, makeGateDD(Xmat, n, c, target0, start)); // CX q[1], q[0]
-            c.erase(Control{target1});
-            c.insert(Control{target0});
-            e = multiply(e, makeGateDD(Xmat, n, c, target1, start));           // CX q[0], q[1]
-            e = multiply(e, makeGateDD(Hmat, n, controls, target0, start));    // H q[0]
-            e = multiply(e, makeGateDD(Sdagmat, n, controls, target0, start)); // Sdag q[0]
-            e = multiply(e, makeGateDD(Sdagmat, n, controls, target1, start)); // Sdag q[1]
-            return e;
-        }
-
-        mEdge makeDCXDD(const QubitCount n, const Qubit target0, const Qubit target1, const std::size_t start = 0) {
-            return makeTwoQubitGateDD(DCXmat, n, target0, target1, start);
-        }
-        mEdge makeDCXDD(const QubitCount n, const Controls& controls, const Qubit target0, const Qubit target1, const std::size_t start = 0) {
-            auto c = controls;
-            c.insert(Control{target0});
-            mEdge e = makeGateDD(Xmat, n, c, target1, start);
-            c.erase(Control{target0});
-            c.insert(Control{target1});
-            e = multiply(e, makeGateDD(Xmat, n, c, target0, start));
-            return e;
-        }
-
-        mEdge makeRZZDD(const QubitCount n, const Qubit target0, const Qubit target1, const fp theta, const std::size_t start = 0) {
-            return makeTwoQubitGateDD(RZZmat(theta), n, target0, target1, start);
-        }
-        mEdge makeRZZDD(const QubitCount n, const Controls& controls, const Qubit target0, const Qubit target1, const fp theta, const std::size_t start = 0) {
-            auto c = controls;
-            c.insert(Control{target0});
-            auto e = makeGateDD(Xmat, n, c, target1, start);
-            c.erase(Control{target0});
-            e = multiply(e, makeGateDD(RZmat(theta), n, c, target1, start));
-            c.insert(Control{target0});
-            e = multiply(e, makeGateDD(Xmat, n, c, target1, start));
-            return e;
-        }
-
-        mEdge makeRYYDD(const QubitCount n, const Qubit target0, const Qubit target1, const fp theta, const std::size_t start = 0) {
-            return makeTwoQubitGateDD(RYYmat(theta), n, target0, target1, start);
-        }
-        mEdge makeRYYDD(const QubitCount n, const Controls& controls, const Qubit target0, const Qubit target1, const fp theta, const std::size_t start = 0) {
-            // no controls are necessary on the RX gates since they cancel if the controls are 0.
-            auto e = makeGateDD(RXmat(PI_2), n, Controls{}, target0, start);
-            e      = multiply(e, makeGateDD(RXmat(PI_2), n, Controls{}, target1, start));
-            e      = multiply(e, makeRZZDD(n, controls, target0, target1, theta, start));
-            e      = multiply(e, makeGateDD(RXmat(-PI_2), n, Controls{}, target1, start));
-            e      = multiply(e, makeGateDD(RXmat(-PI_2), n, Controls{}, target0, start));
-            return e;
-        }
-
-        mEdge makeRXXDD(const QubitCount n, const Qubit target0, const Qubit target1, const fp theta, const std::size_t start = 0) {
-            return makeTwoQubitGateDD(RXXmat(theta), n, target0, target1, start);
-        }
-        mEdge makeRXXDD(const QubitCount n, const Controls& controls, const Qubit target0, const Qubit target1, const fp theta, const std::size_t start = 0) {
-            // no controls are necessary on the H gates since they cancel if the controls are 0.
-            auto e = makeGateDD(Hmat, n, Controls{}, target0, start);
-            e      = multiply(e, makeGateDD(Hmat, n, Controls{}, target1, start));
-            e      = multiply(e, makeRZZDD(n, controls, target0, target1, theta, start));
-            e      = multiply(e, makeGateDD(Hmat, n, Controls{}, target1, start));
-            e      = multiply(e, makeGateDD(Hmat, n, Controls{}, target0, start));
-            return e;
-        }
-
-        mEdge makeRZXDD(const QubitCount n, const Qubit target0, const Qubit target1, const fp theta, const std::size_t start = 0) {
-            return makeTwoQubitGateDD(RZXmat(theta), n, target0, target1, start);
-        }
-        mEdge makeRZXDD(const QubitCount n, const Controls& controls, const Qubit target0, const Qubit target1, const fp theta, const std::size_t start = 0) {
-            // no controls are necessary on the H gates since they cancel if the controls are 0.
-            auto e = makeGateDD(Hmat, n, Controls{}, target1, start);
-            e      = multiply(e, makeRZZDD(n, controls, target0, target1, theta, start));
-            e      = multiply(e, makeGateDD(Hmat, n, Controls{}, target1, start));
-            return e;
-        }
-
-        mEdge makeECRDD(const QubitCount n, const Qubit target0, const Qubit target1, const std::size_t start = 0) {
-            return makeTwoQubitGateDD(ECRmat, n, target0, target1, start);
-        }
-        mEdge makeECRDD(const QubitCount n, const Controls& controls, const Qubit target0, const Qubit target1, const std::size_t start = 0) {
-            auto e = makeRZXDD(n, controls, target0, target1, -PI_4, start);
-            e      = multiply(e, makeGateDD(Xmat, n, controls, target0, start));
-            e      = multiply(e, makeRZXDD(n, controls, target0, target1, PI_4, start));
-            return e;
-        }
-
-        mEdge makeXXMinusYYDD(const QubitCount n, const Qubit target0, const Qubit target1, const fp theta, const fp beta = 0., const std::size_t start = 0) {
-            return makeTwoQubitGateDD(XXMinusYYmat(theta, beta), n, target0, target1, start);
-        }
-        mEdge makeXXMinusYYDD(const QubitCount n, const Controls& controls, const Qubit target0, const Qubit target1, const fp theta, const fp beta = 0., const std::size_t start = 0) {
-            auto e = makeGateDD(RZmat(-beta), n, Controls{}, target1, start);
-            e      = multiply(e, makeGateDD(RZmat(-PI_2), n, Controls{}, target0, start));
-            e      = multiply(e, makeGateDD(SXmat, n, Controls{}, target0, start));
-            e      = multiply(e, makeGateDD(RZmat(PI_2), n, Controls{}, target0, start));
-            e      = multiply(e, makeGateDD(Smat, n, Controls{}, target1, start));
-            e      = multiply(e, makeGateDD(Xmat, n, Control{target0}, target1, start));
-            // only the following two gates need to be controlled by the controls since the other gates cancel if the controls are 0.
-            e = multiply(e, makeGateDD(RYmat(-theta / 2.), n, controls, target0, start));
-            e = multiply(e, makeGateDD(RYmat(theta / 2.), n, controls, target1, start));
-
-            e = multiply(e, makeGateDD(Xmat, n, Control{target0}, target1, start));
-            e = multiply(e, makeGateDD(Sdagmat, n, Controls{}, target1, start));
-            e = multiply(e, makeGateDD(RZmat(-PI_2), n, Controls{}, target0, start));
-            e = multiply(e, makeGateDD(SXdagmat, n, Controls{}, target0, start));
-            e = multiply(e, makeGateDD(RZmat(PI_2), n, Controls{}, target0, start));
-            e = multiply(e, makeGateDD(RZmat(beta), n, Controls{}, target1, start));
-            return e;
-        }
-
-        mEdge makeXXPlusYYDD(const QubitCount n, const Qubit target0, const Qubit target1, const fp theta, const fp beta = 0., const std::size_t start = 0) {
-            return makeTwoQubitGateDD(XXPlusYYmat(theta, beta), n, target0, target1, start);
-        }
-        mEdge makeXXPlusYYDD(const QubitCount n, const Controls& controls, const Qubit target0, const Qubit target1, const fp theta, const fp beta = 0., const std::size_t start = 0) {
-            auto e = makeGateDD(RZmat(beta), n, Controls{}, target1, start);
-            e      = multiply(e, makeGateDD(RZmat(-PI_2), n, Controls{}, target0, start));
-            e      = multiply(e, makeGateDD(SXmat, n, Controls{}, target0, start));
-            e      = multiply(e, makeGateDD(RZmat(PI_2), n, Controls{}, target0, start));
-            e      = multiply(e, makeGateDD(Smat, n, Controls{}, target1, start));
-            e      = multiply(e, makeGateDD(Xmat, n, Control{target0}, target1, start));
-            // only the following two gates need to be controlled by the controls since the other gates cancel if the controls are 0.
-            e = multiply(e, makeGateDD(RYmat(theta / 2.), n, controls, target0, start));
-            e = multiply(e, makeGateDD(RYmat(theta / 2.), n, controls, target1, start));
-
-            e = multiply(e, makeGateDD(Xmat, n, Control{target0}, target1, start));
-            e = multiply(e, makeGateDD(Sdagmat, n, Controls{}, target1, start));
-            e = multiply(e, makeGateDD(RZmat(-PI_2), n, Controls{}, target0, start));
-            e = multiply(e, makeGateDD(SXdagmat, n, Controls{}, target0, start));
-            e = multiply(e, makeGateDD(RZmat(PI_2), n, Controls{}, target0, start));
-            e = multiply(e, makeGateDD(RZmat(-beta), n, Controls{}, target1, start));
-            return e;
-        }
-
-    private:
-        // check whether node represents a symmetric matrix or the identity
-        void checkSpecialMatrices(mNode* p) {
-            if (p->v == -1) {
-                return;
-            }
-
-            p->setIdentity(false);
-            p->setSymmetric(false);
-
-            // check if matrix is symmetric
-            if (!p->e[0].p->isSymmetric() || !p->e[3].p->isSymmetric()) {
-                return;
-            }
-            if (transpose(p->e[1]) != p->e[2]) {
-                return;
-            }
-            p->setSymmetric(true);
-
-            // check if matrix resembles identity
-            if (!(p->e[0].p->isIdentity()) || (p->e[1].w) != Complex::zero || (p->e[2].w) != Complex::zero || (p->e[0].w) != Complex::one || (p->e[3].w) != Complex::one || !(p->e[3].p->isIdentity())) {
-                return;
-            }
-            p->setIdentity(true);
-        }
-
-        vEdge makeStateFromVector(const CVec::const_iterator& begin,
-                                  const CVec::const_iterator& end,
-                                  const Qubit                 level) {
-            if (level == 0) {
-                assert(std::distance(begin, end) == 2);
-                const auto& zeroWeight    = cn.getCached(begin->real(), begin->imag());
-                const auto& oneWeight     = cn.getCached(std::next(begin)->real(), std::next(begin)->imag());
-                const auto  zeroSuccessor = vEdge{vNode::terminal, zeroWeight};
-                const auto  oneSuccessor  = vEdge{vNode::terminal, oneWeight};
-                return makeDDNode<vNode>(0, {zeroSuccessor, oneSuccessor}, true);
-            }
-
-            const auto half          = std::distance(begin, end) / 2;
-            const auto zeroSuccessor = makeStateFromVector(begin, begin + half, level - 1);
-            const auto oneSuccessor  = makeStateFromVector(begin + half, end, level - 1);
-            return makeDDNode<vNode>(level, {zeroSuccessor, oneSuccessor}, true);
-        }
-
-        /**
-        Constructs a decision diagram (DD) from a complex matrix using a recursive algorithm.
-        @param matrix The complex matrix from which to create the DD.
-        @param level The current level of recursion. Starts at the highest level of the matrix (log base 2 of the matrix size - 1).
-        @param rowStart The starting row of the quadrant being processed.
-        @param rowEnd The ending row of the quadrant being processed.
-        @param colStart The starting column of the quadrant being processed.
-        @param colEnd The ending column of the quadrant being processed.
-        @return An mEdge representing the root node of the created DD.
-        @throw std::invalid_argument If level is negative.
-        @details This function recursively breaks down the matrix into quadrants until each quadrant has only one element.
-        At each level of recursion, four new edges are created, one for each quadrant of the matrix.
-        The four resulting decision diagram edges are used to create a new decision diagram node at the current level,
-        and this node is returned as the result of the current recursive call.
-        At the base case of recursion, the matrix has only one element, which is converted into a terminal node of the decision diagram.
-        @note This function assumes that the matrix size is a power of two.
-        **/
-        mEdge makeDDFromMatrix(const CMat& matrix, const Qubit level,
-                               const std::size_t rowStart, const std::size_t rowEnd,
-                               const std::size_t colStart, const std::size_t colEnd) {
-            // base case
-            if (level == -1) {
-                assert(rowEnd - rowStart == 1);
-                assert(colEnd - colStart == 1);
-                return {mNode::terminal, cn.getCached(matrix[rowStart][colStart])};
-            }
-
-            // recursively call the function on all quadrants
-            const auto rowMid = (rowStart + rowEnd) / 2;
-            const auto colMid = (colStart + colEnd) / 2;
-
-            const auto edge0 =
-                    makeDDFromMatrix(matrix, level - 1, rowStart, rowMid, colStart, colMid);
-            const auto edge1 =
-                    makeDDFromMatrix(matrix, level - 1, rowStart, rowMid, colMid, colEnd);
-            const auto edge2 =
-                    makeDDFromMatrix(matrix, level - 1, rowMid, rowEnd, colStart, colMid);
-            const auto edge3 =
-                    makeDDFromMatrix(matrix, level - 1, rowMid, rowEnd, colMid, colEnd);
-
-            return makeDDNode<mNode>(level, {edge0, edge1, edge2, edge3}, true);
-        }
-
-        ///
-        /// Unique tables, Reference counting and garbage collection
-        ///
-    public:
-        // unique tables
-        template<class Node>
-        [[nodiscard]] auto& getUniqueTable() {
-            if constexpr (std::is_same_v<Node, vNode>) {
-                return vUniqueTable;
-            } else if constexpr (std::is_same_v<Node, mNode>) {
-                return mUniqueTable;
-            } else if constexpr (std::is_same_v<Node, dNode>) {
-                return dUniqueTable;
-            }
-        }
-
-        template<class Node>
-        void incRef(const Edge<Node>& e) {
-            getUniqueTable<Node>().incRef(e);
-        }
-        template<class Node>
-        void decRef(const Edge<Node>& e) {
-            getUniqueTable<Node>().decRef(e);
-        }
-
-        UniqueTable<vNode, Config::UT_VEC_NBUCKET, Config::UT_VEC_INITIAL_ALLOCATION_SIZE> vUniqueTable{nqubits};
-        UniqueTable<mNode, Config::UT_MAT_NBUCKET, Config::UT_MAT_INITIAL_ALLOCATION_SIZE> mUniqueTable{nqubits};
-        UniqueTable<dNode, Config::UT_DM_NBUCKET, Config::UT_DM_INITIAL_ALLOCATION_SIZE>   dUniqueTable{nqubits};
-
-        bool garbageCollect(bool force = false) {
-            // return immediately if no table needs collection
-            if (!force &&
-                !vUniqueTable.possiblyNeedsCollection() &&
-                !mUniqueTable.possiblyNeedsCollection() &&
-                !dUniqueTable.possiblyNeedsCollection() &&
-                !cn.complexTable.possiblyNeedsCollection()) {
-                return false;
-            }
-
-            auto cCollect = cn.garbageCollect(force);
-            if (cCollect > 0) {
-                // Collecting garbage in the complex numbers table requires collecting the node tables as well
-                force = true;
-            }
-            auto vCollect = vUniqueTable.garbageCollect(force);
-            auto mCollect = mUniqueTable.garbageCollect(force);
-            auto dCollect = dUniqueTable.garbageCollect(force);
-
-            // invalidate all compute tables involving vectors if any vector node has been collected
-            if (vCollect > 0) {
-                vectorAdd.clear();
-                vectorInnerProduct.clear();
-                vectorKronecker.clear();
-                matrixVectorMultiplication.clear();
-            }
-            // invalidate all compute tables involving matrices if any matrix node has been collected
-            if (mCollect > 0 || dCollect > 0) {
-                matrixAdd.clear();
-                matrixTranspose.clear();
-                conjugateMatrixTranspose.clear();
-                matrixKronecker.clear();
-                matrixVectorMultiplication.clear();
-                matrixMatrixMultiplication.clear();
-                toffoliTable.clear();
-                clearIdentityTable();
-                stochasticNoiseOperationCache.clear();
-                densityAdd.clear();
-                densityDensityMultiplication.clear();
-                densityNoise.clear();
-            }
-            // invalidate all compute tables where any component of the entry contains numbers from the complex table if any complex numbers were collected
-            if (cCollect > 0) {
-                matrixVectorMultiplication.clear();
-                matrixMatrixMultiplication.clear();
-                matrixTranspose.clear();
-                conjugateMatrixTranspose.clear();
-                vectorInnerProduct.clear();
-                vectorKronecker.clear();
-                matrixKronecker.clear();
-                stochasticNoiseOperationCache.clear();
-                densityAdd.clear();
-                densityDensityMultiplication.clear();
-                densityNoise.clear();
-            }
-            return vCollect > 0 || mCollect > 0 || cCollect > 0;
-        }
-
-        void clearUniqueTables() {
-            vUniqueTable.clear();
-            mUniqueTable.clear();
-            dUniqueTable.clear();
-        }
-
-        // create a normalized DD node and return an edge pointing to it. The node is not recreated if it already exists.
-        template<class Node>
-        Edge<Node> makeDDNode(Qubit var, const std::array<Edge<Node>, std::tuple_size_v<decltype(Node::e)>>& edges, bool cached = false, [[maybe_unused]] const bool generateDensityMatrix = false) {
-            auto&      uniqueTable = getUniqueTable<Node>();
-            Edge<Node> e{uniqueTable.getNode(), Complex::one};
-            e.p->v = var;
-            e.p->e = edges;
-
-            if constexpr (std::is_same_v<Node, mNode> || std::is_same_v<Node, dNode>) {
-                e.p->flags = 0;
-                if constexpr (std::is_same_v<Node, dNode>) {
-                    e.p->setDensityMatrixNodeFlag(generateDensityMatrix);
-                }
-            }
-
-            assert(e.p->ref == 0);
-            for ([[maybe_unused]] const auto& edge: edges) {
-                // an error here indicates that cached nodes are assigned multiple times. Check if garbage collect correctly resets the cache tables!
-                assert(edge.p->v == var - 1 || edge.isTerminal());
-            }
-
-            // normalize it
-            e = normalize(e, cached);
-            assert(e.p->v == var || e.isTerminal());
-
-            // look it up in the unique tables
-            auto l = uniqueTable.lookup(e, false);
-            assert(l.p->v == var || l.isTerminal());
-
-            // set specific node properties for matrices
-            if constexpr (std::is_same_v<Node, mNode>) {
-                if (l.p == e.p) {
-                    checkSpecialMatrices(l.p);
-                }
-            }
-            return l;
-        }
-
-        template<class Node>
-        Edge<Node> deleteEdge(const Edge<Node>& e, dd::Qubit v, std::size_t edgeIdx) {
-            std::unordered_map<Node*, Edge<Node>> nodes{};
-            return deleteEdge(e, v, edgeIdx, nodes);
-        }
-
-    private:
-        template<class Node>
-        Edge<Node> deleteEdge(const Edge<Node>& e, dd::Qubit v, std::size_t edgeIdx, std::unordered_map<Node*, Edge<Node>>& nodes) {
-            if (e.p == nullptr || e.isTerminal()) {
-                return e;
-            }
-
-            const auto& nodeit = nodes.find(e.p);
-            Edge<Node>  newedge{};
-            if (nodeit != nodes.end()) {
-                newedge = nodeit->second;
-            } else {
-                constexpr std::size_t     n = std::tuple_size_v<decltype(e.p->e)>;
-                std::array<Edge<Node>, n> edges{};
-                if (e.p->v == v) {
-                    for (std::size_t i = 0; i < n; i++) {
-                        edges[i] = i == edgeIdx ? Edge<Node>::zero : e.p->e[i]; // optimization -> node cannot occur below again, since dd is assumed to be free
-                    }
-                } else {
-                    for (std::size_t i = 0; i < n; i++) {
-                        edges[i] = deleteEdge(e.p->e[i], v, edgeIdx, nodes);
-                    }
-                }
-
-                newedge    = makeDDNode(e.p->v, edges);
-                nodes[e.p] = newedge;
-            }
-
-            if (newedge.w.approximatelyOne()) {
-                newedge.w = e.w;
+struct DDPackageConfig {
+  // Note the order of parameters here must be the *same* as in the template
+  // definition.
+  static constexpr std::size_t UT_VEC_NBUCKET = 32768U;
+  static constexpr std::size_t UT_VEC_INITIAL_ALLOCATION_SIZE = 2048U;
+  static constexpr std::size_t UT_MAT_NBUCKET = 32768U;
+  static constexpr std::size_t UT_MAT_INITIAL_ALLOCATION_SIZE = 2048U;
+  static constexpr std::size_t CT_VEC_ADD_NBUCKET = 16384U;
+  static constexpr std::size_t CT_MAT_ADD_NBUCKET = 16384U;
+  static constexpr std::size_t CT_MAT_TRANS_NBUCKET = 4096U;
+  static constexpr std::size_t CT_MAT_CONJ_TRANS_NBUCKET = 4096U;
+  static constexpr std::size_t CT_MAT_VEC_MULT_NBUCKET = 16384U;
+  static constexpr std::size_t CT_MAT_MAT_MULT_NBUCKET = 16384U;
+  static constexpr std::size_t CT_VEC_KRON_NBUCKET = 4096U;
+  static constexpr std::size_t CT_MAT_KRON_NBUCKET = 4096U;
+  static constexpr std::size_t CT_VEC_INNER_PROD_NBUCKET = 4096U;
+  static constexpr std::size_t CT_DM_NOISE_NBUCKET = 1U;
+  static constexpr std::size_t UT_DM_NBUCKET = 1U;
+  static constexpr std::size_t UT_DM_INITIAL_ALLOCATION_SIZE = 1U;
+  static constexpr std::size_t CT_DM_DM_MULT_NBUCKET = 1U;
+  static constexpr std::size_t CT_DM_ADD_NBUCKET = 1U;
+
+  // The number of different quantum operations. I.e., the number of operations
+  // defined in the QFR OpType.hpp This parameter is required to initialize the
+  // StochasticNoiseOperationTable.hpp
+  static constexpr std::size_t STOCHASTIC_CACHE_OPS = 1;
+};
+
+template <class Config = DDPackageConfig> class Package {
+  static_assert(std::is_base_of_v<DDPackageConfig, Config>,
+                "Config must be derived from DDPackageConfig");
+  ///
+  /// Complex number handling
+  ///
+public:
+  ComplexNumbers cn{};
+
+  ///
+  /// Construction, destruction, information and reset
+  ///
+
+  static constexpr std::size_t MAX_POSSIBLE_QUBITS =
+      static_cast<std::make_unsigned_t<Qubit>>(
+          std::numeric_limits<Qubit>::max()) +
+      1U;
+  static constexpr std::size_t DEFAULT_QUBITS = 128;
+  explicit Package(std::size_t nq = DEFAULT_QUBITS) : nqubits(nq) {
+    resize(nq);
+  };
+  ~Package() = default;
+  Package(const Package& package) = delete;
+
+  Package& operator=(const Package& package) = delete;
+
+  // resize the package instance
+  void resize(std::size_t nq) {
+    if (nq > MAX_POSSIBLE_QUBITS) {
+      throw std::invalid_argument("Requested too many qubits from package. "
+                                  "Qubit datatype only allows up to " +
+                                  std::to_string(MAX_POSSIBLE_QUBITS) +
+                                  " qubits, while " + std::to_string(nq) +
+                                  " were requested. Please recompile the "
+                                  "package with a wider Qubit type!");
+    }
+    nqubits = nq;
+    vUniqueTable.resize(nqubits);
+    mUniqueTable.resize(nqubits);
+    dUniqueTable.resize(nqubits);
+    stochasticNoiseOperationCache.resize(nqubits);
+    idTable.resize(nqubits);
+  }
+
+  // reset package state
+  void reset() {
+    clearUniqueTables();
+    clearComputeTables();
+    cn.clear();
+  }
+
+  // getter for qubits
+  [[nodiscard]] auto qubits() const { return nqubits; }
+
+private:
+  std::size_t nqubits;
+
+  ///
+  /// Vector nodes, edges and quantum states
+  ///
+public:
+  vEdge normalize(const vEdge& e, bool cached) {
+    auto zero = std::array{e.p->e[0].w.approximatelyZero(),
+                           e.p->e[1].w.approximatelyZero()};
+
+    // make sure to release cached numbers approximately zero, but not exactly
+    // zero
+    if (cached) {
+      for (auto i = 0U; i < RADIX; i++) {
+        if (zero[i] && e.p->e[i].w != Complex::zero) {
+          cn.returnToCache(e.p->e[i].w);
+          e.p->e[i] = vEdge::zero;
+        }
+      }
+    }
+
+    if (zero[0]) {
+      // all equal to zero
+      if (zero[1]) {
+        if (!cached && !e.isTerminal()) {
+          // If it is not a cached computation, the node has to be put back into
+          // the chain
+          vUniqueTable.returnNode(e.p);
+        }
+        return vEdge::zero;
+      }
+
+      auto r = e;
+      auto& w = r.p->e[1].w;
+      if (cached && !w.exactlyOne()) {
+        r.w = w;
+      } else {
+        r.w = cn.lookup(w);
+      }
+      w = Complex::one;
+      return r;
+    }
+
+    if (zero[1]) {
+      auto r = e;
+      auto& w = r.p->e[0].w;
+      if (cached && !w.exactlyOne()) {
+        r.w = w;
+      } else {
+        r.w = cn.lookup(w);
+      }
+      w = Complex::one;
+      return r;
+    }
+
+    const auto mag0 = ComplexNumbers::mag2(e.p->e[0].w);
+    const auto mag1 = ComplexNumbers::mag2(e.p->e[1].w);
+    const auto norm2 = mag0 + mag1;
+    const auto mag2Max =
+        (mag0 + ComplexTable<>::tolerance() >= mag1) ? mag0 : mag1;
+    const auto argMax = (mag0 + ComplexTable<>::tolerance() >= mag1) ? 0 : 1;
+    const auto norm = std::sqrt(norm2);
+    const auto magMax = std::sqrt(mag2Max);
+    const auto commonFactor = norm / magMax;
+
+    auto r = e;
+    auto& max = r.p->e[static_cast<std::size_t>(argMax)];
+    if (cached && !max.w.exactlyOne()) {
+      r.w = max.w;
+      r.w.r->value *= commonFactor;
+      r.w.i->value *= commonFactor;
+    } else {
+      r.w = cn.lookup(CTEntry::val(max.w.r) * commonFactor,
+                      CTEntry::val(max.w.i) * commonFactor);
+      if (r.w.approximatelyZero()) {
+        return vEdge::zero;
+      }
+    }
+
+    max.w = cn.lookup(magMax / norm, 0.);
+    if (max.w == Complex::zero) {
+      max = vEdge::zero;
+    }
+
+    const auto argMin = (argMax + 1) % 2;
+    auto& min = r.p->e[static_cast<std::size_t>(argMin)];
+    if (cached) {
+      cn.returnToCache(min.w);
+      ComplexNumbers::div(min.w, min.w, r.w);
+      min.w = cn.lookup(min.w);
+    } else {
+      auto c = cn.getTemporary();
+      ComplexNumbers::div(c, min.w, r.w);
+      min.w = cn.lookup(c);
+    }
+    if (min.w == Complex::zero) {
+      min = vEdge::zero;
+    }
+
+    return r;
+  }
+
+  dEdge makeZeroDensityOperator(QubitCount n) {
+    auto f = dEdge::one;
+    for (std::size_t p = 0; p < n; p++) {
+      f = makeDDNode(static_cast<Qubit>(p),
+                     std::array{f, dEdge::zero, dEdge::zero, dEdge::zero});
+    }
+    return f;
+  }
+
+  // generate |0...0> with n qubits
+  vEdge makeZeroState(QubitCount n, std::size_t start = 0) {
+    if (n + start > nqubits) {
+      throw std::runtime_error{
+          "Requested state with " + std::to_string(n + start) +
+          " qubits, but current package configuration only supports up to " +
+          std::to_string(nqubits) +
+          " qubits. Please allocate a larger package instance."};
+    }
+    auto f = vEdge::one;
+    for (std::size_t p = start; p < n + start; p++) {
+      f = makeDDNode(static_cast<Qubit>(p), std::array{f, vEdge::zero});
+    }
+    return f;
+  }
+  // generate computational basis state |i> with n qubits
+  vEdge makeBasisState(QubitCount n, const std::vector<bool>& state,
+                       std::size_t start = 0) {
+    if (n + start > nqubits) {
+      throw std::runtime_error{
+          "Requested state with " + std::to_string(n + start) +
+          " qubits, but current package configuration only supports up to " +
+          std::to_string(nqubits) +
+          " qubits. Please allocate a larger package instance."};
+    }
+    auto f = vEdge::one;
+    for (std::size_t p = start; p < n + start; ++p) {
+      if (!state[p]) {
+        f = makeDDNode(static_cast<Qubit>(p), std::array{f, vEdge::zero});
+      } else {
+        f = makeDDNode(static_cast<Qubit>(p), std::array{vEdge::zero, f});
+      }
+    }
+    return f;
+  }
+  // generate general basis state with n qubits
+  vEdge makeBasisState(QubitCount n, const std::vector<BasisStates>& state,
+                       std::size_t start = 0) {
+    if (n + start > nqubits) {
+      throw std::runtime_error{
+          "Requested state with " + std::to_string(n + start) +
+          " qubits, but current package configuration only supports up to " +
+          std::to_string(nqubits) +
+          " qubits. Please allocate a larger package instance."};
+    }
+    if (state.size() < n) {
+      throw std::runtime_error(
+          "Insufficient qubit states provided. Requested " + std::to_string(n) +
+          ", but received " + std::to_string(state.size()));
+    }
+
+    auto f = vEdge::one;
+    for (std::size_t p = start; p < n + start; ++p) {
+      switch (state[p]) {
+      case BasisStates::zero:
+        f = makeDDNode(static_cast<Qubit>(p), std::array{f, vEdge::zero});
+        break;
+      case BasisStates::one:
+        f = makeDDNode(static_cast<Qubit>(p), std::array{vEdge::zero, f});
+        break;
+      case BasisStates::plus:
+        f = makeDDNode(
+            static_cast<Qubit>(p),
+            std::array<vEdge, RADIX>{{{f.p, cn.lookup(dd::SQRT2_2, 0)},
+                                      {f.p, cn.lookup(dd::SQRT2_2, 0)}}});
+        break;
+      case BasisStates::minus:
+        f = makeDDNode(
+            static_cast<Qubit>(p),
+            std::array<vEdge, RADIX>{{{f.p, cn.lookup(dd::SQRT2_2, 0)},
+                                      {f.p, cn.lookup(-dd::SQRT2_2, 0)}}});
+        break;
+      case BasisStates::right:
+        f = makeDDNode(
+            static_cast<Qubit>(p),
+            std::array<vEdge, RADIX>{{{f.p, cn.lookup(dd::SQRT2_2, 0)},
+                                      {f.p, cn.lookup(0, dd::SQRT2_2)}}});
+        break;
+      case BasisStates::left:
+        f = makeDDNode(
+            static_cast<Qubit>(p),
+            std::array<vEdge, RADIX>{{{f.p, cn.lookup(dd::SQRT2_2, 0)},
+                                      {f.p, cn.lookup(0, -dd::SQRT2_2)}}});
+        break;
+      }
+    }
+    return f;
+  }
+
+  // generate the decision diagram from an arbitrary state vector
+  vEdge makeStateFromVector(const CVec& stateVector) {
+    if (stateVector.empty()) {
+      return vEdge::one;
+    }
+    const auto& length = stateVector.size();
+    if ((length & (length - 1)) != 0) {
+      throw std::invalid_argument(
+          "State vector must have a length of a power of two.");
+    }
+
+    if (length == 1) {
+      return vEdge::terminal(cn.lookup(stateVector[0]));
+    }
+
+    [[maybe_unused]] const auto before = cn.cacheCount();
+
+    const auto level = static_cast<Qubit>(std::log2(length) - 1);
+    auto state =
+        makeStateFromVector(stateVector.begin(), stateVector.end(), level);
+
+    // the recursive function makes use of the cache, so we have to clean it up
+    if (state.w != Complex::zero) {
+      cn.returnToCache(state.w);
+      state.w = cn.lookup(state.w);
+    }
+
+    [[maybe_unused]] const auto after = cn.cacheCount();
+    assert(after == before);
+    return state;
+  }
+
+  /**
+      Converts a given matrix to a decision diagram
+      @param matrix A complex matrix to convert to a DD.
+      @return An mEdge that represents the DD.
+      @throws std::invalid_argument If the given matrix is not square or its
+  length is not a power of two.
+  **/
+  mEdge makeDDFromMatrix(const CMat& matrix) {
+    if (matrix.empty()) {
+      return mEdge::one;
+    }
+
+    const auto& length = matrix.size();
+    if ((length & (length - 1)) != 0) {
+      throw std::invalid_argument(
+          "Matrix must have a length of a power of two.");
+    }
+
+    const auto& width = matrix[0].size();
+    if (length != width) {
+      throw std::invalid_argument("Matrix must be square.");
+    }
+
+    if (length == 1) {
+      return mEdge::terminal(cn.lookup(matrix[0][0]));
+    }
+
+    [[maybe_unused]] const auto before = cn.cacheCount();
+
+    const auto level = static_cast<Qubit>(std::log2(length) - 1);
+
+    auto matrixDD = makeDDFromMatrix(matrix, level, 0, length, 0, width);
+
+    if (matrixDD.w != Complex::zero) {
+      cn.returnToCache(matrixDD.w);
+      matrixDD.w = cn.lookup(matrixDD.w);
+    }
+
+    [[maybe_unused]] const auto after = cn.cacheCount();
+    assert(after == before);
+    return matrixDD;
+  }
+
+  ///
+  /// Matrix nodes, edges and quantum gates
+  ///
+  template <class Node> Edge<Node> normalize(const Edge<Node>& e, bool cached) {
+    if constexpr (std::is_same_v<Node, mNode> || std::is_same_v<Node, dNode>) {
+      auto argmax = -1;
+
+      auto zero = std::array{
+          e.p->e[0].w.approximatelyZero(), e.p->e[1].w.approximatelyZero(),
+          e.p->e[2].w.approximatelyZero(), e.p->e[3].w.approximatelyZero()};
+
+      // make sure to release cached numbers approximately zero, but not exactly
+      // zero
+      if (cached) {
+        for (auto i = 0U; i < NEDGE; i++) {
+          if (zero[i] && e.p->e[i].w != Complex::zero) {
+            cn.returnToCache(e.p->e[i].w);
+            e.p->e[i] = Edge<Node>::zero;
+          }
+        }
+      }
+
+      fp max = 0;
+      auto maxc = Complex::one;
+      // determine max amplitude
+      for (auto i = 0U; i < NEDGE; ++i) {
+        if (zero[i]) {
+          continue;
+        }
+        if (argmax == -1) {
+          argmax = static_cast<decltype(argmax)>(i);
+          max = ComplexNumbers::mag2(e.p->e[i].w);
+          maxc = e.p->e[i].w;
+        } else {
+          auto mag = ComplexNumbers::mag2(e.p->e[i].w);
+          if (mag - max > ComplexTable<>::tolerance()) {
+            argmax = static_cast<decltype(argmax)>(i);
+            max = mag;
+            maxc = e.p->e[i].w;
+          }
+        }
+      }
+
+      // all equal to zero
+      if (argmax == -1) {
+        if (!cached && !e.isTerminal()) {
+          // If it is not a cached computation, the node has to be put back into
+          // the chain
+          getUniqueTable<Node>().returnNode(e.p);
+        }
+        return Edge<Node>::zero;
+      }
+
+      auto r = e;
+      // divide each entry by max
+      for (auto i = 0U; i < NEDGE; ++i) {
+        if (static_cast<decltype(argmax)>(i) == argmax) {
+          if (cached) {
+            if (r.w.exactlyOne()) {
+              r.w = maxc;
             } else {
-                auto w = cn.getTemporary();
-                dd::ComplexNumbers::mul(w, newedge.w, e.w);
-                newedge.w = cn.lookup(w);
-            }
-
-            return newedge;
-        }
-
-        ///
-        /// Compute table definitions
-        ///
-    public:
-        void clearComputeTables() {
-            vectorAdd.clear();
-            matrixAdd.clear();
-            matrixTranspose.clear();
-            conjugateMatrixTranspose.clear();
-            matrixMatrixMultiplication.clear();
-            matrixVectorMultiplication.clear();
-            vectorInnerProduct.clear();
-            vectorKronecker.clear();
-            matrixKronecker.clear();
-
-            toffoliTable.clear();
-
-            clearIdentityTable();
-
-            stochasticNoiseOperationCache.clear();
-            densityAdd.clear();
-            densityDensityMultiplication.clear();
-            densityNoise.clear();
-        }
-
-        ///
-        /// Measurements from state decision diagrams
-        ///
-        std::string measureAll(vEdge& rootEdge, const bool collapse, std::mt19937_64& mt, fp epsilon = 0.001) {
-            if (std::abs(ComplexNumbers::mag2(rootEdge.w) - 1.0) > epsilon) {
-                if (rootEdge.w.approximatelyZero()) {
-                    throw std::runtime_error("Numerical instabilities led to a 0-vector! Abort simulation!");
-                }
-                std::cerr << "WARNING in MAll: numerical instability occurred during simulation: |alpha|^2 + |beta|^2 = "
-                          << ComplexNumbers::mag2(rootEdge.w) << ", but should be 1!\n";
-            }
-
-            vEdge      cur            = rootEdge;
-            const auto numberOfQubits = static_cast<QubitCount>(rootEdge.p->v + 1);
-
-            std::string result(numberOfQubits, '0');
-
-            std::uniform_real_distribution<fp> dist(0.0, 1.0L);
-
-            for (Qubit i = rootEdge.p->v; i >= 0; --i) {
-                fp       p0  = ComplexNumbers::mag2(cur.p->e.at(0).w);
-                const fp p1  = ComplexNumbers::mag2(cur.p->e.at(1).w);
-                const fp tmp = p0 + p1;
-
-                if (std::abs(tmp - 1.0) > epsilon) {
-                    throw std::runtime_error("Added probabilities differ from 1 by " + std::to_string(std::abs(tmp - 1.0)));
-                }
-                p0 /= tmp;
-
-                const fp threshold = dist(mt);
-                if (threshold < p0) {
-                    cur = cur.p->e.at(0);
-                } else {
-                    result[static_cast<std::size_t>(cur.p->v)] = '1';
-                    cur                                        = cur.p->e.at(1);
-                }
-            }
-
-            if (collapse) {
-                decRef(rootEdge);
-
-                vEdge                e = vEdge::one;
-                std::array<vEdge, 2> edges{};
-
-                for (Qubit p = 0; p < numberOfQubits; p++) {
-                    if (result[static_cast<std::size_t>(p)] == '0') {
-                        edges[0] = e;
-                        edges[1] = vEdge::zero;
-                    } else {
-                        edges[0] = vEdge::zero;
-                        edges[1] = e;
-                    }
-                    e = makeDDNode(p, edges, false);
-                }
-                incRef(e);
-                rootEdge = e;
-                garbageCollect();
-            }
-
-            return std::string{result.rbegin(), result.rend()};
-        }
-
-    private:
-        double assignProbabilities(const vEdge& edge, std::unordered_map<vNode*, fp>& probs) {
-            auto it = probs.find(edge.p);
-            if (it != probs.end()) {
-                return ComplexNumbers::mag2(edge.w) * it->second;
-            }
-            double sum{1};
-            if (!edge.isTerminal()) {
-                sum = assignProbabilities(edge.p->e.at(0), probs) + assignProbabilities(edge.p->e.at(1), probs);
-            }
-
-            probs.insert({edge.p, sum});
-
-            return ComplexNumbers::mag2(edge.w) * sum;
-        }
-
-    public:
-        std::pair<dd::fp, dd::fp> determineMeasurementProbabilities(const vEdge& rootEdge, const Qubit index, const bool assumeProbabilityNormalization) {
-            std::map<vNode*, fp> probsMone;
-            std::set<vNode*>     visited;
-            std::queue<vNode*>   q;
-
-            probsMone[rootEdge.p] = ComplexNumbers::mag2(rootEdge.w);
-            visited.insert(rootEdge.p);
-            q.push(rootEdge.p);
-
-            while (q.front()->v != index) {
-                vNode* ptr = q.front();
-                q.pop();
-                const fp prob = probsMone[ptr];
-
-                if (!ptr->e.at(0).w.approximatelyZero()) {
-                    const fp tmp1 = prob * ComplexNumbers::mag2(ptr->e.at(0).w);
-
-                    if (visited.find(ptr->e.at(0).p) != visited.end()) {
-                        probsMone[ptr->e.at(0).p] = probsMone[ptr->e.at(0).p] + tmp1;
-                    } else {
-                        probsMone[ptr->e.at(0).p] = tmp1;
-                        visited.insert(ptr->e.at(0).p);
-                        q.push(ptr->e.at(0).p);
-                    }
-                }
-
-                if (!ptr->e.at(1).w.approximatelyZero()) {
-                    const fp tmp1 = prob * ComplexNumbers::mag2(ptr->e.at(1).w);
-
-                    if (visited.find(ptr->e.at(1).p) != visited.end()) {
-                        probsMone[ptr->e.at(1).p] = probsMone[ptr->e.at(1).p] + tmp1;
-                    } else {
-                        probsMone[ptr->e.at(1).p] = tmp1;
-                        visited.insert(ptr->e.at(1).p);
-                        q.push(ptr->e.at(1).p);
-                    }
-                }
+              ComplexNumbers::mul(r.w, r.w, maxc);
             }
-
-            fp pzero{0};
-            fp pone{0};
-
-            if (assumeProbabilityNormalization) {
-                while (!q.empty()) {
-                    vNode* ptr = q.front();
-                    q.pop();
-
-                    if (!ptr->e.at(0).w.approximatelyZero()) {
-                        pzero += probsMone[ptr] * ComplexNumbers::mag2(ptr->e.at(0).w);
-                    }
-
-                    if (!ptr->e.at(1).w.approximatelyZero()) {
-                        pone += probsMone[ptr] * ComplexNumbers::mag2(ptr->e.at(1).w);
-                    }
-                }
+          } else {
+            if (r.w.exactlyOne()) {
+              r.w = maxc;
             } else {
-                std::unordered_map<vNode*, fp> probs;
-                assignProbabilities(rootEdge, probs);
-
-                while (!q.empty()) {
-                    vNode* ptr = q.front();
-                    q.pop();
-
-                    if (!ptr->e.at(0).w.approximatelyZero()) {
-                        pzero += probsMone[ptr] * probs[ptr->e.at(0).p] * ComplexNumbers::mag2(ptr->e.at(0).w);
-                    }
-
-                    if (!ptr->e.at(1).w.approximatelyZero()) {
-                        pone += probsMone[ptr] * probs[ptr->e.at(1).p] * ComplexNumbers::mag2(ptr->e.at(1).w);
-                    }
-                }
-            }
-            return {pzero, pone};
-        }
-
-        char measureOneCollapsing(vEdge& rootEdge, const Qubit index, const bool assumeProbabilityNormalization, std::mt19937_64& mt, fp epsilon = 0.001) {
-            const auto& [pzero, pone] = determineMeasurementProbabilities(rootEdge, index, assumeProbabilityNormalization);
-            const fp sum              = pzero + pone;
-            if (std::abs(sum - 1) > epsilon) {
-                throw std::runtime_error("Numerical instability occurred during measurement: |alpha|^2 + |beta|^2 = " + std::to_string(pzero) + " + " + std::to_string(pone) + " = " +
-                                         std::to_string(pzero + pone) + ", but should be 1!");
-            }
-            GateMatrix measurementMatrix{
-                    complex_zero, complex_zero,
-                    complex_zero, complex_zero};
-
-            std::uniform_real_distribution<fp> dist(0.0, 1.0L);
-
-            fp   threshold = dist(mt);
-            fp   normalizationFactor; // NOLINT(cppcoreguidelines-init-variables) always assigned a value in the following block
-            char result;              // NOLINT(cppcoreguidelines-init-variables) always assigned a value in the following block
-
-            if (threshold < pzero / sum) {
-                measurementMatrix[0] = complex_one;
-                normalizationFactor  = pzero;
-                result               = '0';
+              auto c = cn.getTemporary();
+              ComplexNumbers::mul(c, r.w, maxc);
+              r.w = cn.lookup(c);
+            }
+          }
+          r.p->e[i].w = Complex::one;
+        } else {
+          if (zero[i]) {
+            if (cached && r.p->e[i].w != Complex::zero) {
+              cn.returnToCache(r.p->e[i].w);
+            }
+            r.p->e[i] = Edge<Node>::zero;
+            continue;
+          }
+          if (cached && !zero[i] && !r.p->e[i].w.exactlyOne()) {
+            cn.returnToCache(r.p->e[i].w);
+          }
+          if (r.p->e[i].w.approximatelyOne()) {
+            r.p->e[i].w = Complex::one;
+          }
+          auto c = cn.getTemporary();
+          ComplexNumbers::div(c, r.p->e[i].w, maxc);
+          r.p->e[i].w = cn.lookup(c);
+        }
+      }
+      return r;
+    }
+  }
+
+  // build matrix representation for a single gate on an n-qubit circuit
+  mEdge makeGateDD(const std::array<ComplexValue, NEDGE>& mat, QubitCount n,
+                   Qubit target, std::size_t start = 0) {
+    return makeGateDD(mat, n, Controls{}, target, start);
+  }
+  mEdge makeGateDD(const std::array<ComplexValue, NEDGE>& mat, QubitCount n,
+                   const Control& control, Qubit target,
+                   std::size_t start = 0) {
+    return makeGateDD(mat, n, Controls{control}, target, start);
+  }
+  mEdge makeGateDD(const std::array<ComplexValue, NEDGE>& mat, QubitCount n,
+                   const Controls& controls, Qubit target,
+                   std::size_t start = 0) {
+    if (n + start > nqubits) {
+      throw std::runtime_error{
+          "Requested gate with " + std::to_string(n + start) +
+          " qubits, but current package configuration only supports up to " +
+          std::to_string(nqubits) +
+          " qubits. Please allocate a larger package instance."};
+    }
+    std::array<mEdge, NEDGE> em{};
+    auto it = controls.begin();
+    for (auto i = 0U; i < NEDGE; ++i) {
+      // NOLINTNEXTLINE(clang-diagnostic-float-equal) it has to be really zero
+      if (mat[i].r == 0 && mat[i].i == 0) {
+        em[i] = mEdge::zero;
+      } else {
+        em[i] = mEdge::terminal(cn.lookup(mat[i]));
+      }
+    }
+
+    // process lines below target
+    auto z = static_cast<Qubit>(start);
+    for (; z < target; z++) {
+      for (auto i1 = 0U; i1 < RADIX; i1++) {
+        for (auto i2 = 0U; i2 < RADIX; i2++) {
+          auto i = i1 * RADIX + i2;
+          if (it != controls.end() && it->qubit == z) {
+            if (it->type == Control::Type::neg) { // neg. control
+              em[i] = makeDDNode(
+                  z,
+                  std::array{em[i], mEdge::zero, mEdge::zero,
+                             (i1 == i2) ? makeIdent(static_cast<Qubit>(start),
+                                                    static_cast<Qubit>(z - 1))
+                                        : mEdge::zero});
+            } else { // pos. control
+              em[i] = makeDDNode(
+                  z,
+                  std::array{(i1 == i2) ? makeIdent(static_cast<Qubit>(start),
+                                                    static_cast<Qubit>(z - 1))
+                                        : mEdge::zero,
+                             mEdge::zero, mEdge::zero, em[i]});
+            }
+          } else { // not connected
+            em[i] = makeDDNode(
+                z, std::array{em[i], mEdge::zero, mEdge::zero, em[i]});
+          }
+        }
+      }
+      if (it != controls.end() && it->qubit == z) {
+        ++it;
+      }
+    }
+
+    // target line
+    auto e = makeDDNode(z, em);
+
+    // process lines above target
+    for (; z < static_cast<Qubit>(n - 1 + start); z++) {
+      auto q = static_cast<Qubit>(z + 1);
+      if (it != controls.end() && it->qubit == q) {
+        if (it->type == Control::Type::neg) { // neg. control
+          e = makeDDNode(q, std::array{e, mEdge::zero, mEdge::zero,
+                                       makeIdent(static_cast<Qubit>(start),
+                                                 static_cast<Qubit>(q - 1))});
+        } else { // pos. control
+          e = makeDDNode(q, std::array{makeIdent(static_cast<Qubit>(start),
+                                                 static_cast<Qubit>(q - 1)),
+                                       mEdge::zero, mEdge::zero, e});
+        }
+        ++it;
+      } else { // not connected
+        e = makeDDNode(q, std::array{e, mEdge::zero, mEdge::zero, e});
+      }
+    }
+    return e;
+  }
+
+  /**
+  Creates the DD for a two-qubit gate
+  @param mat Matrix representation of the gate
+  @param n Number of qubits in the circuit
+  @param target0 First target qubit
+  @param target1 Second target qubit
+  @param start Start index for the DD
+  @return DD representing the gate
+  @throws std::runtime_error if the number of qubits is larger than the package
+  configuration
+  **/
+  mEdge makeTwoQubitGateDD(
+      const std::array<std::array<ComplexValue, NEDGE>, NEDGE>& mat,
+      const QubitCount n, const Qubit target0, const Qubit target1,
+      const std::size_t start = 0) {
+    // sanity check
+    if (n + start > nqubits) {
+      throw std::runtime_error{
+          "Requested gate with " + std::to_string(n + start) +
+          " qubits, but current package configuration only supports up to " +
+          std::to_string(nqubits) +
+          " qubits. Please allocate a larger package instance."};
+    }
+
+    // create terminal edge matrix
+    std::array<std::array<mEdge, NEDGE>, NEDGE> em{};
+    for (auto i1 = 0U; i1 < NEDGE; i1++) {
+      const auto& matRow = mat.at(i1);
+      auto& emRow = em.at(i1);
+      for (auto i2 = 0U; i2 < NEDGE; i2++) {
+        const auto& matEntry = matRow.at(i2);
+        auto& emEntry = emRow.at(i2);
+        // NOLINTNEXTLINE(clang-diagnostic-float-equal) it has to be really zero
+        if (matEntry.r == 0 && matEntry.i == 0) {
+          emEntry = mEdge::zero;
+        } else {
+          emEntry = mEdge::terminal(cn.lookup(matEntry));
+        }
+      }
+    }
+
+    // process lines below smaller target (by creating identity structures)
+    auto z = static_cast<Qubit>(start);
+    const auto smallerTarget = std::min(target0, target1);
+    for (; z < smallerTarget; ++z) {
+      for (auto& row : em) {
+        for (auto& entry : row) {
+          entry =
+              makeDDNode(z, std::array{entry, mEdge::zero, mEdge::zero, entry});
+        }
+      }
+    }
+
+    // process the smaller target by taking the 16 submatrices and appropriately
+    // combining them into four DDs.
+    std::array<mEdge, NEDGE> em0{};
+    for (std::size_t row = 0; row < RADIX; ++row) {
+      for (std::size_t col = 0; col < RADIX; ++col) {
+        std::array<mEdge, NEDGE> local{};
+        if (target0 > target1) {
+          for (std::size_t i = 0; i < RADIX; ++i) {
+            for (std::size_t j = 0; j < RADIX; ++j) {
+              local.at(i * RADIX + j) =
+                  em.at(row * RADIX + i).at(col * RADIX + j);
+            }
+          }
+        } else {
+          for (std::size_t i = 0; i < RADIX; ++i) {
+            for (std::size_t j = 0; j < RADIX; ++j) {
+              local.at(i * RADIX + j) =
+                  em.at(i * RADIX + row).at(j * RADIX + col);
+            }
+          }
+        }
+        em0.at(row * RADIX + col) = makeDDNode(z, local);
+      }
+    }
+
+    // process lines between the two targets (by creating identity structures)
+    for (++z; z < std::max(target0, target1); ++z) {
+      for (auto& entry : em0) {
+        entry =
+            makeDDNode(z, std::array{entry, mEdge::zero, mEdge::zero, entry});
+      }
+    }
+
+    // process the larger target by combining the four DDs from the smaller
+    // target
+    auto e = makeDDNode(z, em0);
+
+    // process lines above the larger target (by creating identity structures)
+    for (++z; z < static_cast<Qubit>(n + start); ++z) {
+      e = makeDDNode(z, std::array{e, mEdge::zero, mEdge::zero, e});
+    }
+
+    return e;
+  }
+
+  mEdge makeSWAPDD(const QubitCount n, const Qubit target0, const Qubit target1,
+                   const std::size_t start = 0) {
+    return makeTwoQubitGateDD(SWAPmat, n, target0, target1, start);
+  }
+  mEdge makeSWAPDD(const QubitCount n, const Controls& controls,
+                   const Qubit target0, const Qubit target1,
+                   const std::size_t start = 0) {
+    auto c = controls;
+    c.insert(Control{target0});
+    mEdge e = makeGateDD(Xmat, n, c, target1, start);
+    c.erase(Control{target0});
+    c.insert(Control{target1});
+    e = multiply(e, multiply(makeGateDD(Xmat, n, c, target0, start), e));
+    return e;
+  }
+
+  mEdge makePeresDD(const QubitCount n, const Controls& controls,
+                    const Qubit target0, const Qubit target1,
+                    const std::size_t start = 0) {
+    auto c = controls;
+    c.insert(Control{target1});
+    mEdge e = makeGateDD(Xmat, n, c, target0, start);
+    e = multiply(makeGateDD(Xmat, n, controls, target1, start), e);
+    return e;
+  }
+
+  mEdge makePeresdagDD(const QubitCount n, const Controls& controls,
+                       const Qubit target0, const Qubit target1,
+                       const std::size_t start = 0) {
+    mEdge e = makeGateDD(Xmat, n, controls, target1, start);
+    auto c = controls;
+    c.insert(Control{target1});
+    e = multiply(makeGateDD(Xmat, n, c, target0, start), e);
+    return e;
+  }
+
+  mEdge makeiSWAPDD(const QubitCount n, const Qubit target0,
+                    const Qubit target1, const std::size_t start = 0) {
+    return makeTwoQubitGateDD(iSWAPmat, n, target0, target1, start);
+  }
+  mEdge makeiSWAPDD(const QubitCount n, const Controls& controls,
+                    const Qubit target0, const Qubit target1,
+                    const std::size_t start = 0) {
+    mEdge e = makeGateDD(Smat, n, controls, target1, start);        // S q[1]
+    e = multiply(e, makeGateDD(Smat, n, controls, target0, start)); // S q[0]
+    e = multiply(e, makeGateDD(Hmat, n, controls, target0, start)); // H q[0]
+    auto c = controls;
+    c.insert(Control{target0});
+    e = multiply(e, makeGateDD(Xmat, n, c, target1, start)); // CX q[0], q[1]
+    c.erase(Control{target0});
+    c.insert(Control{target1});
+    e = multiply(e, makeGateDD(Xmat, n, c, target0, start)); // CX q[1], q[0]
+    e = multiply(e, makeGateDD(Hmat, n, controls, target1, start)); // H q[1]
+    return e;
+  }
+
+  mEdge makeiSWAPinvDD(const QubitCount n, const Qubit target0,
+                       const Qubit target1, const std::size_t start = 0) {
+    return makeTwoQubitGateDD(iSWAPinvmat, n, target0, target1, start);
+  }
+  mEdge makeiSWAPinvDD(const QubitCount n, const Controls& controls,
+                       const Qubit target0, const Qubit target1,
+                       const std::size_t start = 0) {
+    mEdge e = makeGateDD(Hmat, n, controls, target1, start); // H q[1]
+    auto c = controls;
+    c.insert(Control{target1});
+    e = multiply(e, makeGateDD(Xmat, n, c, target0, start)); // CX q[1], q[0]
+    c.erase(Control{target1});
+    c.insert(Control{target0});
+    e = multiply(e, makeGateDD(Xmat, n, c, target1, start)); // CX q[0], q[1]
+    e = multiply(e, makeGateDD(Hmat, n, controls, target0, start)); // H q[0]
+    e = multiply(e,
+                 makeGateDD(Sdagmat, n, controls, target0, start)); // Sdag q[0]
+    e = multiply(e,
+                 makeGateDD(Sdagmat, n, controls, target1, start)); // Sdag q[1]
+    return e;
+  }
+
+  mEdge makeDCXDD(const QubitCount n, const Qubit target0, const Qubit target1,
+                  const std::size_t start = 0) {
+    return makeTwoQubitGateDD(DCXmat, n, target0, target1, start);
+  }
+  mEdge makeDCXDD(const QubitCount n, const Controls& controls,
+                  const Qubit target0, const Qubit target1,
+                  const std::size_t start = 0) {
+    auto c = controls;
+    c.insert(Control{target0});
+    mEdge e = makeGateDD(Xmat, n, c, target1, start);
+    c.erase(Control{target0});
+    c.insert(Control{target1});
+    e = multiply(e, makeGateDD(Xmat, n, c, target0, start));
+    return e;
+  }
+
+  mEdge makeRZZDD(const QubitCount n, const Qubit target0, const Qubit target1,
+                  const fp theta, const std::size_t start = 0) {
+    return makeTwoQubitGateDD(RZZmat(theta), n, target0, target1, start);
+  }
+  mEdge makeRZZDD(const QubitCount n, const Controls& controls,
+                  const Qubit target0, const Qubit target1, const fp theta,
+                  const std::size_t start = 0) {
+    auto c = controls;
+    c.insert(Control{target0});
+    auto e = makeGateDD(Xmat, n, c, target1, start);
+    c.erase(Control{target0});
+    e = multiply(e, makeGateDD(RZmat(theta), n, c, target1, start));
+    c.insert(Control{target0});
+    e = multiply(e, makeGateDD(Xmat, n, c, target1, start));
+    return e;
+  }
+
+  mEdge makeRYYDD(const QubitCount n, const Qubit target0, const Qubit target1,
+                  const fp theta, const std::size_t start = 0) {
+    return makeTwoQubitGateDD(RYYmat(theta), n, target0, target1, start);
+  }
+  mEdge makeRYYDD(const QubitCount n, const Controls& controls,
+                  const Qubit target0, const Qubit target1, const fp theta,
+                  const std::size_t start = 0) {
+    // no controls are necessary on the RX gates since they cancel if the
+    // controls are 0.
+    auto e = makeGateDD(RXmat(PI_2), n, Controls{}, target0, start);
+    e = multiply(e, makeGateDD(RXmat(PI_2), n, Controls{}, target1, start));
+    e = multiply(e, makeRZZDD(n, controls, target0, target1, theta, start));
+    e = multiply(e, makeGateDD(RXmat(-PI_2), n, Controls{}, target1, start));
+    e = multiply(e, makeGateDD(RXmat(-PI_2), n, Controls{}, target0, start));
+    return e;
+  }
+
+  mEdge makeRXXDD(const QubitCount n, const Qubit target0, const Qubit target1,
+                  const fp theta, const std::size_t start = 0) {
+    return makeTwoQubitGateDD(RXXmat(theta), n, target0, target1, start);
+  }
+  mEdge makeRXXDD(const QubitCount n, const Controls& controls,
+                  const Qubit target0, const Qubit target1, const fp theta,
+                  const std::size_t start = 0) {
+    // no controls are necessary on the H gates since they cancel if the
+    // controls are 0.
+    auto e = makeGateDD(Hmat, n, Controls{}, target0, start);
+    e = multiply(e, makeGateDD(Hmat, n, Controls{}, target1, start));
+    e = multiply(e, makeRZZDD(n, controls, target0, target1, theta, start));
+    e = multiply(e, makeGateDD(Hmat, n, Controls{}, target1, start));
+    e = multiply(e, makeGateDD(Hmat, n, Controls{}, target0, start));
+    return e;
+  }
+
+  mEdge makeRZXDD(const QubitCount n, const Qubit target0, const Qubit target1,
+                  const fp theta, const std::size_t start = 0) {
+    return makeTwoQubitGateDD(RZXmat(theta), n, target0, target1, start);
+  }
+  mEdge makeRZXDD(const QubitCount n, const Controls& controls,
+                  const Qubit target0, const Qubit target1, const fp theta,
+                  const std::size_t start = 0) {
+    // no controls are necessary on the H gates since they cancel if the
+    // controls are 0.
+    auto e = makeGateDD(Hmat, n, Controls{}, target1, start);
+    e = multiply(e, makeRZZDD(n, controls, target0, target1, theta, start));
+    e = multiply(e, makeGateDD(Hmat, n, Controls{}, target1, start));
+    return e;
+  }
+
+  mEdge makeECRDD(const QubitCount n, const Qubit target0, const Qubit target1,
+                  const std::size_t start = 0) {
+    return makeTwoQubitGateDD(ECRmat, n, target0, target1, start);
+  }
+  mEdge makeECRDD(const QubitCount n, const Controls& controls,
+                  const Qubit target0, const Qubit target1,
+                  const std::size_t start = 0) {
+    auto e = makeRZXDD(n, controls, target0, target1, -PI_4, start);
+    e = multiply(e, makeGateDD(Xmat, n, controls, target0, start));
+    e = multiply(e, makeRZXDD(n, controls, target0, target1, PI_4, start));
+    return e;
+  }
+
+  mEdge makeXXMinusYYDD(const QubitCount n, const Qubit target0,
+                        const Qubit target1, const fp theta, const fp beta = 0.,
+                        const std::size_t start = 0) {
+    return makeTwoQubitGateDD(XXMinusYYmat(theta, beta), n, target0, target1,
+                              start);
+  }
+  mEdge makeXXMinusYYDD(const QubitCount n, const Controls& controls,
+                        const Qubit target0, const Qubit target1,
+                        const fp theta, const fp beta = 0.,
+                        const std::size_t start = 0) {
+    auto e = makeGateDD(RZmat(-beta), n, Controls{}, target1, start);
+    e = multiply(e, makeGateDD(RZmat(-PI_2), n, Controls{}, target0, start));
+    e = multiply(e, makeGateDD(SXmat, n, Controls{}, target0, start));
+    e = multiply(e, makeGateDD(RZmat(PI_2), n, Controls{}, target0, start));
+    e = multiply(e, makeGateDD(Smat, n, Controls{}, target1, start));
+    e = multiply(e, makeGateDD(Xmat, n, Control{target0}, target1, start));
+    // only the following two gates need to be controlled by the controls since
+    // the other gates cancel if the controls are 0.
+    e = multiply(e,
+                 makeGateDD(RYmat(-theta / 2.), n, controls, target0, start));
+    e = multiply(e, makeGateDD(RYmat(theta / 2.), n, controls, target1, start));
+
+    e = multiply(e, makeGateDD(Xmat, n, Control{target0}, target1, start));
+    e = multiply(e, makeGateDD(Sdagmat, n, Controls{}, target1, start));
+    e = multiply(e, makeGateDD(RZmat(-PI_2), n, Controls{}, target0, start));
+    e = multiply(e, makeGateDD(SXdagmat, n, Controls{}, target0, start));
+    e = multiply(e, makeGateDD(RZmat(PI_2), n, Controls{}, target0, start));
+    e = multiply(e, makeGateDD(RZmat(beta), n, Controls{}, target1, start));
+    return e;
+  }
+
+  mEdge makeXXPlusYYDD(const QubitCount n, const Qubit target0,
+                       const Qubit target1, const fp theta, const fp beta = 0.,
+                       const std::size_t start = 0) {
+    return makeTwoQubitGateDD(XXPlusYYmat(theta, beta), n, target0, target1,
+                              start);
+  }
+  mEdge makeXXPlusYYDD(const QubitCount n, const Controls& controls,
+                       const Qubit target0, const Qubit target1, const fp theta,
+                       const fp beta = 0., const std::size_t start = 0) {
+    auto e = makeGateDD(RZmat(beta), n, Controls{}, target1, start);
+    e = multiply(e, makeGateDD(RZmat(-PI_2), n, Controls{}, target0, start));
+    e = multiply(e, makeGateDD(SXmat, n, Controls{}, target0, start));
+    e = multiply(e, makeGateDD(RZmat(PI_2), n, Controls{}, target0, start));
+    e = multiply(e, makeGateDD(Smat, n, Controls{}, target1, start));
+    e = multiply(e, makeGateDD(Xmat, n, Control{target0}, target1, start));
+    // only the following two gates need to be controlled by the controls since
+    // the other gates cancel if the controls are 0.
+    e = multiply(e, makeGateDD(RYmat(theta / 2.), n, controls, target0, start));
+    e = multiply(e, makeGateDD(RYmat(theta / 2.), n, controls, target1, start));
+
+    e = multiply(e, makeGateDD(Xmat, n, Control{target0}, target1, start));
+    e = multiply(e, makeGateDD(Sdagmat, n, Controls{}, target1, start));
+    e = multiply(e, makeGateDD(RZmat(-PI_2), n, Controls{}, target0, start));
+    e = multiply(e, makeGateDD(SXdagmat, n, Controls{}, target0, start));
+    e = multiply(e, makeGateDD(RZmat(PI_2), n, Controls{}, target0, start));
+    e = multiply(e, makeGateDD(RZmat(-beta), n, Controls{}, target1, start));
+    return e;
+  }
+
+private:
+  // check whether node represents a symmetric matrix or the identity
+  void checkSpecialMatrices(mNode* p) {
+    if (p->v == -1) {
+      return;
+    }
+
+    p->setIdentity(false);
+    p->setSymmetric(false);
+
+    // check if matrix is symmetric
+    if (!p->e[0].p->isSymmetric() || !p->e[3].p->isSymmetric()) {
+      return;
+    }
+    if (transpose(p->e[1]) != p->e[2]) {
+      return;
+    }
+    p->setSymmetric(true);
+
+    // check if matrix resembles identity
+    if (!(p->e[0].p->isIdentity()) || (p->e[1].w) != Complex::zero ||
+        (p->e[2].w) != Complex::zero || (p->e[0].w) != Complex::one ||
+        (p->e[3].w) != Complex::one || !(p->e[3].p->isIdentity())) {
+      return;
+    }
+    p->setIdentity(true);
+  }
+
+  vEdge makeStateFromVector(const CVec::const_iterator& begin,
+                            const CVec::const_iterator& end,
+                            const Qubit level) {
+    if (level == 0) {
+      assert(std::distance(begin, end) == 2);
+      const auto& zeroWeight = cn.getCached(begin->real(), begin->imag());
+      const auto& oneWeight =
+          cn.getCached(std::next(begin)->real(), std::next(begin)->imag());
+      const auto zeroSuccessor = vEdge{vNode::terminal, zeroWeight};
+      const auto oneSuccessor = vEdge{vNode::terminal, oneWeight};
+      return makeDDNode<vNode>(0, {zeroSuccessor, oneSuccessor}, true);
+    }
+
+    const auto half = std::distance(begin, end) / 2;
+    const auto zeroSuccessor =
+        makeStateFromVector(begin, begin + half, level - 1);
+    const auto oneSuccessor = makeStateFromVector(begin + half, end, level - 1);
+    return makeDDNode<vNode>(level, {zeroSuccessor, oneSuccessor}, true);
+  }
+
+  /**
+  Constructs a decision diagram (DD) from a complex matrix using a recursive
+  algorithm.
+  @param matrix The complex matrix from which to create the DD.
+  @param level The current level of recursion. Starts at the highest level of
+  the matrix (log base 2 of the matrix size - 1).
+  @param rowStart The starting row of the quadrant being processed.
+  @param rowEnd The ending row of the quadrant being processed.
+  @param colStart The starting column of the quadrant being processed.
+  @param colEnd The ending column of the quadrant being processed.
+  @return An mEdge representing the root node of the created DD.
+  @throw std::invalid_argument If level is negative.
+  @details This function recursively breaks down the matrix into quadrants until
+  each quadrant has only one element. At each level of recursion, four new edges
+  are created, one for each quadrant of the matrix. The four resulting decision
+  diagram edges are used to create a new decision diagram node at the current
+  level, and this node is returned as the result of the current recursive call.
+  At the base case of recursion, the matrix has only one element, which is
+  converted into a terminal node of the decision diagram.
+  @note This function assumes that the matrix size is a power of two.
+  **/
+  mEdge makeDDFromMatrix(const CMat& matrix, const Qubit level,
+                         const std::size_t rowStart, const std::size_t rowEnd,
+                         const std::size_t colStart, const std::size_t colEnd) {
+    // base case
+    if (level == -1) {
+      assert(rowEnd - rowStart == 1);
+      assert(colEnd - colStart == 1);
+      return {mNode::terminal, cn.getCached(matrix[rowStart][colStart])};
+    }
+
+    // recursively call the function on all quadrants
+    const auto rowMid = (rowStart + rowEnd) / 2;
+    const auto colMid = (colStart + colEnd) / 2;
+
+    const auto edge0 =
+        makeDDFromMatrix(matrix, level - 1, rowStart, rowMid, colStart, colMid);
+    const auto edge1 =
+        makeDDFromMatrix(matrix, level - 1, rowStart, rowMid, colMid, colEnd);
+    const auto edge2 =
+        makeDDFromMatrix(matrix, level - 1, rowMid, rowEnd, colStart, colMid);
+    const auto edge3 =
+        makeDDFromMatrix(matrix, level - 1, rowMid, rowEnd, colMid, colEnd);
+
+    return makeDDNode<mNode>(level, {edge0, edge1, edge2, edge3}, true);
+  }
+
+  ///
+  /// Unique tables, Reference counting and garbage collection
+  ///
+public:
+  // unique tables
+  template <class Node> [[nodiscard]] auto& getUniqueTable() {
+    if constexpr (std::is_same_v<Node, vNode>) {
+      return vUniqueTable;
+    } else if constexpr (std::is_same_v<Node, mNode>) {
+      return mUniqueTable;
+    } else if constexpr (std::is_same_v<Node, dNode>) {
+      return dUniqueTable;
+    }
+  }
+
+  template <class Node> void incRef(const Edge<Node>& e) {
+    getUniqueTable<Node>().incRef(e);
+  }
+  template <class Node> void decRef(const Edge<Node>& e) {
+    getUniqueTable<Node>().decRef(e);
+  }
+
+  UniqueTable<vNode, Config::UT_VEC_NBUCKET,
+              Config::UT_VEC_INITIAL_ALLOCATION_SIZE>
+      vUniqueTable{nqubits};
+  UniqueTable<mNode, Config::UT_MAT_NBUCKET,
+              Config::UT_MAT_INITIAL_ALLOCATION_SIZE>
+      mUniqueTable{nqubits};
+  UniqueTable<dNode, Config::UT_DM_NBUCKET,
+              Config::UT_DM_INITIAL_ALLOCATION_SIZE>
+      dUniqueTable{nqubits};
+
+  bool garbageCollect(bool force = false) {
+    // return immediately if no table needs collection
+    if (!force && !vUniqueTable.possiblyNeedsCollection() &&
+        !mUniqueTable.possiblyNeedsCollection() &&
+        !dUniqueTable.possiblyNeedsCollection() &&
+        !cn.complexTable.possiblyNeedsCollection()) {
+      return false;
+    }
+
+    auto cCollect = cn.garbageCollect(force);
+    if (cCollect > 0) {
+      // Collecting garbage in the complex numbers table requires collecting the
+      // node tables as well
+      force = true;
+    }
+    auto vCollect = vUniqueTable.garbageCollect(force);
+    auto mCollect = mUniqueTable.garbageCollect(force);
+    auto dCollect = dUniqueTable.garbageCollect(force);
+
+    // invalidate all compute tables involving vectors if any vector node has
+    // been collected
+    if (vCollect > 0) {
+      vectorAdd.clear();
+      vectorInnerProduct.clear();
+      vectorKronecker.clear();
+      matrixVectorMultiplication.clear();
+    }
+    // invalidate all compute tables involving matrices if any matrix node has
+    // been collected
+    if (mCollect > 0 || dCollect > 0) {
+      matrixAdd.clear();
+      matrixTranspose.clear();
+      conjugateMatrixTranspose.clear();
+      matrixKronecker.clear();
+      matrixVectorMultiplication.clear();
+      matrixMatrixMultiplication.clear();
+      toffoliTable.clear();
+      clearIdentityTable();
+      stochasticNoiseOperationCache.clear();
+      densityAdd.clear();
+      densityDensityMultiplication.clear();
+      densityNoise.clear();
+    }
+    // invalidate all compute tables where any component of the entry contains
+    // numbers from the complex table if any complex numbers were collected
+    if (cCollect > 0) {
+      matrixVectorMultiplication.clear();
+      matrixMatrixMultiplication.clear();
+      matrixTranspose.clear();
+      conjugateMatrixTranspose.clear();
+      vectorInnerProduct.clear();
+      vectorKronecker.clear();
+      matrixKronecker.clear();
+      stochasticNoiseOperationCache.clear();
+      densityAdd.clear();
+      densityDensityMultiplication.clear();
+      densityNoise.clear();
+    }
+    return vCollect > 0 || mCollect > 0 || cCollect > 0;
+  }
+
+  void clearUniqueTables() {
+    vUniqueTable.clear();
+    mUniqueTable.clear();
+    dUniqueTable.clear();
+  }
+
+  // create a normalized DD node and return an edge pointing to it. The node is
+  // not recreated if it already exists.
+  template <class Node>
+  Edge<Node> makeDDNode(
+      Qubit var,
+      const std::array<Edge<Node>, std::tuple_size_v<decltype(Node::e)>>& edges,
+      bool cached = false,
+      [[maybe_unused]] const bool generateDensityMatrix = false) {
+    auto& uniqueTable = getUniqueTable<Node>();
+    Edge<Node> e{uniqueTable.getNode(), Complex::one};
+    e.p->v = var;
+    e.p->e = edges;
+
+    if constexpr (std::is_same_v<Node, mNode> || std::is_same_v<Node, dNode>) {
+      e.p->flags = 0;
+      if constexpr (std::is_same_v<Node, dNode>) {
+        e.p->setDensityMatrixNodeFlag(generateDensityMatrix);
+      }
+    }
+
+    assert(e.p->ref == 0);
+    for ([[maybe_unused]] const auto& edge : edges) {
+      // an error here indicates that cached nodes are assigned multiple times.
+      // Check if garbage collect correctly resets the cache tables!
+      assert(edge.p->v == var - 1 || edge.isTerminal());
+    }
+
+    // normalize it
+    e = normalize(e, cached);
+    assert(e.p->v == var || e.isTerminal());
+
+    // look it up in the unique tables
+    auto l = uniqueTable.lookup(e, false);
+    assert(l.p->v == var || l.isTerminal());
+
+    // set specific node properties for matrices
+    if constexpr (std::is_same_v<Node, mNode>) {
+      if (l.p == e.p) {
+        checkSpecialMatrices(l.p);
+      }
+    }
+    return l;
+  }
+
+  template <class Node>
+  Edge<Node> deleteEdge(const Edge<Node>& e, dd::Qubit v, std::size_t edgeIdx) {
+    std::unordered_map<Node*, Edge<Node>> nodes{};
+    return deleteEdge(e, v, edgeIdx, nodes);
+  }
+
+private:
+  template <class Node>
+  Edge<Node> deleteEdge(const Edge<Node>& e, dd::Qubit v, std::size_t edgeIdx,
+                        std::unordered_map<Node*, Edge<Node>>& nodes) {
+    if (e.p == nullptr || e.isTerminal()) {
+      return e;
+    }
+
+    const auto& nodeit = nodes.find(e.p);
+    Edge<Node> newedge{};
+    if (nodeit != nodes.end()) {
+      newedge = nodeit->second;
+    } else {
+      constexpr std::size_t n = std::tuple_size_v<decltype(e.p->e)>;
+      std::array<Edge<Node>, n> edges{};
+      if (e.p->v == v) {
+        for (std::size_t i = 0; i < n; i++) {
+          edges[i] = i == edgeIdx
+                         ? Edge<Node>::zero
+                         : e.p->e[i]; // optimization -> node cannot occur below
+                                      // again, since dd is assumed to be free
+        }
+      } else {
+        for (std::size_t i = 0; i < n; i++) {
+          edges[i] = deleteEdge(e.p->e[i], v, edgeIdx, nodes);
+        }
+      }
+
+      newedge = makeDDNode(e.p->v, edges);
+      nodes[e.p] = newedge;
+    }
+
+    if (newedge.w.approximatelyOne()) {
+      newedge.w = e.w;
+    } else {
+      auto w = cn.getTemporary();
+      dd::ComplexNumbers::mul(w, newedge.w, e.w);
+      newedge.w = cn.lookup(w);
+    }
+
+    return newedge;
+  }
+
+  ///
+  /// Compute table definitions
+  ///
+public:
+  void clearComputeTables() {
+    vectorAdd.clear();
+    matrixAdd.clear();
+    matrixTranspose.clear();
+    conjugateMatrixTranspose.clear();
+    matrixMatrixMultiplication.clear();
+    matrixVectorMultiplication.clear();
+    vectorInnerProduct.clear();
+    vectorKronecker.clear();
+    matrixKronecker.clear();
+
+    toffoliTable.clear();
+
+    clearIdentityTable();
+
+    stochasticNoiseOperationCache.clear();
+    densityAdd.clear();
+    densityDensityMultiplication.clear();
+    densityNoise.clear();
+  }
+
+  ///
+  /// Measurements from state decision diagrams
+  ///
+  std::string measureAll(vEdge& rootEdge, const bool collapse,
+                         std::mt19937_64& mt, fp epsilon = 0.001) {
+    if (std::abs(ComplexNumbers::mag2(rootEdge.w) - 1.0) > epsilon) {
+      if (rootEdge.w.approximatelyZero()) {
+        throw std::runtime_error(
+            "Numerical instabilities led to a 0-vector! Abort simulation!");
+      }
+      std::cerr << "WARNING in MAll: numerical instability occurred during "
+                   "simulation: |alpha|^2 + |beta|^2 = "
+                << ComplexNumbers::mag2(rootEdge.w) << ", but should be 1!\n";
+    }
+
+    vEdge cur = rootEdge;
+    const auto numberOfQubits = static_cast<QubitCount>(rootEdge.p->v + 1);
+
+    std::string result(numberOfQubits, '0');
+
+    std::uniform_real_distribution<fp> dist(0.0, 1.0L);
+
+    for (Qubit i = rootEdge.p->v; i >= 0; --i) {
+      fp p0 = ComplexNumbers::mag2(cur.p->e.at(0).w);
+      const fp p1 = ComplexNumbers::mag2(cur.p->e.at(1).w);
+      const fp tmp = p0 + p1;
+
+      if (std::abs(tmp - 1.0) > epsilon) {
+        throw std::runtime_error("Added probabilities differ from 1 by " +
+                                 std::to_string(std::abs(tmp - 1.0)));
+      }
+      p0 /= tmp;
+
+      const fp threshold = dist(mt);
+      if (threshold < p0) {
+        cur = cur.p->e.at(0);
+      } else {
+        result[static_cast<std::size_t>(cur.p->v)] = '1';
+        cur = cur.p->e.at(1);
+      }
+    }
+
+    if (collapse) {
+      decRef(rootEdge);
+
+      vEdge e = vEdge::one;
+      std::array<vEdge, 2> edges{};
+
+      for (Qubit p = 0; p < numberOfQubits; p++) {
+        if (result[static_cast<std::size_t>(p)] == '0') {
+          edges[0] = e;
+          edges[1] = vEdge::zero;
+        } else {
+          edges[0] = vEdge::zero;
+          edges[1] = e;
+        }
+        e = makeDDNode(p, edges, false);
+      }
+      incRef(e);
+      rootEdge = e;
+      garbageCollect();
+    }
+
+    return std::string{result.rbegin(), result.rend()};
+  }
+
+private:
+  double assignProbabilities(const vEdge& edge,
+                             std::unordered_map<vNode*, fp>& probs) {
+    auto it = probs.find(edge.p);
+    if (it != probs.end()) {
+      return ComplexNumbers::mag2(edge.w) * it->second;
+    }
+    double sum{1};
+    if (!edge.isTerminal()) {
+      sum = assignProbabilities(edge.p->e.at(0), probs) +
+            assignProbabilities(edge.p->e.at(1), probs);
+    }
+
+    probs.insert({edge.p, sum});
+
+    return ComplexNumbers::mag2(edge.w) * sum;
+  }
+
+public:
+  std::pair<dd::fp, dd::fp>
+  determineMeasurementProbabilities(const vEdge& rootEdge, const Qubit index,
+                                    const bool assumeProbabilityNormalization) {
+    std::map<vNode*, fp> probsMone;
+    std::set<vNode*> visited;
+    std::queue<vNode*> q;
+
+    probsMone[rootEdge.p] = ComplexNumbers::mag2(rootEdge.w);
+    visited.insert(rootEdge.p);
+    q.push(rootEdge.p);
+
+    while (q.front()->v != index) {
+      vNode* ptr = q.front();
+      q.pop();
+      const fp prob = probsMone[ptr];
+
+      if (!ptr->e.at(0).w.approximatelyZero()) {
+        const fp tmp1 = prob * ComplexNumbers::mag2(ptr->e.at(0).w);
+
+        if (visited.find(ptr->e.at(0).p) != visited.end()) {
+          probsMone[ptr->e.at(0).p] = probsMone[ptr->e.at(0).p] + tmp1;
+        } else {
+          probsMone[ptr->e.at(0).p] = tmp1;
+          visited.insert(ptr->e.at(0).p);
+          q.push(ptr->e.at(0).p);
+        }
+      }
+
+      if (!ptr->e.at(1).w.approximatelyZero()) {
+        const fp tmp1 = prob * ComplexNumbers::mag2(ptr->e.at(1).w);
+
+        if (visited.find(ptr->e.at(1).p) != visited.end()) {
+          probsMone[ptr->e.at(1).p] = probsMone[ptr->e.at(1).p] + tmp1;
+        } else {
+          probsMone[ptr->e.at(1).p] = tmp1;
+          visited.insert(ptr->e.at(1).p);
+          q.push(ptr->e.at(1).p);
+        }
+      }
+    }
+
+    fp pzero{0};
+    fp pone{0};
+
+    if (assumeProbabilityNormalization) {
+      while (!q.empty()) {
+        vNode* ptr = q.front();
+        q.pop();
+
+        if (!ptr->e.at(0).w.approximatelyZero()) {
+          pzero += probsMone[ptr] * ComplexNumbers::mag2(ptr->e.at(0).w);
+        }
+
+        if (!ptr->e.at(1).w.approximatelyZero()) {
+          pone += probsMone[ptr] * ComplexNumbers::mag2(ptr->e.at(1).w);
+        }
+      }
+    } else {
+      std::unordered_map<vNode*, fp> probs;
+      assignProbabilities(rootEdge, probs);
+
+      while (!q.empty()) {
+        vNode* ptr = q.front();
+        q.pop();
+
+        if (!ptr->e.at(0).w.approximatelyZero()) {
+          pzero += probsMone[ptr] * probs[ptr->e.at(0).p] *
+                   ComplexNumbers::mag2(ptr->e.at(0).w);
+        }
+
+        if (!ptr->e.at(1).w.approximatelyZero()) {
+          pone += probsMone[ptr] * probs[ptr->e.at(1).p] *
+                  ComplexNumbers::mag2(ptr->e.at(1).w);
+        }
+      }
+    }
+    return {pzero, pone};
+  }
+
+  char measureOneCollapsing(vEdge& rootEdge, const Qubit index,
+                            const bool assumeProbabilityNormalization,
+                            std::mt19937_64& mt, fp epsilon = 0.001) {
+    const auto& [pzero, pone] = determineMeasurementProbabilities(
+        rootEdge, index, assumeProbabilityNormalization);
+    const fp sum = pzero + pone;
+    if (std::abs(sum - 1) > epsilon) {
+      throw std::runtime_error(
+          "Numerical instability occurred during measurement: |alpha|^2 + "
+          "|beta|^2 = " +
+          std::to_string(pzero) + " + " + std::to_string(pone) + " = " +
+          std::to_string(pzero + pone) + ", but should be 1!");
+    }
+    GateMatrix measurementMatrix{complex_zero, complex_zero, complex_zero,
+                                 complex_zero};
+
+    std::uniform_real_distribution<fp> dist(0.0, 1.0L);
+
+    fp threshold = dist(mt);
+    fp normalizationFactor; // NOLINT(cppcoreguidelines-init-variables) always
+                            // assigned a value in the following block
+    char result; // NOLINT(cppcoreguidelines-init-variables) always assigned a
+                 // value in the following block
+
+    if (threshold < pzero / sum) {
+      measurementMatrix[0] = complex_one;
+      normalizationFactor = pzero;
+      result = '0';
+    } else {
+      measurementMatrix[3] = complex_one;
+      normalizationFactor = pone;
+      result = '1';
+    }
+
+    mEdge measurementGate =
+        makeGateDD(measurementMatrix,
+                   static_cast<dd::QubitCount>(rootEdge.p->v + 1), index);
+
+    vEdge e = multiply(measurementGate, rootEdge);
+
+    Complex c = cn.getTemporary(std::sqrt(1.0 / normalizationFactor), 0);
+    ComplexNumbers::mul(c, e.w, c);
+    e.w = cn.lookup(c);
+    incRef(e);
+    decRef(rootEdge);
+    rootEdge = e;
+
+    return result;
+  }
+
+  ///
+  /// Addition
+  ///
+  ComputeTable<vCachedEdge, vCachedEdge, vCachedEdge,
+               Config::CT_VEC_ADD_NBUCKET>
+      vectorAdd{};
+  ComputeTable<mCachedEdge, mCachedEdge, mCachedEdge,
+               Config::CT_MAT_ADD_NBUCKET>
+      matrixAdd{};
+  ComputeTable<dCachedEdge, dCachedEdge, dCachedEdge, Config::CT_DM_ADD_NBUCKET>
+      densityAdd{};
+
+  template <class Node> [[nodiscard]] auto& getAddComputeTable() {
+    if constexpr (std::is_same_v<Node, vNode>) {
+      return vectorAdd;
+    } else if constexpr (std::is_same_v<Node, mNode>) {
+      return matrixAdd;
+    } else if constexpr (std::is_same_v<Node, dNode>) {
+      return densityAdd;
+    }
+  }
+
+  template <class Edge> Edge add(const Edge& x, const Edge& y) {
+    [[maybe_unused]] const auto before = cn.cacheCount();
+
+    auto result = add2(x, y);
+
+    if (result.w != Complex::zero) {
+      cn.returnToCache(result.w);
+      result.w = cn.lookup(result.w);
+    }
+
+    [[maybe_unused]] const auto after = cn.complexCache.getCount();
+    assert(after == before);
+
+    return result;
+  }
+
+  template <class Node>
+  Edge<Node> add2(const Edge<Node>& x, const Edge<Node>& y) {
+    if (x.p == nullptr) {
+      return y;
+    }
+    if (y.p == nullptr) {
+      return x;
+    }
+
+    if (x.w.exactlyZero()) {
+      if (y.w.exactlyZero()) {
+        return Edge<Node>::zero;
+      }
+      auto r = y;
+      r.w = cn.getCached(CTEntry::val(y.w.r), CTEntry::val(y.w.i));
+      return r;
+    }
+    if (y.w.exactlyZero()) {
+      auto r = x;
+      r.w = cn.getCached(CTEntry::val(x.w.r), CTEntry::val(x.w.i));
+      return r;
+    }
+    if (x.p == y.p) {
+      auto r = y;
+      r.w = cn.addCached(x.w, y.w);
+      if (r.w.approximatelyZero()) {
+        cn.returnToCache(r.w);
+        return Edge<Node>::zero;
+      }
+      return r;
+    }
+
+    auto& computeTable = getAddComputeTable<Node>();
+    auto r = computeTable.lookup({x.p, x.w}, {y.p, y.w});
+    //           if (r.p != nullptr && false) { // activate for debugging
+    //           caching only
+    if (r.p != nullptr) {
+      if (r.w.approximatelyZero()) {
+        return Edge<Node>::zero;
+      }
+      return {r.p, cn.getCached(r.w)};
+    }
+
+    const Qubit w = (x.isTerminal() || (!y.isTerminal() && y.p->v > x.p->v))
+                        ? y.p->v
+                        : x.p->v;
+
+    constexpr std::size_t n = std::tuple_size_v<decltype(x.p->e)>;
+    std::array<Edge<Node>, n> edge{};
+    for (std::size_t i = 0U; i < n; i++) {
+      Edge<Node> e1{};
+      if (!x.isTerminal() && x.p->v == w) {
+        e1 = x.p->e[i];
+
+        if (e1.w != Complex::zero) {
+          e1.w = cn.mulCached(e1.w, x.w);
+        }
+      } else {
+        e1 = x;
+        if (y.p->e[i].p == nullptr) {
+          e1 = {nullptr, Complex::zero};
+        }
+      }
+      Edge<Node> e2{};
+      if (!y.isTerminal() && y.p->v == w) {
+        e2 = y.p->e[i];
+
+        if (e2.w != Complex::zero) {
+          e2.w = cn.mulCached(e2.w, y.w);
+        }
+      } else {
+        e2 = y;
+        if (x.p->e[i].p == nullptr) {
+          e2 = {nullptr, Complex::zero};
+        }
+      }
+
+      if constexpr (std::is_same_v<Node, dNode>) {
+        dEdge::applyDmChangesToEdges(e1, e2);
+        edge[i] = add2(e1, e2);
+        dEdge::revertDmChangesToEdges(e1, e2);
+      } else {
+        edge[i] = add2(e1, e2);
+      }
+
+      if (!x.isTerminal() && x.p->v == w && e1.w != Complex::zero) {
+        cn.returnToCache(e1.w);
+      }
+
+      if (!y.isTerminal() && y.p->v == w && e2.w != Complex::zero) {
+        cn.returnToCache(e2.w);
+      }
+    }
+
+    auto e = makeDDNode(w, edge, true);
+
+    //           if (r.p != nullptr && e.p != r.p){ // activate for debugging
+    //           caching only
+    //               std::cout << "Caching error detected in add" << std::endl;
+    //           }
+
+    computeTable.insert({x.p, x.w}, {y.p, y.w}, {e.p, e.w});
+    return e;
+  }
+
+  ///
+  /// Matrix (conjugate) transpose
+  ///
+  UnaryComputeTable<mEdge, mEdge, Config::CT_MAT_TRANS_NBUCKET>
+      matrixTranspose{};
+  UnaryComputeTable<mEdge, mEdge, Config::CT_MAT_CONJ_TRANS_NBUCKET>
+      conjugateMatrixTranspose{};
+
+  mEdge transpose(const mEdge& a) {
+    if (a.p == nullptr || a.isTerminal() || a.p->isSymmetric()) {
+      return a;
+    }
+
+    // check in compute table
+    auto r = matrixTranspose.lookup(a);
+    if (r.p != nullptr) {
+      return r;
+    }
+
+    std::array<mEdge, NEDGE> e{};
+    // transpose sub-matrices and rearrange as required
+    for (auto i = 0U; i < RADIX; ++i) {
+      for (auto j = 0U; j < RADIX; ++j) {
+        e[RADIX * i + j] = transpose(a.p->e[RADIX * j + i]);
+      }
+    }
+    // create new top node
+    r = makeDDNode(a.p->v, e);
+    // adjust top weight
+    auto c = cn.getTemporary();
+    ComplexNumbers::mul(c, r.w, a.w);
+    r.w = cn.lookup(c);
+
+    // put in compute table
+    matrixTranspose.insert(a, r);
+    return r;
+  }
+  mEdge conjugateTranspose(const mEdge& a) {
+    if (a.p == nullptr) {
+      return a;
+    }
+    if (a.isTerminal()) { // terminal case
+      auto r = a;
+      r.w = ComplexNumbers::conj(a.w);
+      return r;
+    }
+
+    // check if in compute table
+    auto r = conjugateMatrixTranspose.lookup(a);
+    if (r.p != nullptr) {
+      return r;
+    }
+
+    std::array<mEdge, NEDGE> e{};
+    // conjugate transpose submatrices and rearrange as required
+    for (auto i = 0U; i < RADIX; ++i) {
+      for (auto j = 0U; j < RADIX; ++j) {
+        e[RADIX * i + j] = conjugateTranspose(a.p->e[RADIX * j + i]);
+      }
+    }
+    // create new top node
+    r = makeDDNode(a.p->v, e);
+
+    auto c = cn.getTemporary();
+    // adjust top weight including conjugate
+    ComplexNumbers::mul(c, r.w, ComplexNumbers::conj(a.w));
+    r.w = cn.lookup(c);
+
+    // put it in the compute table
+    conjugateMatrixTranspose.insert(a, r);
+    return r;
+  }
+
+  ///
+  /// Multiplication
+  ///
+  ComputeTable<mEdge, vEdge, vCachedEdge, Config::CT_MAT_VEC_MULT_NBUCKET>
+      matrixVectorMultiplication{};
+  ComputeTable<mEdge, mEdge, mCachedEdge, Config::CT_MAT_MAT_MULT_NBUCKET>
+      matrixMatrixMultiplication{};
+  ComputeTable<dEdge, dEdge, dCachedEdge, Config::CT_DM_DM_MULT_NBUCKET>
+      densityDensityMultiplication{};
+
+  template <class LeftOperandNode, class RightOperandNode>
+  [[nodiscard]] auto& getMultiplicationComputeTable() {
+    if constexpr (std::is_same_v<RightOperandNode, vNode>) {
+      return matrixVectorMultiplication;
+    } else if constexpr (std::is_same_v<RightOperandNode, mNode>) {
+      return matrixMatrixMultiplication;
+    } else if constexpr (std::is_same_v<RightOperandNode, dNode>) {
+      return densityDensityMultiplication;
+    }
+  }
+
+  dEdge applyOperationToDensity(dEdge& e, const mEdge& operation,
+                                bool generateDensityMatrix = false) {
+    [[maybe_unused]] const auto before = cn.cacheCount();
+    auto tmp0 = conjugateTranspose(operation);
+    auto tmp1 = multiply(e, densityFromMatrixEdge(tmp0), 0, false);
+    auto tmp2 = multiply(densityFromMatrixEdge(operation), tmp1, 0,
+                         generateDensityMatrix);
+    incRef(tmp2);
+    dEdge::alignDensityEdge(e);
+    decRef(e);
+    e = tmp2;
+
+    if (generateDensityMatrix) {
+      dEdge::setDensityMatrixTrue(e);
+    }
+
+    return e;
+  }
+
+  template <class LeftOperand, class RightOperand>
+  RightOperand multiply(const LeftOperand& x, const RightOperand& y,
+                        dd::Qubit start = 0,
+                        [[maybe_unused]] bool generateDensityMatrix = false) {
+    [[maybe_unused]] const auto before = cn.cacheCount();
+
+    Qubit var = -1;
+    RightOperand e;
+
+    if constexpr (std::is_same_v<LeftOperand, dEdge>) {
+      auto xCopy = x;
+      auto yCopy = y;
+      dEdge::applyDmChangesToEdges(xCopy, yCopy);
+
+      if (!xCopy.isTerminal()) {
+        var = xCopy.p->v;
+      }
+      if (!y.isTerminal() && yCopy.p->v > var) {
+        var = yCopy.p->v;
+      }
+
+      e = multiply2(xCopy, yCopy, var, start, generateDensityMatrix);
+
+      dEdge::revertDmChangesToEdges(xCopy, yCopy);
+
+    } else {
+      if (!x.isTerminal()) {
+        var = x.p->v;
+      }
+      if (!y.isTerminal() && (y.p->v) > var) {
+        var = y.p->v;
+      }
+      e = multiply2(x, y, var, start);
+    }
+
+    if (!e.w.exactlyZero() && !e.w.exactlyOne()) {
+      cn.returnToCache(e.w);
+      e.w = cn.lookup(e.w);
+    }
+
+    [[maybe_unused]] const auto after = cn.cacheCount();
+    assert(before == after);
+
+    return e;
+  }
+
+private:
+  template <class LeftOperandNode, class RightOperandNode>
+  Edge<RightOperandNode>
+  multiply2(const Edge<LeftOperandNode>& x, const Edge<RightOperandNode>& y,
+            Qubit var, Qubit start = 0,
+            [[maybe_unused]] bool generateDensityMatrix = false) {
+    using LEdge = Edge<LeftOperandNode>;
+    using REdge = Edge<RightOperandNode>;
+    using ResultEdge = Edge<RightOperandNode>;
+
+    if (x.p == nullptr) {
+      return {nullptr, Complex::zero};
+    }
+    if (y.p == nullptr) {
+      return y;
+    }
+
+    if (x.w.exactlyZero() || y.w.exactlyZero()) {
+      return ResultEdge::zero;
+    }
+
+    if (var == start - 1) {
+      return ResultEdge::terminal(cn.mulCached(x.w, y.w));
+    }
+
+    auto xCopy = x;
+    xCopy.w = Complex::one;
+    auto yCopy = y;
+    yCopy.w = Complex::one;
+
+    auto& computeTable =
+        getMultiplicationComputeTable<LeftOperandNode, RightOperandNode>();
+    auto r = computeTable.lookup(xCopy, yCopy, generateDensityMatrix);
+    //            if (r.p != nullptr && false) { // activate for debugging
+    //            caching only
+    if (r.p != nullptr) {
+      if (r.w.approximatelyZero()) {
+        return ResultEdge::zero;
+      }
+      auto e = ResultEdge{r.p, cn.getCached(r.w)};
+      ComplexNumbers::mul(e.w, e.w, x.w);
+      ComplexNumbers::mul(e.w, e.w, y.w);
+      if (e.w.approximatelyZero()) {
+        cn.returnToCache(e.w);
+        return ResultEdge::zero;
+      }
+      return e;
+    }
+
+    constexpr std::size_t n = std::tuple_size_v<decltype(y.p->e)>;
+
+    ResultEdge e{};
+    if constexpr (std::is_same_v<RightOperandNode, mCachedEdge>) {
+      // This branch is only taken for matrices
+      if (x.p->v == var && x.p->v == y.p->v) {
+        if (x.p->isIdentity()) {
+          if constexpr (n == NEDGE) {
+            // additionally check if y is the identity in case of matrix
+            // multiplication
+            if (y.p->isIdentity()) {
+              e = makeIdent(start, var);
             } else {
-                measurementMatrix[3] = complex_one;
-                normalizationFactor  = pone;
-                result               = '1';
-            }
-
-            mEdge measurementGate = makeGateDD(measurementMatrix, static_cast<dd::QubitCount>(rootEdge.p->v + 1), index);
-
-            vEdge e = multiply(measurementGate, rootEdge);
-
-            Complex c = cn.getTemporary(std::sqrt(1.0 / normalizationFactor), 0);
-            ComplexNumbers::mul(c, e.w, c);
-            e.w = cn.lookup(c);
-            incRef(e);
-            decRef(rootEdge);
-            rootEdge = e;
-
-            return result;
-        }
-
-        ///
-        /// Addition
-        ///
-        ComputeTable<vCachedEdge, vCachedEdge, vCachedEdge, Config::CT_VEC_ADD_NBUCKET> vectorAdd{};
-        ComputeTable<mCachedEdge, mCachedEdge, mCachedEdge, Config::CT_MAT_ADD_NBUCKET> matrixAdd{};
-        ComputeTable<dCachedEdge, dCachedEdge, dCachedEdge, Config::CT_DM_ADD_NBUCKET>  densityAdd{};
-
-        template<class Node>
-        [[nodiscard]] auto& getAddComputeTable() {
-            if constexpr (std::is_same_v<Node, vNode>) {
-                return vectorAdd;
-            } else if constexpr (std::is_same_v<Node, mNode>) {
-                return matrixAdd;
-            } else if constexpr (std::is_same_v<Node, dNode>) {
-                return densityAdd;
-            }
-        }
-
-        template<class Edge>
-        Edge add(const Edge& x, const Edge& y) {
-            [[maybe_unused]] const auto before = cn.cacheCount();
-
-            auto result = add2(x, y);
-
-            if (result.w != Complex::zero) {
-                cn.returnToCache(result.w);
-                result.w = cn.lookup(result.w);
-            }
-
-            [[maybe_unused]] const auto after = cn.complexCache.getCount();
-            assert(after == before);
-
-            return result;
-        }
-
-        template<class Node>
-        Edge<Node> add2(const Edge<Node>& x, const Edge<Node>& y) {
-            if (x.p == nullptr) {
-                return y;
-            }
-            if (y.p == nullptr) {
-                return x;
-            }
-
-            if (x.w.exactlyZero()) {
-                if (y.w.exactlyZero()) {
-                    return Edge<Node>::zero;
-                }
-                auto r = y;
-                r.w    = cn.getCached(CTEntry::val(y.w.r), CTEntry::val(y.w.i));
-                return r;
-            }
-            if (y.w.exactlyZero()) {
-                auto r = x;
-                r.w    = cn.getCached(CTEntry::val(x.w.r), CTEntry::val(x.w.i));
-                return r;
-            }
-            if (x.p == y.p) {
-                auto r = y;
-                r.w    = cn.addCached(x.w, y.w);
-                if (r.w.approximatelyZero()) {
-                    cn.returnToCache(r.w);
-                    return Edge<Node>::zero;
-                }
-                return r;
-            }
-
-            auto& computeTable = getAddComputeTable<Node>();
-            auto  r            = computeTable.lookup({x.p, x.w}, {y.p, y.w});
-            //           if (r.p != nullptr && false) { // activate for debugging caching only
-            if (r.p != nullptr) {
-                if (r.w.approximatelyZero()) {
-                    return Edge<Node>::zero;
-                }
-                return {r.p, cn.getCached(r.w)};
-            }
-
-            const Qubit w = (x.isTerminal() || (!y.isTerminal() && y.p->v > x.p->v)) ? y.p->v : x.p->v;
-
-            constexpr std::size_t     n = std::tuple_size_v<decltype(x.p->e)>;
-            std::array<Edge<Node>, n> edge{};
-            for (std::size_t i = 0U; i < n; i++) {
-                Edge<Node> e1{};
-                if (!x.isTerminal() && x.p->v == w) {
-                    e1 = x.p->e[i];
-
-                    if (e1.w != Complex::zero) {
-                        e1.w = cn.mulCached(e1.w, x.w);
-                    }
-                } else {
-                    e1 = x;
-                    if (y.p->e[i].p == nullptr) {
-                        e1 = {nullptr, Complex::zero};
-                    }
-                }
-                Edge<Node> e2{};
-                if (!y.isTerminal() && y.p->v == w) {
-                    e2 = y.p->e[i];
-
-                    if (e2.w != Complex::zero) {
-                        e2.w = cn.mulCached(e2.w, y.w);
-                    }
-                } else {
-                    e2 = y;
-                    if (x.p->e[i].p == nullptr) {
-                        e2 = {nullptr, Complex::zero};
-                    }
-                }
-
-                if constexpr (std::is_same_v<Node, dNode>) {
-                    dEdge::applyDmChangesToEdges(e1, e2);
-                    edge[i] = add2(e1, e2);
-                    dEdge::revertDmChangesToEdges(e1, e2);
-                } else {
-                    edge[i] = add2(e1, e2);
-                }
-
-                if (!x.isTerminal() && x.p->v == w && e1.w != Complex::zero) {
-                    cn.returnToCache(e1.w);
-                }
-
-                if (!y.isTerminal() && y.p->v == w && e2.w != Complex::zero) {
-                    cn.returnToCache(e2.w);
-                }
-            }
-
-            auto e = makeDDNode(w, edge, true);
-
-            //           if (r.p != nullptr && e.p != r.p){ // activate for debugging caching only
-            //               std::cout << "Caching error detected in add" << std::endl;
-            //           }
-
-            computeTable.insert({x.p, x.w}, {y.p, y.w}, {e.p, e.w});
-            return e;
-        }
-
-        ///
-        /// Matrix (conjugate) transpose
-        ///
-        UnaryComputeTable<mEdge, mEdge, Config::CT_MAT_TRANS_NBUCKET>      matrixTranspose{};
-        UnaryComputeTable<mEdge, mEdge, Config::CT_MAT_CONJ_TRANS_NBUCKET> conjugateMatrixTranspose{};
-
-        mEdge transpose(const mEdge& a) {
-            if (a.p == nullptr || a.isTerminal() || a.p->isSymmetric()) {
-                return a;
-            }
-
-            // check in compute table
-            auto r = matrixTranspose.lookup(a);
-            if (r.p != nullptr) {
-                return r;
-            }
-
-            std::array<mEdge, NEDGE> e{};
-            // transpose sub-matrices and rearrange as required
-            for (auto i = 0U; i < RADIX; ++i) {
-                for (auto j = 0U; j < RADIX; ++j) {
-                    e[RADIX * i + j] = transpose(a.p->e[RADIX * j + i]);
-                }
-            }
-            // create new top node
-            r = makeDDNode(a.p->v, e);
-            // adjust top weight
-            auto c = cn.getTemporary();
-            ComplexNumbers::mul(c, r.w, a.w);
-            r.w = cn.lookup(c);
-
-            // put in compute table
-            matrixTranspose.insert(a, r);
-            return r;
-        }
-        mEdge conjugateTranspose(const mEdge& a) {
-            if (a.p == nullptr) {
-                return a;
-            }
-            if (a.isTerminal()) { // terminal case
-                auto r = a;
-                r.w    = ComplexNumbers::conj(a.w);
-                return r;
-            }
-
-            // check if in compute table
-            auto r = conjugateMatrixTranspose.lookup(a);
-            if (r.p != nullptr) {
-                return r;
-            }
-
-            std::array<mEdge, NEDGE> e{};
-            // conjugate transpose submatrices and rearrange as required
-            for (auto i = 0U; i < RADIX; ++i) {
-                for (auto j = 0U; j < RADIX; ++j) {
-                    e[RADIX * i + j] = conjugateTranspose(a.p->e[RADIX * j + i]);
-                }
-            }
-            // create new top node
-            r = makeDDNode(a.p->v, e);
-
-            auto c = cn.getTemporary();
-            // adjust top weight including conjugate
-            ComplexNumbers::mul(c, r.w, ComplexNumbers::conj(a.w));
-            r.w = cn.lookup(c);
-
-            // put it in the compute table
-            conjugateMatrixTranspose.insert(a, r);
-            return r;
-        }
-
-        ///
-        /// Multiplication
-        ///
-        ComputeTable<mEdge, vEdge, vCachedEdge, Config::CT_MAT_VEC_MULT_NBUCKET> matrixVectorMultiplication{};
-        ComputeTable<mEdge, mEdge, mCachedEdge, Config::CT_MAT_MAT_MULT_NBUCKET> matrixMatrixMultiplication{};
-        ComputeTable<dEdge, dEdge, dCachedEdge, Config::CT_DM_DM_MULT_NBUCKET>   densityDensityMultiplication{};
-
-        template<class LeftOperandNode, class RightOperandNode>
-        [[nodiscard]] auto& getMultiplicationComputeTable() {
-            if constexpr (std::is_same_v<RightOperandNode, vNode>) {
-                return matrixVectorMultiplication;
-            } else if constexpr (std::is_same_v<RightOperandNode, mNode>) {
-                return matrixMatrixMultiplication;
-            } else if constexpr (std::is_same_v<RightOperandNode, dNode>) {
-                return densityDensityMultiplication;
-            }
-        }
-
-        dEdge applyOperationToDensity(dEdge& e, const mEdge& operation, bool generateDensityMatrix = false) {
-            [[maybe_unused]] const auto before = cn.cacheCount();
-            auto                        tmp0   = conjugateTranspose(operation);
-            auto                        tmp1   = multiply(e, densityFromMatrixEdge(tmp0), 0, false);
-            auto                        tmp2   = multiply(densityFromMatrixEdge(operation), tmp1, 0, generateDensityMatrix);
-            incRef(tmp2);
-            dEdge::alignDensityEdge(e);
-            decRef(e);
-            e = tmp2;
-
-            if (generateDensityMatrix) {
-                dEdge::setDensityMatrixTrue(e);
-            }
-
-            return e;
-        }
-
-        template<class LeftOperand, class RightOperand>
-        RightOperand multiply(const LeftOperand& x, const RightOperand& y, dd::Qubit start = 0, [[maybe_unused]] bool generateDensityMatrix = false) {
-            [[maybe_unused]] const auto before = cn.cacheCount();
-
-            Qubit        var = -1;
-            RightOperand e;
-
-            if constexpr (std::is_same_v<LeftOperand, dEdge>) {
-                auto xCopy = x;
-                auto yCopy = y;
-                dEdge::applyDmChangesToEdges(xCopy, yCopy);
-
-                if (!xCopy.isTerminal()) {
-                    var = xCopy.p->v;
-                }
-                if (!y.isTerminal() && yCopy.p->v > var) {
-                    var = yCopy.p->v;
-                }
-
-                e = multiply2(xCopy, yCopy, var, start, generateDensityMatrix);
-
-                dEdge::revertDmChangesToEdges(xCopy, yCopy);
-
-            } else {
-                if (!x.isTerminal()) {
-                    var = x.p->v;
-                }
-                if (!y.isTerminal() && (y.p->v) > var) {
-                    var = y.p->v;
-                }
-                e = multiply2(x, y, var, start);
-            }
-
-            if (!e.w.exactlyZero() && !e.w.exactlyOne()) {
-                cn.returnToCache(e.w);
-                e.w = cn.lookup(e.w);
-            }
-
-            [[maybe_unused]] const auto after = cn.cacheCount();
-            assert(before == after);
-
-            return e;
-        }
-
-    private:
-        template<class LeftOperandNode, class RightOperandNode>
-        Edge<RightOperandNode> multiply2(const Edge<LeftOperandNode>& x, const Edge<RightOperandNode>& y, Qubit var, Qubit start = 0, [[maybe_unused]] bool generateDensityMatrix = false) {
-            using LEdge      = Edge<LeftOperandNode>;
-            using REdge      = Edge<RightOperandNode>;
-            using ResultEdge = Edge<RightOperandNode>;
-
-            if (x.p == nullptr) {
-                return {nullptr, Complex::zero};
-            }
-            if (y.p == nullptr) {
-                return y;
-            }
-
-            if (x.w.exactlyZero() || y.w.exactlyZero()) {
-                return ResultEdge::zero;
-            }
-
-            if (var == start - 1) {
-                return ResultEdge::terminal(cn.mulCached(x.w, y.w));
-            }
-
-            auto xCopy = x;
-            xCopy.w    = Complex::one;
-            auto yCopy = y;
-            yCopy.w    = Complex::one;
-
-            auto& computeTable = getMultiplicationComputeTable<LeftOperandNode, RightOperandNode>();
-            auto  r            = computeTable.lookup(xCopy, yCopy, generateDensityMatrix);
-            //            if (r.p != nullptr && false) { // activate for debugging caching only
-            if (r.p != nullptr) {
-                if (r.w.approximatelyZero()) {
-                    return ResultEdge::zero;
-                }
-                auto e = ResultEdge{r.p, cn.getCached(r.w)};
-                ComplexNumbers::mul(e.w, e.w, x.w);
-                ComplexNumbers::mul(e.w, e.w, y.w);
-                if (e.w.approximatelyZero()) {
-                    cn.returnToCache(e.w);
-                    return ResultEdge::zero;
-                }
-                return e;
-            }
-
-            constexpr std::size_t n = std::tuple_size_v<decltype(y.p->e)>;
-
-            ResultEdge e{};
-            if constexpr (std::is_same_v<RightOperandNode, mCachedEdge>) {
-                // This branch is only taken for matrices
-                if (x.p->v == var && x.p->v == y.p->v) {
-                    if (x.p->isIdentity()) {
-                        if constexpr (n == NEDGE) {
-                            // additionally check if y is the identity in case of matrix multiplication
-                            if (y.p->isIdentity()) {
-                                e = makeIdent(start, var);
-                            } else {
-                                e = yCopy;
-                            }
-                        } else {
-                            e = yCopy;
-                        }
-                        computeTable.insert(xCopy, yCopy, {e.p, e.w});
-                        e.w = cn.mulCached(x.w, y.w);
-                        if (e.w.approximatelyZero()) {
-                            cn.returnToCache(e.w);
-                            return ResultEdge::zero;
-                        }
-                        return e;
-                    }
-
-                    if constexpr (n == NEDGE) {
-                        // additionally check if y is the identity in case of matrix multiplication
-                        if (y.p->isIdentity()) {
-                            e = xCopy;
-                            computeTable.insert(xCopy, yCopy, {e.p, e.w});
-                            e.w = cn.mulCached(x.w, y.w);
-
-                            if (e.w.approximatelyZero()) {
-                                cn.returnToCache(e.w);
-                                return ResultEdge::zero;
-                            }
-                            return e;
-                        }
-                    }
-                }
-            }
-
-            constexpr std::size_t rows = RADIX;
-            constexpr std::size_t cols = n == NEDGE ? RADIX : 1U;
-
-            std::array<ResultEdge, n> edge{};
-            for (auto i = 0U; i < rows; i++) {
-                for (auto j = 0U; j < cols; j++) {
-                    auto idx  = cols * i + j;
-                    edge[idx] = ResultEdge::zero;
-                    for (auto k = 0U; k < rows; k++) {
-                        LEdge e1{};
-                        if (!x.isTerminal() && x.p->v == var) {
-                            e1 = x.p->e[rows * i + k];
-                        } else {
-                            e1 = xCopy;
-                        }
-
-                        REdge e2{};
-                        if (!y.isTerminal() && y.p->v == var) {
-                            e2 = y.p->e[j + cols * k];
-                        } else {
-                            e2 = yCopy;
-                        }
-
-                        if constexpr (std::is_same_v<LeftOperandNode, dNode>) {
-                            dEdge m;
-                            dEdge::applyDmChangesToEdges(e1, e2);
-                            if (!generateDensityMatrix || idx == 1) {
-                                // When generateDensityMatrix is false or I have the first edge I don't optimize anything and set generateDensityMatrix to false for all child edges
-                                m = multiply2(e1, e2, static_cast<Qubit>(var - 1), start, false);
-                            } else if (idx == 2) {
-                                // When I have the second edge and generateDensityMatrix == false, then edge[2] == edge[1]
-                                if (k == 0) {
-                                    if (edge[1].w.approximatelyZero()) {
-                                        edge[2] = ResultEdge::zero;
-                                    } else {
-                                        edge[2] = ResultEdge{edge[1].p, cn.getCached(edge[1].w.r->value, edge[1].w.i->value)};
-                                    }
-                                }
-                                continue;
-                            } else {
-                                m = multiply2(e1, e2, static_cast<Qubit>(var - 1), start, generateDensityMatrix);
-                            }
-
-                            if (k == 0 || edge[idx].w.exactlyZero()) {
-                                edge[idx] = m;
-                            } else if (!m.w.exactlyZero()) {
-                                dEdge::applyDmChangesToEdges(edge[idx], m);
-                                auto oldE = edge[idx];
-                                edge[idx] = add2(edge[idx], m);
-                                dEdge::revertDmChangesToEdges(edge[idx], e2);
-                                cn.returnToCache(oldE.w);
-                                cn.returnToCache(m.w);
-                            }
-                            //Undo modifications on density matrices
-                            dEdge::revertDmChangesToEdges(e1, e2);
-                        } else {
-                            auto m = multiply2(e1, e2, static_cast<Qubit>(var - 1), start);
-
-                            if (k == 0 || edge[idx].w.exactlyZero()) {
-                                edge[idx] = m;
-                            } else if (!m.w.exactlyZero()) {
-                                auto oldE = edge[idx];
-                                edge[idx] = add2(edge[idx], m);
-                                cn.returnToCache(oldE.w);
-                                cn.returnToCache(m.w);
-                            }
-                        }
-                    }
-                }
+              e = yCopy;
             }
-            e = makeDDNode(var, edge, true, generateDensityMatrix);
-
-            //            if (r.p != nullptr && e.p != r.p) { // activate for debugging caching
-            //                std::cout << "Caching error detected in mul" << std::endl;
-            //            }
-
+          } else {
+            e = yCopy;
+          }
+          computeTable.insert(xCopy, yCopy, {e.p, e.w});
+          e.w = cn.mulCached(x.w, y.w);
+          if (e.w.approximatelyZero()) {
+            cn.returnToCache(e.w);
+            return ResultEdge::zero;
+          }
+          return e;
+        }
+
+        if constexpr (n == NEDGE) {
+          // additionally check if y is the identity in case of matrix
+          // multiplication
+          if (y.p->isIdentity()) {
+            e = xCopy;
             computeTable.insert(xCopy, yCopy, {e.p, e.w});
+            e.w = cn.mulCached(x.w, y.w);
 
-            if (!e.w.exactlyZero() && (x.w.exactlyOne() || !y.w.exactlyZero())) {
-                if (e.w.exactlyOne()) {
-                    e.w = cn.mulCached(x.w, y.w);
-                } else {
-                    ComplexNumbers::mul(e.w, e.w, x.w);
-                    ComplexNumbers::mul(e.w, e.w, y.w);
-                }
-                if (e.w.approximatelyZero()) {
-                    cn.returnToCache(e.w);
-                    return ResultEdge::zero;
-                }
-            }
-            return e;
-        }
-
-        ///
-        /// Inner product, fidelity, expectation value
-        ///
-    public:
-        ComputeTable<vEdge, vEdge, vCachedEdge, Config::CT_VEC_INNER_PROD_NBUCKET> vectorInnerProduct{};
-
-        /**
-            Calculates the inner product of two vector decision diagrams x and y.
-            @param x a vector DD representing a quantum state
-            @param y a vector DD representing a quantum state
-            @return a complex number representing the scalar product of the DDs
-        **/
-        ComplexValue innerProduct(const vEdge& x, const vEdge& y) {
-            if (x.p == nullptr || y.p == nullptr || x.w.approximatelyZero() || y.w.approximatelyZero()) { // the 0 case
-                return {0, 0};
-            }
-
-            [[maybe_unused]] const auto before = cn.cacheCount();
-
-            auto w = x.p->v;
-            if (y.p->v > w) {
-                w = y.p->v;
-            }
-            auto xCopy = x;
-            xCopy.w    = ComplexNumbers::conj(x.w); // Overall normalization factor needs to be conjugated
-                                                    // before input into recursive private function
-            const ComplexValue ip = innerProduct(xCopy, y, static_cast<Qubit>(w + 1));
-
-            [[maybe_unused]] const auto after = cn.cacheCount();
-            assert(after == before);
-
-            return ip;
-        }
-
-        fp fidelity(const vEdge& x, const vEdge& y) {
-            const auto fid = innerProduct(x, y);
-            return fid.r * fid.r + fid.i * fid.i;
-        }
-
-        [[gnu::pure]] dd::fp fidelityOfMeasurementOutcomes(const vEdge& e, const ProbabilityVector& probs) {
             if (e.w.approximatelyZero()) {
-                return 0.;
-            }
-            return fidelityOfMeasurementOutcomesRecursive(e, probs, 0);
-        }
-
-        [[gnu::pure]] dd::fp fidelityOfMeasurementOutcomesRecursive(const vEdge& e, const ProbabilityVector& probs, const std::size_t i) {
-            const auto topw = dd::ComplexNumbers::mag(e.w);
-            if (e.isTerminal()) {
-                if (auto it = probs.find(i); it != probs.end()) {
-                    return topw * std::sqrt(it->second);
-                }
-                return 0.;
-            }
-
-            std::size_t leftIdx          = i;
-            dd::fp      leftContribution = 0.;
-            if (!e.p->e[0].w.approximatelyZero()) {
-                leftContribution = fidelityOfMeasurementOutcomesRecursive(e.p->e[0], probs, leftIdx);
-            }
-
-            std::size_t rightIdx          = i | (1ULL << e.p->v);
-            auto        rightContribution = 0.;
-            if (!e.p->e[1].w.approximatelyZero()) {
-                rightContribution = fidelityOfMeasurementOutcomesRecursive(e.p->e[1], probs, rightIdx);
-            }
-
-            const dd::fp fidelity = topw * (leftContribution + rightContribution);
-            return fidelity;
-        }
-
-    private:
-        /**
-            Private function to recursively calculate the inner product of two vector decision diagrams x and y with var levels.
-            @param x a vector DD representing a quantum state
-            @param y a vector DD representing a quantum state
-            @param var the number of levels contained in each vector DD
-            @return a complex number  representing the scalar product of the DDs
-            @note This function is called recursively such that the number of levels decreases each time to traverse the DDs.
-        **/
-        ComplexValue innerProduct(const vEdge& x, const vEdge& y, Qubit var) {
-            if (x.p == nullptr || y.p == nullptr || x.w.approximatelyZero() || y.w.approximatelyZero()) { // the 0 case
-                return {0.0, 0.0};
-            }
-
-            if (var == 0) { // Multiplies terminal weights
-                auto c = cn.getTemporary();
-                ComplexNumbers::mul(c, x.w, y.w);
-                return {c.r->value, c.i->value};
-            }
-
-            auto xCopy = x;
-            xCopy.w    = Complex::one; // Set to one to generate more lookup hits
-            auto yCopy = y;
-            yCopy.w    = Complex::one;
-
-            auto r = vectorInnerProduct.lookup(xCopy, yCopy);
-            if (r.p != nullptr) {
-                auto c = cn.getTemporary(r.w);
-                ComplexNumbers::mul(c, c, x.w);
-                ComplexNumbers::mul(c, c, y.w);
-                return {CTEntry::val(c.r), CTEntry::val(c.i)};
-            }
-
-            auto w = static_cast<Qubit>(var - 1);
-
-            ComplexValue sum{0.0, 0.0};
-            // Iterates through edge weights recursively until terminal
-            for (auto i = 0U; i < RADIX; i++) {
-                vEdge e1{};
-                if (!x.isTerminal() && x.p->v == w) {
-                    e1   = x.p->e[i];
-                    e1.w = ComplexNumbers::conj(e1.w);
-                } else {
-                    e1 = xCopy;
-                }
-                vEdge e2{};
-                if (!y.isTerminal() && y.p->v == w) {
-                    e2 = y.p->e[i];
-                } else {
-                    e2 = yCopy;
-                }
-                auto cv = innerProduct(e1, e2, w);
-                sum.r += cv.r;
-                sum.i += cv.i;
+              cn.returnToCache(e.w);
+              return ResultEdge::zero;
             }
-            r.p = vNode::terminal;
-            r.w = sum;
-
-            vectorInnerProduct.insert(xCopy, yCopy, r);
-            auto c = cn.getTemporary(sum);
-            ComplexNumbers::mul(c, c, x.w);
-            ComplexNumbers::mul(c, c, y.w);
-            return {CTEntry::val(c.r), CTEntry::val(c.i)};
-        }
-
-    public:
-        /**
-            Calculates the expectation value of an operator x with respect to a quantum state y given their corresponding decision diagrams.
-            @param x a matrix DD representing the operator
-            @param y a vector DD representing the quantum state
-            @return a floating point value representing the expectation value of the operator with respect to the quantum state
-            @throw an exception message is thrown if the edges are not on the same level or if the expectation value is non-real.
-            @note This function calls the multiply() function to apply the operator to the quantum state, then calls innerProduct()
-                  to calculate the overlap between the original state and the applied state i.e. <Psi| Psi'> = <Psi| (Op|Psi>).
-                  It also calls the garbageCollect() function to free up any unused memory.
-        **/
-        fp expectationValue(const mEdge& x, const vEdge& y) {
-            if (x.p->v != y.p->v) {
-                throw std::invalid_argument("Observable and state must act on the same number of qubits to compute the expectation value.");
-            }
-
-            auto               yPrime   = multiply(x, y);
-            const ComplexValue expValue = innerProduct(y, yPrime);
-
-            assert(CTEntry::approximatelyZero(expValue.i));
-
-            garbageCollect();
-
-            return expValue.r;
-        }
-
-        ///
-        /// Kronecker/tensor product
-        ///
-
-        ComputeTable<vEdge, vEdge, vCachedEdge, Config::CT_VEC_KRON_NBUCKET> vectorKronecker{};
-        ComputeTable<mEdge, mEdge, mCachedEdge, Config::CT_MAT_KRON_NBUCKET> matrixKronecker{};
-
-        template<class Node>
-        [[nodiscard]] auto& getKroneckerComputeTable() {
-            if constexpr (std::is_same_v<Node, vNode>) {
-                return vectorKronecker;
-            } else {
-                return matrixKronecker;
-            }
-        }
-
-        template<class Edge>
-        Edge kronecker(const Edge& x, const Edge& y, bool incIdx = true) {
-            if constexpr (std::is_same_v<Edge, dEdge>) {
-                throw std::invalid_argument("Kronecker is currently not supported for density matrices");
-            }
-
-            auto e = kronecker2(x, y, incIdx);
-
-            if (e.w != Complex::zero && !e.w.exactlyOne()) {
-                cn.returnToCache(e.w);
-                e.w = cn.lookup(e.w);
-            }
-
-            return e;
-        }
-
-        // extent the DD pointed to by `e` with `h` identities on top and `l` identities at the bottom
-        mEdge extend(const mEdge& e, Qubit h, Qubit l = 0) {
-            auto f = (l > 0) ? kronecker(e, makeIdent(static_cast<dd::QubitCount>(l))) : e;
-            auto g = (h > 0) ? kronecker(makeIdent(static_cast<dd::QubitCount>(h)), f) : f;
-            return g;
-        }
-
-    private:
-        template<class Node>
-        Edge<Node> kronecker2(const Edge<Node>& x, const Edge<Node>& y, bool incIdx = true) {
-            if (x.w.approximatelyZero() || y.w.approximatelyZero()) {
-                return Edge<Node>::zero;
-            }
-
-            if (x.isTerminal()) {
-                auto r = y;
-                r.w    = cn.mulCached(x.w, y.w);
-                return r;
-            }
-
-            auto& computeTable = getKroneckerComputeTable<Node>();
-            auto  r            = computeTable.lookup(x, y);
-            if (r.p != nullptr) {
-                if (r.w.approximatelyZero()) {
-                    return Edge<Node>::zero;
-                }
-                return {r.p, cn.getCached(r.w)};
-            }
-
-            constexpr std::size_t n = std::tuple_size_v<decltype(x.p->e)>;
-            // special case handling for matrices
-            if constexpr (n == NEDGE) {
-                if (x.p->isIdentity()) {
-                    auto idx = incIdx ? static_cast<Qubit>(y.p->v + 1) : y.p->v;
-                    auto e   = makeDDNode(idx, std::array{y, Edge<Node>::zero, Edge<Node>::zero, y});
-                    for (auto i = 0; i < x.p->v; ++i) {
-                        idx = incIdx ? static_cast<Qubit>(e.p->v + 1) : e.p->v;
-                        e   = makeDDNode(idx, std::array{e, Edge<Node>::zero, Edge<Node>::zero, e});
-                    }
-
-                    e.w = cn.getCached(CTEntry::val(y.w.r), CTEntry::val(y.w.i));
-                    computeTable.insert(x, y, {e.p, e.w});
-                    return e;
-                }
-            }
-
-            std::array<Edge<Node>, n> edge{};
-            for (auto i = 0U; i < n; ++i) {
-                edge[i] = kronecker2(x.p->e[i], y, incIdx);
-            }
-
-            auto idx = incIdx ? static_cast<Qubit>(y.p->v + x.p->v + 1) : x.p->v;
-            auto e   = makeDDNode(idx, edge, true);
-            ComplexNumbers::mul(e.w, e.w, x.w);
-            computeTable.insert(x, y, {e.p, e.w});
             return e;
+          }
         }
+      }
+    }
 
-        ///
-        /// (Partial) trace
-        ///
-    public:
-        mEdge partialTrace(const mEdge& a, const std::vector<bool>& eliminate) {
-            [[maybe_unused]] const auto before = cn.cacheCount();
-            const auto                  result = trace(a, eliminate);
-            [[maybe_unused]] const auto after  = cn.cacheCount();
-            assert(before == after);
-            return result;
-        }
-        ComplexValue trace(const mEdge& a) {
-            auto                        eliminate = std::vector<bool>(nqubits, true);
-            [[maybe_unused]] const auto before    = cn.cacheCount();
-            const auto                  res       = partialTrace(a, eliminate);
-            [[maybe_unused]] const auto after     = cn.cacheCount();
-            assert(before == after);
-            return {CTEntry::val(res.w.r), CTEntry::val(res.w.i)};
-        }
-        bool isCloseToIdentity(const mEdge& m, dd::fp tol = 1e-10) {
-            std::unordered_set<decltype(m.p)> visited{};
-            visited.reserve(mUniqueTable.getActiveNodeCount());
-            return isCloseToIdentityRecursive(m, visited, tol);
-        }
-
-    private:
-        /// TODO: introduce a compute table for the trace?
-        mEdge trace(const mEdge& a, const std::vector<bool>& eliminate, std::size_t alreadyEliminated = 0) {
-            if (a.w.approximatelyZero()) {
-                return mEdge::zero;
-            }
-
-            if (std::none_of(eliminate.begin(), eliminate.end(), [](bool v) { return v; })) {
-                return a;
-            }
-            auto v = a.p->v;
-            // Base case
-            if (v == -1) {
-                if (a.isTerminal()) {
-                    return a;
-                }
-                throw std::runtime_error("Expected terminal node in trace.");
-            }
-
-            if (eliminate[static_cast<std::size_t>(v)]) {
-                auto elims = alreadyEliminated + 1;
-                auto r     = mEdge::zero;
-
-                auto t0 = trace(a.p->e[0], eliminate, elims);
-                r       = add2(r, t0);
-                auto r1 = r;
-
-                auto t1 = trace(a.p->e[3], eliminate, elims);
-                r       = add2(r, t1);
-                auto r2 = r;
-
-                if (r.w.exactlyOne()) {
-                    r.w = a.w;
+    constexpr std::size_t rows = RADIX;
+    constexpr std::size_t cols = n == NEDGE ? RADIX : 1U;
+
+    std::array<ResultEdge, n> edge{};
+    for (auto i = 0U; i < rows; i++) {
+      for (auto j = 0U; j < cols; j++) {
+        auto idx = cols * i + j;
+        edge[idx] = ResultEdge::zero;
+        for (auto k = 0U; k < rows; k++) {
+          LEdge e1{};
+          if (!x.isTerminal() && x.p->v == var) {
+            e1 = x.p->e[rows * i + k];
+          } else {
+            e1 = xCopy;
+          }
+
+          REdge e2{};
+          if (!y.isTerminal() && y.p->v == var) {
+            e2 = y.p->e[j + cols * k];
+          } else {
+            e2 = yCopy;
+          }
+
+          if constexpr (std::is_same_v<LeftOperandNode, dNode>) {
+            dEdge m;
+            dEdge::applyDmChangesToEdges(e1, e2);
+            if (!generateDensityMatrix || idx == 1) {
+              // When generateDensityMatrix is false or I have the first edge I
+              // don't optimize anything and set generateDensityMatrix to false
+              // for all child edges
+              m = multiply2(e1, e2, static_cast<Qubit>(var - 1), start, false);
+            } else if (idx == 2) {
+              // When I have the second edge and generateDensityMatrix == false,
+              // then edge[2] == edge[1]
+              if (k == 0) {
+                if (edge[1].w.approximatelyZero()) {
+                  edge[2] = ResultEdge::zero;
                 } else {
-                    auto c = cn.getTemporary();
-                    ComplexNumbers::mul(c, r.w, a.w);
-                    r.w = cn.lookup(c); // better safe than sorry. this may result in complex values with magnitude > 1 in the complex table
-                }
-
-                if (r1.w != Complex::zero) {
-                    cn.returnToCache(r1.w);
-                }
-
-                if (r2.w != Complex::zero) {
-                    cn.returnToCache(r2.w);
+                  edge[2] =
+                      ResultEdge{edge[1].p, cn.getCached(edge[1].w.r->value,
+                                                         edge[1].w.i->value)};
                 }
-
-                return r;
-            }
-
-            std::array<mEdge, NEDGE> edge{};
-            std::transform(a.p->e.cbegin(),
-                           a.p->e.cend(),
-                           edge.begin(),
-                           [&](const mEdge& e) -> mEdge { return trace(e, eliminate, alreadyEliminated); });
-            auto adjustedV = static_cast<Qubit>(static_cast<std::size_t>(a.p->v) - (static_cast<std::size_t>(std::count(eliminate.begin(), eliminate.end(), true)) - alreadyEliminated));
-            auto r         = makeDDNode(adjustedV, edge);
-
-            if (r.w.exactlyOne()) {
-                r.w = a.w;
+              }
+              continue;
             } else {
-                auto c = cn.getTemporary();
-                ComplexNumbers::mul(c, r.w, a.w);
-                r.w = cn.lookup(c);
-            }
-            return r;
-        }
-
-        bool isCloseToIdentityRecursive(const mEdge& m, std::unordered_set<decltype(m.p)>& visited, dd::fp tol) {
-            // immediately return if this node has already been visited
-            if (visited.find(m.p) != visited.end()) {
-                return true;
-            }
-
-            // immediately return of this node is identical to the identity
-            if (m.p->isIdentity()) {
-                return true;
-            }
-
-            // check whether any of the middle successors is non-zero, i.e., m = [ x 0 0 y ]
-            const auto mag1 = dd::ComplexNumbers::mag2(m.p->e[1U].w);
-            const auto mag2 = dd::ComplexNumbers::mag2(m.p->e[2U].w);
-            if (mag1 > tol || mag2 > tol) {
-                visited.insert(m.p);
-                return false;
-            }
-
-            // check whether  m = [ ~1 0 0 y ]
-            const auto mag0 = dd::ComplexNumbers::mag2(m.p->e[0U].w);
-            if (std::abs(mag0 - 1.0) > tol) {
-                visited.insert(m.p);
-                return false;
-            }
-            const auto arg0 = dd::ComplexNumbers::arg(m.p->e[0U].w);
-            if (std::abs(arg0) > tol) {
-                visited.insert(m.p);
-                return false;
-            }
-
-            // check whether m = [ x 0 0 ~1 ] or m = [ x 0 0 ~0 ] (the last case is true for an ancillary qubit)
-            const auto mag3 = dd::ComplexNumbers::mag2(m.p->e[3U].w);
-            if (mag3 > tol) {
-                if (std::abs(mag3 - 1.0) > tol) {
-                    visited.insert(m.p);
-                    return false;
-                }
-                const auto arg3 = dd::ComplexNumbers::arg(m.p->e[3U].w);
-                if (std::abs(arg3) > tol) {
-                    visited.insert(m.p);
-                    return false;
-                }
-            }
-
-            // m either has the form [ ~1 0 0 ~1 ] or [ ~1 0 0 ~0 ]
-            const auto ident0 = isCloseToIdentityRecursive(m.p->e[0U], visited, tol);
-            if (!ident0) {
-                visited.insert(m.p);
-                return false;
-            }
-
-            // m either has the form [ I 0 0 ~1 ] or [ I 0 0 ~0 ]
-            const auto ident3 = isCloseToIdentityRecursive(m.p->e[3U], visited, tol);
-            visited.insert(m.p);
-            return ident3;
-        }
-
-        ///
-        /// Toffoli gates
-        ///
-    public:
-        ToffoliTable<mEdge> toffoliTable{};
-
-        ///
-        /// Identity matrices
-        ///
-        // create n-qubit identity DD. makeIdent(n) === makeIdent(0, n-1)
-        mEdge makeIdent(QubitCount n) { return makeIdent(0, static_cast<Qubit>(n - 1)); }
-        mEdge makeIdent(Qubit leastSignificantQubit, Qubit mostSignificantQubit) {
-            if (mostSignificantQubit < leastSignificantQubit) {
-                return mEdge::one;
-            }
-
-            if (leastSignificantQubit == 0 && idTable[static_cast<std::size_t>(mostSignificantQubit)].p != nullptr) {
-                return idTable[static_cast<std::size_t>(mostSignificantQubit)];
-            }
-            if (mostSignificantQubit >= 1 && (idTable[static_cast<std::size_t>(mostSignificantQubit - 1)]).p != nullptr) {
-                idTable[static_cast<std::size_t>(mostSignificantQubit)] = makeDDNode(mostSignificantQubit,
-                                                                                     std::array{idTable[static_cast<std::size_t>(mostSignificantQubit - 1)],
-                                                                                                mEdge::zero,
-                                                                                                mEdge::zero,
-                                                                                                idTable[static_cast<std::size_t>(mostSignificantQubit - 1)]});
-                return idTable[static_cast<std::size_t>(mostSignificantQubit)];
-            }
-
-            auto e = makeDDNode(leastSignificantQubit, std::array{mEdge::one, mEdge::zero, mEdge::zero, mEdge::one});
-            for (auto k = static_cast<std::size_t>(leastSignificantQubit + 1); k <= static_cast<std::make_unsigned_t<Qubit>>(mostSignificantQubit); k++) {
-                e = makeDDNode(static_cast<Qubit>(k), std::array{e, mEdge::zero, mEdge::zero, e});
-            }
-            if (leastSignificantQubit == 0) {
-                idTable[static_cast<std::size_t>(mostSignificantQubit)] = e;
-            }
-            return e;
-        }
-
-        // identity table access and reset
-        [[nodiscard]] const auto& getIdentityTable() const { return idTable; }
-
-        void clearIdentityTable() {
-            for (auto& entry: idTable) {
-                entry.p = nullptr;
-            }
-        }
-
-        mEdge createInitialMatrix(dd::QubitCount n, const std::vector<bool>& ancillary) {
-            auto e = makeIdent(n);
-            incRef(e);
-            return reduceAncillae(e, ancillary);
-        }
-
-    private:
-        std::vector<mEdge> idTable{};
-
-        ///
-        /// Noise Operations
-        ///
-    public:
-        StochasticNoiseOperationTable<mEdge, Config::STOCHASTIC_CACHE_OPS> stochasticNoiseOperationCache{nqubits};
-        DensityNoiseTable<dEdge, dEdge, Config::CT_DM_NOISE_NBUCKET>       densityNoise{};
-
-        ///
-        /// Decision diagram size
-        ///
-        template<class Edge>
-        unsigned int size(const Edge& e) {
-            static constexpr unsigned int            NODECOUNT_BUCKETS = 200000;
-            static std::unordered_set<decltype(e.p)> visited{NODECOUNT_BUCKETS}; // 2e6
-            visited.max_load_factor(10);
-            visited.clear();
-            return nodeCount(e, visited);
-        }
-
-    private:
-        template<class Edge>
-        unsigned int nodeCount(const Edge& e, std::unordered_set<decltype(e.p)>& v) const {
-            v.insert(e.p);
-            unsigned int sum = 1;
-            if (!e.isTerminal()) {
-                for (const auto& edge: e.p->e) {
-                    if (edge.p != nullptr && !v.count(edge.p)) {
-                        sum += nodeCount(edge, v);
-                    }
-                }
-            }
-            return sum;
-        }
-
-        ///
-        /// Ancillary and garbage reduction
-        ///
-    public:
-        mEdge reduceAncillae(mEdge& e, const std::vector<bool>& ancillary, bool regular = true) {
-            // return if no more garbage left
-            if (std::none_of(ancillary.begin(), ancillary.end(), [](bool v) { return v; }) || e.p == nullptr) {
-                return e;
-            }
-            Qubit lowerbound = 0;
-            for (auto i = 0U; i < ancillary.size(); ++i) {
-                if (ancillary[i]) {
-                    lowerbound = static_cast<Qubit>(i);
-                    break;
-                }
-            }
-            if (e.p->v < lowerbound) {
-                return e;
-            }
-            auto f = reduceAncillaeRecursion(e, ancillary, lowerbound, regular);
-            decRef(e);
-            incRef(f);
-            return f;
-        }
-
-        // Garbage reduction works for reversible circuits --- to be thoroughly tested for quantum circuits
-        vEdge reduceGarbage(vEdge& e, const std::vector<bool>& garbage) {
-            // return if no more garbage left
-            if (std::none_of(garbage.begin(), garbage.end(), [](bool v) { return v; }) || e.p == nullptr) {
-                return e;
-            }
-            Qubit lowerbound = 0;
-            for (std::size_t i = 0U; i < garbage.size(); ++i) {
-                if (garbage[i]) {
-                    lowerbound = static_cast<Qubit>(i);
-                    break;
-                }
-            }
-            if (e.p->v < lowerbound) {
-                return e;
-            }
-            auto f = reduceGarbageRecursion(e, garbage, lowerbound);
-            decRef(e);
-            incRef(f);
-            return f;
-        }
-        mEdge reduceGarbage(mEdge& e, const std::vector<bool>& garbage, bool regular = true) {
-            // return if no more garbage left
-            if (std::none_of(garbage.begin(), garbage.end(), [](bool v) { return v; }) || e.p == nullptr) {
-                return e;
-            }
-            Qubit lowerbound = 0;
-            for (auto i = 0U; i < garbage.size(); ++i) {
-                if (garbage[i]) {
-                    lowerbound = static_cast<Qubit>(i);
-                    break;
-                }
-            }
-            if (e.p->v < lowerbound) {
-                return e;
-            }
-            auto f = reduceGarbageRecursion(e, garbage, lowerbound, regular);
-            decRef(e);
-            incRef(f);
-            return f;
-        }
-
-    private:
-        mEdge reduceAncillaeRecursion(mEdge& e, const std::vector<bool>& ancillary, Qubit lowerbound, bool regular = true) {
-            if (e.p->v < lowerbound) {
-                return e;
-            }
-
-            auto f = e;
-
-            std::array<mEdge, NEDGE> edges{};
-            std::bitset<NEDGE>       handled{};
-            for (auto i = 0U; i < NEDGE; ++i) {
-                if (!handled.test(i)) {
-                    if (e.p->e[i].isTerminal()) {
-                        edges[i] = e.p->e[i];
-                    } else {
-                        edges[i] = reduceAncillaeRecursion(f.p->e[i], ancillary, lowerbound, regular);
-                        for (auto j = i + 1; j < NEDGE; ++j) {
-                            if (e.p->e[i].p == e.p->e[j].p) {
-                                edges[j] = edges[i];
-                                handled.set(j);
-                            }
-                        }
-                    }
-                    handled.set(i);
-                }
-            }
-            f = makeDDNode(f.p->v, edges);
-
-            // something to reduce for this qubit
-            if (f.p->v >= 0 && ancillary[static_cast<std::size_t>(f.p->v)]) {
-                if (regular) {
-                    if (f.p->e[1].w != Complex::zero || f.p->e[3].w != Complex::zero) {
-                        f = makeDDNode(f.p->v, std::array{f.p->e[0], mEdge::zero, f.p->e[2], mEdge::zero});
-                    }
-                } else {
-                    if (f.p->e[2].w != Complex::zero || f.p->e[3].w != Complex::zero) {
-                        f = makeDDNode(f.p->v, std::array{f.p->e[0], f.p->e[1], mEdge::zero, mEdge::zero});
-                    }
-                }
-            }
-
-            auto c = cn.mulCached(f.w, e.w);
-            f.w    = cn.lookup(c);
-            cn.returnToCache(c);
-            return f;
-        }
-
-        vEdge reduceGarbageRecursion(vEdge& e, const std::vector<bool>& garbage, Qubit lowerbound) {
-            if (e.p->v < lowerbound) {
-                return e;
-            }
-
-            auto f = e;
-
-            std::array<vEdge, RADIX> edges{};
-            std::bitset<RADIX>       handled{};
-            for (auto i = 0U; i < RADIX; ++i) {
-                if (!handled.test(i)) {
-                    if (e.p->e[i].isTerminal()) {
-                        edges[i] = e.p->e[i];
-                    } else {
-                        edges[i] = reduceGarbageRecursion(f.p->e[i], garbage, lowerbound);
-                        for (auto j = i + 1; j < RADIX; ++j) {
-                            if (e.p->e[i].p == e.p->e[j].p) {
-                                edges[j] = edges[i];
-                                handled.set(j);
-                            }
-                        }
-                    }
-                    handled.set(i);
-                }
-            }
-            f = makeDDNode(f.p->v, edges);
-
-            // something to reduce for this qubit
-            if (f.p->v >= 0 && garbage[static_cast<std::size_t>(f.p->v)]) {
-                if (f.p->e[1].w != Complex::zero) {
-                    vEdge g{};
-                    if (f.p->e[0].w == Complex::zero && f.p->e[1].w != Complex::zero) {
-                        g = f.p->e[1];
-                    } else if (f.p->e[1].w != Complex::zero) {
-                        g = add(f.p->e[0], f.p->e[1]);
-                    } else {
-                        g = f.p->e[0];
-                    }
-                    f = makeDDNode(e.p->v, std::array{g, vEdge::zero});
-                }
-            }
-
-            auto c = cn.mulCached(f.w, e.w);
-            f.w    = cn.lookup(c);
-            cn.returnToCache(c);
-
-            // Quick-fix for normalization bug
-            if (ComplexNumbers::mag2(f.w) > 1.0) {
-                f.w = Complex::one;
-            }
-
-            return f;
-        }
-        mEdge reduceGarbageRecursion(mEdge& e, const std::vector<bool>& garbage, Qubit lowerbound, bool regular = true) {
-            if (e.p->v < lowerbound) {
-                return e;
-            }
-
-            auto f = e;
-
-            std::array<mEdge, NEDGE> edges{};
-            std::bitset<NEDGE>       handled{};
-            for (auto i = 0U; i < NEDGE; ++i) {
-                if (!handled.test(i)) {
-                    if (e.p->e[i].isTerminal()) {
-                        edges[i] = e.p->e[i];
-                    } else {
-                        edges[i] = reduceGarbageRecursion(f.p->e[i], garbage, lowerbound, regular);
-                        for (auto j = i + 1; j < NEDGE; ++j) {
-                            if (e.p->e[i].p == e.p->e[j].p) {
-                                edges[j] = edges[i];
-                                handled.set(j);
-                            }
-                        }
-                    }
-                    handled.set(i);
-                }
+              m = multiply2(e1, e2, static_cast<Qubit>(var - 1), start,
+                            generateDensityMatrix);
             }
-            f = makeDDNode(f.p->v, edges);
 
-            // something to reduce for this qubit
-            if (f.p->v >= 0 && garbage[static_cast<std::size_t>(f.p->v)]) {
-                if (regular) {
-                    if (f.p->e[2].w != Complex::zero || f.p->e[3].w != Complex::zero) {
-                        mEdge g{};
-                        if (f.p->e[0].w == Complex::zero && f.p->e[2].w != Complex::zero) {
-                            g = f.p->e[2];
-                        } else if (f.p->e[2].w != Complex::zero) {
-                            g = add(f.p->e[0], f.p->e[2]);
-                        } else {
-                            g = f.p->e[0];
-                        }
-                        mEdge h{};
-                        if (f.p->e[1].w == Complex::zero && f.p->e[3].w != Complex::zero) {
-                            h = f.p->e[3];
-                        } else if (f.p->e[3].w != Complex::zero) {
-                            h = add(f.p->e[1], f.p->e[3]);
-                        } else {
-                            h = f.p->e[1];
-                        }
-                        f = makeDDNode(e.p->v, std::array{g, h, mEdge::zero, mEdge::zero});
-                    }
-                } else {
-                    if (f.p->e[1].w != Complex::zero || f.p->e[3].w != Complex::zero) {
-                        mEdge g{};
-                        if (f.p->e[0].w == Complex::zero && f.p->e[1].w != Complex::zero) {
-                            g = f.p->e[1];
-                        } else if (f.p->e[1].w != Complex::zero) {
-                            g = add(f.p->e[0], f.p->e[1]);
-                        } else {
-                            g = f.p->e[0];
-                        }
-                        mEdge h{};
-                        if (f.p->e[2].w == Complex::zero && f.p->e[3].w != Complex::zero) {
-                            h = f.p->e[3];
-                        } else if (f.p->e[3].w != Complex::zero) {
-                            h = add(f.p->e[2], f.p->e[3]);
-                        } else {
-                            h = f.p->e[2];
-                        }
-                        f = makeDDNode(e.p->v, std::array{g, mEdge::zero, h, mEdge::zero});
-                    }
-                }
-            }
-
-            auto c = cn.mulCached(f.w, e.w);
-            f.w    = cn.lookup(c);
-            cn.returnToCache(c);
-
-            // Quick-fix for normalization bug
-            if (ComplexNumbers::mag2(f.w) > 1.0) {
-                f.w = Complex::one;
-            }
-
-            return f;
-        }
-
-        ///
-        /// Vector and matrix extraction from DDs
-        ///
-    public:
-        /// Get a single element of the vector or matrix represented by the dd with root edge e
-        /// \tparam Edge type of edge to use (vector or matrix)
-        /// \param e edge to traverse
-        /// \param elements string {0, 1, 2, 3}^n describing which outgoing edge should be followed
-        ///        (for vectors entries are limited to 0 and 1)
-        ///        If string is longer than required, the additional characters are ignored.
-        /// \return the complex amplitude of the specified element
-        template<class Edge>
-        ComplexValue getValueByPath(const Edge& e, const std::string& elements) {
-            if (e.isTerminal()) {
-                return {CTEntry::val(e.w.r), CTEntry::val(e.w.i)};
-            }
-
-            auto c = cn.getTemporary(1, 0);
-            auto r = e;
-            do {
-                ComplexNumbers::mul(c, c, r.w);
-                auto tmp = static_cast<std::size_t>(elements.at(static_cast<std::size_t>(r.p->v)) - '0');
-                assert(tmp <= r.p->e.size());
-                r = r.p->e.at(tmp);
-            } while (!r.isTerminal());
-            ComplexNumbers::mul(c, c, r.w);
-
-            return {CTEntry::val(c.r), CTEntry::val(c.i)};
-        }
-        ComplexValue getValueByPath(const vEdge& e, std::size_t i) {
-            if (e.isTerminal()) {
-                return {CTEntry::val(e.w.r), CTEntry::val(e.w.i)};
-            }
-            return getValueByPath(e, Complex::one, i);
-        }
-        ComplexValue getValueByPath(const vEdge& e, const Complex& amp, std::size_t i) {
-            auto c = cn.mulCached(e.w, amp);
-
-            if (e.isTerminal()) {
-                cn.returnToCache(c);
-                return {CTEntry::val(c.r), CTEntry::val(c.i)};
-            }
-
-            const bool one = (i & (1ULL << e.p->v)) != 0U;
-
-            ComplexValue r{};
-            if (!one && !e.p->e[0].w.approximatelyZero()) {
-                r = getValueByPath(e.p->e[0], c, i);
-            } else if (one && !e.p->e[1].w.approximatelyZero()) {
-                r = getValueByPath(e.p->e[1], c, i);
-            }
-            cn.returnToCache(c);
-            return r;
-        }
-        ComplexValue getValueByPath(const mEdge& e, std::size_t i, std::size_t j) {
-            if (e.isTerminal()) {
-                return {CTEntry::val(e.w.r), CTEntry::val(e.w.i)};
-            }
-            return getValueByPath(e, Complex::one, i, j);
-        }
-        ComplexValue getValueByPath(const mEdge& e, const Complex& amp, std::size_t i, std::size_t j) {
-            auto c = cn.mulCached(e.w, amp);
-
-            if (e.isTerminal()) {
-                cn.returnToCache(c);
-                return {CTEntry::val(c.r), CTEntry::val(c.i)};
-            }
-
-            const bool row = (i & (1ULL << e.p->v)) != 0U;
-            const bool col = (j & (1ULL << e.p->v)) != 0U;
-
-            ComplexValue r{};
-            if (!row && !col && !e.p->e[0].w.approximatelyZero()) {
-                r = getValueByPath(e.p->e[0], c, i, j);
-            } else if (!row && col && !e.p->e[1].w.approximatelyZero()) {
-                r = getValueByPath(e.p->e[1], c, i, j);
-            } else if (row && !col && !e.p->e[2].w.approximatelyZero()) {
-                r = getValueByPath(e.p->e[2], c, i, j);
-            } else if (row && col && !e.p->e[3].w.approximatelyZero()) {
-                r = getValueByPath(e.p->e[3], c, i, j);
-            }
-            cn.returnToCache(c);
-            return r;
-        }
-
-        std::map<std::string, dd::fp> getProbVectorFromDensityMatrix(dEdge e, double measurementThreshold) {
-            dEdge::alignDensityEdge(e);
-            if (std::pow(2, e.p->v + 1) >= static_cast<double>(std::numeric_limits<std::size_t>::max())) {
-                throw std::runtime_error(std::string{"Density matrix is too large to measure!"});
-            }
-
-            const std::size_t             statesToMeasure = 2ULL << e.p->v;
-            std::map<std::string, dd::fp> measuredResult  = {};
-            for (std::size_t m = 0; m < statesToMeasure; m++) {
-                std::size_t currentResult     = m;
-                auto        globalProbability = dd::CTEntry::val(e.w.r);
-                auto        resultString      = intToString(m, '1', e.p->v + 1);
-                dEdge       cur               = e;
-                for (dd::Qubit i = 0; i < e.p->v + 1; ++i) {
-                    if (cur.p->v == -1 || globalProbability <= measurementThreshold) {
-                        globalProbability = 0;
-                        break;
-                    }
-                    assert(dd::CTEntry::approximatelyZero(cur.p->e.at(0).w.i) && dd::CTEntry::approximatelyZero(cur.p->e.at(3).w.i));
-                    auto p0 = dd::CTEntry::val(cur.p->e.at(0).w.r);
-                    auto p1 = dd::CTEntry::val(cur.p->e.at(3).w.r);
-
-                    if (currentResult % 2 == 0) {
-                        cur = cur.p->e.at(0);
-                        globalProbability *= p0;
-                    } else {
-                        cur = cur.p->e.at(3);
-                        globalProbability *= p1;
-                    }
-                    currentResult = currentResult >> 1;
-                }
-                if (globalProbability > 0) { // No need to track probabilities of 0
-                    measuredResult.insert({resultString, globalProbability});
-                }
-            }
-            return measuredResult;
-        }
-
-        [[nodiscard]] std::string intToString(std::size_t targetNumber, char value, dd::Qubit size) const {
-            std::string path(static_cast<std::size_t>(size), '0');
-            for (auto i = 1; i <= size; i++) {
-                if ((targetNumber % 2) != 0U) {
-                    path[static_cast<std::size_t>(size - i)] = value;
-                }
-                targetNumber = targetNumber >> 1U;
-            }
-            return path;
-        }
-
-        CVec getVector(const vEdge& e) {
-            const std::size_t dim = 2ULL << e.p->v;
-            // allocate resulting vector
-            auto vec = CVec(dim, {0.0, 0.0});
-            getVector(e, Complex::one, 0, vec);
-            return vec;
-        }
-        void getVector(const vEdge& e, const Complex& amp, std::size_t i, CVec& vec) {
-            // calculate new accumulated amplitude
-            auto c = cn.mulCached(e.w, amp);
-
-            // base case
-            if (e.isTerminal()) {
-                vec.at(i) = {CTEntry::val(c.r), CTEntry::val(c.i)};
-                cn.returnToCache(c);
-                return;
-            }
-
-            const std::size_t x = i | (1ULL << e.p->v);
-
-            // recursive case
-            if (!e.p->e[0].w.approximatelyZero()) {
-                getVector(e.p->e[0], c, i, vec);
-            }
-            if (!e.p->e[1].w.approximatelyZero()) {
-                getVector(e.p->e[1], c, x, vec);
-            }
-            cn.returnToCache(c);
-        }
-
-        void printVector(const vEdge& e) {
-            const std::size_t element = 2ULL << e.p->v;
-            for (auto i = 0ULL; i < element; i++) {
-                const auto amplitude = getValueByPath(e, i);
-                for (Qubit j = e.p->v; j >= 0; j--) {
-                    std::cout << ((i >> j) & 1ULL);
-                }
-                constexpr auto precision = 3;
-                // set fixed width to maximum of a printed number
-                // (-) 0.precision plus/minus 0.precision i
-                constexpr auto width = 1 + 2 + precision + 1 + 2 + precision + 1;
-                std::cout << ": " << std::setw(width) << ComplexValue::toString(amplitude.r, amplitude.i, false, precision) << "\n";
-            }
-            std::cout << std::flush;
-        }
-
-        void printMatrix(const mEdge& e) {
-            const std::size_t element = 2ULL << e.p->v;
-            for (auto i = 0ULL; i < element; i++) {
-                for (auto j = 0ULL; j < element; j++) {
-                    const auto     amplitude = getValueByPath(e, i, j);
-                    constexpr auto precision = 3;
-                    // set fixed width to maximum of a printed number
-                    // (-) 0.precision plus/minus 0.precision i
-                    constexpr auto width = 1 + 2 + precision + 1 + 2 + precision + 1;
-                    std::cout << std::setw(width) << ComplexValue::toString(amplitude.r, amplitude.i, false, precision) << " ";
-                }
-                std::cout << "\n";
-            }
-            std::cout << std::flush;
-        }
-
-        CMat getMatrix(const mEdge& e) {
-            const std::size_t dim = 2ULL << e.p->v;
-            // allocate resulting matrix
-            auto mat = CMat(dim, CVec(dim, {0.0, 0.0}));
-            getMatrix(e, Complex::one, 0, 0, mat);
-            return mat;
-        }
-        void getMatrix(const mEdge& e, const Complex& amp, std::size_t i, std::size_t j, CMat& mat) {
-            // calculate new accumulated amplitude
-            auto c = cn.mulCached(e.w, amp);
-
-            // base case
-            if (e.isTerminal()) {
-                mat.at(i).at(j) = {CTEntry::val(c.r), CTEntry::val(c.i)};
-                cn.returnToCache(c);
-                return;
-            }
-
-            const std::size_t x = i | (1ULL << e.p->v);
-            const std::size_t y = j | (1ULL << e.p->v);
-
-            // recursive case
-            if (!e.p->e[0].w.approximatelyZero()) {
-                getMatrix(e.p->e[0], c, i, j, mat);
-            }
-            if (!e.p->e[1].w.approximatelyZero()) {
-                getMatrix(e.p->e[1], c, i, y, mat);
-            }
-            if (!e.p->e[2].w.approximatelyZero()) {
-                getMatrix(e.p->e[2], c, x, j, mat);
-            }
-            if (!e.p->e[3].w.approximatelyZero()) {
-                getMatrix(e.p->e[3], c, x, y, mat);
-            }
-            cn.returnToCache(c);
-        }
-
-        CMat getDensityMatrix(dEdge& e) {
-            dEdge::applyDmChangesToEdge(e);
-            const std::size_t dim = 2ULL << e.p->v;
-            // allocate resulting matrix
-            auto mat = CMat(dim, CVec(dim, {0.0, 0.0}));
-            getDensityMatrix(e, Complex::one, 0, 0, mat);
-            dd::dEdge::revertDmChangesToEdge(e);
-            return mat;
-        }
-
-        void getDensityMatrix(dEdge& e, const Complex& amp, std::size_t i, std::size_t j, CMat& mat) {
-            // calculate new accumulated amplitude
-            auto c = cn.mulCached(e.w, amp);
-
-            // base case
-            if (e.isTerminal()) {
-                mat.at(i).at(j) = {CTEntry::val(c.r), CTEntry::val(c.i)};
-                cn.returnToCache(c);
-                return;
-            }
-
-            const std::size_t x = i | (1ULL << e.p->v);
-            const std::size_t y = j | (1ULL << e.p->v);
-
-            // recursive case
-            if (!e.p->e[0].w.approximatelyZero()) {
-                dEdge::applyDmChangesToEdge(e.p->e[0]);
-                getDensityMatrix(e.p->e[0], c, i, j, mat);
-                dd::dEdge::revertDmChangesToEdge(e.p->e[0]);
-            }
-            if (!e.p->e[1].w.approximatelyZero()) {
-                dEdge::applyDmChangesToEdge(e.p->e[1]);
-                getDensityMatrix(e.p->e[1], c, i, y, mat);
-                dd::dEdge::revertDmChangesToEdge(e.p->e[1]);
-            }
-            if (!e.p->e[2].w.approximatelyZero()) {
-                dEdge::applyDmChangesToEdge(e.p->e[2]);
-                getDensityMatrix(e.p->e[2], c, x, j, mat);
-                dd::dEdge::revertDmChangesToEdge(e.p->e[2]);
-            }
-            if (!e.p->e[3].w.approximatelyZero()) {
-                dEdge::applyDmChangesToEdge(e.p->e[3]);
-                getDensityMatrix(e.p->e[3], c, x, y, mat);
-                dd::dEdge::revertDmChangesToEdge(e.p->e[3]);
-            }
-
-            cn.returnToCache(c);
-        }
-
-        void exportAmplitudesRec(const vEdge& edge, std::ostream& oss, const std::string& path, Complex& amplitude, dd::QubitCount level, bool binary = false) {
+            if (k == 0 || edge[idx].w.exactlyZero()) {
+              edge[idx] = m;
+            } else if (!m.w.exactlyZero()) {
+              dEdge::applyDmChangesToEdges(edge[idx], m);
+              auto oldE = edge[idx];
+              edge[idx] = add2(edge[idx], m);
+              dEdge::revertDmChangesToEdges(edge[idx], e2);
+              cn.returnToCache(oldE.w);
+              cn.returnToCache(m.w);
+            }
+            // Undo modifications on density matrices
+            dEdge::revertDmChangesToEdges(e1, e2);
+          } else {
+            auto m = multiply2(e1, e2, static_cast<Qubit>(var - 1), start);
+
+            if (k == 0 || edge[idx].w.exactlyZero()) {
+              edge[idx] = m;
+            } else if (!m.w.exactlyZero()) {
+              auto oldE = edge[idx];
+              edge[idx] = add2(edge[idx], m);
+              cn.returnToCache(oldE.w);
+              cn.returnToCache(m.w);
+            }
+          }
+        }
+      }
+    }
+    e = makeDDNode(var, edge, true, generateDensityMatrix);
+
+    //            if (r.p != nullptr && e.p != r.p) { // activate for debugging
+    //            caching
+    //                std::cout << "Caching error detected in mul" << std::endl;
+    //            }
+
+    computeTable.insert(xCopy, yCopy, {e.p, e.w});
+
+    if (!e.w.exactlyZero() && (x.w.exactlyOne() || !y.w.exactlyZero())) {
+      if (e.w.exactlyOne()) {
+        e.w = cn.mulCached(x.w, y.w);
+      } else {
+        ComplexNumbers::mul(e.w, e.w, x.w);
+        ComplexNumbers::mul(e.w, e.w, y.w);
+      }
+      if (e.w.approximatelyZero()) {
+        cn.returnToCache(e.w);
+        return ResultEdge::zero;
+      }
+    }
+    return e;
+  }
+
+  ///
+  /// Inner product, fidelity, expectation value
+  ///
+public:
+  ComputeTable<vEdge, vEdge, vCachedEdge, Config::CT_VEC_INNER_PROD_NBUCKET>
+      vectorInnerProduct{};
+
+  /**
+      Calculates the inner product of two vector decision diagrams x and y.
+      @param x a vector DD representing a quantum state
+      @param y a vector DD representing a quantum state
+      @return a complex number representing the scalar product of the DDs
+  **/
+  ComplexValue innerProduct(const vEdge& x, const vEdge& y) {
+    if (x.p == nullptr || y.p == nullptr || x.w.approximatelyZero() ||
+        y.w.approximatelyZero()) { // the 0 case
+      return {0, 0};
+    }
+
+    [[maybe_unused]] const auto before = cn.cacheCount();
+
+    auto w = x.p->v;
+    if (y.p->v > w) {
+      w = y.p->v;
+    }
+    auto xCopy = x;
+    xCopy.w = ComplexNumbers::conj(
+        x.w); // Overall normalization factor needs to be conjugated
+              // before input into recursive private function
+    const ComplexValue ip = innerProduct(xCopy, y, static_cast<Qubit>(w + 1));
+
+    [[maybe_unused]] const auto after = cn.cacheCount();
+    assert(after == before);
+
+    return ip;
+  }
+
+  fp fidelity(const vEdge& x, const vEdge& y) {
+    const auto fid = innerProduct(x, y);
+    return fid.r * fid.r + fid.i * fid.i;
+  }
+
+  [[gnu::pure]] dd::fp
+  fidelityOfMeasurementOutcomes(const vEdge& e,
+                                const ProbabilityVector& probs) {
+    if (e.w.approximatelyZero()) {
+      return 0.;
+    }
+    return fidelityOfMeasurementOutcomesRecursive(e, probs, 0);
+  }
+
+  [[gnu::pure]] dd::fp fidelityOfMeasurementOutcomesRecursive(
+      const vEdge& e, const ProbabilityVector& probs, const std::size_t i) {
+    const auto topw = dd::ComplexNumbers::mag(e.w);
+    if (e.isTerminal()) {
+      if (auto it = probs.find(i); it != probs.end()) {
+        return topw * std::sqrt(it->second);
+      }
+      return 0.;
+    }
+
+    std::size_t leftIdx = i;
+    dd::fp leftContribution = 0.;
+    if (!e.p->e[0].w.approximatelyZero()) {
+      leftContribution =
+          fidelityOfMeasurementOutcomesRecursive(e.p->e[0], probs, leftIdx);
+    }
+
+    std::size_t rightIdx = i | (1ULL << e.p->v);
+    auto rightContribution = 0.;
+    if (!e.p->e[1].w.approximatelyZero()) {
+      rightContribution =
+          fidelityOfMeasurementOutcomesRecursive(e.p->e[1], probs, rightIdx);
+    }
+
+    const dd::fp fidelity = topw * (leftContribution + rightContribution);
+    return fidelity;
+  }
+
+private:
+  /**
+      Private function to recursively calculate the inner product of two vector
+  decision diagrams x and y with var levels.
+      @param x a vector DD representing a quantum state
+      @param y a vector DD representing a quantum state
+      @param var the number of levels contained in each vector DD
+      @return a complex number  representing the scalar product of the DDs
+      @note This function is called recursively such that the number of levels
+  decreases each time to traverse the DDs.
+  **/
+  ComplexValue innerProduct(const vEdge& x, const vEdge& y, Qubit var) {
+    if (x.p == nullptr || y.p == nullptr || x.w.approximatelyZero() ||
+        y.w.approximatelyZero()) { // the 0 case
+      return {0.0, 0.0};
+    }
+
+    if (var == 0) { // Multiplies terminal weights
+      auto c = cn.getTemporary();
+      ComplexNumbers::mul(c, x.w, y.w);
+      return {c.r->value, c.i->value};
+    }
+
+    auto xCopy = x;
+    xCopy.w = Complex::one; // Set to one to generate more lookup hits
+    auto yCopy = y;
+    yCopy.w = Complex::one;
+
+    auto r = vectorInnerProduct.lookup(xCopy, yCopy);
+    if (r.p != nullptr) {
+      auto c = cn.getTemporary(r.w);
+      ComplexNumbers::mul(c, c, x.w);
+      ComplexNumbers::mul(c, c, y.w);
+      return {CTEntry::val(c.r), CTEntry::val(c.i)};
+    }
+
+    auto w = static_cast<Qubit>(var - 1);
+
+    ComplexValue sum{0.0, 0.0};
+    // Iterates through edge weights recursively until terminal
+    for (auto i = 0U; i < RADIX; i++) {
+      vEdge e1{};
+      if (!x.isTerminal() && x.p->v == w) {
+        e1 = x.p->e[i];
+        e1.w = ComplexNumbers::conj(e1.w);
+      } else {
+        e1 = xCopy;
+      }
+      vEdge e2{};
+      if (!y.isTerminal() && y.p->v == w) {
+        e2 = y.p->e[i];
+      } else {
+        e2 = yCopy;
+      }
+      auto cv = innerProduct(e1, e2, w);
+      sum.r += cv.r;
+      sum.i += cv.i;
+    }
+    r.p = vNode::terminal;
+    r.w = sum;
+
+    vectorInnerProduct.insert(xCopy, yCopy, r);
+    auto c = cn.getTemporary(sum);
+    ComplexNumbers::mul(c, c, x.w);
+    ComplexNumbers::mul(c, c, y.w);
+    return {CTEntry::val(c.r), CTEntry::val(c.i)};
+  }
+
+public:
+  /**
+      Calculates the expectation value of an operator x with respect to a
+  quantum state y given their corresponding decision diagrams.
+      @param x a matrix DD representing the operator
+      @param y a vector DD representing the quantum state
+      @return a floating point value representing the expectation value of the
+  operator with respect to the quantum state
+      @throw an exception message is thrown if the edges are not on the same
+  level or if the expectation value is non-real.
+      @note This function calls the multiply() function to apply the operator to
+  the quantum state, then calls innerProduct() to calculate the overlap between
+  the original state and the applied state i.e. <Psi| Psi'> = <Psi| (Op|Psi>).
+            It also calls the garbageCollect() function to free up any unused
+  memory.
+  **/
+  fp expectationValue(const mEdge& x, const vEdge& y) {
+    if (x.p->v != y.p->v) {
+      throw std::invalid_argument(
+          "Observable and state must act on the same number of qubits to "
+          "compute the expectation value.");
+    }
+
+    auto yPrime = multiply(x, y);
+    const ComplexValue expValue = innerProduct(y, yPrime);
+
+    assert(CTEntry::approximatelyZero(expValue.i));
+
+    garbageCollect();
+
+    return expValue.r;
+  }
+
+  ///
+  /// Kronecker/tensor product
+  ///
+
+  ComputeTable<vEdge, vEdge, vCachedEdge, Config::CT_VEC_KRON_NBUCKET>
+      vectorKronecker{};
+  ComputeTable<mEdge, mEdge, mCachedEdge, Config::CT_MAT_KRON_NBUCKET>
+      matrixKronecker{};
+
+  template <class Node> [[nodiscard]] auto& getKroneckerComputeTable() {
+    if constexpr (std::is_same_v<Node, vNode>) {
+      return vectorKronecker;
+    } else {
+      return matrixKronecker;
+    }
+  }
+
+  template <class Edge>
+  Edge kronecker(const Edge& x, const Edge& y, bool incIdx = true) {
+    if constexpr (std::is_same_v<Edge, dEdge>) {
+      throw std::invalid_argument(
+          "Kronecker is currently not supported for density matrices");
+    }
+
+    auto e = kronecker2(x, y, incIdx);
+
+    if (e.w != Complex::zero && !e.w.exactlyOne()) {
+      cn.returnToCache(e.w);
+      e.w = cn.lookup(e.w);
+    }
+
+    return e;
+  }
+
+  // extent the DD pointed to by `e` with `h` identities on top and `l`
+  // identities at the bottom
+  mEdge extend(const mEdge& e, Qubit h, Qubit l = 0) {
+    auto f =
+        (l > 0) ? kronecker(e, makeIdent(static_cast<dd::QubitCount>(l))) : e;
+    auto g =
+        (h > 0) ? kronecker(makeIdent(static_cast<dd::QubitCount>(h)), f) : f;
+    return g;
+  }
+
+private:
+  template <class Node>
+  Edge<Node> kronecker2(const Edge<Node>& x, const Edge<Node>& y,
+                        bool incIdx = true) {
+    if (x.w.approximatelyZero() || y.w.approximatelyZero()) {
+      return Edge<Node>::zero;
+    }
+
+    if (x.isTerminal()) {
+      auto r = y;
+      r.w = cn.mulCached(x.w, y.w);
+      return r;
+    }
+
+    auto& computeTable = getKroneckerComputeTable<Node>();
+    auto r = computeTable.lookup(x, y);
+    if (r.p != nullptr) {
+      if (r.w.approximatelyZero()) {
+        return Edge<Node>::zero;
+      }
+      return {r.p, cn.getCached(r.w)};
+    }
+
+    constexpr std::size_t n = std::tuple_size_v<decltype(x.p->e)>;
+    // special case handling for matrices
+    if constexpr (n == NEDGE) {
+      if (x.p->isIdentity()) {
+        auto idx = incIdx ? static_cast<Qubit>(y.p->v + 1) : y.p->v;
+        auto e = makeDDNode(
+            idx, std::array{y, Edge<Node>::zero, Edge<Node>::zero, y});
+        for (auto i = 0; i < x.p->v; ++i) {
+          idx = incIdx ? static_cast<Qubit>(e.p->v + 1) : e.p->v;
+          e = makeDDNode(idx,
+                         std::array{e, Edge<Node>::zero, Edge<Node>::zero, e});
+        }
+
+        e.w = cn.getCached(CTEntry::val(y.w.r), CTEntry::val(y.w.i));
+        computeTable.insert(x, y, {e.p, e.w});
+        return e;
+      }
+    }
+
+    std::array<Edge<Node>, n> edge{};
+    for (auto i = 0U; i < n; ++i) {
+      edge[i] = kronecker2(x.p->e[i], y, incIdx);
+    }
+
+    auto idx = incIdx ? static_cast<Qubit>(y.p->v + x.p->v + 1) : x.p->v;
+    auto e = makeDDNode(idx, edge, true);
+    ComplexNumbers::mul(e.w, e.w, x.w);
+    computeTable.insert(x, y, {e.p, e.w});
+    return e;
+  }
+
+  ///
+  /// (Partial) trace
+  ///
+public:
+  mEdge partialTrace(const mEdge& a, const std::vector<bool>& eliminate) {
+    [[maybe_unused]] const auto before = cn.cacheCount();
+    const auto result = trace(a, eliminate);
+    [[maybe_unused]] const auto after = cn.cacheCount();
+    assert(before == after);
+    return result;
+  }
+  ComplexValue trace(const mEdge& a) {
+    auto eliminate = std::vector<bool>(nqubits, true);
+    [[maybe_unused]] const auto before = cn.cacheCount();
+    const auto res = partialTrace(a, eliminate);
+    [[maybe_unused]] const auto after = cn.cacheCount();
+    assert(before == after);
+    return {CTEntry::val(res.w.r), CTEntry::val(res.w.i)};
+  }
+  bool isCloseToIdentity(const mEdge& m, dd::fp tol = 1e-10) {
+    std::unordered_set<decltype(m.p)> visited{};
+    visited.reserve(mUniqueTable.getActiveNodeCount());
+    return isCloseToIdentityRecursive(m, visited, tol);
+  }
+
+private:
+  /// TODO: introduce a compute table for the trace?
+  mEdge trace(const mEdge& a, const std::vector<bool>& eliminate,
+              std::size_t alreadyEliminated = 0) {
+    if (a.w.approximatelyZero()) {
+      return mEdge::zero;
+    }
+
+    if (std::none_of(eliminate.begin(), eliminate.end(),
+                     [](bool v) { return v; })) {
+      return a;
+    }
+    auto v = a.p->v;
+    // Base case
+    if (v == -1) {
+      if (a.isTerminal()) {
+        return a;
+      }
+      throw std::runtime_error("Expected terminal node in trace.");
+    }
+
+    if (eliminate[static_cast<std::size_t>(v)]) {
+      auto elims = alreadyEliminated + 1;
+      auto r = mEdge::zero;
+
+      auto t0 = trace(a.p->e[0], eliminate, elims);
+      r = add2(r, t0);
+      auto r1 = r;
+
+      auto t1 = trace(a.p->e[3], eliminate, elims);
+      r = add2(r, t1);
+      auto r2 = r;
+
+      if (r.w.exactlyOne()) {
+        r.w = a.w;
+      } else {
+        auto c = cn.getTemporary();
+        ComplexNumbers::mul(c, r.w, a.w);
+        r.w =
+            cn.lookup(c); // better safe than sorry. this may result in complex
+                          // values with magnitude > 1 in the complex table
+      }
+
+      if (r1.w != Complex::zero) {
+        cn.returnToCache(r1.w);
+      }
+
+      if (r2.w != Complex::zero) {
+        cn.returnToCache(r2.w);
+      }
+
+      return r;
+    }
+
+    std::array<mEdge, NEDGE> edge{};
+    std::transform(a.p->e.cbegin(), a.p->e.cend(), edge.begin(),
+                   [&](const mEdge& e) -> mEdge {
+                     return trace(e, eliminate, alreadyEliminated);
+                   });
+    auto adjustedV =
+        static_cast<Qubit>(static_cast<std::size_t>(a.p->v) -
+                           (static_cast<std::size_t>(std::count(
+                                eliminate.begin(), eliminate.end(), true)) -
+                            alreadyEliminated));
+    auto r = makeDDNode(adjustedV, edge);
+
+    if (r.w.exactlyOne()) {
+      r.w = a.w;
+    } else {
+      auto c = cn.getTemporary();
+      ComplexNumbers::mul(c, r.w, a.w);
+      r.w = cn.lookup(c);
+    }
+    return r;
+  }
+
+  bool isCloseToIdentityRecursive(const mEdge& m,
+                                  std::unordered_set<decltype(m.p)>& visited,
+                                  dd::fp tol) {
+    // immediately return if this node has already been visited
+    if (visited.find(m.p) != visited.end()) {
+      return true;
+    }
+
+    // immediately return of this node is identical to the identity
+    if (m.p->isIdentity()) {
+      return true;
+    }
+
+    // check whether any of the middle successors is non-zero, i.e., m = [ x 0 0
+    // y ]
+    const auto mag1 = dd::ComplexNumbers::mag2(m.p->e[1U].w);
+    const auto mag2 = dd::ComplexNumbers::mag2(m.p->e[2U].w);
+    if (mag1 > tol || mag2 > tol) {
+      visited.insert(m.p);
+      return false;
+    }
+
+    // check whether  m = [ ~1 0 0 y ]
+    const auto mag0 = dd::ComplexNumbers::mag2(m.p->e[0U].w);
+    if (std::abs(mag0 - 1.0) > tol) {
+      visited.insert(m.p);
+      return false;
+    }
+    const auto arg0 = dd::ComplexNumbers::arg(m.p->e[0U].w);
+    if (std::abs(arg0) > tol) {
+      visited.insert(m.p);
+      return false;
+    }
+
+    // check whether m = [ x 0 0 ~1 ] or m = [ x 0 0 ~0 ] (the last case is true
+    // for an ancillary qubit)
+    const auto mag3 = dd::ComplexNumbers::mag2(m.p->e[3U].w);
+    if (mag3 > tol) {
+      if (std::abs(mag3 - 1.0) > tol) {
+        visited.insert(m.p);
+        return false;
+      }
+      const auto arg3 = dd::ComplexNumbers::arg(m.p->e[3U].w);
+      if (std::abs(arg3) > tol) {
+        visited.insert(m.p);
+        return false;
+      }
+    }
+
+    // m either has the form [ ~1 0 0 ~1 ] or [ ~1 0 0 ~0 ]
+    const auto ident0 = isCloseToIdentityRecursive(m.p->e[0U], visited, tol);
+    if (!ident0) {
+      visited.insert(m.p);
+      return false;
+    }
+
+    // m either has the form [ I 0 0 ~1 ] or [ I 0 0 ~0 ]
+    const auto ident3 = isCloseToIdentityRecursive(m.p->e[3U], visited, tol);
+    visited.insert(m.p);
+    return ident3;
+  }
+
+  ///
+  /// Toffoli gates
+  ///
+public:
+  ToffoliTable<mEdge> toffoliTable{};
+
+  ///
+  /// Identity matrices
+  ///
+  // create n-qubit identity DD. makeIdent(n) === makeIdent(0, n-1)
+  mEdge makeIdent(QubitCount n) {
+    return makeIdent(0, static_cast<Qubit>(n - 1));
+  }
+  mEdge makeIdent(Qubit leastSignificantQubit, Qubit mostSignificantQubit) {
+    if (mostSignificantQubit < leastSignificantQubit) {
+      return mEdge::one;
+    }
+
+    if (leastSignificantQubit == 0 &&
+        idTable[static_cast<std::size_t>(mostSignificantQubit)].p != nullptr) {
+      return idTable[static_cast<std::size_t>(mostSignificantQubit)];
+    }
+    if (mostSignificantQubit >= 1 &&
+        (idTable[static_cast<std::size_t>(mostSignificantQubit - 1)]).p !=
+            nullptr) {
+      idTable[static_cast<std::size_t>(mostSignificantQubit)] = makeDDNode(
+          mostSignificantQubit,
+          std::array{
+              idTable[static_cast<std::size_t>(mostSignificantQubit - 1)],
+              mEdge::zero, mEdge::zero,
+              idTable[static_cast<std::size_t>(mostSignificantQubit - 1)]});
+      return idTable[static_cast<std::size_t>(mostSignificantQubit)];
+    }
+
+    auto e =
+        makeDDNode(leastSignificantQubit, std::array{mEdge::one, mEdge::zero,
+                                                     mEdge::zero, mEdge::one});
+    for (auto k = static_cast<std::size_t>(leastSignificantQubit + 1);
+         k <= static_cast<std::make_unsigned_t<Qubit>>(mostSignificantQubit);
+         k++) {
+      e = makeDDNode(static_cast<Qubit>(k),
+                     std::array{e, mEdge::zero, mEdge::zero, e});
+    }
+    if (leastSignificantQubit == 0) {
+      idTable[static_cast<std::size_t>(mostSignificantQubit)] = e;
+    }
+    return e;
+  }
+
+  // identity table access and reset
+  [[nodiscard]] const auto& getIdentityTable() const { return idTable; }
+
+  void clearIdentityTable() {
+    for (auto& entry : idTable) {
+      entry.p = nullptr;
+    }
+  }
+
+  mEdge createInitialMatrix(dd::QubitCount n,
+                            const std::vector<bool>& ancillary) {
+    auto e = makeIdent(n);
+    incRef(e);
+    return reduceAncillae(e, ancillary);
+  }
+
+private:
+  std::vector<mEdge> idTable{};
+
+  ///
+  /// Noise Operations
+  ///
+public:
+  StochasticNoiseOperationTable<mEdge, Config::STOCHASTIC_CACHE_OPS>
+      stochasticNoiseOperationCache{nqubits};
+  DensityNoiseTable<dEdge, dEdge, Config::CT_DM_NOISE_NBUCKET> densityNoise{};
+
+  ///
+  /// Decision diagram size
+  ///
+  template <class Edge> unsigned int size(const Edge& e) {
+    static constexpr unsigned int NODECOUNT_BUCKETS = 200000;
+    static std::unordered_set<decltype(e.p)> visited{NODECOUNT_BUCKETS}; // 2e6
+    visited.max_load_factor(10);
+    visited.clear();
+    return nodeCount(e, visited);
+  }
+
+private:
+  template <class Edge>
+  unsigned int nodeCount(const Edge& e,
+                         std::unordered_set<decltype(e.p)>& v) const {
+    v.insert(e.p);
+    unsigned int sum = 1;
+    if (!e.isTerminal()) {
+      for (const auto& edge : e.p->e) {
+        if (edge.p != nullptr && !v.count(edge.p)) {
+          sum += nodeCount(edge, v);
+        }
+      }
+    }
+    return sum;
+  }
+
+  ///
+  /// Ancillary and garbage reduction
+  ///
+public:
+  mEdge reduceAncillae(mEdge& e, const std::vector<bool>& ancillary,
+                       bool regular = true) {
+    // return if no more garbage left
+    if (std::none_of(ancillary.begin(), ancillary.end(),
+                     [](bool v) { return v; }) ||
+        e.p == nullptr) {
+      return e;
+    }
+    Qubit lowerbound = 0;
+    for (auto i = 0U; i < ancillary.size(); ++i) {
+      if (ancillary[i]) {
+        lowerbound = static_cast<Qubit>(i);
+        break;
+      }
+    }
+    if (e.p->v < lowerbound) {
+      return e;
+    }
+    auto f = reduceAncillaeRecursion(e, ancillary, lowerbound, regular);
+    decRef(e);
+    incRef(f);
+    return f;
+  }
+
+  // Garbage reduction works for reversible circuits --- to be thoroughly tested
+  // for quantum circuits
+  vEdge reduceGarbage(vEdge& e, const std::vector<bool>& garbage) {
+    // return if no more garbage left
+    if (std::none_of(garbage.begin(), garbage.end(),
+                     [](bool v) { return v; }) ||
+        e.p == nullptr) {
+      return e;
+    }
+    Qubit lowerbound = 0;
+    for (std::size_t i = 0U; i < garbage.size(); ++i) {
+      if (garbage[i]) {
+        lowerbound = static_cast<Qubit>(i);
+        break;
+      }
+    }
+    if (e.p->v < lowerbound) {
+      return e;
+    }
+    auto f = reduceGarbageRecursion(e, garbage, lowerbound);
+    decRef(e);
+    incRef(f);
+    return f;
+  }
+  mEdge reduceGarbage(mEdge& e, const std::vector<bool>& garbage,
+                      bool regular = true) {
+    // return if no more garbage left
+    if (std::none_of(garbage.begin(), garbage.end(),
+                     [](bool v) { return v; }) ||
+        e.p == nullptr) {
+      return e;
+    }
+    Qubit lowerbound = 0;
+    for (auto i = 0U; i < garbage.size(); ++i) {
+      if (garbage[i]) {
+        lowerbound = static_cast<Qubit>(i);
+        break;
+      }
+    }
+    if (e.p->v < lowerbound) {
+      return e;
+    }
+    auto f = reduceGarbageRecursion(e, garbage, lowerbound, regular);
+    decRef(e);
+    incRef(f);
+    return f;
+  }
+
+private:
+  mEdge reduceAncillaeRecursion(mEdge& e, const std::vector<bool>& ancillary,
+                                Qubit lowerbound, bool regular = true) {
+    if (e.p->v < lowerbound) {
+      return e;
+    }
+
+    auto f = e;
+
+    std::array<mEdge, NEDGE> edges{};
+    std::bitset<NEDGE> handled{};
+    for (auto i = 0U; i < NEDGE; ++i) {
+      if (!handled.test(i)) {
+        if (e.p->e[i].isTerminal()) {
+          edges[i] = e.p->e[i];
+        } else {
+          edges[i] = reduceAncillaeRecursion(f.p->e[i], ancillary, lowerbound,
+                                             regular);
+          for (auto j = i + 1; j < NEDGE; ++j) {
+            if (e.p->e[i].p == e.p->e[j].p) {
+              edges[j] = edges[i];
+              handled.set(j);
+            }
+          }
+        }
+        handled.set(i);
+      }
+    }
+    f = makeDDNode(f.p->v, edges);
+
+    // something to reduce for this qubit
+    if (f.p->v >= 0 && ancillary[static_cast<std::size_t>(f.p->v)]) {
+      if (regular) {
+        if (f.p->e[1].w != Complex::zero || f.p->e[3].w != Complex::zero) {
+          f = makeDDNode(f.p->v, std::array{f.p->e[0], mEdge::zero, f.p->e[2],
+                                            mEdge::zero});
+        }
+      } else {
+        if (f.p->e[2].w != Complex::zero || f.p->e[3].w != Complex::zero) {
+          f = makeDDNode(f.p->v, std::array{f.p->e[0], f.p->e[1], mEdge::zero,
+                                            mEdge::zero});
+        }
+      }
+    }
+
+    auto c = cn.mulCached(f.w, e.w);
+    f.w = cn.lookup(c);
+    cn.returnToCache(c);
+    return f;
+  }
+
+  vEdge reduceGarbageRecursion(vEdge& e, const std::vector<bool>& garbage,
+                               Qubit lowerbound) {
+    if (e.p->v < lowerbound) {
+      return e;
+    }
+
+    auto f = e;
+
+    std::array<vEdge, RADIX> edges{};
+    std::bitset<RADIX> handled{};
+    for (auto i = 0U; i < RADIX; ++i) {
+      if (!handled.test(i)) {
+        if (e.p->e[i].isTerminal()) {
+          edges[i] = e.p->e[i];
+        } else {
+          edges[i] = reduceGarbageRecursion(f.p->e[i], garbage, lowerbound);
+          for (auto j = i + 1; j < RADIX; ++j) {
+            if (e.p->e[i].p == e.p->e[j].p) {
+              edges[j] = edges[i];
+              handled.set(j);
+            }
+          }
+        }
+        handled.set(i);
+      }
+    }
+    f = makeDDNode(f.p->v, edges);
+
+    // something to reduce for this qubit
+    if (f.p->v >= 0 && garbage[static_cast<std::size_t>(f.p->v)]) {
+      if (f.p->e[1].w != Complex::zero) {
+        vEdge g{};
+        if (f.p->e[0].w == Complex::zero && f.p->e[1].w != Complex::zero) {
+          g = f.p->e[1];
+        } else if (f.p->e[1].w != Complex::zero) {
+          g = add(f.p->e[0], f.p->e[1]);
+        } else {
+          g = f.p->e[0];
+        }
+        f = makeDDNode(e.p->v, std::array{g, vEdge::zero});
+      }
+    }
+
+    auto c = cn.mulCached(f.w, e.w);
+    f.w = cn.lookup(c);
+    cn.returnToCache(c);
+
+    // Quick-fix for normalization bug
+    if (ComplexNumbers::mag2(f.w) > 1.0) {
+      f.w = Complex::one;
+    }
+
+    return f;
+  }
+  mEdge reduceGarbageRecursion(mEdge& e, const std::vector<bool>& garbage,
+                               Qubit lowerbound, bool regular = true) {
+    if (e.p->v < lowerbound) {
+      return e;
+    }
+
+    auto f = e;
+
+    std::array<mEdge, NEDGE> edges{};
+    std::bitset<NEDGE> handled{};
+    for (auto i = 0U; i < NEDGE; ++i) {
+      if (!handled.test(i)) {
+        if (e.p->e[i].isTerminal()) {
+          edges[i] = e.p->e[i];
+        } else {
+          edges[i] =
+              reduceGarbageRecursion(f.p->e[i], garbage, lowerbound, regular);
+          for (auto j = i + 1; j < NEDGE; ++j) {
+            if (e.p->e[i].p == e.p->e[j].p) {
+              edges[j] = edges[i];
+              handled.set(j);
+            }
+          }
+        }
+        handled.set(i);
+      }
+    }
+    f = makeDDNode(f.p->v, edges);
+
+    // something to reduce for this qubit
+    if (f.p->v >= 0 && garbage[static_cast<std::size_t>(f.p->v)]) {
+      if (regular) {
+        if (f.p->e[2].w != Complex::zero || f.p->e[3].w != Complex::zero) {
+          mEdge g{};
+          if (f.p->e[0].w == Complex::zero && f.p->e[2].w != Complex::zero) {
+            g = f.p->e[2];
+          } else if (f.p->e[2].w != Complex::zero) {
+            g = add(f.p->e[0], f.p->e[2]);
+          } else {
+            g = f.p->e[0];
+          }
+          mEdge h{};
+          if (f.p->e[1].w == Complex::zero && f.p->e[3].w != Complex::zero) {
+            h = f.p->e[3];
+          } else if (f.p->e[3].w != Complex::zero) {
+            h = add(f.p->e[1], f.p->e[3]);
+          } else {
+            h = f.p->e[1];
+          }
+          f = makeDDNode(e.p->v, std::array{g, h, mEdge::zero, mEdge::zero});
+        }
+      } else {
+        if (f.p->e[1].w != Complex::zero || f.p->e[3].w != Complex::zero) {
+          mEdge g{};
+          if (f.p->e[0].w == Complex::zero && f.p->e[1].w != Complex::zero) {
+            g = f.p->e[1];
+          } else if (f.p->e[1].w != Complex::zero) {
+            g = add(f.p->e[0], f.p->e[1]);
+          } else {
+            g = f.p->e[0];
+          }
+          mEdge h{};
+          if (f.p->e[2].w == Complex::zero && f.p->e[3].w != Complex::zero) {
+            h = f.p->e[3];
+          } else if (f.p->e[3].w != Complex::zero) {
+            h = add(f.p->e[2], f.p->e[3]);
+          } else {
+            h = f.p->e[2];
+          }
+          f = makeDDNode(e.p->v, std::array{g, mEdge::zero, h, mEdge::zero});
+        }
+      }
+    }
+
+    auto c = cn.mulCached(f.w, e.w);
+    f.w = cn.lookup(c);
+    cn.returnToCache(c);
+
+    // Quick-fix for normalization bug
+    if (ComplexNumbers::mag2(f.w) > 1.0) {
+      f.w = Complex::one;
+    }
+
+    return f;
+  }
+
+  ///
+  /// Vector and matrix extraction from DDs
+  ///
+public:
+  /// Get a single element of the vector or matrix represented by the dd with
+  /// root edge e \tparam Edge type of edge to use (vector or matrix) \param e
+  /// edge to traverse \param elements string {0, 1, 2, 3}^n describing which
+  /// outgoing edge should be followed
+  ///        (for vectors entries are limited to 0 and 1)
+  ///        If string is longer than required, the additional characters are
+  ///        ignored.
+  /// \return the complex amplitude of the specified element
+  template <class Edge>
+  ComplexValue getValueByPath(const Edge& e, const std::string& elements) {
+    if (e.isTerminal()) {
+      return {CTEntry::val(e.w.r), CTEntry::val(e.w.i)};
+    }
+
+    auto c = cn.getTemporary(1, 0);
+    auto r = e;
+    // NOLINTNEXTLINE(cppcoreguidelines-avoid-do-while)
+    do {
+      ComplexNumbers::mul(c, c, r.w);
+      auto tmp = static_cast<std::size_t>(
+          elements.at(static_cast<std::size_t>(r.p->v)) - '0');
+      assert(tmp <= r.p->e.size());
+      r = r.p->e.at(tmp);
+    } while (!r.isTerminal());
+    ComplexNumbers::mul(c, c, r.w);
+
+    return {CTEntry::val(c.r), CTEntry::val(c.i)};
+  }
+  ComplexValue getValueByPath(const vEdge& e, std::size_t i) {
+    if (e.isTerminal()) {
+      return {CTEntry::val(e.w.r), CTEntry::val(e.w.i)};
+    }
+    return getValueByPath(e, Complex::one, i);
+  }
+  ComplexValue getValueByPath(const vEdge& e, const Complex& amp,
+                              std::size_t i) {
+    auto c = cn.mulCached(e.w, amp);
+
+    if (e.isTerminal()) {
+      cn.returnToCache(c);
+      return {CTEntry::val(c.r), CTEntry::val(c.i)};
+    }
+
+    const bool one = (i & (1ULL << e.p->v)) != 0U;
+
+    ComplexValue r{};
+    if (!one && !e.p->e[0].w.approximatelyZero()) {
+      r = getValueByPath(e.p->e[0], c, i);
+    } else if (one && !e.p->e[1].w.approximatelyZero()) {
+      r = getValueByPath(e.p->e[1], c, i);
+    }
+    cn.returnToCache(c);
+    return r;
+  }
+  ComplexValue getValueByPath(const mEdge& e, std::size_t i, std::size_t j) {
+    if (e.isTerminal()) {
+      return {CTEntry::val(e.w.r), CTEntry::val(e.w.i)};
+    }
+    return getValueByPath(e, Complex::one, i, j);
+  }
+  ComplexValue getValueByPath(const mEdge& e, const Complex& amp, std::size_t i,
+                              std::size_t j) {
+    auto c = cn.mulCached(e.w, amp);
+
+    if (e.isTerminal()) {
+      cn.returnToCache(c);
+      return {CTEntry::val(c.r), CTEntry::val(c.i)};
+    }
+
+    const bool row = (i & (1ULL << e.p->v)) != 0U;
+    const bool col = (j & (1ULL << e.p->v)) != 0U;
+
+    ComplexValue r{};
+    if (!row && !col && !e.p->e[0].w.approximatelyZero()) {
+      r = getValueByPath(e.p->e[0], c, i, j);
+    } else if (!row && col && !e.p->e[1].w.approximatelyZero()) {
+      r = getValueByPath(e.p->e[1], c, i, j);
+    } else if (row && !col && !e.p->e[2].w.approximatelyZero()) {
+      r = getValueByPath(e.p->e[2], c, i, j);
+    } else if (row && col && !e.p->e[3].w.approximatelyZero()) {
+      r = getValueByPath(e.p->e[3], c, i, j);
+    }
+    cn.returnToCache(c);
+    return r;
+  }
+
+  std::map<std::string, dd::fp>
+  getProbVectorFromDensityMatrix(dEdge e, double measurementThreshold) {
+    dEdge::alignDensityEdge(e);
+    if (std::pow(2, e.p->v + 1) >=
+        static_cast<double>(std::numeric_limits<std::size_t>::max())) {
+      throw std::runtime_error(
+          std::string{"Density matrix is too large to measure!"});
+    }
+
+    const std::size_t statesToMeasure = 2ULL << e.p->v;
+    std::map<std::string, dd::fp> measuredResult = {};
+    for (std::size_t m = 0; m < statesToMeasure; m++) {
+      std::size_t currentResult = m;
+      auto globalProbability = dd::CTEntry::val(e.w.r);
+      auto resultString = intToString(m, '1', e.p->v + 1);
+      dEdge cur = e;
+      for (dd::Qubit i = 0; i < e.p->v + 1; ++i) {
+        if (cur.p->v == -1 || globalProbability <= measurementThreshold) {
+          globalProbability = 0;
+          break;
+        }
+        assert(dd::CTEntry::approximatelyZero(cur.p->e.at(0).w.i) &&
+               dd::CTEntry::approximatelyZero(cur.p->e.at(3).w.i));
+        auto p0 = dd::CTEntry::val(cur.p->e.at(0).w.r);
+        auto p1 = dd::CTEntry::val(cur.p->e.at(3).w.r);
+
+        if (currentResult % 2 == 0) {
+          cur = cur.p->e.at(0);
+          globalProbability *= p0;
+        } else {
+          cur = cur.p->e.at(3);
+          globalProbability *= p1;
+        }
+        currentResult = currentResult >> 1;
+      }
+      if (globalProbability > 0) { // No need to track probabilities of 0
+        measuredResult.insert({resultString, globalProbability});
+      }
+    }
+    return measuredResult;
+  }
+
+  [[nodiscard]] std::string intToString(std::size_t targetNumber, char value,
+                                        dd::Qubit size) const {
+    std::string path(static_cast<std::size_t>(size), '0');
+    for (auto i = 1; i <= size; i++) {
+      if ((targetNumber % 2) != 0U) {
+        path[static_cast<std::size_t>(size - i)] = value;
+      }
+      targetNumber = targetNumber >> 1U;
+    }
+    return path;
+  }
+
+  CVec getVector(const vEdge& e) {
+    const std::size_t dim = 2ULL << e.p->v;
+    // allocate resulting vector
+    auto vec = CVec(dim, {0.0, 0.0});
+    getVector(e, Complex::one, 0, vec);
+    return vec;
+  }
+  void getVector(const vEdge& e, const Complex& amp, std::size_t i, CVec& vec) {
+    // calculate new accumulated amplitude
+    auto c = cn.mulCached(e.w, amp);
+
+    // base case
+    if (e.isTerminal()) {
+      vec.at(i) = {CTEntry::val(c.r), CTEntry::val(c.i)};
+      cn.returnToCache(c);
+      return;
+    }
+
+    const std::size_t x = i | (1ULL << e.p->v);
+
+    // recursive case
+    if (!e.p->e[0].w.approximatelyZero()) {
+      getVector(e.p->e[0], c, i, vec);
+    }
+    if (!e.p->e[1].w.approximatelyZero()) {
+      getVector(e.p->e[1], c, x, vec);
+    }
+    cn.returnToCache(c);
+  }
+
+  void printVector(const vEdge& e) {
+    const std::size_t element = 2ULL << e.p->v;
+    for (auto i = 0ULL; i < element; i++) {
+      const auto amplitude = getValueByPath(e, i);
+      for (Qubit j = e.p->v; j >= 0; j--) {
+        std::cout << ((i >> j) & 1ULL);
+      }
+      constexpr auto precision = 3;
+      // set fixed width to maximum of a printed number
+      // (-) 0.precision plus/minus 0.precision i
+      constexpr auto width = 1 + 2 + precision + 1 + 2 + precision + 1;
+      std::cout << ": " << std::setw(width)
+                << ComplexValue::toString(amplitude.r, amplitude.i, false,
+                                          precision)
+                << "\n";
+    }
+    std::cout << std::flush;
+  }
+
+  void printMatrix(const mEdge& e) {
+    const std::size_t element = 2ULL << e.p->v;
+    for (auto i = 0ULL; i < element; i++) {
+      for (auto j = 0ULL; j < element; j++) {
+        const auto amplitude = getValueByPath(e, i, j);
+        constexpr auto precision = 3;
+        // set fixed width to maximum of a printed number
+        // (-) 0.precision plus/minus 0.precision i
+        constexpr auto width = 1 + 2 + precision + 1 + 2 + precision + 1;
+        std::cout << std::setw(width)
+                  << ComplexValue::toString(amplitude.r, amplitude.i, false,
+                                            precision)
+                  << " ";
+      }
+      std::cout << "\n";
+    }
+    std::cout << std::flush;
+  }
+
+  CMat getMatrix(const mEdge& e) {
+    const std::size_t dim = 2ULL << e.p->v;
+    // allocate resulting matrix
+    auto mat = CMat(dim, CVec(dim, {0.0, 0.0}));
+    getMatrix(e, Complex::one, 0, 0, mat);
+    return mat;
+  }
+  void getMatrix(const mEdge& e, const Complex& amp, std::size_t i,
+                 std::size_t j, CMat& mat) {
+    // calculate new accumulated amplitude
+    auto c = cn.mulCached(e.w, amp);
+
+    // base case
+    if (e.isTerminal()) {
+      mat.at(i).at(j) = {CTEntry::val(c.r), CTEntry::val(c.i)};
+      cn.returnToCache(c);
+      return;
+    }
+
+    const std::size_t x = i | (1ULL << e.p->v);
+    const std::size_t y = j | (1ULL << e.p->v);
+
+    // recursive case
+    if (!e.p->e[0].w.approximatelyZero()) {
+      getMatrix(e.p->e[0], c, i, j, mat);
+    }
+    if (!e.p->e[1].w.approximatelyZero()) {
+      getMatrix(e.p->e[1], c, i, y, mat);
+    }
+    if (!e.p->e[2].w.approximatelyZero()) {
+      getMatrix(e.p->e[2], c, x, j, mat);
+    }
+    if (!e.p->e[3].w.approximatelyZero()) {
+      getMatrix(e.p->e[3], c, x, y, mat);
+    }
+    cn.returnToCache(c);
+  }
+
+  CMat getDensityMatrix(dEdge& e) {
+    dEdge::applyDmChangesToEdge(e);
+    const std::size_t dim = 2ULL << e.p->v;
+    // allocate resulting matrix
+    auto mat = CMat(dim, CVec(dim, {0.0, 0.0}));
+    getDensityMatrix(e, Complex::one, 0, 0, mat);
+    dd::dEdge::revertDmChangesToEdge(e);
+    return mat;
+  }
+
+  void getDensityMatrix(dEdge& e, const Complex& amp, std::size_t i,
+                        std::size_t j, CMat& mat) {
+    // calculate new accumulated amplitude
+    auto c = cn.mulCached(e.w, amp);
+
+    // base case
+    if (e.isTerminal()) {
+      mat.at(i).at(j) = {CTEntry::val(c.r), CTEntry::val(c.i)};
+      cn.returnToCache(c);
+      return;
+    }
+
+    const std::size_t x = i | (1ULL << e.p->v);
+    const std::size_t y = j | (1ULL << e.p->v);
+
+    // recursive case
+    if (!e.p->e[0].w.approximatelyZero()) {
+      dEdge::applyDmChangesToEdge(e.p->e[0]);
+      getDensityMatrix(e.p->e[0], c, i, j, mat);
+      dd::dEdge::revertDmChangesToEdge(e.p->e[0]);
+    }
+    if (!e.p->e[1].w.approximatelyZero()) {
+      dEdge::applyDmChangesToEdge(e.p->e[1]);
+      getDensityMatrix(e.p->e[1], c, i, y, mat);
+      dd::dEdge::revertDmChangesToEdge(e.p->e[1]);
+    }
+    if (!e.p->e[2].w.approximatelyZero()) {
+      dEdge::applyDmChangesToEdge(e.p->e[2]);
+      getDensityMatrix(e.p->e[2], c, x, j, mat);
+      dd::dEdge::revertDmChangesToEdge(e.p->e[2]);
+    }
+    if (!e.p->e[3].w.approximatelyZero()) {
+      dEdge::applyDmChangesToEdge(e.p->e[3]);
+      getDensityMatrix(e.p->e[3], c, x, y, mat);
+      dd::dEdge::revertDmChangesToEdge(e.p->e[3]);
+    }
+
+    cn.returnToCache(c);
+  }
+
+  void exportAmplitudesRec(const vEdge& edge, std::ostream& oss,
+                           const std::string& path, Complex& amplitude,
+                           dd::QubitCount level, bool binary = false) {
+    if (edge.isTerminal()) {
+      auto amp = cn.getTemporary();
+      dd::ComplexNumbers::mul(amp, amplitude, edge.w);
+      for (std::size_t i = 0; i < (1ULL << level); i++) {
+        if (binary) {
+          amp.writeBinary(oss);
+        } else {
+          oss << amp.toString(false, 16) << "\n";
+        }
+      }
+
+      return;
+    }
+
+    auto a = cn.mulCached(amplitude, edge.w);
+    exportAmplitudesRec(edge.p->e[0], oss, path + "0", a, level - 1, binary);
+    exportAmplitudesRec(edge.p->e[1], oss, path + "1", a, level - 1, binary);
+    cn.returnToCache(a);
+  }
+  void exportAmplitudes(const vEdge& edge, std::ostream& oss, dd::QubitCount nq,
+                        bool binary = false) {
+    if (edge.isTerminal()) {
+      // TODO special treatment
+      return;
+    }
+    auto weight = cn.getCached(1., 0.);
+    exportAmplitudesRec(edge, oss, "", weight, nq, binary);
+    cn.returnToCache(weight);
+  }
+  void exportAmplitudes(const vEdge& edge, const std::string& outputFilename,
+                        dd::QubitCount nq, bool binary = false) {
+    std::ofstream init(outputFilename);
+    std::ostringstream oss{};
+
+    exportAmplitudes(edge, oss, nq, binary);
+
+    init << oss.str() << std::flush;
+    init.close();
+  }
+
+  void exportAmplitudesRec(const vEdge& edge,
+                           std::vector<std::complex<dd::fp>>& amplitudes,
+                           Complex& amplitude, dd::QubitCount level,
+                           std::size_t idx) {
+    if (edge.isTerminal()) {
+      auto amp = cn.getTemporary();
+      dd::ComplexNumbers::mul(amp, amplitude, edge.w);
+      idx <<= level;
+      for (std::size_t i = 0; i < (1ULL << level); i++) {
+        amplitudes[idx++] =
+            std::complex<dd::fp>{dd::ComplexTable<>::Entry::val(amp.r),
+                                 dd::ComplexTable<>::Entry::val(amp.i)};
+      }
+
+      return;
+    }
+
+    auto a = cn.mulCached(amplitude, edge.w);
+    exportAmplitudesRec(edge.p->e[0], amplitudes, a, level - 1, idx << 1);
+    exportAmplitudesRec(edge.p->e[1], amplitudes, a, level - 1,
+                        (idx << 1) | 1ULL);
+    cn.returnToCache(a);
+  }
+  void exportAmplitudes(const vEdge& edge,
+                        std::vector<std::complex<dd::fp>>& amplitudes,
+                        dd::QubitCount nq) {
+    if (edge.isTerminal()) {
+      // TODO special treatment
+      return;
+    }
+    auto weight = cn.getCached(1., 0.);
+    exportAmplitudesRec(edge, amplitudes, weight, nq, 0);
+    cn.returnToCache(weight);
+  }
+
+  void addAmplitudesRec(const vEdge& edge,
+                        std::vector<std::complex<dd::fp>>& amplitudes,
+                        ComplexValue& amplitude, dd::QubitCount level,
+                        std::size_t idx) {
+    auto ar = dd::ComplexTable<>::Entry::val(edge.w.r);
+    auto ai = dd::ComplexTable<>::Entry::val(edge.w.i);
+    ComplexValue amp{ar * amplitude.r - ai * amplitude.i,
+                     ar * amplitude.i + ai * amplitude.r};
+
+    if (edge.isTerminal()) {
+      idx <<= level;
+      for (std::size_t i = 0; i < (1ULL << level); i++) {
+        auto temp = std::complex<dd::fp>{amp.r + amplitudes[idx].real(),
+                                         amp.i + amplitudes[idx].imag()};
+        amplitudes[idx++] = temp;
+      }
+
+      return;
+    }
+
+    addAmplitudesRec(edge.p->e[0], amplitudes, amp, level - 1, idx << 1);
+    addAmplitudesRec(edge.p->e[1], amplitudes, amp, level - 1, idx << 1 | 1ULL);
+  }
+  void addAmplitudes(const vEdge& edge,
+                     std::vector<std::complex<dd::fp>>& amplitudes,
+                     dd::QubitCount nq) {
+    if (edge.isTerminal()) {
+      // TODO special treatment
+      return;
+    }
+    ComplexValue a{1., 0.};
+    addAmplitudesRec(edge, amplitudes, a, nq, 0);
+  }
+
+  // transfers a decision diagram from another package to this package
+  template <class Edge> Edge transfer(Edge& original) {
+    // POST ORDER TRAVERSAL USING ONE STACK
+    // https://www.geeksforgeeks.org/iterative-postorder-traversal-using-stack/
+    Edge root{};
+    std::stack<Edge*> stack;
+
+    std::unordered_map<decltype(original.p), decltype(original.p)> mappedNode{};
+
+    Edge* currentEdge = &original;
+    if (!currentEdge->isTerminal()) {
+      constexpr std::size_t n = std::tuple_size_v<decltype(original.p->e)>;
+      // NOLINTNEXTLINE(cppcoreguidelines-avoid-do-while)
+      do {
+        while (currentEdge != nullptr && !currentEdge->isTerminal()) {
+          for (std::size_t i = n - 1; i > 0; --i) {
+            auto& edge = currentEdge->p->e[i];
             if (edge.isTerminal()) {
-                auto amp = cn.getTemporary();
-                dd::ComplexNumbers::mul(amp, amplitude, edge.w);
-                for (std::size_t i = 0; i < (1ULL << level); i++) {
-                    if (binary) {
-                        amp.writeBinary(oss);
-                    } else {
-                        oss << amp.toString(false, 16) << "\n";
-                    }
-                }
-
-                return;
+              continue;
             }
-
-            auto a = cn.mulCached(amplitude, edge.w);
-            exportAmplitudesRec(edge.p->e[0], oss, path + "0", a, level - 1, binary);
-            exportAmplitudesRec(edge.p->e[1], oss, path + "1", a, level - 1, binary);
-            cn.returnToCache(a);
-        }
-        void exportAmplitudes(const vEdge& edge, std::ostream& oss, dd::QubitCount nq, bool binary = false) {
-            if (edge.isTerminal()) {
-                // TODO special treatment
-                return;
+            if (edge.w.approximatelyZero()) {
+              continue;
             }
-            auto weight = cn.getCached(1., 0.);
-            exportAmplitudesRec(edge, oss, "", weight, nq, binary);
-            cn.returnToCache(weight);
-        }
-        void exportAmplitudes(const vEdge& edge, const std::string& outputFilename, dd::QubitCount nq, bool binary = false) {
-            std::ofstream      init(outputFilename);
-            std::ostringstream oss{};
-
-            exportAmplitudes(edge, oss, nq, binary);
-
-            init << oss.str() << std::flush;
-            init.close();
-        }
-
-        void exportAmplitudesRec(const vEdge& edge, std::vector<std::complex<dd::fp>>& amplitudes, Complex& amplitude, dd::QubitCount level, std::size_t idx) {
-            if (edge.isTerminal()) {
-                auto amp = cn.getTemporary();
-                dd::ComplexNumbers::mul(amp, amplitude, edge.w);
-                idx <<= level;
-                for (std::size_t i = 0; i < (1ULL << level); i++) {
-                    amplitudes[idx++] = std::complex<dd::fp>{dd::ComplexTable<>::Entry::val(amp.r), dd::ComplexTable<>::Entry::val(amp.i)};
-                }
-
-                return;
+            if (mappedNode.find(edge.p) != mappedNode.end()) {
+              continue;
             }
 
-            auto a = cn.mulCached(amplitude, edge.w);
-            exportAmplitudesRec(edge.p->e[0], amplitudes, a, level - 1, idx << 1);
-            exportAmplitudesRec(edge.p->e[1], amplitudes, a, level - 1, (idx << 1) | 1ULL);
-            cn.returnToCache(a);
-        }
-        void exportAmplitudes(const vEdge& edge, std::vector<std::complex<dd::fp>>& amplitudes, dd::QubitCount nq) {
-            if (edge.isTerminal()) {
-                // TODO special treatment
-                return;
-            }
-            auto weight = cn.getCached(1., 0.);
-            exportAmplitudesRec(edge, amplitudes, weight, nq, 0);
-            cn.returnToCache(weight);
-        }
-
-        void addAmplitudesRec(const vEdge& edge, std::vector<std::complex<dd::fp>>& amplitudes, ComplexValue& amplitude, dd::QubitCount level, std::size_t idx) {
-            auto         ar = dd::ComplexTable<>::Entry::val(edge.w.r);
-            auto         ai = dd::ComplexTable<>::Entry::val(edge.w.i);
-            ComplexValue amp{ar * amplitude.r - ai * amplitude.i, ar * amplitude.i + ai * amplitude.r};
-
-            if (edge.isTerminal()) {
-                idx <<= level;
-                for (std::size_t i = 0; i < (1ULL << level); i++) {
-                    auto temp         = std::complex<dd::fp>{amp.r + amplitudes[idx].real(), amp.i + amplitudes[idx].imag()};
-                    amplitudes[idx++] = temp;
-                }
-
-                return;
-            }
-
-            addAmplitudesRec(edge.p->e[0], amplitudes, amp, level - 1, idx << 1);
-            addAmplitudesRec(edge.p->e[1], amplitudes, amp, level - 1, idx << 1 | 1ULL);
-        }
-        void addAmplitudes(const vEdge& edge, std::vector<std::complex<dd::fp>>& amplitudes, dd::QubitCount nq) {
-            if (edge.isTerminal()) {
-                // TODO special treatment
-                return;
-            }
-            ComplexValue a{1., 0.};
-            addAmplitudesRec(edge, amplitudes, a, nq, 0);
-        }
-
-        // transfers a decision diagram from another package to this package
-        template<class Edge>
-        Edge transfer(Edge& original) {
-            // POST ORDER TRAVERSAL USING ONE STACK   https://www.geeksforgeeks.org/iterative-postorder-traversal-using-stack/
-            Edge              root{};
-            std::stack<Edge*> stack;
-
-            std::unordered_map<decltype(original.p), decltype(original.p)> mappedNode{};
-
-            Edge* currentEdge = &original;
-            if (!currentEdge->isTerminal()) {
-                constexpr std::size_t n = std::tuple_size_v<decltype(original.p->e)>;
-                do {
-                    while (currentEdge != nullptr && !currentEdge->isTerminal()) {
-                        for (std::size_t i = n - 1; i > 0; --i) {
-                            auto& edge = currentEdge->p->e[i];
-                            if (edge.isTerminal()) {
-                                continue;
-                            }
-                            if (edge.w.approximatelyZero()) {
-                                continue;
-                            }
-                            if (mappedNode.find(edge.p) != mappedNode.end()) {
-                                continue;
-                            }
-
-                            // non-zero edge to be included
-                            stack.push(&edge);
-                        }
-                        stack.push(currentEdge);
-                        currentEdge = &currentEdge->p->e[0];
-                    }
-                    currentEdge = stack.top();
-                    stack.pop();
-
-                    bool hasChild = false;
-                    for (std::size_t i = 1; i < n && !hasChild; ++i) {
-                        auto& edge = currentEdge->p->e[i];
-                        if (edge.w.approximatelyZero()) {
-                            continue;
-                        }
-                        if (mappedNode.find(edge.p) != mappedNode.end()) {
-                            continue;
-                        }
-                        hasChild = edge.p == stack.top()->p;
-                    }
-
-                    if (hasChild) {
-                        Edge* temp = stack.top();
-                        stack.pop();
-                        stack.push(currentEdge);
-                        currentEdge = temp;
-                    } else {
-                        if (mappedNode.find(currentEdge->p) != mappedNode.end()) {
-                            currentEdge = nullptr;
-                            continue;
-                        }
-                        std::array<Edge, n> edges{};
-                        for (std::size_t i = 0; i < n; i++) {
-                            if (currentEdge->p->e[i].isTerminal()) {
-                                edges[i].p = currentEdge->p->e[i].p;
-                            } else {
-                                edges[i].p = mappedNode[currentEdge->p->e[i].p];
-                            }
-                            edges[i].w = cn.lookup(currentEdge->p->e[i].w);
-                        }
-                        root                       = makeDDNode(currentEdge->p->v, edges);
-                        mappedNode[currentEdge->p] = root.p;
-                        currentEdge                = nullptr;
-                    }
-                } while (!stack.empty());
-
-                auto w = cn.getCached(dd::ComplexTable<>::Entry::val(original.w.r), dd::ComplexTable<>::Entry::val(original.w.i));
-                dd::ComplexNumbers::mul(w, root.w, w);
-                root.w = cn.lookup(w);
-                cn.returnToCache(w);
-            } else {
-                root.p = original.p; // terminal -> static
-                root.w = cn.lookup(original.w);
-            }
-            return root;
-        }
-
-        ///
-        /// Deserialization
-        /// Note: do not rely on the binary format being portable across different architectures/platforms
-        ///
-
-        template<class Node, class Edge = Edge<Node>, std::size_t N = std::tuple_size_v<decltype(Node::e)>>
-        Edge deserialize(std::istream& is, bool readBinary = false) {
-            auto         result = Edge::zero;
-            ComplexValue rootweight{};
-
-            std::unordered_map<std::int64_t, Node*> nodes{};
-            std::int64_t                            nodeIndex{};
-            Qubit                                   v{};
-            std::array<ComplexValue, N>             edgeWeights{};
-            std::array<std::int64_t, N>             edgeIndices{};
-            edgeIndices.fill(-2);
-
-            if (readBinary) {
-                std::remove_const_t<decltype(SERIALIZATION_VERSION)> version{};
-                is.read(reinterpret_cast<char*>(&version), sizeof(decltype(SERIALIZATION_VERSION)));
-                if (version != SERIALIZATION_VERSION) {
-                    throw std::runtime_error("Wrong Version of serialization file version. version of file: " + std::to_string(version) + "; current version: " + std::to_string(SERIALIZATION_VERSION));
-                }
-
-                if (!is.eof()) {
-                    rootweight.readBinary(is);
-                }
-
-                while (is.read(reinterpret_cast<char*>(&nodeIndex), sizeof(decltype(nodeIndex)))) {
-                    is.read(reinterpret_cast<char*>(&v), sizeof(decltype(v)));
-                    for (std::size_t i = 0U; i < N; i++) {
-                        is.read(reinterpret_cast<char*>(&edgeIndices[i]), sizeof(decltype(edgeIndices[i])));
-                        edgeWeights[i].readBinary(is);
-                    }
-                    result = deserializeNode(nodeIndex, v, edgeIndices, edgeWeights, nodes);
-                }
+            // non-zero edge to be included
+            stack.push(&edge);
+          }
+          stack.push(currentEdge);
+          currentEdge = &currentEdge->p->e[0];
+        }
+        currentEdge = stack.top();
+        stack.pop();
+
+        bool hasChild = false;
+        for (std::size_t i = 1; i < n && !hasChild; ++i) {
+          auto& edge = currentEdge->p->e[i];
+          if (edge.w.approximatelyZero()) {
+            continue;
+          }
+          if (mappedNode.find(edge.p) != mappedNode.end()) {
+            continue;
+          }
+          hasChild = edge.p == stack.top()->p;
+        }
+
+        if (hasChild) {
+          Edge* temp = stack.top();
+          stack.pop();
+          stack.push(currentEdge);
+          currentEdge = temp;
+        } else {
+          if (mappedNode.find(currentEdge->p) != mappedNode.end()) {
+            currentEdge = nullptr;
+            continue;
+          }
+          std::array<Edge, n> edges{};
+          for (std::size_t i = 0; i < n; i++) {
+            if (currentEdge->p->e[i].isTerminal()) {
+              edges[i].p = currentEdge->p->e[i].p;
             } else {
-                std::string version;
-                std::getline(is, version);
-                if (std::stoi(version) != SERIALIZATION_VERSION) {
-                    throw std::runtime_error("Wrong Version of serialization file version. version of file: " + version + "; current version: " + std::to_string(SERIALIZATION_VERSION));
-                }
-
-                const std::string complexRealRegex = R"(([+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?(?![ \d\.]*(?:[eE][+-])?\d*[iI]))?)";
-                const std::string complexImagRegex = R"(( ?[+-]? ?(?:(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?)?[iI])?)";
-                const std::string edgeRegex        = " \\(((-?\\d+) (" + complexRealRegex + complexImagRegex + "))?\\)";
-                const std::regex  complexWeightRegex(complexRealRegex + complexImagRegex);
-
-                std::string lineConstruct = "(\\d+) (\\d+)";
-                for (std::size_t i = 0U; i < N; ++i) {
-                    lineConstruct += "(?:" + edgeRegex + ")";
-                }
-                lineConstruct += " *(?:#.*)?";
-                const std::regex lineRegex(lineConstruct);
-                std::smatch      m;
-
-                std::string line;
-                if (std::getline(is, line)) {
-                    if (!std::regex_match(line, m, complexWeightRegex)) {
-                        throw std::runtime_error("Regex did not match second line: " + line);
-                    }
-                    rootweight.fromString(m.str(1), m.str(2));
-                }
-
-                while (std::getline(is, line)) {
-                    if (line.empty() || line.size() == 1) {
-                        continue;
-                    }
-
-                    if (!std::regex_match(line, m, lineRegex)) {
-                        throw std::runtime_error("Regex did not match line: " + line);
-                    }
-
-                    // match 1: node_idx
-                    // match 2: qubit_idx
-
-                    // repeats for every edge
-                    // match 3: edge content
-                    // match 4: edge_target_idx
-                    // match 5: real + imag (without i)
-                    // match 6: real
-                    // match 7: imag (without i)
-                    nodeIndex = std::stoi(m.str(1));
-                    v         = static_cast<Qubit>(std::stoi(m.str(2)));
-
-                    for (auto edgeIdx = 3U, i = 0U; i < N; i++, edgeIdx += 5) {
-                        if (m.str(edgeIdx).empty()) {
-                            continue;
-                        }
-
-                        edgeIndices[i] = std::stoi(m.str(edgeIdx + 1));
-                        edgeWeights[i].fromString(m.str(edgeIdx + 3), m.str(edgeIdx + 4));
-                    }
-
-                    result = deserializeNode(nodeIndex, v, edgeIndices, edgeWeights, nodes);
-                }
-            }
-
-            auto w = cn.getCached(rootweight.r, rootweight.i);
-            ComplexNumbers::mul(w, result.w, w);
-            result.w = cn.lookup(w);
-            cn.returnToCache(w);
-
-            return result;
-        }
-
-        template<class Node, class Edge = Edge<Node>>
-        Edge deserialize(const std::string& inputFilename, bool readBinary) {
-            auto ifs = std::ifstream(inputFilename, std::ios::binary);
-
-            if (!ifs.good()) {
-                throw std::invalid_argument("Cannot open serialized file: " + inputFilename);
-            }
-
-            return deserialize<Node>(ifs, readBinary);
-        }
-
-    private:
-        template<class Node, class Edge = Edge<Node>, std::size_t N = std::tuple_size_v<decltype(Node::e)>>
-        Edge deserializeNode(std::int64_t index, Qubit v, std::array<std::int64_t, N>& edgeIdx, std::array<ComplexValue, N>& edgeWeight, std::unordered_map<std::int64_t, Node*>& nodes) {
-            if (index == -1) {
-                return Edge::zero;
+              edges[i].p = mappedNode[currentEdge->p->e[i].p];
             }
-
-            std::array<Edge, N> edges{};
-            for (auto i = 0U; i < N; ++i) {
-                if (edgeIdx[i] == -2) {
-                    edges[i] = Edge::zero;
-                } else {
-                    if (edgeIdx[i] == -1) {
-                        edges[i] = Edge::one;
-                    } else {
-                        edges[i].p = nodes[edgeIdx[i]];
-                    }
-                    edges[i].w = cn.lookup(edgeWeight[i]);
-                }
-            }
-
-            auto newedge = makeDDNode(v, edges);
-            nodes[index] = newedge.p;
-
-            // reset
-            edgeIdx.fill(-2);
-
-            return newedge;
-        }
-
-        ///
-        /// Debugging
-        ///
-    public:
-        template<class Node>
-        void debugnode(const Node* p) const {
-            if (Node::isTerminal(p)) {
-                std::clog << "terminal\n";
-                return;
-            }
-            std::clog << "Debug node: " << debugnodeLine(p) << "\n";
-            for (const auto& edge: p->e) {
-                std::clog << "  " << std::hexfloat
-                          << std::setw(22) << CTEntry::val(edge.w.r) << " "
-                          << std::setw(22) << CTEntry::val(edge.w.i) << std::defaultfloat
-                          << "i --> " << debugnodeLine(edge.p) << "\n";
-            }
-            std::clog << std::flush;
-        }
-
-        template<class Node>
-        std::string debugnodeLine(const Node* p) const {
-            if (Node::isTerminal(p)) {
-                return "terminal";
-            }
-            std::stringstream sst;
-            sst << "0x" << std::hex << reinterpret_cast<std::uintptr_t>(p) << std::dec
-                << "[v=" << static_cast<std::int64_t>(p->v)
-                << " ref=" << p->ref
-                << " hash=" << UniqueTable<Node>::hash(p)
-                << "]";
-            return sst.str();
-        }
-
-        template<class Edge>
-        bool isLocallyConsistent(const Edge& e) {
-            // NOLINTNEXTLINE(clang-diagnostic-float-equal)
-            assert(Complex::one.r->value == 1 && Complex::one.i->value == 0);
-            // NOLINTNEXTLINE(clang-diagnostic-float-equal)
-            assert(Complex::zero.r->value == 0 && Complex::zero.i->value == 0);
-
-            const bool result = isLocallyConsistent2(e);
-            return result;
-        }
-
-        template<class Edge>
-        bool isGloballyConsistent(const Edge& e) {
-            std::map<ComplexTable<>::Entry*, std::size_t> weightCounter{};
-            std::map<decltype(e.p), std::size_t>          nodeCounter{};
-            fillConsistencyCounter(e, weightCounter, nodeCounter);
-            checkConsistencyCounter(e, weightCounter, nodeCounter);
-            return true;
-        }
-
-    private:
-        template<class Edge>
-        bool isLocallyConsistent2(const Edge& e) {
-            const auto* ptrR = CTEntry::getAlignedPointer(e.w.r);
-            const auto* ptrI = CTEntry::getAlignedPointer(e.w.i);
-
-            if ((ptrR->refCount == 0 || ptrI->refCount == 0) && e.w != Complex::one && e.w != Complex::zero) {
-                std::clog << "\nLOCAL INCONSISTENCY FOUND\nOffending Number: " << e.w << " (" << ptrR->refCount << ", " << ptrI->refCount << ")\n\n";
-                debugnode(e.p);
-                return false;
-            }
-
-            if (e.isTerminal()) {
-                return true;
-            }
-
-            if (!e.isTerminal() && e.p->ref == 0) {
-                std::clog << "\nLOCAL INCONSISTENCY FOUND: RC==0\n";
-                debugnode(e.p);
-                return false;
-            }
-
-            for (const auto& child: e.p->e) {
-                if (child.p->v + 1 != e.p->v && !child.isTerminal()) {
-                    std::clog << "\nLOCAL INCONSISTENCY FOUND: Wrong V\n";
-                    debugnode(e.p);
-                    return false;
-                }
-                if (!child.isTerminal() && child.p->ref == 0) {
-                    std::clog << "\nLOCAL INCONSISTENCY FOUND: RC==0\n";
-                    debugnode(e.p);
-                    return false;
-                }
-                if (!isLocallyConsistent2(child)) {
-                    return false;
-                }
-            }
-            return true;
-        }
-
-        template<class Edge>
-        void fillConsistencyCounter(const Edge& edge, std::map<ComplexTable<>::Entry*, std::size_t>& weightMap, std::map<decltype(edge.p), std::size_t>& nodeMap) {
-            weightMap[CTEntry::getAlignedPointer(edge.w.r)]++;
-            weightMap[CTEntry::getAlignedPointer(edge.w.i)]++;
-
-            if (edge.isTerminal()) {
-                return;
-            }
-            nodeMap[edge.p]++;
-            for (auto& child: edge.p->e) {
-                if (nodeMap[child.p] == 0) {
-                    fillConsistencyCounter(child, weightMap, nodeMap);
-                } else {
-                    nodeMap[child.p]++;
-                    weightMap[CTEntry::getAlignedPointer(child.w.r)]++;
-                    weightMap[CTEntry::getAlignedPointer(child.w.i)]++;
-                }
-            }
-        }
-
-        template<class Edge>
-        void checkConsistencyCounter(const Edge& edge, const std::map<ComplexTable<>::Entry*, std::size_t>& weightMap, const std::map<decltype(edge.p), std::size_t>& nodeMap) {
-            auto* rPtr = CTEntry::getAlignedPointer(edge.w.r);
-            auto* iPtr = CTEntry::getAlignedPointer(edge.w.i);
-
-            if (weightMap.at(rPtr) > rPtr->refCount && rPtr != Complex::one.r && rPtr != Complex::zero.i && rPtr != &ComplexTable<>::sqrt2_2) {
-                std::clog << "\nOffending weight: " << edge.w << "\n";
-                std::clog << "Bits: " << std::hexfloat << CTEntry::val(edge.w.r) << "r " << CTEntry::val(edge.w.i) << std::defaultfloat << "i\n";
-                debugnode(edge.p);
-                throw std::runtime_error("Ref-Count mismatch for " + std::to_string(rPtr->value) + "(r): " + std::to_string(weightMap.at(rPtr)) + " occurrences in DD but Ref-Count is only " + std::to_string(rPtr->refCount));
-            }
-
-            if (weightMap.at(iPtr) > iPtr->refCount && iPtr != Complex::zero.i && iPtr != Complex::one.r && iPtr != &ComplexTable<>::sqrt2_2) {
-                std::clog << "\nOffending weight: " << edge.w << "\n";
-                std::clog << "Bits: " << std::hexfloat << CTEntry::val(edge.w.r) << "r " << CTEntry::val(edge.w.i) << std::defaultfloat << "i\n";
-                debugnode(edge.p);
-                throw std::runtime_error("Ref-Count mismatch for " + std::to_string(iPtr->value) + "(i): " + std::to_string(weightMap.at(iPtr)) + " occurrences in DD but Ref-Count is only " + std::to_string(iPtr->refCount));
-            }
-
-            if (edge.isTerminal()) {
-                return;
-            }
-
-            if (nodeMap.at(edge.p) != edge.p->ref) {
-                debugnode(edge.p);
-                throw std::runtime_error("Ref-Count mismatch for node: " + std::to_string(nodeMap.at(edge.p)) + " occurrences in DD but Ref-Count is " + std::to_string(edge.p->ref));
-            }
-            for (auto child: edge.p->e) {
-                if (!child.isTerminal() && child.p->v != edge.p->v - 1) {
-                    std::clog << "child.p->v == " << child.p->v << "\n";
-                    std::clog << " edge.p->v == " << edge.p->v << "\n";
-                    debugnode(child.p);
-                    debugnode(edge.p);
-                    throw std::runtime_error("Variable level ordering seems wrong");
-                }
-                checkConsistencyCounter(child, weightMap, nodeMap);
-            }
-        }
-
-        ///
-        /// Printing and Statistics
-        ///
-    public:
-        // print information on package and its members
-        static void printInformation() {
-            std::cout << "\n  compiled: " << __DATE__ << " " << __TIME__
-                      << "\n  Complex size: " << sizeof(Complex) << " bytes (aligned " << alignof(Complex) << " bytes)"
-                      << "\n  ComplexValue size: " << sizeof(ComplexValue) << " bytes (aligned " << alignof(ComplexValue) << " bytes)"
-                      << "\n  ComplexNumbers size: " << sizeof(ComplexNumbers) << " bytes (aligned " << alignof(ComplexNumbers) << " bytes)"
-                      << "\n  vEdge size: " << sizeof(vEdge) << " bytes (aligned " << alignof(vEdge) << " bytes)"
-                      << "\n  vNode size: " << sizeof(vNode) << " bytes (aligned " << alignof(vNode) << " bytes)"
-                      << "\n  mEdge size: " << sizeof(mEdge) << " bytes (aligned " << alignof(mEdge) << " bytes)"
-                      << "\n  mNode size: " << sizeof(mNode) << " bytes (aligned " << alignof(mNode) << " bytes)"
-                      << "\n  CT Vector Add size: " << sizeof(typename decltype(vectorAdd)::Entry) << " bytes (aligned " << alignof(typename decltype(vectorAdd)::Entry) << " bytes)"
-                      << "\n  CT Matrix Add size: " << sizeof(typename decltype(matrixAdd)::Entry) << " bytes (aligned " << alignof(typename decltype(matrixAdd)::Entry) << " bytes)"
-                      << "\n  CT Matrix Transpose size: " << sizeof(typename decltype(matrixTranspose)::Entry) << " bytes (aligned " << alignof(typename decltype(matrixTranspose)::Entry) << " bytes)"
-                      << "\n  CT Conjugate Matrix Transpose size: " << sizeof(typename decltype(conjugateMatrixTranspose)::Entry) << " bytes (aligned " << alignof(typename decltype(conjugateMatrixTranspose)::Entry) << " bytes)"
-                      << "\n  CT Matrix Multiplication size: " << sizeof(typename decltype(matrixMatrixMultiplication)::Entry) << " bytes (aligned " << alignof(typename decltype(matrixMatrixMultiplication)::Entry) << " bytes)"
-                      << "\n  CT Matrix Vector Multiplication size: " << sizeof(typename decltype(matrixVectorMultiplication)::Entry) << " bytes (aligned " << alignof(typename decltype(matrixVectorMultiplication)::Entry) << " bytes)"
-                      << "\n  CT Vector Inner Product size: " << sizeof(typename decltype(vectorInnerProduct)::Entry) << " bytes (aligned " << alignof(typename decltype(vectorInnerProduct)::Entry) << " bytes)"
-                      << "\n  CT Vector Kronecker size: " << sizeof(typename decltype(vectorKronecker)::Entry) << " bytes (aligned " << alignof(typename decltype(vectorKronecker)::Entry) << " bytes)"
-                      << "\n  CT Matrix Kronecker size: " << sizeof(typename decltype(matrixKronecker)::Entry) << " bytes (aligned " << alignof(typename decltype(matrixKronecker)::Entry) << " bytes)"
-                      << "\n  ToffoliTable::Entry size: " << sizeof(ToffoliTable<mEdge>::Entry) << " bytes (aligned " << alignof(ToffoliTable<mEdge>::Entry) << " bytes)"
-                      << "\n  Package size: " << sizeof(Package) << " bytes (aligned " << alignof(Package) << " bytes)"
-                      << "\n"
-                      << std::flush;
-        }
-
-        // print unique and compute table statistics
-        void statistics() {
-            std::cout << "DD statistics:" << std::endl
-                      << "[vUniqueTable] ";
-            vUniqueTable.printStatistics();
-            std::cout << "[mUniqueTable] ";
-            mUniqueTable.printStatistics();
-            std::cout << "[CT Vector Add] ";
-            vectorAdd.printStatistics();
-            std::cout << "[CT Matrix Add] ";
-            matrixAdd.printStatistics();
-            std::cout << "[CT Matrix Transpose] ";
-            matrixTranspose.printStatistics();
-            std::cout << "[CT Conjugate Matrix Transpose] ";
-            conjugateMatrixTranspose.printStatistics();
-            std::cout << "[CT Matrix Multiplication] ";
-            matrixMatrixMultiplication.printStatistics();
-            std::cout << "[CT Matrix Vector Multiplication] ";
-            matrixVectorMultiplication.printStatistics();
-            std::cout << "[CT Inner Product] ";
-            vectorInnerProduct.printStatistics();
-            std::cout << "[CT Vector Kronecker] ";
-            vectorKronecker.printStatistics();
-            std::cout << "[CT Matrix Kronecker] ";
-            matrixKronecker.printStatistics();
-            std::cout << "[Toffoli Table] ";
-            toffoliTable.printStatistics();
-            std::cout << "[Stochastic Noise Table] ";
-            stochasticNoiseOperationCache.printStatistics();
-            std::cout << "[CT Density Add] ";
-            densityAdd.printStatistics();
-            std::cout << "[CT Density Mul] ";
-            densityDensityMultiplication.printStatistics();
-            std::cout << "[CT Density Noise] ";
-            densityNoise.printStatistics();
-            std::cout << "[ComplexTable] ";
-            cn.complexTable.printStatistics();
-        }
-    };
+            edges[i].w = cn.lookup(currentEdge->p->e[i].w);
+          }
+          root = makeDDNode(currentEdge->p->v, edges);
+          mappedNode[currentEdge->p] = root.p;
+          currentEdge = nullptr;
+        }
+      } while (!stack.empty());
+
+      auto w = cn.getCached(dd::ComplexTable<>::Entry::val(original.w.r),
+                            dd::ComplexTable<>::Entry::val(original.w.i));
+      dd::ComplexNumbers::mul(w, root.w, w);
+      root.w = cn.lookup(w);
+      cn.returnToCache(w);
+    } else {
+      root.p = original.p; // terminal -> static
+      root.w = cn.lookup(original.w);
+    }
+    return root;
+  }
+
+  ///
+  /// Deserialization
+  /// Note: do not rely on the binary format being portable across different
+  /// architectures/platforms
+  ///
+
+  template <class Node, class Edge = Edge<Node>,
+            std::size_t N = std::tuple_size_v<decltype(Node::e)>>
+  Edge deserialize(std::istream& is, bool readBinary = false) {
+    auto result = Edge::zero;
+    ComplexValue rootweight{};
+
+    std::unordered_map<std::int64_t, Node*> nodes{};
+    std::int64_t nodeIndex{};
+    Qubit v{};
+    std::array<ComplexValue, N> edgeWeights{};
+    std::array<std::int64_t, N> edgeIndices{};
+    edgeIndices.fill(-2);
+
+    if (readBinary) {
+      std::remove_const_t<decltype(SERIALIZATION_VERSION)> version{};
+      is.read(reinterpret_cast<char*>(&version),
+              sizeof(decltype(SERIALIZATION_VERSION)));
+      if (version != SERIALIZATION_VERSION) {
+        throw std::runtime_error(
+            "Wrong Version of serialization file version. version of file: " +
+            std::to_string(version) +
+            "; current version: " + std::to_string(SERIALIZATION_VERSION));
+      }
+
+      if (!is.eof()) {
+        rootweight.readBinary(is);
+      }
+
+      while (is.read(reinterpret_cast<char*>(&nodeIndex),
+                     sizeof(decltype(nodeIndex)))) {
+        is.read(reinterpret_cast<char*>(&v), sizeof(decltype(v)));
+        for (std::size_t i = 0U; i < N; i++) {
+          is.read(reinterpret_cast<char*>(&edgeIndices[i]),
+                  sizeof(decltype(edgeIndices[i])));
+          edgeWeights[i].readBinary(is);
+        }
+        result = deserializeNode(nodeIndex, v, edgeIndices, edgeWeights, nodes);
+      }
+    } else {
+      std::string version;
+      std::getline(is, version);
+      if (std::stoi(version) != SERIALIZATION_VERSION) {
+        throw std::runtime_error(
+            "Wrong Version of serialization file version. version of file: " +
+            version +
+            "; current version: " + std::to_string(SERIALIZATION_VERSION));
+      }
+
+      const std::string complexRealRegex =
+          R"(([+-]?(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?(?![ \d\.]*(?:[eE][+-])?\d*[iI]))?)";
+      const std::string complexImagRegex =
+          R"(( ?[+-]? ?(?:(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?)?[iI])?)";
+      const std::string edgeRegex =
+          " \\(((-?\\d+) (" + complexRealRegex + complexImagRegex + "))?\\)";
+      const std::regex complexWeightRegex(complexRealRegex + complexImagRegex);
+
+      std::string lineConstruct = "(\\d+) (\\d+)";
+      for (std::size_t i = 0U; i < N; ++i) {
+        lineConstruct += "(?:" + edgeRegex + ")";
+      }
+      lineConstruct += " *(?:#.*)?";
+      const std::regex lineRegex(lineConstruct);
+      std::smatch m;
+
+      std::string line;
+      if (std::getline(is, line)) {
+        if (!std::regex_match(line, m, complexWeightRegex)) {
+          throw std::runtime_error("Regex did not match second line: " + line);
+        }
+        rootweight.fromString(m.str(1), m.str(2));
+      }
+
+      while (std::getline(is, line)) {
+        if (line.empty() || line.size() == 1) {
+          continue;
+        }
+
+        if (!std::regex_match(line, m, lineRegex)) {
+          throw std::runtime_error("Regex did not match line: " + line);
+        }
+
+        // match 1: node_idx
+        // match 2: qubit_idx
+
+        // repeats for every edge
+        // match 3: edge content
+        // match 4: edge_target_idx
+        // match 5: real + imag (without i)
+        // match 6: real
+        // match 7: imag (without i)
+        nodeIndex = std::stoi(m.str(1));
+        v = static_cast<Qubit>(std::stoi(m.str(2)));
+
+        for (auto edgeIdx = 3U, i = 0U; i < N; i++, edgeIdx += 5) {
+          if (m.str(edgeIdx).empty()) {
+            continue;
+          }
+
+          edgeIndices[i] = std::stoi(m.str(edgeIdx + 1));
+          edgeWeights[i].fromString(m.str(edgeIdx + 3), m.str(edgeIdx + 4));
+        }
+
+        result = deserializeNode(nodeIndex, v, edgeIndices, edgeWeights, nodes);
+      }
+    }
+
+    auto w = cn.getCached(rootweight.r, rootweight.i);
+    ComplexNumbers::mul(w, result.w, w);
+    result.w = cn.lookup(w);
+    cn.returnToCache(w);
+
+    return result;
+  }
+
+  template <class Node, class Edge = Edge<Node>>
+  Edge deserialize(const std::string& inputFilename, bool readBinary) {
+    auto ifs = std::ifstream(inputFilename, std::ios::binary);
+
+    if (!ifs.good()) {
+      throw std::invalid_argument("Cannot open serialized file: " +
+                                  inputFilename);
+    }
+
+    return deserialize<Node>(ifs, readBinary);
+  }
+
+private:
+  template <class Node, class Edge = Edge<Node>,
+            std::size_t N = std::tuple_size_v<decltype(Node::e)>>
+  Edge deserializeNode(std::int64_t index, Qubit v,
+                       std::array<std::int64_t, N>& edgeIdx,
+                       std::array<ComplexValue, N>& edgeWeight,
+                       std::unordered_map<std::int64_t, Node*>& nodes) {
+    if (index == -1) {
+      return Edge::zero;
+    }
+
+    std::array<Edge, N> edges{};
+    for (auto i = 0U; i < N; ++i) {
+      if (edgeIdx[i] == -2) {
+        edges[i] = Edge::zero;
+      } else {
+        if (edgeIdx[i] == -1) {
+          edges[i] = Edge::one;
+        } else {
+          edges[i].p = nodes[edgeIdx[i]];
+        }
+        edges[i].w = cn.lookup(edgeWeight[i]);
+      }
+    }
+
+    auto newedge = makeDDNode(v, edges);
+    nodes[index] = newedge.p;
+
+    // reset
+    edgeIdx.fill(-2);
+
+    return newedge;
+  }
+
+  ///
+  /// Debugging
+  ///
+public:
+  template <class Node> void debugnode(const Node* p) const {
+    if (Node::isTerminal(p)) {
+      std::clog << "terminal\n";
+      return;
+    }
+    std::clog << "Debug node: " << debugnodeLine(p) << "\n";
+    for (const auto& edge : p->e) {
+      std::clog << "  " << std::hexfloat << std::setw(22)
+                << CTEntry::val(edge.w.r) << " " << std::setw(22)
+                << CTEntry::val(edge.w.i) << std::defaultfloat << "i --> "
+                << debugnodeLine(edge.p) << "\n";
+    }
+    std::clog << std::flush;
+  }
+
+  template <class Node> std::string debugnodeLine(const Node* p) const {
+    if (Node::isTerminal(p)) {
+      return "terminal";
+    }
+    std::stringstream sst;
+    sst << "0x" << std::hex << reinterpret_cast<std::uintptr_t>(p) << std::dec
+        << "[v=" << static_cast<std::int64_t>(p->v) << " ref=" << p->ref
+        << " hash=" << UniqueTable<Node>::hash(p) << "]";
+    return sst.str();
+  }
+
+  template <class Edge> bool isLocallyConsistent(const Edge& e) {
+    // NOLINTNEXTLINE(clang-diagnostic-float-equal)
+    assert(Complex::one.r->value == 1 && Complex::one.i->value == 0);
+    // NOLINTNEXTLINE(clang-diagnostic-float-equal)
+    assert(Complex::zero.r->value == 0 && Complex::zero.i->value == 0);
+
+    const bool result = isLocallyConsistent2(e);
+    return result;
+  }
+
+  template <class Edge> bool isGloballyConsistent(const Edge& e) {
+    std::map<ComplexTable<>::Entry*, std::size_t> weightCounter{};
+    std::map<decltype(e.p), std::size_t> nodeCounter{};
+    fillConsistencyCounter(e, weightCounter, nodeCounter);
+    checkConsistencyCounter(e, weightCounter, nodeCounter);
+    return true;
+  }
+
+private:
+  template <class Edge> bool isLocallyConsistent2(const Edge& e) {
+    const auto* ptrR = CTEntry::getAlignedPointer(e.w.r);
+    const auto* ptrI = CTEntry::getAlignedPointer(e.w.i);
+
+    if ((ptrR->refCount == 0 || ptrI->refCount == 0) && e.w != Complex::one &&
+        e.w != Complex::zero) {
+      std::clog << "\nLOCAL INCONSISTENCY FOUND\nOffending Number: " << e.w
+                << " (" << ptrR->refCount << ", " << ptrI->refCount << ")\n\n";
+      debugnode(e.p);
+      return false;
+    }
+
+    if (e.isTerminal()) {
+      return true;
+    }
+
+    if (!e.isTerminal() && e.p->ref == 0) {
+      std::clog << "\nLOCAL INCONSISTENCY FOUND: RC==0\n";
+      debugnode(e.p);
+      return false;
+    }
+
+    for (const auto& child : e.p->e) {
+      if (child.p->v + 1 != e.p->v && !child.isTerminal()) {
+        std::clog << "\nLOCAL INCONSISTENCY FOUND: Wrong V\n";
+        debugnode(e.p);
+        return false;
+      }
+      if (!child.isTerminal() && child.p->ref == 0) {
+        std::clog << "\nLOCAL INCONSISTENCY FOUND: RC==0\n";
+        debugnode(e.p);
+        return false;
+      }
+      if (!isLocallyConsistent2(child)) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  template <class Edge>
+  void fillConsistencyCounter(
+      const Edge& edge,
+      std::map<ComplexTable<>::Entry*, std::size_t>& weightMap,
+      std::map<decltype(edge.p), std::size_t>& nodeMap) {
+    weightMap[CTEntry::getAlignedPointer(edge.w.r)]++;
+    weightMap[CTEntry::getAlignedPointer(edge.w.i)]++;
+
+    if (edge.isTerminal()) {
+      return;
+    }
+    nodeMap[edge.p]++;
+    for (auto& child : edge.p->e) {
+      if (nodeMap[child.p] == 0) {
+        fillConsistencyCounter(child, weightMap, nodeMap);
+      } else {
+        nodeMap[child.p]++;
+        weightMap[CTEntry::getAlignedPointer(child.w.r)]++;
+        weightMap[CTEntry::getAlignedPointer(child.w.i)]++;
+      }
+    }
+  }
+
+  template <class Edge>
+  void checkConsistencyCounter(
+      const Edge& edge,
+      const std::map<ComplexTable<>::Entry*, std::size_t>& weightMap,
+      const std::map<decltype(edge.p), std::size_t>& nodeMap) {
+    auto* rPtr = CTEntry::getAlignedPointer(edge.w.r);
+    auto* iPtr = CTEntry::getAlignedPointer(edge.w.i);
+
+    if (weightMap.at(rPtr) > rPtr->refCount && rPtr != Complex::one.r &&
+        rPtr != Complex::zero.i && rPtr != &ComplexTable<>::sqrt2_2) {
+      std::clog << "\nOffending weight: " << edge.w << "\n";
+      std::clog << "Bits: " << std::hexfloat << CTEntry::val(edge.w.r) << "r "
+                << CTEntry::val(edge.w.i) << std::defaultfloat << "i\n";
+      debugnode(edge.p);
+      throw std::runtime_error("Ref-Count mismatch for " +
+                               std::to_string(rPtr->value) +
+                               "(r): " + std::to_string(weightMap.at(rPtr)) +
+                               " occurrences in DD but Ref-Count is only " +
+                               std::to_string(rPtr->refCount));
+    }
+
+    if (weightMap.at(iPtr) > iPtr->refCount && iPtr != Complex::zero.i &&
+        iPtr != Complex::one.r && iPtr != &ComplexTable<>::sqrt2_2) {
+      std::clog << "\nOffending weight: " << edge.w << "\n";
+      std::clog << "Bits: " << std::hexfloat << CTEntry::val(edge.w.r) << "r "
+                << CTEntry::val(edge.w.i) << std::defaultfloat << "i\n";
+      debugnode(edge.p);
+      throw std::runtime_error("Ref-Count mismatch for " +
+                               std::to_string(iPtr->value) +
+                               "(i): " + std::to_string(weightMap.at(iPtr)) +
+                               " occurrences in DD but Ref-Count is only " +
+                               std::to_string(iPtr->refCount));
+    }
+
+    if (edge.isTerminal()) {
+      return;
+    }
+
+    if (nodeMap.at(edge.p) != edge.p->ref) {
+      debugnode(edge.p);
+      throw std::runtime_error(
+          "Ref-Count mismatch for node: " + std::to_string(nodeMap.at(edge.p)) +
+          " occurrences in DD but Ref-Count is " + std::to_string(edge.p->ref));
+    }
+    for (auto child : edge.p->e) {
+      if (!child.isTerminal() && child.p->v != edge.p->v - 1) {
+        std::clog << "child.p->v == " << child.p->v << "\n";
+        std::clog << " edge.p->v == " << edge.p->v << "\n";
+        debugnode(child.p);
+        debugnode(edge.p);
+        throw std::runtime_error("Variable level ordering seems wrong");
+      }
+      checkConsistencyCounter(child, weightMap, nodeMap);
+    }
+  }
+
+  ///
+  /// Printing and Statistics
+  ///
+public:
+  // print information on package and its members
+  static void printInformation() {
+    std::cout << "\n  compiled: " << __DATE__ << " " << __TIME__
+              << "\n  Complex size: " << sizeof(Complex) << " bytes (aligned "
+              << alignof(Complex) << " bytes)"
+              << "\n  ComplexValue size: " << sizeof(ComplexValue)
+              << " bytes (aligned " << alignof(ComplexValue) << " bytes)"
+              << "\n  ComplexNumbers size: " << sizeof(ComplexNumbers)
+              << " bytes (aligned " << alignof(ComplexNumbers) << " bytes)"
+              << "\n  vEdge size: " << sizeof(vEdge) << " bytes (aligned "
+              << alignof(vEdge) << " bytes)"
+              << "\n  vNode size: " << sizeof(vNode) << " bytes (aligned "
+              << alignof(vNode) << " bytes)"
+              << "\n  mEdge size: " << sizeof(mEdge) << " bytes (aligned "
+              << alignof(mEdge) << " bytes)"
+              << "\n  mNode size: " << sizeof(mNode) << " bytes (aligned "
+              << alignof(mNode) << " bytes)"
+              << "\n  CT Vector Add size: "
+              << sizeof(typename decltype(vectorAdd)::Entry)
+              << " bytes (aligned "
+              << alignof(typename decltype(vectorAdd)::Entry) << " bytes)"
+              << "\n  CT Matrix Add size: "
+              << sizeof(typename decltype(matrixAdd)::Entry)
+              << " bytes (aligned "
+              << alignof(typename decltype(matrixAdd)::Entry) << " bytes)"
+              << "\n  CT Matrix Transpose size: "
+              << sizeof(typename decltype(matrixTranspose)::Entry)
+              << " bytes (aligned "
+              << alignof(typename decltype(matrixTranspose)::Entry) << " bytes)"
+              << "\n  CT Conjugate Matrix Transpose size: "
+              << sizeof(typename decltype(conjugateMatrixTranspose)::Entry)
+              << " bytes (aligned "
+              << alignof(typename decltype(conjugateMatrixTranspose)::Entry)
+              << " bytes)"
+              << "\n  CT Matrix Multiplication size: "
+              << sizeof(typename decltype(matrixMatrixMultiplication)::Entry)
+              << " bytes (aligned "
+              << alignof(typename decltype(matrixMatrixMultiplication)::Entry)
+              << " bytes)"
+              << "\n  CT Matrix Vector Multiplication size: "
+              << sizeof(typename decltype(matrixVectorMultiplication)::Entry)
+              << " bytes (aligned "
+              << alignof(typename decltype(matrixVectorMultiplication)::Entry)
+              << " bytes)"
+              << "\n  CT Vector Inner Product size: "
+              << sizeof(typename decltype(vectorInnerProduct)::Entry)
+              << " bytes (aligned "
+              << alignof(typename decltype(vectorInnerProduct)::Entry)
+              << " bytes)"
+              << "\n  CT Vector Kronecker size: "
+              << sizeof(typename decltype(vectorKronecker)::Entry)
+              << " bytes (aligned "
+              << alignof(typename decltype(vectorKronecker)::Entry) << " bytes)"
+              << "\n  CT Matrix Kronecker size: "
+              << sizeof(typename decltype(matrixKronecker)::Entry)
+              << " bytes (aligned "
+              << alignof(typename decltype(matrixKronecker)::Entry) << " bytes)"
+              << "\n  ToffoliTable::Entry size: "
+              << sizeof(ToffoliTable<mEdge>::Entry) << " bytes (aligned "
+              << alignof(ToffoliTable<mEdge>::Entry) << " bytes)"
+              << "\n  Package size: " << sizeof(Package) << " bytes (aligned "
+              << alignof(Package) << " bytes)"
+              << "\n"
+              << std::flush;
+  }
+
+  // print unique and compute table statistics
+  void statistics() {
+    std::cout << "DD statistics:" << std::endl << "[vUniqueTable] ";
+    vUniqueTable.printStatistics();
+    std::cout << "[mUniqueTable] ";
+    mUniqueTable.printStatistics();
+    std::cout << "[CT Vector Add] ";
+    vectorAdd.printStatistics();
+    std::cout << "[CT Matrix Add] ";
+    matrixAdd.printStatistics();
+    std::cout << "[CT Matrix Transpose] ";
+    matrixTranspose.printStatistics();
+    std::cout << "[CT Conjugate Matrix Transpose] ";
+    conjugateMatrixTranspose.printStatistics();
+    std::cout << "[CT Matrix Multiplication] ";
+    matrixMatrixMultiplication.printStatistics();
+    std::cout << "[CT Matrix Vector Multiplication] ";
+    matrixVectorMultiplication.printStatistics();
+    std::cout << "[CT Inner Product] ";
+    vectorInnerProduct.printStatistics();
+    std::cout << "[CT Vector Kronecker] ";
+    vectorKronecker.printStatistics();
+    std::cout << "[CT Matrix Kronecker] ";
+    matrixKronecker.printStatistics();
+    std::cout << "[Toffoli Table] ";
+    toffoliTable.printStatistics();
+    std::cout << "[Stochastic Noise Table] ";
+    stochasticNoiseOperationCache.printStatistics();
+    std::cout << "[CT Density Add] ";
+    densityAdd.printStatistics();
+    std::cout << "[CT Density Mul] ";
+    densityDensityMultiplication.printStatistics();
+    std::cout << "[CT Density Noise] ";
+    densityNoise.printStatistics();
+    std::cout << "[ComplexTable] ";
+    cn.complexTable.printStatistics();
+  }
+};
 
 } // namespace dd
-
-#endif
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/StochasticNoiseOperationTable.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/dd/StochasticNoiseOperationTable.hpp`

 * *Files 20% similar despite different names*

```diff
@@ -1,80 +1,82 @@
-/*
- * This file is part of the MQT DD Package which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum_dd/ for more information.
- */
-
-#ifndef DDpackage_NOISEOPERATIONTABLE_HPP
-#define DDpackage_NOISEOPERATIONTABLE_HPP
+#pragma once
 
 #include "Definitions.hpp"
 
 #include <array>
 #include <cassert>
 #include <cstddef>
 #include <cstdint>
 #include <iostream>
 #include <vector>
 
 namespace dd {
-    template<class Edge, std::size_t numberOfStochasticOperations = 64>
-    class StochasticNoiseOperationTable {
-    public:
-        explicit StochasticNoiseOperationTable(const std::size_t nv):
-            nvars(nv) { resize(nv); };
-
-        // access functions
-        [[nodiscard]] const auto& getTable() const { return table; }
-
-        void resize(std::size_t nq) {
-            nvars = nq;
-            table.resize(nvars);
-        }
-
-        void insert(std::uint8_t kind, Qubit target, const Edge& r) {
-            assert(kind < numberOfStochasticOperations); // There are new operations in OpType. Increase the value of numberOfOperations accordingly
-            table.at(static_cast<std::size_t>(target)).at(kind) = r;
-            ++count;
-        }
-
-        Edge lookup(std::uint8_t kind, Qubit target) {
-            assert(kind < numberOfStochasticOperations); // There are new operations in OpType. Increase the value of numberOfOperations accordingly
-            lookups++;
-            Edge r{};
-            auto entry = table.at(static_cast<std::size_t>(target)).at(kind);
-            if (entry.p == nullptr) {
-                return r;
-            }
-            hits++;
-            return entry;
-        }
-
-        void clear() {
-            if (count > 0) {
-                for (auto& tableRow: table) {
-                    for (auto& entry: tableRow) {
-                        entry.p = nullptr;
-                    }
-                }
-                count = 0;
-            }
-        }
-
-        [[nodiscard]] fp hitRatio() const { return static_cast<fp>(hits) / static_cast<fp>(lookups); }
-
-        std::ostream& printStatistics(std::ostream& os = std::cout) {
-            os << "hits: " << hits << ", looks: " << lookups << ", ratio: " << hitRatio() << std::endl;
-            return os;
+template <class Edge, std::size_t numberOfStochasticOperations = 64>
+class StochasticNoiseOperationTable {
+public:
+  explicit StochasticNoiseOperationTable(const std::size_t nv) : nvars(nv) {
+    resize(nv);
+  };
+
+  // access functions
+  [[nodiscard]] const auto& getTable() const { return table; }
+
+  void resize(std::size_t nq) {
+    nvars = nq;
+    table.resize(nvars);
+  }
+
+  void insert(std::uint8_t kind, Qubit target, const Edge& r) {
+    assert(kind <
+           numberOfStochasticOperations); // There are new operations in OpType.
+                                          // Increase the value of
+                                          // numberOfOperations accordingly
+    table.at(static_cast<std::size_t>(target)).at(kind) = r;
+    ++count;
+  }
+
+  Edge lookup(std::uint8_t kind, Qubit target) {
+    assert(kind <
+           numberOfStochasticOperations); // There are new operations in OpType.
+                                          // Increase the value of
+                                          // numberOfOperations accordingly
+    lookups++;
+    Edge r{};
+    auto entry = table.at(static_cast<std::size_t>(target)).at(kind);
+    if (entry.p == nullptr) {
+      return r;
+    }
+    hits++;
+    return entry;
+  }
+
+  void clear() {
+    if (count > 0) {
+      for (auto& tableRow : table) {
+        for (auto& entry : tableRow) {
+          entry.p = nullptr;
         }
-
-    private:
-        std::size_t                                                 nvars;
-        std::vector<std::array<Edge, numberOfStochasticOperations>> table;
-
-        // operation table lookup statistics
-        std::size_t hits    = 0;
-        std::size_t lookups = 0;
-        std::size_t count   = 0;
-    };
+      }
+      count = 0;
+    }
+  }
+
+  [[nodiscard]] fp hitRatio() const {
+    return static_cast<fp>(hits) / static_cast<fp>(lookups);
+  }
+
+  std::ostream& printStatistics(std::ostream& os = std::cout) {
+    os << "hits: " << hits << ", looks: " << lookups
+       << ", ratio: " << hitRatio() << std::endl;
+    return os;
+  }
+
+private:
+  std::size_t nvars;
+  std::vector<std::array<Edge, numberOfStochasticOperations>> table;
+
+  // operation table lookup statistics
+  std::size_t hits = 0;
+  std::size_t lookups = 0;
+  std::size_t count = 0;
+};
 } // namespace dd
-
-#endif //DDpackage_NOISEOPERATIONTABLE_HPP
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/ToffoliTable.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/dd/ToffoliTable.hpp`

 * *Files 14% similar despite different names*

```diff
@@ -1,106 +1,103 @@
-/*
- * This file is part of the MQT DD Package which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum_dd/ for more information.
- */
-
-#ifndef DDpackage_TOFFOLITABLE_HPP
-#define DDpackage_TOFFOLITABLE_HPP
+#pragma once
 
 #include "Control.hpp"
 #include "Definitions.hpp"
 
 #include <cstddef>
 #include <iostream>
 #include <set>
 #include <type_traits>
 #include <vector>
 
 namespace dd {
-    template<class Edge, std::size_t NBUCKET = 2048>
-    class ToffoliTable {
-    public:
-        ToffoliTable() = default;
-
-        struct Entry {
-            QubitCount n = 0;
-            Controls   controls{};
-            Qubit      target = 0;
-            Edge       e;
-        };
-
-        static constexpr std::size_t MASK = NBUCKET - 1;
-
-        // access functions
-        [[nodiscard]] const auto& getTable() const { return table; }
-
-        void insert(QubitCount n, const Controls& controls, Qubit target, const Edge& e) {
-            const auto key = hash(controls, target);
-            table[key]     = {n, controls, target, e};
-            ++count;
-        }
-
-        Edge lookup(QubitCount n, const Controls& controls, Qubit target) {
-            lookups++;
-            Edge        r{};
-            const auto  key   = hash(controls, target);
-            const auto& entry = table[key];
-            if (entry.e.p == nullptr) {
-                return r;
-            }
-            if (entry.n != n) {
-                return r;
-            }
-            if (entry.target != target) {
-                return r;
-            }
-            if (entry.controls != controls) {
-                return r;
-            }
-            hits++;
-            return entry.e;
-        }
-
-        static std::size_t hash(const Controls& controls, Qubit target) {
-            auto key = static_cast<std::size_t>(static_cast<std::make_unsigned_t<Qubit>>(target));
-            for (const auto& control: controls) {
-                if (control.type == dd::Control::Type::pos) {
-                    key *= 29UL * static_cast<std::size_t>(control.qubit);
-                } else {
-                    key *= 71UL * static_cast<std::size_t>(control.qubit);
-                }
-            }
-            return key & MASK;
-        }
-
-        void clear() {
-            if (count > 0) {
-                for (auto& entry: table) {
-                    entry.e.p = nullptr;
-                }
-                count = 0;
-            }
-            hits    = 0;
-            lookups = 0;
-        }
-
-        [[nodiscard]] fp hitRatio() const { return static_cast<fp>(hits) / static_cast<fp>(lookups); }
-
-        std::ostream& printStatistics(std::ostream& os = std::cout) {
-            os << "hits: " << hits << ", looks: " << lookups << ", ratio: " << hitRatio() << std::endl;
-            return os;
-        }
-
-    private:
-        /// gcc is having serious troubles compiling this using std::array (compilation times >15min).
-        /// std::vector shouldn't be any less efficient in our application scenario
-        /// TODO: revisit this in the future
-        std::vector<Entry> table{NBUCKET};
-
-        // compute table lookup statistics
-        std::size_t hits    = 0;
-        std::size_t lookups = 0;
-        std::size_t count   = 0;
-    };
+template <class Edge, std::size_t NBUCKET = 2048> class ToffoliTable {
+public:
+  ToffoliTable() = default;
+
+  struct Entry {
+    QubitCount n = 0;
+    Controls controls{};
+    Qubit target = 0;
+    Edge e;
+  };
+
+  static constexpr std::size_t MASK = NBUCKET - 1;
+
+  // access functions
+  [[nodiscard]] const auto& getTable() const { return table; }
+
+  void insert(QubitCount n, const Controls& controls, Qubit target,
+              const Edge& e) {
+    const auto key = hash(controls, target);
+    table[key] = {n, controls, target, e};
+    ++count;
+  }
+
+  Edge lookup(QubitCount n, const Controls& controls, Qubit target) {
+    lookups++;
+    Edge r{};
+    const auto key = hash(controls, target);
+    const auto& entry = table[key];
+    if (entry.e.p == nullptr) {
+      return r;
+    }
+    if (entry.n != n) {
+      return r;
+    }
+    if (entry.target != target) {
+      return r;
+    }
+    if (entry.controls != controls) {
+      return r;
+    }
+    hits++;
+    return entry.e;
+  }
+
+  static std::size_t hash(const Controls& controls, Qubit target) {
+    auto key = static_cast<std::size_t>(
+        static_cast<std::make_unsigned_t<Qubit>>(target));
+    for (const auto& control : controls) {
+      if (control.type == dd::Control::Type::pos) {
+        key *= 29UL * static_cast<std::size_t>(control.qubit);
+      } else {
+        key *= 71UL * static_cast<std::size_t>(control.qubit);
+      }
+    }
+    return key & MASK;
+  }
+
+  void clear() {
+    if (count > 0) {
+      for (auto& entry : table) {
+        entry.e.p = nullptr;
+      }
+      count = 0;
+    }
+    hits = 0;
+    lookups = 0;
+  }
+
+  [[nodiscard]] fp hitRatio() const {
+    return static_cast<fp>(hits) / static_cast<fp>(lookups);
+  }
+
+  std::ostream& printStatistics(std::ostream& os = std::cout) {
+    os << "hits: " << hits << ", looks: " << lookups
+       << ", ratio: " << hitRatio() << std::endl;
+    return os;
+  }
+
+private:
+  /// gcc is having serious troubles compiling this using std::array
+  /// (compilation times >15min). std::vector shouldn't be any less efficient in
+  /// our application scenario
+  /// TODO: revisit this in the future
+  std::vector<Entry> table{NBUCKET};
+
+  // compute table lookup statistics
+  std::size_t hits = 0;
+  std::size_t lookups = 0;
+  std::size_t count = 0;
+};
 } // namespace dd
-
-#endif //DDpackage_TOFFOLITABLE_HPP
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/dd_package/include/dd/UniqueTable.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/dd/UniqueTable.hpp`

 * *Files 14% similar despite different names*

```diff
@@ -1,14 +1,8 @@
-/*
- * This file is part of the MQT DD Package which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum_dd/ for more information.
- */
-
-#ifndef DDpackage_UNIQUETABLE_HPP
-#define DDpackage_UNIQUETABLE_HPP
+#pragma once
 
 #include "ComplexNumbers.hpp"
 #include "Definitions.hpp"
 #include "Node.hpp"
 
 #include <algorithm>
 #include <array>
@@ -19,407 +13,417 @@
 #include <limits>
 #include <numeric>
 #include <stdexcept>
 #include <vector>
 
 namespace dd {
 
-    /// Data structure for providing and uniquely storing DD nodes
-    /// \tparam Node class of nodes to provide/store
-    /// \tparam NBUCKET number of hash buckets to use (has to be a power of two)
-    /// \tparam INITIAL_ALLOCATION_SIZE number if nodes initially allocated
-    /// \tparam GROWTH_PERCENTAGE percentage that the allocations' size shall grow over time
-    /// \tparam INITIAL_GC_LIMIT number of nodes initially used as garbage collection threshold
-    /// \tparam GC_INCREMENT absolute number of nodes to increase the garbage collection threshold after garbage collection has been performed
-    template<class Node, std::size_t NBUCKET = 32768, std::size_t INITIAL_ALLOCATION_SIZE = 2048, std::size_t GROWTH_FACTOR = 2, std::size_t INITIAL_GC_LIMIT = 131072>
-    class UniqueTable {
-    public:
-        explicit UniqueTable(const std::size_t nv):
-            nvars(nv) {
-        }
-
-        ~UniqueTable() = default;
-
-        static constexpr std::size_t MASK = NBUCKET - 1;
-
-        void resize(std::size_t nq) {
-            nvars = nq;
-            tables.resize(nq);
-            // TODO: if the new size is smaller than the old one we might have to release the unique table entries for the superfluous variables
-            active.resize(nq);
-            activeNodeCount = std::accumulate(active.begin(), active.end(), 0UL);
-        }
-
-        static std::size_t hash(const Node* p) {
-            std::size_t key = 0;
-            for (std::size_t i = 0; i < p->e.size(); ++i) {
-                key = dd::combineHash(key, std::hash<Edge<Node>>{}(p->e[i]));
-                // old hash function:
-                //     key += ((reinterpret_cast<std::size_t>(p->e[i].p)   >>  i) +
-                //             (reinterpret_cast<std::size_t>(p->e[i].w.r) >>  i) +
-                //             (reinterpret_cast<std::size_t>(p->e[i].w.i) >> (i + 1))) & MASK;
-            }
-            key &= MASK;
-            return key;
-        }
-
-        // access functions
-        [[nodiscard]] std::size_t getNodeCount() const { return nodeCount; }
-
-        [[nodiscard]] std::size_t getPeakNodeCount() const { return peakNodeCount; }
-
-        [[nodiscard]] std::size_t getMaxActiveNodes() const { return maxActive; }
-
-        [[nodiscard]] std::size_t getAllocations() const { return allocations; }
-
-        [[nodiscard]] float getGrowthFactor() const { return GROWTH_FACTOR; }
-
-        [[nodiscard]] const auto& getTables() const { return tables; }
-
-        static bool nodesAreEqual(const Node* p, const Node* q) {
-            if constexpr (std::is_same_v<Node, dNode>) {
-                return (p->e == q->e && (p->flags == q->flags));
+/// Data structure for providing and uniquely storing DD nodes
+/// \tparam Node class of nodes to provide/store
+/// \tparam NBUCKET number of hash buckets to use (has to be a power of two)
+/// \tparam INITIAL_ALLOCATION_SIZE number if nodes initially allocated
+/// \tparam GROWTH_PERCENTAGE percentage that the allocations' size shall grow
+/// over time \tparam INITIAL_GC_LIMIT number of nodes initially used as garbage
+/// collection threshold \tparam GC_INCREMENT absolute number of nodes to
+/// increase the garbage collection threshold after garbage collection has been
+/// performed
+template <class Node, std::size_t NBUCKET = 32768,
+          std::size_t INITIAL_ALLOCATION_SIZE = 2048,
+          std::size_t GROWTH_FACTOR = 2, std::size_t INITIAL_GC_LIMIT = 131072>
+class UniqueTable {
+public:
+  explicit UniqueTable(const std::size_t nv) : nvars(nv) {}
+
+  ~UniqueTable() = default;
+
+  static constexpr std::size_t MASK = NBUCKET - 1;
+
+  void resize(std::size_t nq) {
+    nvars = nq;
+    tables.resize(nq);
+    // TODO: if the new size is smaller than the old one we might have to
+    // release the unique table entries for the superfluous variables
+    active.resize(nq);
+    activeNodeCount = std::accumulate(active.begin(), active.end(), 0UL);
+  }
+
+  static std::size_t hash(const Node* p) {
+    std::size_t key = 0;
+    for (std::size_t i = 0; i < p->e.size(); ++i) {
+      key = dd::combineHash(key, std::hash<Edge<Node>>{}(p->e[i]));
+      // old hash function:
+      //     key += ((reinterpret_cast<std::size_t>(p->e[i].p)   >>  i) +
+      //             (reinterpret_cast<std::size_t>(p->e[i].w.r) >>  i) +
+      //             (reinterpret_cast<std::size_t>(p->e[i].w.i) >> (i + 1))) &
+      //             MASK;
+    }
+    key &= MASK;
+    return key;
+  }
+
+  // access functions
+  [[nodiscard]] std::size_t getNodeCount() const { return nodeCount; }
+
+  [[nodiscard]] std::size_t getPeakNodeCount() const { return peakNodeCount; }
+
+  [[nodiscard]] std::size_t getMaxActiveNodes() const { return maxActive; }
+
+  [[nodiscard]] std::size_t getAllocations() const { return allocations; }
+
+  [[nodiscard]] float getGrowthFactor() const { return GROWTH_FACTOR; }
+
+  [[nodiscard]] const auto& getTables() const { return tables; }
+
+  static bool nodesAreEqual(const Node* p, const Node* q) {
+    if constexpr (std::is_same_v<Node, dNode>) {
+      return (p->e == q->e && (p->flags == q->flags));
+    } else {
+      return p->e == q->e;
+    }
+  }
+
+  // lookup a node in the unique table for the appropriate variable; insert it,
+  // if it has not been found NOTE: reference counting is to be adjusted by
+  // function invoking the table lookup and only normalized nodes shall be
+  // stored.
+  Edge<Node> lookup(const Edge<Node>& e, bool keepNode = false) {
+    // there are unique terminal nodes
+    if (e.isTerminal()) {
+      return e;
+    }
+
+    ++lookups;
+    const auto key = hash(e.p);
+    const auto v = e.p->v;
+
+    // search bucket in table corresponding to hashed value for the given node
+    // and return it if found.
+    if (const auto hashedNode = searchTable(e, key, keepNode);
+        hashedNode != Edge<Node>::zero) {
+      return hashedNode;
+    }
+
+    // if node not found -> add it to front of unique table bucket
+    e.p->next = tables[static_cast<std::size_t>(v)][key];
+    tables[static_cast<std::size_t>(v)][key] = e.p;
+    ++nodeCount;
+    peakNodeCount = std::max(peakNodeCount, nodeCount);
+
+    return e;
+  }
+
+  [[nodiscard]] Node* getNode() {
+    // a node is available on the stack
+    if (available != nullptr) {
+      Node* p = available;
+      available = p->next;
+      // returned nodes could have a ref count != 0
+      p->ref = 0;
+      return p;
+    }
+
+    // new chunk has to be allocated
+    if (chunkIt == chunkEndIt) {
+      chunks.emplace_back(allocationSize);
+      allocations += allocationSize;
+      allocationSize *= GROWTH_FACTOR;
+      chunkID++;
+      chunkIt = chunks[chunkID].begin();
+      chunkEndIt = chunks[chunkID].end();
+    }
+
+    auto p = &(*chunkIt);
+    ++chunkIt;
+    return p;
+  }
+
+  void returnNode(Node* p) {
+    p->next = available;
+    available = p;
+  }
+
+  // increment reference counter for node e points to
+  // and recursively increment reference counter for
+  // each child if this is the first reference
+  void incRef(const Edge<Node>& e) {
+    dd::ComplexNumbers::incRef(e.w);
+    if (e.p == nullptr || e.isTerminal()) {
+      return;
+    }
+
+    if (e.p->ref == std::numeric_limits<decltype(e.p->ref)>::max()) {
+      std::clog << "[WARN] MAXREFCNT reached for p="
+                << reinterpret_cast<std::uintptr_t>(e.p)
+                << ". Node will never be collected." << std::endl;
+      return;
+    }
+
+    e.p->ref++;
+
+    if (e.p->ref == 1) {
+      for (const auto& edge : e.p->e) {
+        if (edge.p != nullptr) {
+          incRef(edge);
+        }
+      }
+      active[static_cast<std::size_t>(e.p->v)]++;
+      activeNodeCount++;
+      maxActive = std::max(maxActive, activeNodeCount);
+    }
+  }
+
+  // decrement reference counter for node e points to
+  // and recursively decrement reference counter for
+  // each child if this is the last reference
+  void decRef(const Edge<Node>& e) {
+    dd::ComplexNumbers::decRef(e.w);
+    if (e.p == nullptr || e.isTerminal()) {
+      return;
+    }
+    if (e.p->ref == std::numeric_limits<decltype(e.p->ref)>::max()) {
+      return;
+    }
+
+    if (e.p->ref == 0) {
+      throw std::runtime_error("In decref: ref==0 before decref\n");
+    }
+
+    e.p->ref--;
+
+    if (e.p->ref == 0) {
+      for (const auto& edge : e.p->e) {
+        if (edge.p != nullptr) {
+          decRef(edge);
+        }
+      }
+      active[static_cast<std::size_t>(e.p->v)]--;
+      activeNodeCount--;
+    }
+  }
+
+  [[nodiscard]] bool possiblyNeedsCollection() const {
+    return nodeCount >= gcLimit;
+  }
+
+  std::size_t garbageCollect(bool force = false) {
+    gcCalls++;
+    if ((!force && nodeCount < gcLimit) || nodeCount == 0) {
+      return 0;
+    }
+
+    gcRuns++;
+    std::size_t collected = 0;
+    std::size_t remaining = 0;
+    for (auto& table : tables) {
+      for (auto& bucket : table) {
+        Node* p = bucket;
+        Node* lastp = nullptr;
+        while (p != nullptr) {
+          if (p->ref == 0) {
+            assert(!Node::isTerminal(p));
+            Node* next = p->next;
+            if (lastp == nullptr) {
+              bucket = next;
             } else {
-                return p->e == q->e;
-            }
-        }
-
-        // lookup a node in the unique table for the appropriate variable; insert it, if it has not been found
-        // NOTE: reference counting is to be adjusted by function invoking the table lookup and only normalized nodes shall be stored.
-        Edge<Node> lookup(const Edge<Node>& e, bool keepNode = false) {
-            // there are unique terminal nodes
-            if (e.isTerminal()) {
-                return e;
-            }
-
-            ++lookups;
-            const auto key = hash(e.p);
-            const auto v   = e.p->v;
-
-            // successors of a node shall either have successive variable numbers or be terminals
-            for ([[maybe_unused]] const auto& edge: e.p->e) {
-                assert(edge.p->v == v - 1 || edge.isTerminal());
+              lastp->next = next;
             }
-
-            // search bucket in table corresponding to hashed value for the given node and return it if found.
-            if (const auto hashedNode = searchTable(e, key, keepNode); hashedNode != Edge<Node>::zero) {
-                return hashedNode;
-            }
-
-            // if node not found -> add it to front of unique table bucket
-            e.p->next                                = tables[static_cast<std::size_t>(v)][key];
-            tables[static_cast<std::size_t>(v)][key] = e.p;
-            ++nodeCount;
-            peakNodeCount = std::max(peakNodeCount, nodeCount);
-
-            return e;
-        }
-
-        [[nodiscard]] Node* getNode() {
-            // a node is available on the stack
-            if (available != nullptr) {
-                Node* p   = available;
-                available = p->next;
-                // returned nodes could have a ref count != 0
-                p->ref = 0;
-                return p;
-            }
-
-            // new chunk has to be allocated
-            if (chunkIt == chunkEndIt) {
-                chunks.emplace_back(allocationSize);
-                allocations += allocationSize;
-                allocationSize *= GROWTH_FACTOR;
-                chunkID++;
-                chunkIt    = chunks[chunkID].begin();
-                chunkEndIt = chunks[chunkID].end();
-            }
-
-            auto p = &(*chunkIt);
-            ++chunkIt;
-            return p;
-        }
-
-        void returnNode(Node* p) {
-            p->next   = available;
-            available = p;
-        }
-
-        // increment reference counter for node e points to
-        // and recursively increment reference counter for
-        // each child if this is the first reference
-        void incRef(const Edge<Node>& e) {
-            dd::ComplexNumbers::incRef(e.w);
-            if (e.p == nullptr || e.isTerminal()) {
-                return;
-            }
-
-            if (e.p->ref == std::numeric_limits<decltype(e.p->ref)>::max()) {
-                std::clog << "[WARN] MAXREFCNT reached for p=" << reinterpret_cast<std::uintptr_t>(e.p)
-                          << ". Node will never be collected." << std::endl;
-                return;
-            }
-
-            e.p->ref++;
-
-            if (e.p->ref == 1) {
-                for (const auto& edge: e.p->e) {
-                    if (edge.p != nullptr) {
-                        incRef(edge);
-                    }
-                }
-                active[static_cast<std::size_t>(e.p->v)]++;
-                activeNodeCount++;
-                maxActive = std::max(maxActive, activeNodeCount);
-            }
-        }
-
-        // decrement reference counter for node e points to
-        // and recursively decrement reference counter for
-        // each child if this is the last reference
-        void decRef(const Edge<Node>& e) {
-            dd::ComplexNumbers::decRef(e.w);
-            if (e.p == nullptr || e.isTerminal()) {
-                return;
-            }
-            if (e.p->ref == std::numeric_limits<decltype(e.p->ref)>::max()) {
-                return;
-            }
-
-            if (e.p->ref == 0) {
-                throw std::runtime_error("In decref: ref==0 before decref\n");
-            }
-
-            e.p->ref--;
-
-            if (e.p->ref == 0) {
-                for (const auto& edge: e.p->e) {
-                    if (edge.p != nullptr) {
-                        decRef(edge);
-                    }
-                }
-                active[static_cast<std::size_t>(e.p->v)]--;
-                activeNodeCount--;
-            }
-        }
-
-        [[nodiscard]] bool possiblyNeedsCollection() const { return nodeCount >= gcLimit; }
-
-        std::size_t garbageCollect(bool force = false) {
-            gcCalls++;
-            if ((!force && nodeCount < gcLimit) || nodeCount == 0) {
-                return 0;
-            }
-
-            gcRuns++;
-            std::size_t collected = 0;
-            std::size_t remaining = 0;
-            for (auto& table: tables) {
-                for (auto& bucket: table) {
-                    Node* p     = bucket;
-                    Node* lastp = nullptr;
-                    while (p != nullptr) {
-                        if (p->ref == 0) {
-                            assert(!Node::isTerminal(p));
-                            Node* next = p->next;
-                            if (lastp == nullptr) {
-                                bucket = next;
-                            } else {
-                                lastp->next = next;
-                            }
-                            returnNode(p);
-                            p = next;
-                            collected++;
-                        } else {
-                            lastp = p;
-                            p     = p->next;
-                            remaining++;
-                        }
-                    }
-                }
-            }
-            // The garbage collection limit changes dynamically depending on the number of remaining (active) nodes.
-            // If it were not changed, garbage collection would run through the complete table on each successive call
-            // once the number of remaining entries reaches the garbage collection limit. It is increased whenever the
-            // number of remaining entries is rather close to the garbage collection threshold and decreased if the
-            // number of remaining entries is much lower than the current limit.
-            if (remaining > gcLimit / 10 * 9) {
-                gcLimit = remaining + INITIAL_GC_LIMIT;
-            }
-            //            else if (remaining < gcLimit / 32) {
-            //                gcLimit /= 4;
-            //            }
-            nodeCount = remaining;
-            return collected;
-        }
-
-        void clear() {
-            // clear unique table buckets
-            for (auto& table: tables) {
-                for (auto& bucket: table) {
-                    bucket = nullptr;
-                }
-            }
-            // clear available stack
-            available = nullptr;
-
-            // release memory of all but the first chunk TODO: it could be desirable to keep the memory
-            while (chunkID > 0) {
-                chunks.pop_back();
-                chunkID--;
-            }
-            // restore initial chunk setting
-            chunkIt        = chunks[0].begin();
-            chunkEndIt     = chunks[0].end();
-            allocationSize = INITIAL_ALLOCATION_SIZE * GROWTH_FACTOR;
-            allocations    = INITIAL_ALLOCATION_SIZE;
-
-            for (auto& node: chunks[0]) {
-                node.ref = 0;
-            }
-
-            nodeCount     = 0;
-            peakNodeCount = 0;
-
-            collisions = 0;
-            hits       = 0;
-            lookups    = 0;
-
-            std::fill(active.begin(), active.end(), 0);
-            activeNodeCount = 0;
-            maxActive       = 0;
-
-            gcCalls = 0;
-            gcRuns  = 0;
-            gcLimit = INITIAL_GC_LIMIT;
-        };
-
-        void print() {
-            auto q = static_cast<dd::Qubit>(nvars - 1);
-            for (auto it = tables.rbegin(); it != tables.rend(); ++it) {
-                auto& table = *it;
-                std::cout << "\tq" << static_cast<std::size_t>(q) << ":"
-                          << "\n";
-                for (std::size_t key = 0; key < table.size(); ++key) {
-                    auto p = table[key];
-                    if (p != nullptr) {
-                        std::cout << "\tkey=" << key << ": ";
-                    }
-
-                    while (p != nullptr) {
-                        std::cout << "\t\t" << std::hex << reinterpret_cast<std::uintptr_t>(p) << std::dec << " "
-                                  << p->ref << std::hex;
-                        for (const auto& e: p->e) {
-                            std::cout << " p" << reinterpret_cast<std::uintptr_t>(e.p) << "(r"
-                                      << reinterpret_cast<std::uintptr_t>(e.w.r) << " i"
-                                      << reinterpret_cast<std::uintptr_t>(e.w.i) << ")";
-                        }
-                        std::cout << std::dec << "\n";
-                        p = p->next;
-                    }
-                }
-                --q;
-            }
-        }
-
-        void printActive() {
-            std::cout << "#printActive: " << activeNodeCount << ", ";
-            for (const auto& a: active) {
-                std::cout << a << " ";
-            }
-            std::cout << "\n";
-        }
-
-        [[nodiscard]] fp hitRatio() const { return static_cast<fp>(hits) / static_cast<fp>(lookups); }
-
-        [[nodiscard]] fp colRatio() const { return static_cast<fp>(collisions) / static_cast<fp>(lookups); }
-
-        [[nodiscard]] std::size_t getActiveNodeCount() const {
-            return activeNodeCount;
-        }
-
-        [[nodiscard]] std::size_t getActiveNodeCount(Qubit var) { return active.at(var); }
-
-        std::ostream& printStatistics(std::ostream& os = std::cout) {
-            os << "hits: " << hits << ", collisions: " << collisions << ", looks: " << lookups << ", hitRatio: "
-               << hitRatio() << ", colRatio: " << colRatio() << ", gc calls: " << gcCalls << ", gc runs: " << gcRuns
-               << "\n";
-            return os;
-        }
-
-    private:
-        using NodeBucket = Node*;
-        using Table      = std::array<NodeBucket, NBUCKET>;
-
-        // unique tables (one per input variable)
-        std::size_t        nvars = 0;
-        std::vector<Table> tables{nvars};
-
-        Node*                                available{};
-        std::vector<std::vector<Node>>       chunks{1, std::vector<Node>{INITIAL_ALLOCATION_SIZE}};
-        std::size_t                          chunkID{0};
-        typename std::vector<Node>::iterator chunkIt{chunks[0].begin()};
-        typename std::vector<Node>::iterator chunkEndIt{chunks[0].end()};
-        std::size_t                          allocationSize{INITIAL_ALLOCATION_SIZE * GROWTH_FACTOR};
-
-        std::size_t allocations   = INITIAL_ALLOCATION_SIZE;
-        std::size_t nodeCount     = 0;
-        std::size_t peakNodeCount = 0;
-
-        // unique table lookup statistics
-        std::size_t collisions = 0;
-        std::size_t hits       = 0;
-        std::size_t lookups    = 0;
-
-        // (max) active nodes
-        // number of active vector nodes for each variable
-        std::vector<std::size_t> active{std::vector<std::size_t>(nvars, 0)};
-        std::size_t              activeNodeCount = 0;
-        std::size_t              maxActive       = 0;
-
-        // garbage collection
-        std::size_t gcCalls = 0;
-        std::size_t gcRuns  = 0;
-        std::size_t gcLimit = INITIAL_GC_LIMIT;
-
-        /**
-        Searches for a node in the hash table with the given key.
-        @param e The node to search for.
-        @param key The hashed value used to search the table.
-        @param keepNode If true, the node pointed to by e.p will not be put on the available chain.
-        @return The Edge<Node> found in the hash table or Edge<Node>::zero if not found.
-        **/
-        Edge<Node> searchTable(const Edge<Node>& e, const std::size_t& key, const bool keepNode = false) {
-            const auto v = e.p->v;
-
-            Node* p = tables[static_cast<std::size_t>(v)][key];
-            while (p != nullptr) {
-                if (nodesAreEqual(e.p, p)) {
-                    // Match found
-                    if (e.p != p && !keepNode) {
-                        // put node pointed to by e.p on available chain
-                        returnNode(e.p);
-                    }
-                    ++hits;
-
-                    // variables should stay the same
-                    assert(p->v == e.p->v);
-
-                    // successors of a node shall either have successive variable numbers or be terminals
-                    for ([[maybe_unused]] const auto& edge: e.p->e) {
-                        assert(edge.p->v == v - 1 || edge.isTerminal());
-                    }
-
-                    return {p, e.w};
-                }
-                ++collisions;
-                p = p->next;
-            }
-
-            // Node not found in bucket
-            return Edge<Node>::zero;
-        }
-    };
+            returnNode(p);
+            p = next;
+            collected++;
+          } else {
+            lastp = p;
+            p = p->next;
+            remaining++;
+          }
+        }
+      }
+    }
+    // The garbage collection limit changes dynamically depending on the number
+    // of remaining (active) nodes. If it were not changed, garbage collection
+    // would run through the complete table on each successive call once the
+    // number of remaining entries reaches the garbage collection limit. It is
+    // increased whenever the number of remaining entries is rather close to the
+    // garbage collection threshold and decreased if the number of remaining
+    // entries is much lower than the current limit.
+    if (remaining > gcLimit / 10 * 9) {
+      gcLimit = remaining + INITIAL_GC_LIMIT;
+    }
+    nodeCount = remaining;
+    return collected;
+  }
+
+  void clear() {
+    // clear unique table buckets
+    for (auto& table : tables) {
+      for (auto& bucket : table) {
+        bucket = nullptr;
+      }
+    }
+    // clear available stack
+    available = nullptr;
+
+    // release memory of all but the first chunk TODO: it could be desirable to
+    // keep the memory
+    while (chunkID > 0) {
+      chunks.pop_back();
+      chunkID--;
+    }
+    // restore initial chunk setting
+    chunkIt = chunks[0].begin();
+    chunkEndIt = chunks[0].end();
+    allocationSize = INITIAL_ALLOCATION_SIZE * GROWTH_FACTOR;
+    allocations = INITIAL_ALLOCATION_SIZE;
+
+    for (auto& node : chunks[0]) {
+      node.ref = 0;
+    }
+
+    nodeCount = 0;
+    peakNodeCount = 0;
+
+    collisions = 0;
+    hits = 0;
+    lookups = 0;
+
+    std::fill(active.begin(), active.end(), 0);
+    activeNodeCount = 0;
+    maxActive = 0;
+
+    gcCalls = 0;
+    gcRuns = 0;
+    gcLimit = INITIAL_GC_LIMIT;
+  };
+
+  void print() {
+    auto q = static_cast<dd::Qubit>(nvars - 1);
+    for (auto it = tables.rbegin(); it != tables.rend(); ++it) {
+      auto& table = *it;
+      std::cout << "\tq" << static_cast<std::size_t>(q) << ":"
+                << "\n";
+      for (std::size_t key = 0; key < table.size(); ++key) {
+        auto p = table[key];
+        if (p != nullptr) {
+          std::cout << "\tkey=" << key << ": ";
+        }
+
+        while (p != nullptr) {
+          std::cout << "\t\t" << std::hex << reinterpret_cast<std::uintptr_t>(p)
+                    << std::dec << " " << p->ref << std::hex;
+          for (const auto& e : p->e) {
+            std::cout << " p" << reinterpret_cast<std::uintptr_t>(e.p) << "(r"
+                      << reinterpret_cast<std::uintptr_t>(e.w.r) << " i"
+                      << reinterpret_cast<std::uintptr_t>(e.w.i) << ")";
+          }
+          std::cout << std::dec << "\n";
+          p = p->next;
+        }
+      }
+      --q;
+    }
+  }
+
+  void printActive() {
+    std::cout << "#printActive: " << activeNodeCount << ", ";
+    for (const auto& a : active) {
+      std::cout << a << " ";
+    }
+    std::cout << "\n";
+  }
+
+  [[nodiscard]] fp hitRatio() const {
+    return static_cast<fp>(hits) / static_cast<fp>(lookups);
+  }
+
+  [[nodiscard]] fp colRatio() const {
+    return static_cast<fp>(collisions) / static_cast<fp>(lookups);
+  }
+
+  [[nodiscard]] std::size_t getActiveNodeCount() const {
+    return activeNodeCount;
+  }
+
+  [[nodiscard]] std::size_t getActiveNodeCount(Qubit var) {
+    return active.at(var);
+  }
+
+  std::ostream& printStatistics(std::ostream& os = std::cout) {
+    os << "hits: " << hits << ", collisions: " << collisions
+       << ", looks: " << lookups << ", hitRatio: " << hitRatio()
+       << ", colRatio: " << colRatio() << ", gc calls: " << gcCalls
+       << ", gc runs: " << gcRuns << "\n";
+    return os;
+  }
+
+private:
+  using NodeBucket = Node*;
+  using Table = std::array<NodeBucket, NBUCKET>;
+
+  // unique tables (one per input variable)
+  std::size_t nvars = 0;
+  std::vector<Table> tables{nvars};
+
+  Node* available{};
+  std::vector<std::vector<Node>> chunks{
+      1, std::vector<Node>{INITIAL_ALLOCATION_SIZE}};
+  std::size_t chunkID{0};
+  typename std::vector<Node>::iterator chunkIt{chunks[0].begin()};
+  typename std::vector<Node>::iterator chunkEndIt{chunks[0].end()};
+  std::size_t allocationSize{INITIAL_ALLOCATION_SIZE * GROWTH_FACTOR};
+
+  std::size_t allocations = INITIAL_ALLOCATION_SIZE;
+  std::size_t nodeCount = 0;
+  std::size_t peakNodeCount = 0;
+
+  // unique table lookup statistics
+  std::size_t collisions = 0;
+  std::size_t hits = 0;
+  std::size_t lookups = 0;
+
+  // (max) active nodes
+  // number of active vector nodes for each variable
+  std::vector<std::size_t> active{std::vector<std::size_t>(nvars, 0)};
+  std::size_t activeNodeCount = 0;
+  std::size_t maxActive = 0;
+
+  // garbage collection
+  std::size_t gcCalls = 0;
+  std::size_t gcRuns = 0;
+  std::size_t gcLimit = INITIAL_GC_LIMIT;
+
+  /**
+  Searches for a node in the hash table with the given key.
+  @param e The node to search for.
+  @param key The hashed value used to search the table.
+  @param keepNode If true, the node pointed to by e.p will not be put on the
+  available chain.
+  @return The Edge<Node> found in the hash table or Edge<Node>::zero if not
+  found.
+  **/
+  Edge<Node> searchTable(const Edge<Node>& e, const std::size_t& key,
+                         const bool keepNode = false) {
+    const auto v = e.p->v;
+
+    Node* p = tables[static_cast<std::size_t>(v)][key];
+    while (p != nullptr) {
+      if (nodesAreEqual(e.p, p)) {
+        // Match found
+        if (e.p != p && !keepNode) {
+          // put node pointed to by e.p on available chain
+          returnNode(e.p);
+        }
+        ++hits;
+
+        // variables should stay the same
+        assert(p->v == e.p->v);
+
+        return {p, e.w};
+      }
+      ++collisions;
+      p = p->next;
+    }
+
+    // Node not found in bucket
+    return Edge<Node>::zero;
+  }
+};
 
 } // namespace dd
-
-#endif //DDpackage_UNIQUETABLE_HPP
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/json/.clang-format` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/json/.clang-format`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/json/.clang-tidy` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/json/.clang-tidy`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/json/.gitignore` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/json/.gitignore`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/json/.reuse/dep5` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/json/.reuse/dep5`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/json/BUILD.bazel` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/json/BUILD.bazel`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/json/CMakeLists.txt` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/json/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/json/ChangeLog.md` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/json/ChangeLog.md`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/json/LICENSE.MIT` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/json/LICENSE.MIT`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/json/LICENSES/Apache-2.0.txt` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/json/LICENSES/Apache-2.0.txt`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/json/LICENSES/BSD-3-Clause.txt` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/json/LICENSES/BSD-3-Clause.txt`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/json/LICENSES/GPL-3.0-only.txt` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/json/LICENSES/GPL-3.0-only.txt`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/json/LICENSES/MIT.txt` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/json/LICENSES/MIT.txt`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/json/Makefile` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/json/Makefile`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/json/README.md` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/json/README.md`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/json/cmake/ci.cmake` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/json/cmake/ci.cmake`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/json/cmake/config.cmake.in` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/json/cmake/config.cmake.in`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/json/cmake/download_test_data.cmake` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/json/cmake/download_test_data.cmake`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/json/cmake/nlohmann_jsonConfigVersion.cmake.in` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/json/cmake/nlohmann_jsonConfigVersion.cmake.in`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/json/cmake/scripts/gen_bazel_build_file.cmake` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/json/cmake/scripts/gen_bazel_build_file.cmake`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/json/cmake/test.cmake` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/json/cmake/test.cmake`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/json/meson.build` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/json/meson.build`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/json/nlohmann_json.natvis` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/json/nlohmann_json.natvis`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/json/single_include/nlohmann/json.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/json/single_include/nlohmann/json.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/json/single_include/nlohmann/json_fwd.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/json/single_include/nlohmann/json_fwd.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/json/wsjcpp.yml` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/json/wsjcpp.yml`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.appveyor.yml` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/.appveyor.yml`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.clang-format` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/.clang-format`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.clang-tidy` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/.clang-tidy`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.cmake-format.yaml` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/.cmake-format.yaml`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.codespell-ignore-lines` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/.codespell-ignore-lines`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/.pre-commit-config.yaml` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/.pre-commit-config.yaml`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/CMakeLists.txt` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/LICENSE` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/LICENSE`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/README.rst` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/README.rst`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/SECURITY.md` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/SECURITY.md`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/attr.h` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/attr.h`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/buffer_info.h` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/buffer_info.h`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/cast.h` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/cast.h`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/chrono.h` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/chrono.h`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/complex.h` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/complex.h`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/detail/class.h` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/detail/class.h`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/detail/common.h` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/detail/common.h`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/detail/descr.h` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/detail/descr.h`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/detail/init.h` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/detail/init.h`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/detail/internals.h` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/detail/internals.h`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/detail/type_caster_base.h` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/detail/type_caster_base.h`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/detail/typeid.h` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/detail/typeid.h`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/eigen/matrix.h` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/eigen/matrix.h`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/eigen/tensor.h` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/eigen/tensor.h`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/embed.h` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/embed.h`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/eval.h` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/eval.h`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/functional.h` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/functional.h`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/gil.h` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/gil.h`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/iostream.h` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/iostream.h`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/numpy.h` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/numpy.h`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/operators.h` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/operators.h`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/options.h` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/options.h`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/pybind11.h` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/pybind11.h`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/pytypes.h` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/pytypes.h`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/stl/filesystem.h` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/stl/filesystem.h`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/stl.h` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/stl.h`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/stl_bind.h` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/stl_bind.h`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/include/pybind11/type_caster_pyobject_ptr.h` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/include/pybind11/type_caster_pyobject_ptr.h`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/noxfile.py` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/noxfile.py`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/pybind11/__main__.py` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/pybind11/__main__.py`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/pybind11/commands.py` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/pybind11/commands.py`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/pybind11/setup_helpers.py` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/pybind11/setup_helpers.py`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/pyproject.toml` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/pyproject.toml`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/setup.cfg` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/setup.cfg`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/setup.py` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/setup.py`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/FindCatch.cmake` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/FindCatch.cmake`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/FindEigen3.cmake` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/FindEigen3.cmake`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/FindPythonLibsNew.cmake` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/FindPythonLibsNew.cmake`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/JoinPaths.cmake` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/JoinPaths.cmake`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/check-style.sh` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/check-style.sh`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/cmake_uninstall.cmake.in` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/cmake_uninstall.cmake.in`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/codespell_ignore_lines_from_errors.py` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/codespell_ignore_lines_from_errors.py`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/libsize.py` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/libsize.py`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/make_changelog.py` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/make_changelog.py`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/pybind11Common.cmake` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/pybind11Common.cmake`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/pybind11Config.cmake.in` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/pybind11Config.cmake.in`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/pybind11NewTools.cmake` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/pybind11NewTools.cmake`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/pybind11Tools.cmake` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/pybind11Tools.cmake`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/setup_global.py.in` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/setup_global.py.in`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11/tools/setup_main.py.in` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11/tools/setup_main.py.in`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11_json/CMakeLists.txt` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11_json/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11_json/LICENSE` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11_json/LICENSE`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11_json/README.md` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11_json/README.md`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11_json/include/pybind11_json/pybind11_json.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11_json/include/pybind11_json/pybind11_json.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/pybind11_json/pybind11_jsonConfig.cmake.in` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/pybind11_json/pybind11_jsonConfig.cmake.in`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/LICENSE` & `mqt.ddsim-1.18.0/extern/taskflow/LICENSE`

 * *Files 6% similar despite different names*

```diff
@@ -1,10 +1,10 @@
-MIT License
+TASKFLOW MIT LICENSE 
 
-Copyright (c) 2022 Chair for Design Automation, TU Munich
+Copyright (c) 2018-2023 Dr. Tsung-Wei Huang
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/cmake/FindGMP.cmake` & `mqt.ddsim-1.18.0/extern/mqt-core/cmake/FindGMP.cmake`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/.circleci/config.yml` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/.circleci/config.yml`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/.drone/boost.sh` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/.drone/boost.sh`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/.drone.star` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/.drone.star`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/.gitattributes` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/.gitattributes`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/CMakeLists.txt` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/README.md` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/README.md`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/appveyor.yml` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/appveyor.yml`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/Jamfile.v2` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/Jamfile.v2`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/architecture/Jamfile.jam` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/architecture/Jamfile.jam`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/architecture/combined.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/architecture/combined.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/architecture/x86.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/architecture/x86.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_aggregate_bases_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_aggregate_bases_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_aggregate_nsdmi_14.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_aggregate_nsdmi_14.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_alias_templates_11.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_alias_templates_11.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_aligned_new_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_aligned_new_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_attributes_11.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_attributes_11.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_binary_literals_14.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_binary_literals_14.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_capture_star_this_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_capture_star_this_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_char8_t_20.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_char8_t_20.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_conditional_explicit_20.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_conditional_explicit_20.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_constexpr_11.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_constexpr_11.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_constexpr_14.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_constexpr_14.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_constexpr_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_constexpr_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_decltype_11.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_decltype_11.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_decltype_auto_14.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_decltype_auto_14.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_deduction_guides_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_deduction_guides_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_delegating_constructors_11.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_delegating_constructors_11.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_enumerator_attributes_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_enumerator_attributes_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_exceptions_03.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_exceptions_03.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_explicit_conversion_11.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_explicit_conversion_11.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_fold_expressions_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_fold_expressions_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_generic_lambdas_14.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_generic_lambdas_14.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_guaranteed_copy_elision_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_guaranteed_copy_elision_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_hex_float_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_hex_float_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_if_constexpr_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_if_constexpr_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_impl_destroying_delete_20.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_impl_destroying_delete_20.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_impl_three_way_comparison_20.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_impl_three_way_comparison_20.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_inheriting_constructors_11.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_inheriting_constructors_11.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_inheriting_constructors_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_inheriting_constructors_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_init_captures_14.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_init_captures_14.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_initializer_lists_11.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_initializer_lists_11.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_inline_variables_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_inline_variables_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lambdas_11.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lambdas_11.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_addressof_constexpr_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_addressof_constexpr_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_allocator_traits_is_always_equal_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_allocator_traits_is_always_equal_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_any_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_any_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_apply_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_apply_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_array_constexpr_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_array_constexpr_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_as_const_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_as_const_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_atomic_is_always_lock_free_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_atomic_is_always_lock_free_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_atomic_ref_20.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_atomic_ref_20.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_bind_front_20.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_bind_front_20.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_bit_cast_20.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_bit_cast_20.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_bool_constant_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_bool_constant_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_boyer_moore_searcher_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_boyer_moore_searcher_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_byte_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_byte_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_char8_t_20.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_char8_t_20.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_chrono_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_chrono_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_chrono_udls_14.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_chrono_udls_14.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_clamp_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_clamp_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_complex_udls_14.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_complex_udls_14.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_concepts_20.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_concepts_20.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_constexpr_misc_20.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_constexpr_misc_20.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_constexpr_swap_algorithms_20.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_constexpr_swap_algorithms_20.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_destroying_delete_20.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_destroying_delete_20.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_enable_shared_from_this_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_enable_shared_from_this_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_erase_if_20.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_erase_if_20.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_exchange_function_14.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_exchange_function_14.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_execution_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_execution_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_filesystem_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_filesystem_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_gcd_lcm_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_gcd_lcm_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_generic_associative_lookup_14.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_generic_associative_lookup_14.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_generic_unordered_lookup_20.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_generic_unordered_lookup_20.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_hardware_interference_size_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_hardware_interference_size_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_has_unique_object_representations_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_has_unique_object_representations_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_hypot_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_hypot_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_incomplete_container_elements_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_incomplete_container_elements_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_integer_sequence_14.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_integer_sequence_14.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_integral_constant_callable_14.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_integral_constant_callable_14.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_invoke_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_invoke_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_is_aggregate_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_is_aggregate_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_is_constant_evaluated_20.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_is_constant_evaluated_20.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_is_final_14.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_is_final_14.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_is_invocable_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_is_invocable_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_is_null_pointer_14.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_is_null_pointer_14.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_is_swappable_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_is_swappable_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_launder_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_launder_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_list_remove_return_type_20.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_list_remove_return_type_20.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_logical_traits_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_logical_traits_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_make_from_tuple_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_make_from_tuple_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_make_reverse_iterator_14.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_make_reverse_iterator_14.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_make_unique_14.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_make_unique_14.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_map_try_emplace_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_map_try_emplace_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_math_special_functions_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_math_special_functions_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_memory_resource_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_memory_resource_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_node_extract_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_node_extract_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_nonmember_container_access_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_nonmember_container_access_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_not_fn_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_not_fn_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_null_iterators_14.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_null_iterators_14.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_optional_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_optional_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_parallel_algorithm_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_parallel_algorithm_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_quoted_string_io_14.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_quoted_string_io_14.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_ranges_20.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_ranges_20.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_raw_memory_algorithms_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_raw_memory_algorithms_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_result_of_sfinae_14.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_result_of_sfinae_14.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_robust_nonmodifying_seq_ops_14.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_robust_nonmodifying_seq_ops_14.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_sample_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_sample_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_scoped_lock_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_scoped_lock_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_shared_mutex_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_shared_mutex_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_shared_ptr_arrays_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_shared_ptr_arrays_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_shared_ptr_weak_type_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_shared_ptr_weak_type_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_shared_timed_mutex_14.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_shared_timed_mutex_14.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_string_udls_14.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_string_udls_14.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_string_view_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_string_view_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_three_way_comparison_20.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_three_way_comparison_20.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_to_chars_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_to_chars_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_transformation_trait_aliases_14.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_transformation_trait_aliases_14.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_transparent_operators_14.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_transparent_operators_14.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_transparent_operators_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_transparent_operators_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_tuple_element_t_14.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_tuple_element_t_14.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_tuples_by_type_14.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_tuples_by_type_14.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_type_trait_variable_templates_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_type_trait_variable_templates_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_uncaught_exceptions_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_uncaught_exceptions_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_unordered_map_try_emplace_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_unordered_map_try_emplace_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_variant_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_variant_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_lib_void_t_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_lib_void_t_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_namespace_attributes_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_namespace_attributes_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_noexcept_function_type_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_noexcept_function_type_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_nontype_template_args_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_nontype_template_args_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_nontype_template_parameter_auto_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_nontype_template_parameter_auto_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_nontype_template_parameter_class_20.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_nontype_template_parameter_class_20.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_nsdmi_11.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_nsdmi_11.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_range_based_for_11.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_range_based_for_11.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_range_based_for_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_range_based_for_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_raw_strings_11.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_raw_strings_11.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_ref_qualifiers_11.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_ref_qualifiers_11.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_return_type_deduction_14.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_return_type_deduction_14.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_rtti_03.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_rtti_03.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_rvalue_references_11.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_rvalue_references_11.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_sized_deallocation_14.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_sized_deallocation_14.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_static_assert_11.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_static_assert_11.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_static_assert_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_static_assert_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_structured_bindings_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_structured_bindings_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_template_template_args_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_template_template_args_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_threadsafe_static_init_11.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_threadsafe_static_init_11.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_unicode_characters_11.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_unicode_characters_11.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_unicode_literals_11.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_unicode_literals_11.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_user_defined_literals_11.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_user_defined_literals_11.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_variable_templates_14.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_variable_templates_14.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_variadic_templates_11.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_variadic_templates_11.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/std/cpp_variadic_using_17.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/std/cpp_variadic_using_17.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/checks/test_case.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/checks/test_case.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/configure` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/configure`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/abi/borland_prefix.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/abi/borland_prefix.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/abi/msvc_prefix.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/abi/msvc_prefix.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/abi_prefix.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/abi_prefix.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/abi_suffix.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/abi_suffix.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/assert_cxx03.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/assert_cxx03.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/assert_cxx11.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/assert_cxx11.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/assert_cxx14.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/assert_cxx14.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/assert_cxx17.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/assert_cxx17.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/assert_cxx20.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/assert_cxx20.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/assert_cxx98.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/assert_cxx98.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/auto_link.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/auto_link.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/borland.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/borland.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/clang.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/clang.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/clang_version.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/clang_version.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/codegear.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/codegear.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/comeau.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/comeau.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/common_edg.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/common_edg.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/cray.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/cray.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/diab.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/diab.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/digitalmars.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/digitalmars.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/gcc.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/gcc.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/gcc_xml.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/gcc_xml.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/greenhills.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/greenhills.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/hp_acc.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/hp_acc.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/intel.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/intel.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/kai.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/kai.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/metrowerks.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/metrowerks.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/mpw.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/mpw.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/nvcc.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/nvcc.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/pathscale.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/pathscale.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/pgi.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/pgi.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/sgi_mipspro.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/sgi_mipspro.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/sunpro_cc.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/sunpro_cc.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/vacpp.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/vacpp.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/visualc.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/visualc.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/xlcpp.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/xlcpp.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/compiler/xlcpp_zos.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/compiler/xlcpp_zos.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/detail/cxx_composite.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/detail/cxx_composite.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/detail/posix_features.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/detail/posix_features.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/detail/select_compiler_config.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/detail/select_compiler_config.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/detail/select_platform_config.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/detail/select_platform_config.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/detail/select_stdlib_config.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/detail/select_stdlib_config.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/detail/suffix.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/detail/suffix.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/header_deprecated.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/header_deprecated.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/helper_macros.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/helper_macros.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/no_tr1/cmath.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/no_tr1/cmath.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/no_tr1/complex.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/no_tr1/complex.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/no_tr1/functional.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/no_tr1/functional.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/no_tr1/memory.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/no_tr1/memory.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/no_tr1/utility.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/no_tr1/utility.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/aix.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/aix.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/beos.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/beos.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/bsd.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/bsd.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/cloudabi.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/cloudabi.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/cygwin.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/cygwin.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/haiku.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/haiku.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/hpux.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/hpux.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/irix.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/irix.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/linux.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/linux.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/macos.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/macos.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/qnxnto.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/qnxnto.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/solaris.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/solaris.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/symbian.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/symbian.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/vms.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/vms.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/vxworks.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/vxworks.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/wasm.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/wasm.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/win32.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/win32.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/platform/zos.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/platform/zos.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/pragma_message.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/pragma_message.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/requires_threads.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/requires_threads.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/stdlib/dinkumware.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/stdlib/dinkumware.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/stdlib/libcomo.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/stdlib/libcomo.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/stdlib/libcpp.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/stdlib/libcpp.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/stdlib/libstdcpp3.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/stdlib/libstdcpp3.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/stdlib/modena.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/stdlib/modena.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/stdlib/msl.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/stdlib/msl.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/stdlib/roguewave.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/stdlib/roguewave.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/stdlib/sgi.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/stdlib/sgi.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/stdlib/stlport.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/stdlib/stlport.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/stdlib/vacpp.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/stdlib/vacpp.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/stdlib/xlcpp_zos.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/stdlib/xlcpp_zos.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/user.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/user.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/warning_disable.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/warning_disable.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config/workaround.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config/workaround.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/config.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/config.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/cstdint.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/cstdint.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/cxx11_char_types.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/cxx11_char_types.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/limits.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/limits.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/include/boost/version.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/include/boost/version.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/index.html` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/index.html`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/tools/configure.in` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/tools/configure.in`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/config/tools/generate.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/config/tools/generate.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/.circleci/config.yml` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/.circleci/config.yml`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/.clang-format` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/.clang-format`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/.drone/boost.sh` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/.drone/boost.sh`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/.drone.star` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/.drone.star`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/.gitattributes` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/.gitattributes`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/CMakeLists.txt` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/LICENSE` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/LICENSE`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/README.md` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/README.md`

 * *Files 8% similar despite different names*

```diff
@@ -1,12 +1,11 @@
 Boost Multiprecision Library
 ============================
 
->ANNOUNCEMENT: Support for C++11 will be deprecated in this library starting in July 2023 (Boost 1.82).  
->New features will require *at least* C++14, as will existing features starting with the deprecation release.
+>ANNOUNCEMENT: This library now requires a compliant C++14 compiler.
 
 |                  |  Master  |   Develop   |
 |------------------|----------|-------------|
 | Drone            |  [![Build Status](https://drone.cpp.al/api/badges/boostorg/multiprecision/status.svg?ref=refs/heads/master)](https://drone.cpp.al/boostorg/multiprecision) | [![Build Status](https://drone.cpp.al/api/badges/boostorg/multiprecision/status.svg)](https://drone.cpp.al/boostorg/multiprecision) |
 | Github Actions | [![Build Status](https://github.com/boostorg/multiprecision/workflows/multiprecision/badge.svg?branch=master)](https://github.com/boostorg/multiprecision/actions) | [![Build Status](https://github.com/boostorg/multiprecision/workflows/multiprecision/badge.svg?branch=develop)](https://github.com/boostorg/multiprecision/actions) |
 
  The Multiprecision Library provides integer, rational, floating-point, complex and interval number types in C++ that have more range and
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/config/Jamfile.v2` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/config/Jamfile.v2`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/config/has_gmp.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/config/has_gmp.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/config/has_is_constant_evaluated.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/config/has_is_constant_evaluated.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/config/has_mpc.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/config/has_mpc.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/config/has_mpfi.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/config/has_mpfi.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/config/has_mpfr.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/config/has_mpfr.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/doc/tutorial_fwd.qbk` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/fwd.hpp`

 * *Files 4% similar despite different names*

```diff
@@ -1,39 +1,50 @@
-[/
-  Copyright 2011 - 2020 John Maddock.
-  Copyright 2013 - 2019 Paul A. Bristow.
-  Copyright 2013 Christopher Kormanyos.
-
-  Distributed under the Boost Software License, Version 1.0.
-  (See accompanying file LICENSE_1_0.txt or copy at
-  http://www.boost.org/LICENSE_1_0.txt).
-]
+///////////////////////////////////////////////////////////////////////////////
+//  Copyright 2023 John Maddock. Distributed under the Boost
+//  Software License, Version 1.0. (See accompanying file
+//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
-[section:fwd Forward Declarations]
+#ifndef BOOST_MP_FWD_HPP
+#define BOOST_MP_FWD_HPP
 
-The header `<boost/multiprecision/fwd.hpp>` contains forward declarations for class `number` plus all of the
-available backends in the this library:
+#include <boost/multiprecision/cpp_int/cpp_int_config.hpp>
 
-   namespace boost {
+namespace boost {
    namespace multiprecision {
 
       enum expression_template_option
       {
          et_off = 0,
          et_on = 1
       };
 
       template <class Backend>
-      struct expression_template_default { /*details*/ };
+      struct expression_template_default
+      {
+         static constexpr expression_template_option value = et_on;
+      };
 
       template <class Backend, expression_template_option ExpressionTemplates = expression_template_default<Backend>::value>
       class number;
 
       template <class T>
-      struct is_number;
+      struct is_number : public std::integral_constant<bool, false>
+      {};
+
+      template <class Backend, expression_template_option ExpressionTemplates>
+      struct is_number<number<Backend, ExpressionTemplates> > : public std::integral_constant<bool, true>
+      {};
+
+      namespace detail {
+
+         // Forward-declare an expression wrapper
+         template <class tag, class Arg1 = void, class Arg2 = void, class Arg3 = void, class Arg4 = void>
+         struct expression;
+
+      } // namespace detail
 
       enum cpp_integer_type
       {
          signed_magnitude = 1,
          unsigned_magnitude = 0,
          signed_packed = 3,
          unsigned_packed = 2
@@ -46,17 +57,15 @@
       };
 
       enum mpfr_allocation_type
       {
          allocate_stack,
          allocate_dynamic
       };
-      //
-      // Logging functions for lagged_adaptor:
-      //
+
       template <class Backend>
       void log_postfix_event(const Backend&, const char* /*event_description*/);
       template <class Backend, class T>
       void log_postfix_event(const Backend&, const T&, const char* /*event_description*/);
       template <class Backend>
       void log_prefix_event(const Backend&, const char* /*event_description*/);
       template <class Backend, class T>
@@ -113,17 +122,15 @@
          struct mpfr_float_backend<0, allocate_stack>;
 
          template <class Backend>
          struct rational_adaptor;
 
          struct tommath_int;
       }
-      //
-      // All the backends are imported into boost::multiprecision:
-      //
+
       using boost::multiprecision::backends::complex_adaptor;
       using boost::multiprecision::backends::debug_adaptor;
       using boost::multiprecision::backends::logged_adaptor;
       using backends::cpp_bin_float;
       using backends::digit_base_10;
       using backends::digit_base_2;
       using boost::multiprecision::backends::cpp_dec_float;
@@ -134,17 +141,31 @@
       using boost::multiprecision::backends::gmp_rational;
       using boost::multiprecision::backends::mpc_complex_backend;
       using boost::multiprecision::backends::mpfi_float_backend;
       using boost::multiprecision::backends::mpfr_float_backend;
       using boost::multiprecision::backends::rational_adaptor;
       using boost::multiprecision::backends::tommath_int;
 
-      //
-      // convenience typedefs:
-      //
+      template <unsigned Digits, backends::digit_base_type DigitBase, class Allocator, class Exponent, Exponent MinE, Exponent MaxE>
+      struct expression_template_default<cpp_bin_float<Digits, DigitBase, Allocator, Exponent, MinE, MaxE> >
+      {
+         static constexpr expression_template_option value = std::is_void<Allocator>::value ? et_off : et_on;
+      };
+
+      template <std::size_t MinBits, std::size_t MaxBits, cpp_integer_type SignType, cpp_int_check_type Checked>
+      struct expression_template_default<backends::cpp_int_backend<MinBits, MaxBits, SignType, Checked, void> >
+      {
+         static constexpr expression_template_option value = et_off;
+      };
+
+      template <class IntBackend>
+      struct expression_template_default<backends::rational_adaptor<IntBackend> > : public expression_template_default<IntBackend>
+      {};
+
+      using complex128 = number<complex_adaptor<float128_backend>, et_off>;
 
       using cpp_bin_float_50 = number<backends::cpp_bin_float<50> >;
       using cpp_bin_float_100 = number<backends::cpp_bin_float<100> >;
 
       using cpp_bin_float_single = number<backends::cpp_bin_float<24, backends::digit_base_2, void, std::int16_t, -126, 127>, et_off>;
       using cpp_bin_float_double = number<backends::cpp_bin_float<53, backends::digit_base_2, void, std::int16_t, -1022, 1023>, et_off>;
       using cpp_bin_float_double_extended = number<backends::cpp_bin_float<64, backends::digit_base_2, void, std::int16_t, -16382, 16383>, et_off>;
@@ -202,16 +223,16 @@
       using checked_int1024_t = number<cpp_int_backend<1024, 1024, signed_magnitude, checked, void> >;
 
       template <class Number>
       using debug_adaptor_t = number<debug_adaptor<typename Number::backend_type>, Number::et>;
       template <class Number>
       using logged_adaptor_t = number<logged_adaptor<typename Number::backend_type>, Number::et>;
 
+
       using float128 = number<float128_backend, et_off>;
-      using complex128 = number<complex_adaptor<float128_backend>, et_off>;
 
       using mpf_float_50 = number<gmp_float<50> >;
       using mpf_float_100 = number<gmp_float<100> >;
       using mpf_float_500 = number<gmp_float<500> >;
       using mpf_float_1000 = number<gmp_float<1000> >;
       using mpf_float = number<gmp_float<0> >;
       using mpz_int = number<gmp_int>;
@@ -238,11 +259,10 @@
       using static_mpfr_float_50 = number<mpfr_float_backend<50, allocate_stack> >;
       using static_mpfr_float_100 = number<mpfr_float_backend<100, allocate_stack> >;
 
       using tom_int = number<tommath_int>;
       using tommath_rational = rational_adaptor<tommath_int>;
       using tom_rational = number<tommath_rational>;
 
-    } }
-
+} }
 
-[endsect] [/section]
+#endif
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/Jamfile.v2` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/Jamfile.v2`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/big_seventh.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/big_seventh.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/complex128_examples.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/complex128_examples.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/constexpr_float_arithmetic_examples.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/constexpr_float_arithmetic_examples.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/cpp_bin_float_import_export.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/cpp_bin_float_import_export.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/cpp_bin_float_snips.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/cpp_bin_float_snips.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/cpp_complex_examples.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/cpp_complex_examples.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/cpp_dec_float_snips.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/cpp_dec_float_snips.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/cpp_int_import_export.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/cpp_int_import_export.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/cpp_int_mul_timing.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/cpp_int_mul_timing.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/cpp_int_snips.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/cpp_int_snips.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/debug_adaptor_snips.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/debug_adaptor_snips.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/eigen_example.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/eigen_example.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/exercise_threading_log_agm.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/exercise_threading_log_agm.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/float128_snips.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/float128_snips.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/floating_point_examples.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/floating_point_examples.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/gauss_laguerre_quadrature.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/gauss_laguerre_quadrature.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/gmp_snips.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/gmp_snips.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/hashing_examples.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/hashing_examples.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/hypergeometric_luke_algorithms.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/hypergeometric_luke_algorithms.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/integer_examples.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/integer_examples.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/logged_adaptor.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/logged_adaptor.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/mixed_integer_arithmetic.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/mixed_integer_arithmetic.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/mpc_examples.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/mpc_examples.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/mpfi_snips.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/mpfi_snips.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/mpfr_precision.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/mpfr_precision.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/mpfr_snips.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/mpfr_snips.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/numeric_limits_snips.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/numeric_limits_snips.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/random_snips.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/random_snips.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/safe_prime.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/safe_prime.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/scoped_precision_example.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/scoped_precision_example.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/standalone_bernoulli_tgamma.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/standalone_bernoulli_tgamma.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/example/tommath_snips.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/example/tommath_snips.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/complex128.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/complex128.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/complex_adaptor.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/complex_adaptor.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/concepts/mp_number_archetypes.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/concepts/mp_number_archetypes.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_bin_float/io.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_bin_float/io.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_bin_float/transcendental.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_bin_float/transcendental.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_bin_float.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_bin_float.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_dec_float.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_dec_float.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/add.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/add.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/add_unsigned.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/add_unsigned.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/bitwise.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/bitwise.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/checked.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/checked.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/comparison.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/comparison.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/cpp_int_config.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/cpp_int_config.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/divide.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/divide.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/import_export.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/import_export.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/intel_intrinsics.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/intel_intrinsics.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/limits.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/limits.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/literals.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/literals.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/misc.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/misc.hpp`

 * *Files 0% similar despite different names*

```diff
@@ -180,15 +180,15 @@
       check_is_negative(std::integral_constant<bool, boost::multiprecision::detail::is_signed<R>::value && boost::multiprecision::detail::is_integral<R>::value>());
       *result = negate_integer(*result, std::integral_constant<bool, boost::multiprecision::detail::is_signed<R>::value && boost::multiprecision::detail::is_integral<R>::value>());
    }
 }
 
 template <class R, std::size_t MinBits1, std::size_t MaxBits1, cpp_integer_type SignType1, cpp_int_check_type Checked1, class Allocator1>
 inline BOOST_MP_CXX14_CONSTEXPR typename std::enable_if<std::is_floating_point<R>::value && !is_trivial_cpp_int<cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1> >::value, void>::type
-eval_convert_to(R* result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& backend) noexcept(boost::multiprecision::detail::is_arithmetic<R>::value)
+eval_convert_to(R* result, const cpp_int_backend<MinBits1, MaxBits1, SignType1, Checked1, Allocator1>& backend) noexcept(boost::multiprecision::detail::is_arithmetic<R>::value && std::numeric_limits<R>::has_infinity)
 {
    BOOST_MP_FLOAT128_USING using std::ldexp;
    if (eval_is_zero(backend))
    {
       *result = 0.0f;
       return;
    }
@@ -240,15 +240,23 @@
       // Perform rounding:
       bits -= 1 + std::numeric_limits<R>::digits;
       if (eval_bit_test(backend, static_cast<unsigned>(bits)))
       {
          if ((eval_lsb_imp(backend) < static_cast<std::size_t>(bits)) || eval_bit_test(backend, static_cast<std::size_t>(bits + 1)))
          {
             #ifdef BOOST_MP_MATH_AVAILABLE
-            *result = boost::math::float_next(*result);
+            BOOST_IF_CONSTEXPR(std::numeric_limits<R>::has_infinity)
+            {
+               // Must NOT throw:
+               *result = boost::math::float_next(*result, boost::math::policies::make_policy(boost::math::policies::overflow_error<boost::math::policies::ignore_error>()));
+            }
+            else
+            {
+               *result = boost::math::float_next(*result);
+            }
             #else
             using std::nextafter; BOOST_MP_FLOAT128_USING
             *result = nextafter(*result, *result * 2);
             #endif
          }
       }
    }
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/multiply.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/multiply.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/serialize.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/serialize.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/value_pack.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int/value_pack.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/cpp_int.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/cpp_int.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/debug_adaptor.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/debug_adaptor.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/assert.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/assert.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/atomic.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/atomic.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/bitscan.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/bitscan.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/check_cpp11_config.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/check_cpp11_config.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/constexpr.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/constexpr.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/default_ops.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/default_ops.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/digits.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/digits.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/dynamic_array.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/dynamic_array.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/empty_value.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/empty_value.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/endian.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/endian.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/et_ops.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/et_ops.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/float128_functions.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/float128_functions.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/float_string_cvt.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/float_string_cvt.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/fpclassify.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/fpclassify.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/functions/constants.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/functions/constants.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/functions/pow.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/functions/pow.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/functions/trig.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/functions/trig.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/functions/trunc.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/functions/trunc.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/generic_interconvert.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/generic_interconvert.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/hash.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/hash.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/integer_ops.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/integer_ops.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/itos.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/itos.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/min_max.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/min_max.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/no_et_ops.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/no_et_ops.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/no_exceptions_support.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/no_exceptions_support.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/number_base.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/number_base.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/number_compare.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/number_compare.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/precision.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/precision.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/rebind.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/rebind.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/standalone_config.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/standalone_config.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/static_array.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/static_array.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/string_helpers.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/string_helpers.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/tables.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/tables.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/ublas_interop.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/ublas_interop.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/uniform_int_distribution.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/uniform_int_distribution.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/detail/utype_helper.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/detail/utype_helper.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/eigen.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/eigen.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/float128.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/float128.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/gmp.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/gmp.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/integer.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/integer.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/logged_adaptor.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/logged_adaptor.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/miller_rabin.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/miller_rabin.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/mpc.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/mpc.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/mpfi.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/mpfi.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/mpfr.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/mpfr.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/number.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/number.hpp`

 * *Files 0% similar despite different names*

```diff
@@ -1117,14 +1117,15 @@
    static constexpr variable_precision_options thread_default_variable_precision_options()noexcept
    {
       return Backend::thread_default_variable_precision_options();
    }
    static BOOST_MP_CXX14_CONSTEXPR void default_variable_precision_options(variable_precision_options opts)
    {
       Backend::default_variable_precision_options(opts);
+      Backend::thread_default_variable_precision_options(opts);
    }
    static BOOST_MP_CXX14_CONSTEXPR void thread_default_variable_precision_options(variable_precision_options opts)
    {
       Backend::thread_default_variable_precision_options(opts);
    }
    //
    // Comparison:
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/random.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/random.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/rational_adaptor.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/rational_adaptor.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/tommath.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/tommath.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/traits/explicit_conversion.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/traits/explicit_conversion.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/traits/extract_exponent_type.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/traits/extract_exponent_type.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/traits/is_backend.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/traits/is_backend.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/traits/is_byte_container.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/traits/is_byte_container.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/traits/is_complex.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/traits/is_complex.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/traits/is_convertible_arithmetic.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/traits/is_convertible_arithmetic.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/traits/is_restricted_conversion.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/traits/is_restricted_conversion.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/traits/is_variable_precision.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/traits/is_variable_precision.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/traits/max_digits10.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/traits/max_digits10.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/traits/std_integer_traits.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/traits/std_integer_traits.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/include/boost/multiprecision/traits/transcendental_reduction_type.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/include/boost/multiprecision/traits/transcendental_reduction_type.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/index.html` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/index.html`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/Jamfile.v2` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/Jamfile.v2`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/arithmetic_backend.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/arithmetic_backend.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/cpp_bin_float_conversion_performance.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/cpp_bin_float_conversion_performance.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/delaunay_test.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/delaunay_test.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/delaunay_test.log` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/delaunay_test.log`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/gcd_bench.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/gcd_bench.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/linpack-benchmark.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/linpack-benchmark.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/miller_rabin_performance.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/miller_rabin_performance.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/miller_rabin_performance.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/miller_rabin_performance.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/miller_rabin_performance.log` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/miller_rabin_performance.log`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/miller_rabin_performance_files/test10.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/miller_rabin_performance_files/test10.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/mixed_equivalent_types_bench.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/mixed_equivalent_types_bench.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test-gcc-linux.log` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test-gcc-linux.log`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test-intel-linux.log` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test-intel-linux.log`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test-msvc-10.log` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test-msvc-10.log`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test.log` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test.log`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test09.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test09.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test10.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test10.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test11.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test11.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test12.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test12.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test28.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test28.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test31.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test31.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test34.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test34.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test41.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test41.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test43.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test43.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test44.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test44.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test48.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test48.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/performance_test_files/test49.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/performance_test_files/test49.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/rational_bernoulli_allocations.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/rational_bernoulli_allocations.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/rational_bernoulli_allocations.log` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/rational_bernoulli_allocations.log`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/rational_bernoulli_bench.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/rational_bernoulli_bench.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/rational_bernoulli_bench.log` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/rational_bernoulli_bench.log`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/rational_determinant_bench.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/rational_determinant_bench.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/rational_determinant_bench.log` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/rational_determinant_bench.log`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/rational_zeta18_bench.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/rational_zeta18_bench.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance-msvc-10.log` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance-msvc-10.log`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance.log` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance.log`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_bessel.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_bessel.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_basic_9.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_basic_9.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_01.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_01.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_02.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_02.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_03.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_03.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_04.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_files/sf_performance_bessel_04.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_nct.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_nct.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sf_performance_poly.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sf_performance_poly.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/sqrt_bench.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/sqrt_bench.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/veronoi_performance.log` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/veronoi_performance.log`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/performance/voronoi_performance.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/performance/voronoi_performance.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/extern/boost/multiprecision/tools/sincos.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/extern/boost/multiprecision/tools/sincos.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/include/Definitions.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/zx/Definitions.hpp`

 * *Files 25% similar despite different names*

```diff
@@ -1,28 +1,28 @@
 #pragma once
 
-#include "Expression.hpp"
-#include "Rational.hpp"
+#include "operations/Expression.hpp"
+#include "zx/Rational.hpp"
 
 #include <cstdint>
 #include <stdexcept>
 #include <string>
 
 namespace zx {
 enum class EdgeType { Simple, Hadamard };
 enum class VertexType { Boundary, Z, X };
 using Vertex = std::size_t;
-using Col    = std::int32_t;
-using Qubit  = std::int32_t;
-using fp     = double;
-
-constexpr fp          MAX_DENOM           = 1e9; // TODO: maybe too high
-constexpr fp          PARAMETER_TOLERANCE = 1e-13;
-constexpr fp          TOLERANCE           = 1e-13;
-static constexpr auto PI                  = static_cast<fp>(
+using Col = std::int32_t;
+using Qubit = std::int32_t;
+using fp = double;
+
+constexpr fp MAX_DENOM = 1e9; // TODO: maybe too high
+constexpr fp PARAMETER_TOLERANCE = 1e-13;
+constexpr fp TOLERANCE = 1e-13;
+static constexpr auto PI = static_cast<fp>(
     3.141592653589793238462643383279502884197169399375105820974L);
 
 using PiExpression = sym::Expression<double, PiRational>;
 
 class ZXException : public std::invalid_argument {
   std::string msg;
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/include/Expression.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/operations/Expression.hpp`

 * *Files 1% similar despite different names*

```diff
@@ -1,13 +1,12 @@
 #pragma once
 
 #include <algorithm>
 #include <cmath>
 #include <cstdint>
-#include <cstdlib>
 #include <numeric>
 #include <ostream>
 #include <string>
 #include <type_traits>
 #include <unordered_map>
 #include <utility>
 #include <vector>
@@ -27,15 +26,15 @@
   }
 };
 
 struct Variable {
   // NOLINTBEGIN(cppcoreguidelines-avoid-non-const-global-variables)
   static inline std::unordered_map<std::string, std::size_t> registered{};
   static inline std::unordered_map<std::size_t, std::string> names{};
-  static inline std::size_t                                  nextId{};
+  static inline std::size_t nextId{};
   // NOLINTEND(cppcoreguidelines-avoid-non-const-global-variables)
 
   explicit Variable(const std::string& name);
 
   [[nodiscard]] std::string getName() const;
 
   bool operator==(const Variable& rhs) const { return id == rhs.id; }
@@ -64,26 +63,26 @@
 
 template <typename T,
           typename = std::enable_if<std::is_constructible_v<int, T> &&
                                     std::is_constructible_v<T, double>>>
 class Term {
 public:
   [[nodiscard]] Variable getVar() const { return var; }
-  [[nodiscard]] T        getCoeff() const { return coeff; }
+  [[nodiscard]] T getCoeff() const { return coeff; }
 
   [[nodiscard]] bool hasZeroCoeff() const {
     return std::abs(static_cast<double>(coeff)) < TOLERANCE;
   }
 
   Term(T coef, const Variable v) : coeff(coef), var(v){};
   explicit Term(const Variable v) : coeff(1), var(v){};
 
   Term operator-() const { return Term(-coeff, var); }
 
-  void  addCoeff(const T& r) { coeff += r; }
+  void addCoeff(const T& r) { coeff += r; }
   Term& operator*=(const T& rhs) {
     coeff *= rhs;
     return *this;
   }
 
   Term& operator/=(const T& rhs) {
     coeff /= rhs;
@@ -99,15 +98,15 @@
       throw SymbolicException("Cannot instantiate variable " +
                               getVar().getName() + ". No value given.");
     }
     return assignment.at(getVar()) * getCoeff();
   }
 
 private:
-  T        coeff;
+  T coeff;
   Variable var;
 };
 template <typename T,
           typename = std::enable_if<std::is_constructible_v<int, T>>>
 inline Term<T> operator*(Term<T> lhs, const double rhs) {
   lhs *= rhs;
   return lhs;
@@ -133,15 +132,15 @@
     typename T, typename U,
     typename = std::enable_if<
         std::is_constructible_v<T, U> && std::is_constructible_v<U, T> &&
         std::is_constructible_v<int, T> && std::is_constructible_v<T, double> &&
         std::is_constructible_v<U, double>>>
 class Expression {
 public:
-  using iterator       = typename std::vector<Term<T>>::iterator;
+  using iterator = typename std::vector<Term<T>>::iterator;
   using const_iterator = typename std::vector<Term<T>>::const_iterator;
 
   template <typename... Args> explicit Expression(Term<T> t, Args&&... ms) {
     terms.emplace_back(t);
     (terms.emplace_back(std::forward<Args>(ms)), ...);
     sortTerms();
     aggregateEqualTerms();
@@ -157,17 +156,17 @@
   Expression(const std::vector<Term<T>>& ts, const U& con)
       : terms(ts), constant(con){};
 
   Expression() = default;
 
   explicit Expression(const U& r) : constant(r){};
 
-  iterator                     begin() { return terms.begin(); }
+  iterator begin() { return terms.begin(); }
   [[nodiscard]] const_iterator begin() const { return terms.cbegin(); }
-  iterator                     end() { return terms.end(); }
+  iterator end() { return terms.end(); }
   [[nodiscard]] const_iterator end() const { return terms.cend(); }
   [[nodiscard]] const_iterator cbegin() const { return terms.cbegin(); }
   [[nodiscard]] const_iterator cend() const { return terms.cend(); }
 
   [[nodiscard]] bool isZero() const {
     return terms.empty() && constant == U{T{0}};
   }
@@ -275,16 +274,16 @@
     e.constant = -constant;
     return e;
   }
 
   [[nodiscard]] const Term<T>& operator[](const std::size_t i) const {
     return terms[i];
   }
-  [[nodiscard]] U    getConst() const { return constant; }
-  void               setConst(const U& val) { constant = val; }
+  [[nodiscard]] U getConst() const { return constant; }
+  void setConst(const U& val) { constant = val; }
   [[nodiscard]] auto numTerms() const { return terms.size(); }
 
   [[nodiscard]] const std::vector<Term<T>>& getTerms() const { return terms; }
 
   template <typename V,
             typename std::enable_if_t<std::is_constructible_v<U, V>>* = nullptr>
   Expression<T, V> convert() const {
@@ -297,15 +296,15 @@
                            [&](const double sum, const auto& term) {
                              return term.evaluate(assignment) + sum;
                            });
   }
 
 private:
   std::vector<Term<T>> terms;
-  U                    constant{T{0.0}};
+  U constant{T{0.0}};
 
   void sortTerms() {
     std::sort(terms.begin(), terms.end(),
               [&](const Term<T>& lhs, const Term<T>& rhs) {
                 return lhs.getVar() < rhs.getVar();
               });
   }
@@ -323,15 +322,15 @@
         t = next;
       }
     }
   }
 };
 
 template <typename T, typename U>
-inline Expression<T, U> operator+(Expression<T, U>        lhs,
+inline Expression<T, U> operator+(Expression<T, U> lhs,
                                   const Expression<T, U>& rhs) {
   lhs += rhs;
   return lhs;
 }
 
 template <typename T, typename U>
 inline Expression<T, U> operator+(Expression<T, U> lhs, const Term<T>& rhs) {
@@ -355,21 +354,21 @@
 inline Expression<T, U> operator+(Expression<T, U> lhs, const U& rhs) {
   lhs += rhs;
   return lhs;
 }
 
 template <typename T, typename U>
 inline Expression<T, U> operator+([[maybe_unused]] const T& lhs,
-                                  Expression<T, U>          rhs) {
+                                  Expression<T, U> rhs) {
   rhs += rhs;
   return rhs;
 }
 
 template <typename T, typename U>
-inline Expression<T, U> operator-(Expression<T, U>        lhs,
+inline Expression<T, U> operator-(Expression<T, U> lhs,
                                   const Expression<T, U>& rhs) {
   lhs -= rhs;
   return lhs;
 }
 template <typename T, typename U>
 inline Expression<T, U> operator-(Expression<T, U> lhs, const Term<T>& rhs) {
   lhs -= rhs;
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/include/Rational.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/zx/Rational.hpp`

 * *Files 1% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 #pragma once
 
 #if defined(GMP)
 #include "boost/multiprecision/gmp.hpp"
 using Rational = boost::multiprecision::mpq_rational;
-using BigInt   = boost::multiprecision::mpz_int;
+using BigInt = boost::multiprecision::mpz_int;
 #else
 #include "boost/multiprecision/cpp_int.hpp"
 using Rational = boost::multiprecision::cpp_rational;
-using BigInt   = boost::multiprecision::cpp_int;
+using BigInt = boost::multiprecision::cpp_int;
 #endif
 
 #include <cmath>
 #include <cstdint>
 #include <cstdlib>
 #include <iostream>
 #include <type_traits>
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/include/Rules.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/zx/Rules.hpp`

 * *Files 5% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #pragma once
 
-#include "Definitions.hpp"
+#include "zx/Definitions.hpp"
 
 namespace zx {
 class ZXDiagram;
 
 bool checkIdSimp(const ZXDiagram& diag, Vertex v);
 
 void removeId(ZXDiagram& diag, Vertex v);
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/include/Simplify.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/zx/Simplify.hpp`

 * *Files 4% similar despite different names*

```diff
@@ -1,22 +1,22 @@
 #pragma once
 
-#include "Definitions.hpp"
-#include "Rules.hpp"
-#include "ZXDiagram.hpp"
+#include "zx/Definitions.hpp"
+#include "zx/Rules.hpp"
+#include "zx/ZXDiagram.hpp"
 
 #include <cstddef>
 
 namespace zx {
 
 template <class VertexCheckFun, class VertexRuleFun>
 std::size_t simplifyVertices(ZXDiagram& diag, VertexCheckFun check,
                              VertexRuleFun rule) {
   std::size_t nSimplifications = 0;
-  bool        newMatches       = true;
+  bool newMatches = true;
 
   while (newMatches) {
     newMatches = false;
     for (const auto [v, _] : diag.getVertices()) {
       if (check(diag, v)) {
         rule(diag, v);
         newMatches = true;
@@ -28,15 +28,15 @@
   return nSimplifications;
 }
 
 template <class EdgeCheckFun, class EdgeRuleFun>
 std::size_t simplifyEdges(ZXDiagram& diag, EdgeCheckFun check,
                           EdgeRuleFun rule) {
   std::size_t nSimplifications = 0;
-  bool        newMatches       = true;
+  bool newMatches = true;
 
   while (newMatches) {
     newMatches = false;
     for (const auto& [v0, v1] : diag.getEdges()) {
       if (diag.isDeleted(v0) || diag.isDeleted(v1) || !check(diag, v0, v1)) {
         continue;
       }
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/include/Utils.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/zx/Utils.hpp`

 * *Files 22% similar despite different names*

```diff
@@ -1,139 +1,149 @@
 #pragma once
 
-#include "Definitions.hpp"
-#include "Expression.hpp"
+#include "operations/Expression.hpp"
+#include "zx/Definitions.hpp"
 
 #include <cstdint>
 #include <iterator>
 #include <optional>
 #include <utility>
 #include <vector>
 
 namespace zx {
 
 struct Edge {
-  Vertex   to;
+  Vertex to;
   EdgeType type;
 
   Edge() = default;
   Edge(const Vertex t, const EdgeType typ) : to(t), type(typ){};
   void toggle() {
     if (type == EdgeType::Simple) {
       type = EdgeType::Hadamard;
     } else {
       type = EdgeType::Simple;
     }
   }
 };
 
 struct VertexData {
-  Col          col;
-  Qubit        qubit;
+  Col col;
+  Qubit qubit;
   PiExpression phase;
-  VertexType   type;
+  VertexType type;
 };
 
 class Vertices {
 public:
   explicit Vertices(const std::vector<std::optional<VertexData>>& verts)
       : vertices(verts){};
 
   class VertexIterator {
   public:
     using iterator_category = std::forward_iterator_tag;
-    using difference_type   = std::int32_t;
-    using value_type        = std::pair<Vertex, const VertexData&>;
-    using pointer           = value_type*;
-    using reference         = value_type&;
+    using difference_type = std::int32_t;
+    using value_type = std::pair<Vertex, const VertexData&>;
+    using pointer = value_type*;
+    using reference = value_type&;
 
     explicit VertexIterator(const std::vector<std::optional<VertexData>>& verts)
         : currentPos(verts.begin()), vertices(verts) {
       nextValidVertex();
     }
-    VertexIterator(const std::vector<std::optional<VertexData>>& vertices,
-                   Vertex                                        v);
+    VertexIterator(const std::vector<std::optional<VertexData>>& verts,
+                   Vertex vertex);
 
-    value_type operator*() const { return {v, currentPos->value()}; }
+    value_type operator*() const {
+      assert(currentPos->has_value());
+      // NOLINTNEXTLINE(bugprone-unchecked-optional-access)
+      return {v, currentPos->value()};
+    }
 
     // Prefix increment
     VertexIterator operator++();
 
     // Postfix increment
     VertexIterator operator++(int);
 
     friend bool operator==(const VertexIterator& a, const VertexIterator& b);
     friend bool operator!=(const VertexIterator& a, const VertexIterator& b);
 
   private:
-    Vertex                                                 v = 0;
+    Vertex v = 0;
     std::vector<std::optional<VertexData>>::const_iterator currentPos;
-    const std::vector<std::optional<VertexData>>&          vertices;
+    // NOLINTNEXTLINE(cppcoreguidelines-avoid-const-or-ref-data-members)
+    const std::vector<std::optional<VertexData>>& vertices;
 
     void nextValidVertex();
   };
 
   using iterator = VertexIterator;
 
   iterator begin() { return VertexIterator(vertices); }
   iterator end() { return {vertices, vertices.size()}; }
 
 private:
+  // NOLINTNEXTLINE(cppcoreguidelines-avoid-const-or-ref-data-members)
   const std::vector<std::optional<VertexData>>& vertices;
 };
 
 class Edges {
 public:
-  Edges(const std::vector<std::vector<Edge>>&         edgs,
+  Edges(const std::vector<std::vector<Edge>>& edgs,
         const std::vector<std::optional<VertexData>>& verts)
       : edges(edgs), vertices(verts){};
 
   class EdgeIterator {
   public:
     using iterator_category = std::forward_iterator_tag;
-    using difference_type   = std::int32_t;
-    using value_type        = std::pair<Vertex, Vertex>;
-    using pointer           = value_type*;
-    using reference         = value_type&;
-
-    EdgeIterator(const std::vector<std::vector<Edge>>&         edges,
-                 const std::vector<std::optional<VertexData>>& vertices);
-
-    EdgeIterator(const std::vector<std::vector<Edge>>&         edges,
-                 const std::vector<std::optional<VertexData>>& vertices,
-                 Vertex                                        v);
+    using difference_type = std::int32_t;
+    using value_type = std::pair<Vertex, Vertex>;
+    using pointer = value_type*;
+    using reference = value_type&;
+
+    EdgeIterator(const std::vector<std::vector<Edge>>& es,
+                 const std::vector<std::optional<VertexData>>& verts);
+
+    EdgeIterator(const std::vector<std::vector<Edge>>& es,
+                 const std::vector<std::optional<VertexData>>& verts,
+                 Vertex vertex);
 
     value_type operator*() const { return {v, currentPos->to}; }
 
     // Prefix increment
     EdgeIterator operator++();
 
     // Postfix increment
     EdgeIterator operator++(int);
 
     friend bool operator==(const EdgeIterator& a, const EdgeIterator& b);
     friend bool operator!=(const EdgeIterator& a, const EdgeIterator& b);
 
   private:
-    Vertex                                         v;
-    std::vector<Edge>::const_iterator              currentPos;
+    Vertex v;
+    std::vector<Edge>::const_iterator currentPos;
     std::vector<std::vector<Edge>>::const_iterator edgesPos;
-    const std::vector<std::vector<Edge>>&          edges;
-    const std::vector<std::optional<VertexData>>&  vertices;
+    // NOLINTNEXTLINE(cppcoreguidelines-avoid-const-or-ref-data-members)
+    const std::vector<std::vector<Edge>>& edges;
+    // NOLINTNEXTLINE(cppcoreguidelines-avoid-const-or-ref-data-members)
+    const std::vector<std::optional<VertexData>>& vertices;
 
     void checkNextVertex();
   };
 
   using iterator = EdgeIterator;
 
   iterator begin() { return {edges, vertices}; }
   iterator end() { return {edges, vertices, edges.size()}; }
 
 private:
-  const std::vector<std::vector<Edge>>&         edges;
+  // NOLINTNEXTLINE(cppcoreguidelines-avoid-const-or-ref-data-members)
+  const std::vector<std::vector<Edge>>& edges;
+  // NOLINTNEXTLINE(cppcoreguidelines-avoid-const-or-ref-data-members)
   const std::vector<std::optional<VertexData>>& vertices;
 };
 
 bool isPauli(const PiExpression& expr);
 bool isClifford(const PiExpression& expr);
 bool isProperClifford(const PiExpression& expr);
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/include/ZXDiagram.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/zx/ZXDiagram.hpp`

 * *Files 9% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 #pragma once
 
-#include "Definitions.hpp"
-#include "Expression.hpp"
-#include "Utils.hpp"
+#include "operations/Expression.hpp"
+#include "zx/Definitions.hpp"
+#include "zx/Utils.hpp"
 
 #include <cstddef>
 #include <optional>
 #include <string>
 #include <utility>
 #include <vector>
 
@@ -24,55 +24,61 @@
   void addEdgeParallelAware(Vertex from, Vertex to,
                             EdgeType eType = EdgeType::Simple);
   void removeEdge(Vertex from, Vertex to);
 
   Vertex addVertex(const VertexData& data);
   Vertex addVertex(Qubit qubit, Col col = 0,
                    const PiExpression& phase = PiExpression(),
-                   VertexType          type  = VertexType::Z);
-  void   addQubit();
-  void   addQubits(zx::Qubit n);
-  void   removeVertex(Vertex toRemove);
+                   VertexType type = VertexType::Z);
+  void addQubit();
+  void addQubits(zx::Qubit n);
+  void removeVertex(Vertex toRemove);
 
   [[nodiscard]] std::size_t getNdeleted() const { return deleted.size(); }
   [[nodiscard]] std::size_t getNVertices() const { return nvertices; }
   [[nodiscard]] std::size_t getNEdges() const { return nedges; }
   [[nodiscard]] std::size_t getNQubits() const { return inputs.size(); }
 
-  [[nodiscard]] bool                connected(Vertex from, Vertex to) const;
+  [[nodiscard]] bool connected(Vertex from, Vertex to) const;
   [[nodiscard]] std::optional<Edge> getEdge(Vertex from, Vertex to) const;
   [[nodiscard]] const std::vector<Edge>& incidentEdges(const Vertex v) const {
     return edges[v];
   }
   [[nodiscard]] const Edge& incidentEdge(const Vertex v, const std::size_t n) {
     return edges[v][n];
   }
 
   [[nodiscard]] std::size_t degree(const Vertex v) const {
     return edges[v].size();
   }
 
   [[nodiscard]] const PiExpression& phase(const Vertex v) const {
-    return vertices[v].value().phase;
+    const auto& vertex = vertices[v];
+    assert(vertex.has_value());
+    return vertex->phase; // NOLINT(bugprone-unchecked-optional-access)
   }
 
   [[nodiscard]] Qubit qubit(const Vertex v) const {
-    return vertices[v].value().qubit;
+    const auto& vertex = vertices[v];
+    assert(vertex.has_value());
+    return vertex->qubit; // NOLINT(bugprone-unchecked-optional-access)
   }
 
   [[nodiscard]] VertexType type(const Vertex v) const {
-    return vertices[v].value().type;
+    const auto& vertex = vertices[v];
+    assert(vertex.has_value());
+    return vertex->type; // NOLINT(bugprone-unchecked-optional-access)
   }
 
   [[nodiscard]] std::optional<VertexData> getVData(const Vertex v) const {
     return vertices[v];
   }
 
   [[nodiscard]] std::vector<std::pair<Vertex, const VertexData&>>
-                                                       getVertices() const;
+  getVertices() const;
   [[nodiscard]] std::vector<std::pair<Vertex, Vertex>> getEdges() const;
 
   [[nodiscard]] const std::vector<Vertex>& getInputs() const { return inputs; }
   [[nodiscard]] Vertex getInput(const std::size_t i) const { return inputs[i]; }
 
   [[nodiscard]] const std::vector<Vertex>& getOutputs() const {
     return outputs;
@@ -83,30 +89,39 @@
   }
 
   [[nodiscard]] bool isDeleted(const Vertex v) const {
     return !vertices[v].has_value();
   }
 
   [[nodiscard]] bool isBoundaryVertex(const Vertex v) const {
-    return vertices[v].value().type == VertexType::Boundary;
+    return type(v) == VertexType::Boundary;
   }
 
   [[nodiscard]] bool isInput(Vertex v) const;
   [[nodiscard]] bool isOutput(Vertex v) const;
 
   void addPhase(const Vertex v, const PiExpression& phase) {
-    vertices[v].value().phase += phase;
+    auto& vertex = vertices[v];
+    if (vertex.has_value()) {
+      vertex->phase += phase;
+    }
   }
 
   void setPhase(const Vertex v, const PiExpression& phase) {
-    vertices[v].value().phase = phase;
+    auto& vertex = vertices[v];
+    if (vertex.has_value()) {
+      vertex->phase = phase;
+    }
   }
 
   void setType(const Vertex v, const VertexType type) {
-    vertices[v].value().type = type;
+    auto& vertex = vertices[v];
+    if (vertex.has_value()) {
+      vertex->type = type;
+    }
   }
 
   void toGraphlike();
 
   [[nodiscard]] bool isIdentity() const;
 
   [[nodiscard]] ZXDiagram adjoint() const;
@@ -119,34 +134,34 @@
   void makeAncilla(Qubit qubit);
   void makeAncilla(Qubit in, Qubit out);
 
   void approximateCliffords(fp tolerance);
 
   void removeDisconnectedSpiders();
 
-  void                       addGlobalPhase(const PiExpression& phase);
+  void addGlobalPhase(const PiExpression& phase);
   [[nodiscard]] PiExpression getGlobalPhase() const { return globalPhase; }
   [[nodiscard]] bool globalPhaseIsZero() const { return globalPhase.isZero(); }
   [[nodiscard]] gf2Mat getAdjMat() const;
   [[nodiscard]] std::vector<Vertex>
-              getConnectedSet(const std::vector<Vertex>& s,
-                              const std::vector<Vertex>& exclude = {}) const;
+  getConnectedSet(const std::vector<Vertex>& s,
+                  const std::vector<Vertex>& exclude = {}) const;
   static bool isIn(const Vertex& v, const std::vector<Vertex>& vertices);
 
 private:
-  std::vector<std::vector<Edge>>         edges;
+  std::vector<std::vector<Edge>> edges;
   std::vector<std::optional<VertexData>> vertices;
-  std::vector<Vertex>                    deleted;
-  std::vector<Vertex>                    inputs;
-  std::vector<Vertex>                    outputs;
-  std::size_t                            nvertices   = 0;
-  std::size_t                            nedges      = 0;
-  PiExpression                           globalPhase = {};
+  std::vector<Vertex> deleted;
+  std::vector<Vertex> inputs;
+  std::vector<Vertex> outputs;
+  std::size_t nvertices = 0;
+  std::size_t nedges = 0;
+  PiExpression globalPhase = {};
 
   std::vector<Vertex> initGraph(std::size_t nqubits);
-  void                closeGraph(const std::vector<Vertex>& qubitVertices);
+  void closeGraph(const std::vector<Vertex>& qubitVertices);
 
   void removeHalfEdge(Vertex from, Vertex to);
 
   std::vector<Edge>::iterator getEdgePtr(Vertex from, Vertex to);
 };
 } // namespace zx
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/src/Rational.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/zx/Rational.cpp`

 * *Files 4% similar despite different names*

```diff
@@ -1,23 +1,23 @@
-#include "Rational.hpp"
+#include "zx/Rational.hpp"
 
-#include "Definitions.hpp"
+#include "zx/Definitions.hpp"
 
 namespace zx {
 
 PiRational::PiRational(double val) {
   if (std::abs(val) < PARAMETER_TOLERANCE) {
     return;
   }
 
-  const double multPi  = PI / val;
+  const double multPi = PI / val;
   const double nearest = std::round(multPi);
   if (std::abs(nearest - multPi) < PARAMETER_TOLERANCE) {
     auto denom = static_cast<int>(nearest);
-    frac       = Rational(1, denom);
+    frac = Rational(1, denom);
     modPi();
     return;
   }
 
   val /= PI;
   val -= 2 * static_cast<int>(val / 2);
   if (val > 1) {
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/src/Rules.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/zx/Rules.cpp`

 * *Files 3% similar despite different names*

```diff
@@ -1,28 +1,91 @@
-#include "Rules.hpp"
+#include "zx/Rules.hpp"
 
-#include "Definitions.hpp"
-#include "Rational.hpp"
-#include "Utils.hpp"
-#include "ZXDiagram.hpp"
+#include "zx/Definitions.hpp"
+#include "zx/Rational.hpp"
+#include "zx/Utils.hpp"
+#include "zx/ZXDiagram.hpp"
 
 #include <algorithm>
 #include <cstddef>
 #include <optional>
 
 namespace zx {
+
+namespace {
+bool isPauli(const ZXDiagram& diag, const Vertex v) {
+  return isPauli(diag.phase(v));
+}
+
+bool isInterior(const ZXDiagram& diag, const Vertex v) {
+  const auto& edges = diag.incidentEdges(v);
+  return std::all_of(edges.begin(), edges.end(), [&](auto& edge) {
+    return diag.degree(edge.to) > 1 && diag.type(edge.to) == VertexType::Z;
+  });
+}
+
+void extractGadget(ZXDiagram& diag, const Vertex v) {
+  const auto& vData = diag.getVData(v);
+  if (!vData.has_value()) {
+    return;
+  }
+  const Vertex phaseVert = diag.addVertex(vData->qubit, -2, vData->phase);
+  const Vertex idVert = diag.addVertex(vData->qubit, -1);
+  diag.setPhase(v, PiExpression(PiRational(0, 1)));
+  diag.addHadamardEdge(v, idVert);
+  diag.addHadamardEdge(idVert, phaseVert);
+}
+
+void extractPauliGadget(ZXDiagram& diag, const Vertex v) {
+  if (isPauli(diag.phase(v))) {
+    return;
+  }
+
+  extractGadget(diag, v);
+}
+
+void ensureInterior(ZXDiagram& diag, const Vertex v) {
+  const auto edges = diag.incidentEdges(v);
+  const auto& vData = diag.getVData(v);
+  if (!vData.has_value()) {
+    return;
+  }
+
+  for (const auto& [to, type] : edges) {
+    if (!diag.isBoundaryVertex(to)) {
+      continue;
+    }
+
+    const Vertex newV = diag.addVertex(vData->qubit, vData->col,
+                                       PiExpression(PiRational(0, 1)));
+    const auto boundaryEdgeType = type == zx::EdgeType::Simple
+                                      ? zx::EdgeType::Hadamard
+                                      : zx::EdgeType::Simple;
+
+    diag.addEdge(v, newV, EdgeType::Hadamard);
+    diag.addEdge(to, newV, boundaryEdgeType);
+    diag.removeEdge(v, to);
+  }
+}
+
+void ensurePauliVertex(ZXDiagram& diag, const Vertex v) {
+  extractPauliGadget(diag, v);
+  ensureInterior(diag, v);
+}
+} // namespace
+
 bool checkIdSimp(const ZXDiagram& diag, const Vertex v) {
   return diag.degree(v) == 2 && diag.phase(v).isZero() &&
          !diag.isBoundaryVertex(v);
 }
 
 void removeId(ZXDiagram& diag, const Vertex v) {
-  auto         edges = diag.incidentEdges(v);
-  const Vertex v0    = edges[0].to;
-  const Vertex v1    = edges[1].to;
+  auto edges = diag.incidentEdges(v);
+  const Vertex v0 = edges[0].to;
+  const Vertex v1 = edges[1].to;
 
   EdgeType type = EdgeType::Simple;
   if (edges[0].type != edges[1].type) {
     type = EdgeType::Hadamard;
   }
   diag.addEdgeParallelAware(v0, v1, type);
   diag.removeVertex(v);
@@ -58,35 +121,31 @@
   return std::all_of(edges.begin(), edges.end(), [&](auto& edge) {
     return edge.type == EdgeType::Hadamard &&
            diag.type(edge.to) == VertexType::Z;
   });
 }
 
 void localComp(ZXDiagram& diag, const Vertex v) { // TODO:scalars
-  const auto  phase  = -diag.phase(v);
-  const auto& edges  = diag.incidentEdges(v);
-  const auto  nedges = edges.size();
+  const auto phase = -diag.phase(v);
+  const auto& edges = diag.incidentEdges(v);
+  const auto nedges = edges.size();
 
   for (std::size_t i = 0U; i < nedges; ++i) {
     const auto& [n0, _] = edges[i];
     diag.addPhase(n0, phase);
     for (size_t j = i + 1; j < nedges; ++j) {
       const auto& [n1, _u] = edges[j];
       diag.addEdgeParallelAware(n0, n1, EdgeType::Hadamard);
     }
   }
   diag.addGlobalPhase(
       PiExpression(PiRational{diag.phase(v).getConst().getNum(), 4}));
   diag.removeVertex(v);
 }
 
-static bool isPauli(const ZXDiagram& diag, const Vertex v) {
-  return isPauli(diag.phase(v));
-}
-
 bool checkPivotPauli(const ZXDiagram& diag, const Vertex v0, const Vertex v1) {
   const auto v0Data = diag.getVData(v0).value_or(
       VertexData{0, 0, PiExpression(), VertexType::X});
   const auto v1Data = diag.getVData(v0).value_or(
       VertexData{0, 0, PiExpression(), VertexType::X});
 
   if (v0Data.type != VertexType::Z || // maybe problem if there is a self-loop?
@@ -96,16 +155,16 @@
   }
 
   const auto edgeOpt = diag.getEdge(v0, v1);
   if (!edgeOpt.has_value() || edgeOpt.value().type != EdgeType::Hadamard) {
     return false;
   }
 
-  const auto& v0Edges     = diag.incidentEdges(v0);
-  auto        isValidEdge = [&](const Edge& e) {
+  const auto& v0Edges = diag.incidentEdges(v0);
+  auto isValidEdge = [&](const Edge& e) {
     return diag.type(e.to) == VertexType::Z && e.type == EdgeType::Hadamard;
   };
 
   if (!std::all_of(v0Edges.begin(), v0Edges.end(), isValidEdge)) {
     return false;
   }
 
@@ -129,54 +188,47 @@
 
   for (const auto& [neighbor_v0, _] : v0Edges) {
     if (neighbor_v0 == v1) {
       continue;
     }
 
     diag.addPhase(neighbor_v0, v1Phase);
-    for (const auto& [neighbor_v1, _] : v1Edges) {
+    for (const auto& [neighbor_v1, type] : v1Edges) {
       if (neighbor_v1 != v0) {
         diag.addEdgeParallelAware(neighbor_v0, neighbor_v1, EdgeType::Hadamard);
       }
     }
   }
 
   for (const auto& [neighbor_v1, _] : v1Edges) {
     diag.addPhase(neighbor_v1, v0Phase);
   }
 
   diag.removeVertex(v0);
   diag.removeVertex(v1);
 }
 
-static bool isInterior(const ZXDiagram& diag, const Vertex v) {
-  const auto& edges = diag.incidentEdges(v);
-  return std::all_of(edges.begin(), edges.end(), [&](auto& edge) {
-    return diag.degree(edge.to) > 1 && diag.type(edge.to) == VertexType::Z;
-  });
-}
-
 bool checkPivot(const ZXDiagram& diag, const Vertex v0, const Vertex v1) {
   const auto v0Type = diag.type(v0);
   const auto v1Type = diag.type(v1);
 
   if (v0 == v1 || v0Type != VertexType::Z || v1Type != VertexType::Z) {
     return false;
   }
 
   const auto edgeOpt = diag.getEdge(v0, v1);
   if (!edgeOpt.has_value() || edgeOpt.value().type != EdgeType::Hadamard) {
     return false;
   }
 
-  const auto& v0Edges       = diag.incidentEdges(v0);
-  const auto  isInvalidEdge = [&](const Edge& e) {
+  const auto& v0Edges = diag.incidentEdges(v0);
+  const auto isInvalidEdge = [&](const Edge& e) {
     const auto toType = diag.type(e.to);
-    return !((toType == VertexType::Z && e.type == EdgeType::Hadamard) ||
-             toType == VertexType::Boundary);
+    return (toType != VertexType::Z || e.type != EdgeType::Hadamard) &&
+           toType != VertexType::Boundary;
   };
 
   if (std::any_of(v0Edges.begin(), v0Edges.end(), isInvalidEdge)) {
     return false;
   }
 
   const auto& v1Edges = diag.incidentEdges(v1);
@@ -187,57 +239,14 @@
   auto isInteriorPauli = [&](const Vertex v) {
     return isInterior(diag, v) && isPauli(diag, v);
   };
 
   return (isInteriorPauli(v0) || isInteriorPauli(v1));
 }
 
-static void extractGadget(ZXDiagram& diag, const Vertex v) {
-  const auto   vData     = diag.getVData(v).value();
-  const Vertex phaseVert = diag.addVertex(vData.qubit, -2, vData.phase);
-  const Vertex idVert    = diag.addVertex(vData.qubit, -1);
-  diag.setPhase(v, PiExpression(PiRational(0, 1)));
-  diag.addHadamardEdge(v, idVert);
-  diag.addHadamardEdge(idVert, phaseVert);
-}
-
-static void extractPauliGadget(ZXDiagram& diag, const Vertex v) {
-  if (isPauli(diag.phase(v))) {
-    return;
-  }
-
-  extractGadget(diag, v);
-}
-
-static void ensureInterior(ZXDiagram& diag, const Vertex v) {
-  const auto edges = diag.incidentEdges(v);
-  const auto vData = diag.getVData(v).value();
-
-  for (const auto& [to, type] : edges) {
-    if (!diag.isBoundaryVertex(to)) {
-      continue;
-    }
-
-    const Vertex newV =
-        diag.addVertex(vData.qubit, vData.col, PiExpression(PiRational(0, 1)));
-    const auto boundaryEdgeType = type == zx::EdgeType::Simple
-                                      ? zx::EdgeType::Hadamard
-                                      : zx::EdgeType::Simple;
-
-    diag.addEdge(v, newV, EdgeType::Hadamard);
-    diag.addEdge(to, newV, boundaryEdgeType);
-    diag.removeEdge(v, to);
-  }
-}
-
-static void ensurePauliVertex(ZXDiagram& diag, const Vertex v) {
-  extractPauliGadget(diag, v);
-  ensureInterior(diag, v);
-}
-
 void pivot(ZXDiagram& diag, const Vertex v0, const Vertex v1) {
   ensurePauliVertex(diag, v0);
   ensurePauliVertex(diag, v1);
 
   pivotPauli(diag, v0, v1);
 }
 
@@ -268,15 +277,15 @@
 }
 
 bool checkAndFuseGadget(ZXDiagram& diag, const Vertex v) {
   if (diag.degree(v) != 1 || diag.isBoundaryVertex(v)) {
     return false;
   }
 
-  const auto id0      = diag.incidentEdges(v)[0].to;
+  const auto id0 = diag.incidentEdges(v)[0].to;
   const auto id0Etype = diag.incidentEdges(v)[0].type;
   if (!isPauli(diag, id0) || diag.degree(id0) < 2 ||
       id0Etype != zx::EdgeType::Hadamard) {
     return false;
   }
 
   if (diag.degree(id0) == 2) {
@@ -321,15 +330,15 @@
     if (etype != zx::EdgeType::Hadamard || diag.isDeleted(n) ||
         !isPauli(diag.phase(n)) || diag.degree(n) != diag.degree(id0) ||
         diag.connected(n, id0)) {
       continue;
     }
 
     foundGadget = true;
-    id1         = n;
+    id1 = n;
 
     for (const auto& [nn, nnEtype] :
          diag.incidentEdges(id1.value())) { // Todo: maybe problem with parallel
                                             // edge? There shouldn't be any
       if (nnEtype != zx::EdgeType::Hadamard || diag.isDeleted(nn)) {
         // not a phase gadget
         foundGadget = false;
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/src/Simplify.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/zx/Simplify.cpp`

 * *Files 14% similar despite different names*

```diff
@@ -1,20 +1,19 @@
-#include "Simplify.hpp"
+#include "zx/Simplify.hpp"
 
-#include "Definitions.hpp"
-#include "Rules.hpp"
-#include "ZXDiagram.hpp"
+#include "zx/Rules.hpp"
+#include "zx/ZXDiagram.hpp"
 
 #include <utility>
 
 namespace zx {
 
 std::size_t gadgetSimp(ZXDiagram& diag) {
   std::size_t nSimplifications = 0;
-  bool        newMatches       = true;
+  bool newMatches = true;
 
   while (newMatches) {
     newMatches = false;
     for (auto [v, _] : diag.getVertices()) {
       if (diag.isDeleted(v)) {
         continue;
       }
@@ -47,38 +46,38 @@
 std::size_t pivotSimp(ZXDiagram& diag) {
   return simplifyEdges(diag, checkPivot, pivot);
 }
 
 std::size_t interiorCliffordSimp(ZXDiagram& diag) {
   spiderSimp(diag);
 
-  bool        newMatches       = true;
+  bool newMatches = true;
   std::size_t nSimplifications = 0;
   while (newMatches) {
-    newMatches            = false;
-    const auto nId        = idSimp(diag);
-    const auto nSpider    = spiderSimp(diag);
-    const auto nPivot     = pivotPauliSimp(diag);
+    newMatches = false;
+    const auto nId = idSimp(diag);
+    const auto nSpider = spiderSimp(diag);
+    const auto nPivot = pivotPauliSimp(diag);
     const auto nLocalComp = localCompSimp(diag);
 
     if ((nId + nSpider + nPivot + nLocalComp) != 0) {
       newMatches = true;
       nSimplifications++;
     }
   }
   return nSimplifications;
 }
 
 std::size_t cliffordSimp(ZXDiagram& diag) {
-  bool        newMatches       = true;
+  bool newMatches = true;
   std::size_t nSimplifications = 0;
   while (newMatches) {
-    newMatches           = false;
+    newMatches = false;
     const auto nClifford = interiorCliffordSimp(diag);
-    const auto nPivot    = pivotSimp(diag);
+    const auto nPivot = pivotSimp(diag);
     if ((nClifford + nPivot) != 0) {
       newMatches = true;
       nSimplifications++;
     }
   }
   return nSimplifications;
 }
@@ -104,17 +103,19 @@
   }
   diag.removeDisconnectedSpiders();
 
   return nSimplifications;
 }
 
 std::size_t fullReduceApproximate(ZXDiagram& diag, const fp tolerance) {
-  auto        nSimplifications = fullReduce(diag);
-  std::size_t newSimps         = 0;
-  do {
+  auto nSimplifications = fullReduce(diag);
+  while (true) {
     diag.approximateCliffords(tolerance);
-    newSimps = fullReduce(diag);
+    const auto newSimps = fullReduce(diag);
+    if (newSimps == 0U) {
+      break;
+    }
     nSimplifications += newSimps;
-  } while (newSimps != 0U);
+  }
   return nSimplifications;
 }
 } // namespace zx
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/src/Utils.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/zx/Utils.cpp`

 * *Files 3% similar despite different names*

```diff
@@ -1,18 +1,18 @@
-#include "Utils.hpp"
+#include "zx/Utils.hpp"
 
 #include <cstddef>
 
 namespace zx {
 Vertices::VertexIterator::VertexIterator(
-    const std::vector<std::optional<VertexData>>& vertices, const Vertex v)
-    : v(v), currentPos(vertices.begin()), vertices(vertices) {
+    const std::vector<std::optional<VertexData>>& verts, const Vertex vertex)
+    : v(vertex), currentPos(verts.begin()), vertices(verts) {
   if (v >= vertices.size()) {
     currentPos = vertices.end();
-    this->v    = vertices.size();
+    v = vertices.size();
   } else {
     currentPos = vertices.begin() + static_cast<int>(v);
     nextValidVertex();
   }
 }
 // Prefix increment
 Vertices::VertexIterator Vertices::VertexIterator::operator++() {
@@ -44,43 +44,43 @@
   while (currentPos != vertices.end() && !currentPos->has_value()) {
     ++v;
     ++currentPos;
   }
 }
 
 Edges::EdgeIterator::EdgeIterator(
-    const std::vector<std::vector<Edge>>&         edges,
-    const std::vector<std::optional<VertexData>>& vertices)
-    : v(0), currentPos(edges[0].begin()), edgesPos(edges.begin()), edges(edges),
-      vertices(vertices) {
+    const std::vector<std::vector<Edge>>& es,
+    const std::vector<std::optional<VertexData>>& verts)
+    : v(0), currentPos(es[0].begin()), edgesPos(es.begin()), edges(es),
+      vertices(verts) {
   if (!vertices.empty()) {
     while (v < edges.size() && !vertices[v].has_value()) {
       ++v;
     }
     currentPos = edges[v].begin();
-    edgesPos   = edges.begin() + static_cast<int>(v);
+    edgesPos = edges.begin() + static_cast<int>(v);
     checkNextVertex();
   } else {
     currentPos = edges.back().end();
-    edgesPos   = edges.end();
-    v          = edges.size();
+    edgesPos = edges.end();
+    v = edges.size();
   }
 }
 
 Edges::EdgeIterator::EdgeIterator(
-    const std::vector<std::vector<Edge>>&         edges,
-    const std::vector<std::optional<VertexData>>& vertices, const Vertex v)
-    : v(v), edges(edges), vertices(vertices) {
+    const std::vector<std::vector<Edge>>& es,
+    const std::vector<std::optional<VertexData>>& verts, const Vertex vertex)
+    : v(vertex), edges(es), vertices(verts) {
   if (v >= edges.size()) {
     currentPos = edges.back().end();
-    edgesPos   = edges.end();
-    this->v    = edges.size();
+    edgesPos = edges.end();
+    this->v = edges.size();
   } else {
     currentPos = edges[v].begin();
-    edgesPos   = edges.begin() + static_cast<int>(v);
+    edgesPos = edges.begin() + static_cast<int>(v);
   }
 }
 
 // Prefix increment
 Edges::EdgeIterator Edges::EdgeIterator::operator++() {
   Edges::EdgeIterator it = *this;
   currentPos++;
@@ -98,20 +98,20 @@
     ++v;
     while (v < edges.size() && !vertices[v].has_value()) {
       ++v;
     }
 
     if (v == edges.size()) {
       currentPos = edges.back().end();
-      edgesPos   = edges.end();
+      edgesPos = edges.end();
       --v;
       return;
     }
     currentPos = edges[v].begin();
-    edgesPos   = edges.begin() + static_cast<int>(v);
+    edgesPos = edges.begin() + static_cast<int>(v);
     while (currentPos != edges[v].end() &&
            currentPos->to < v) { // make sure to not iterate over an edge twice
       ++currentPos;
     }
   }
 }
 // Postfix increment
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/extern/zx/src/ZXDiagram.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/zx/ZXDiagram.cpp`

 * *Files 5% similar despite different names*

```diff
@@ -1,13 +1,13 @@
-#include "ZXDiagram.hpp"
+#include "zx/ZXDiagram.hpp"
 
-#include "Definitions.hpp"
-#include "Expression.hpp"
-#include "Rational.hpp"
-#include "Utils.hpp"
+#include "operations/Expression.hpp"
+#include "zx/Definitions.hpp"
+#include "zx/Rational.hpp"
+#include "zx/Utils.hpp"
 
 #include <algorithm>
 #include <unordered_map>
 #include <unordered_set>
 
 namespace zx {
 
@@ -104,16 +104,16 @@
 
 Vertex ZXDiagram::addVertex(const Qubit qubit, const Col col,
                             const PiExpression& phase, const VertexType type) {
   return addVertex({col, qubit, phase, type});
 }
 
 void ZXDiagram::addQubit() {
-  auto in  = addVertex(static_cast<zx::Qubit>(getNQubits()) + 1, 0,
-                       PiExpression(), VertexType::Boundary);
+  auto in = addVertex(static_cast<zx::Qubit>(getNQubits()) + 1, 0,
+                      PiExpression(), VertexType::Boundary);
   auto out = addVertex(static_cast<zx::Qubit>(getNQubits()) + 1, 0,
                        PiExpression(), VertexType::Boundary);
   inputs.emplace_back(in);
   outputs.emplace_back(out);
 }
 void ZXDiagram::addQubits(const Qubit n) {
   for (zx::Qubit i = 0; i < n; ++i) {
@@ -135,36 +135,36 @@
 [[nodiscard]] bool ZXDiagram::connected(const Vertex from,
                                         const Vertex to) const {
   if (isDeleted(from) || isDeleted(to)) {
     return false;
   }
 
   const auto& incident = edges[from];
-  const auto  edge     = std::find_if(incident.begin(), incident.end(),
-                                      [&](const auto& e) { return e.to == to; });
+  const auto edge = std::find_if(incident.begin(), incident.end(),
+                                 [&](const auto& e) { return e.to == to; });
   return edge != incident.end();
 }
 
 [[nodiscard]] std::optional<Edge> ZXDiagram::getEdge(const Vertex from,
                                                      const Vertex to) const {
   std::optional<Edge> ret;
-  const auto&         incident = edges[from];
-  const auto          edge     = std::find_if(incident.begin(), incident.end(),
-                                              [&](const auto& e) { return e.to == to; });
+  const auto& incident = edges[from];
+  const auto edge = std::find_if(incident.begin(), incident.end(),
+                                 [&](const auto& e) { return e.to == to; });
   if (edge != incident.end()) {
     ret = *edge;
   }
   return ret;
 }
 
 std::vector<Edge>::iterator ZXDiagram::getEdgePtr(const Vertex from,
                                                   const Vertex to) {
   auto& incident = edges[from];
-  auto  edge     = std::find_if(incident.begin(), incident.end(),
-                                [&](const auto& e) { return e.to == to; });
+  auto edge = std::find_if(incident.begin(), incident.end(),
+                           [&](const auto& e) { return e.to == to; });
   return edge;
 }
 
 [[nodiscard]] std::vector<std::pair<Vertex, const VertexData&>>
 ZXDiagram::getVertices() const {
   Vertices verts(vertices);
 
@@ -183,39 +183,40 @@
 bool ZXDiagram::isOutput(const Vertex v) const {
   return std::find(outputs.begin(), outputs.end(), v) != outputs.end();
 }
 
 void ZXDiagram::toGraphlike() {
   const auto nverts = vertices.size();
   for (Vertex v = 0U; v < nverts; ++v) {
-    if (!vertices[v].has_value()) {
+    auto& vertex = vertices[v];
+    if (!vertex.has_value()) {
       continue;
     }
-    if (vertices[v].value().type == VertexType::X) {
+    if (vertex.value().type == VertexType::X) {
       for (auto& edge : edges[v]) {
         edge.toggle();
         // toggle corresponding edge in other direction
         getEdgePtr(edge.to, v)->toggle();
       }
 
-      vertices[v].value().type = VertexType::Z;
+      vertex.value().type = VertexType::Z;
     }
   }
 }
 
 [[nodiscard]] ZXDiagram ZXDiagram::adjoint() const {
   ZXDiagram copy = *this;
   copy.invert();
   return copy;
 }
 
 ZXDiagram& ZXDiagram::invert() {
   const auto h = inputs;
-  inputs       = outputs;
-  outputs      = h;
+  inputs = outputs;
+  outputs = h;
 
   for (auto& data : vertices) {
     if (data.has_value()) {
       data.value().phase = -data.value().phase;
     }
   }
   return *this;
@@ -224,36 +225,37 @@
 ZXDiagram& ZXDiagram::concat(const ZXDiagram& rhs) {
   if (rhs.getNQubits() != this->getNQubits()) {
     throw ZXException(
         "Cannot concatenate Diagrams with differing number of qubits!");
   }
 
   std::unordered_map<Vertex, Vertex> newVs;
-  const auto                         nverts = rhs.vertices.size();
+  const auto nverts = rhs.vertices.size();
   for (std::size_t i = 0; i < nverts; ++i) {
-    if (!rhs.vertices[i].has_value() || rhs.isInput(i)) {
+    const auto& vertex = rhs.vertices[i];
+    if (!vertex.has_value() || rhs.isInput(i)) {
       continue;
     }
 
-    const auto newV = addVertex(rhs.vertices[i].value());
-    newVs[i]        = newV;
+    const auto newV = addVertex(vertex.value());
+    newVs[i] = newV;
   }
 
   for (std::size_t i = 0; i < nverts; ++i) { // add new edges
     if (!rhs.vertices[i].has_value() || rhs.isInput(i)) {
       continue;
     }
 
     for (const auto& [to, type] : rhs.edges[i]) {
       if (!rhs.isInput(to)) {
         if (i < to) { // make sure not to add edge twice
           addEdge(newVs[i], newVs[to], type);
         }
       } else {
-        const auto outV = outputs[rhs.qubit(to)];
+        const auto outV = outputs[static_cast<std::size_t>(rhs.qubit(to))];
         for (const auto& [interior_v, interior_type] :
              edges[outV]) { // redirect edges going to outputs
           if (interior_type == type) {
             addEdge(interior_v, newVs[i], EdgeType::Simple);
           } else {
             addEdge(interior_v, newVs[i], EdgeType::Hadamard);
           }
@@ -298,28 +300,31 @@
   }
 
   return qubitVertices;
 }
 
 void ZXDiagram::closeGraph(const std::vector<Vertex>& qubitVertices) {
   for (const Vertex v : qubitVertices) {
-    const VertexData vData = vertices[v].value();
+    const auto& vData = vertices[v];
+    if (!vData.has_value()) {
+      continue;
+    }
 
     const Vertex newV = addVertex(
-        {vData.col + 1, vData.qubit, PiExpression(), VertexType::Boundary});
+        {vData->col + 1, vData->qubit, PiExpression(), VertexType::Boundary});
     addEdge(v, newV);
     outputs.push_back(newV);
   }
 }
 
 void ZXDiagram::makeAncilla(const Qubit qubit) { makeAncilla(qubit, qubit); }
 
 void ZXDiagram::makeAncilla(const Qubit in, const Qubit out) {
-  const auto inV  = inputs[in];
-  const auto outV = outputs[out];
+  const auto inV = inputs[static_cast<std::size_t>(in)];
+  const auto outV = outputs[static_cast<std::size_t>(out)];
   inputs.erase(inputs.begin() + in);
   outputs.erase(outputs.begin() + out);
 
   setType(inV, VertexType::X);
   setType(outV, VertexType::X);
 }
 
@@ -328,17 +333,17 @@
     if (v.has_value()) {
       roundToClifford(v.value().phase, tolerance);
     }
   }
 }
 
 void ZXDiagram::removeDisconnectedSpiders() {
-  auto connectedToBoundary = [&](const Vertex v) {
+  auto connectedToBoundary = [this](const Vertex v) {
     std::unordered_set<Vertex> visited{};
-    std::vector<Vertex>        stack{};
+    std::vector<Vertex> stack{};
     stack.push_back(v);
 
     while (!stack.empty()) {
       auto w = stack.back();
       stack.pop_back();
 
       if (visited.find(w) != visited.end()) {
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/include/CircuitOptimizer.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/CircuitOptimizer.hpp`

 * *Files 5% similar despite different names*

```diff
@@ -1,69 +1,80 @@
-/*
- * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
- */
-
 #pragma once
 
 #include "Definitions.hpp"
 #include "QuantumComputation.hpp"
 #include "operations/Operation.hpp"
 
 #include <array>
 #include <memory>
 
 namespace qc {
-    static constexpr std::array<qc::OpType, 8> DIAGONAL_GATES = {qc::I, qc::Z, qc::S, qc::Sdag, qc::T, qc::Tdag, qc::Phase, qc::RZ};
+static constexpr std::array<qc::OpType, 8> DIAGONAL_GATES = {
+    qc::I, qc::Z, qc::S, qc::Sdag, qc::T, qc::Tdag, qc::Phase, qc::RZ};
 
-    class CircuitOptimizer {
-    protected:
-        static void addToDag(DAG& dag, std::unique_ptr<Operation>* op);
-        static void addNonStandardOperationToDag(DAG& dag, std::unique_ptr<Operation>* op);
+class CircuitOptimizer {
+protected:
+  static void addToDag(DAG& dag, std::unique_ptr<Operation>* op);
+  static void addNonStandardOperationToDag(DAG& dag,
+                                           std::unique_ptr<Operation>* op);
 
-    public:
-        CircuitOptimizer() = default;
+public:
+  CircuitOptimizer() = default;
 
-        static DAG  constructDAG(QuantumComputation& qc);
-        static void printDAG(const DAG& dag);
-        static void printDAG(const DAG& dag, const DAGIterators& iterators);
+  static DAG constructDAG(QuantumComputation& qc);
+  static void printDAG(const DAG& dag);
+  static void printDAG(const DAG& dag, const DAGIterators& iterators);
 
-        static void swapReconstruction(QuantumComputation& qc);
+  static void swapReconstruction(QuantumComputation& qc);
 
-        static void singleQubitGateFusion(QuantumComputation& qc);
+  static void singleQubitGateFusion(QuantumComputation& qc);
 
-        static void removeIdentities(QuantumComputation& qc);
+  static void removeIdentities(QuantumComputation& qc);
 
-        static void removeDiagonalGatesBeforeMeasure(QuantumComputation& qc);
+  static void removeDiagonalGatesBeforeMeasure(QuantumComputation& qc);
 
-        static void removeFinalMeasurements(QuantumComputation& qc);
+  static void removeFinalMeasurements(QuantumComputation& qc);
 
-        static void decomposeSWAP(QuantumComputation& qc, bool isDirectedArchitecture);
+  static void decomposeSWAP(QuantumComputation& qc,
+                            bool isDirectedArchitecture);
 
-        static void decomposeTeleport(QuantumComputation& qc);
+  static void decomposeTeleport(QuantumComputation& qc);
 
-        static void eliminateResets(QuantumComputation& qc);
+  static void eliminateResets(QuantumComputation& qc);
 
-        static void deferMeasurements(QuantumComputation& qc);
+  static void deferMeasurements(QuantumComputation& qc);
 
-        static bool isDynamicCircuit(QuantumComputation& qc);
+  static bool isDynamicCircuit(QuantumComputation& qc);
 
-        static void reorderOperations(QuantumComputation& qc);
+  static void reorderOperations(QuantumComputation& qc);
 
-        static void flattenOperations(QuantumComputation& qc);
+  static void flattenOperations(QuantumComputation& qc);
 
-        static void cancelCNOTs(QuantumComputation& qc);
+  static void cancelCNOTs(QuantumComputation& qc);
 
-    protected:
-        static void removeDiagonalGatesBeforeMeasureRecursive(DAG& dag, DAGReverseIterators& dagIterators, Qubit idx, const DAGReverseIterator& until);
-        static bool removeDiagonalGate(DAG& dag, DAGReverseIterators& dagIterators, Qubit idx, DAGReverseIterator& it, qc::Operation* op);
+protected:
+  static void removeDiagonalGatesBeforeMeasureRecursive(
+      DAG& dag, DAGReverseIterators& dagIterators, Qubit idx,
+      const DAGReverseIterator& until);
+  static bool removeDiagonalGate(DAG& dag, DAGReverseIterators& dagIterators,
+                                 Qubit idx, DAGReverseIterator& it,
+                                 qc::Operation* op);
 
-        static void removeFinalMeasurementsRecursive(DAG& dag, DAGReverseIterators& dagIterators, Qubit idx, const DAGReverseIterator& until);
-        static bool removeFinalMeasurement(DAG& dag, DAGReverseIterators& dagIterators, Qubit idx, DAGReverseIterator& it, qc::Operation* op);
+  static void
+  removeFinalMeasurementsRecursive(DAG& dag, DAGReverseIterators& dagIterators,
+                                   Qubit idx, const DAGReverseIterator& until);
+  static bool removeFinalMeasurement(DAG& dag,
+                                     DAGReverseIterators& dagIterators,
+                                     Qubit idx, DAGReverseIterator& it,
+                                     qc::Operation* op);
 
-        static void changeTargets(Targets& targets, const std::map<Qubit, Qubit>& replacementMap);
-        static void changeControls(Controls& controls, const std::map<Qubit, Qubit>& replacementMap);
+  static void changeTargets(Targets& targets,
+                            const std::map<Qubit, Qubit>& replacementMap);
+  static void changeControls(Controls& controls,
+                             const std::map<Qubit, Qubit>& replacementMap);
 
-        using Iterator = decltype(qc::QuantumComputation::ops.begin());
-        static Iterator flattenCompoundOperation(std::vector<std::unique_ptr<Operation>>& ops, Iterator it);
-    };
+  using Iterator = decltype(qc::QuantumComputation::ops.begin());
+  static Iterator
+  flattenCompoundOperation(std::vector<std::unique_ptr<Operation>>& ops,
+                           Iterator it);
+};
 } // namespace qc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/include/Definitions.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/Definitions.hpp`

 * *Files 14% similar despite different names*

```diff
@@ -1,79 +1,71 @@
-/*
- * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
- */
-
 #pragma once
 
-#include "Expression.hpp"
+#include "operations/Expression.hpp"
 
 #include <bitset>
 #include <deque>
 #include <map>
 #include <memory>
 #include <utility>
 #include <variant>
 #include <vector>
 
 namespace qc {
-    class QFRException: public std::invalid_argument {
-        std::string msg;
+class QFRException : public std::invalid_argument {
+  std::string msg;
 
-    public:
-        explicit QFRException(std::string m):
-            std::invalid_argument("QFR Exception"), msg(std::move(m)) {}
-
-        [[nodiscard]] const char* what() const noexcept override {
-            return msg.c_str();
-        }
-    };
-
-    using Qubit = std::uint32_t;
-    using Bit   = std::uint64_t;
-
-    template<class IdxType, class SizeType>
-    using Register          = std::pair<IdxType, SizeType>;
-    using QuantumRegister   = Register<Qubit, std::size_t>;
-    using ClassicalRegister = Register<Bit, std::size_t>;
-    template<class RegisterType>
-    using RegisterMap          = std::map<std::string, RegisterType, std::greater<>>;
-    using QuantumRegisterMap   = RegisterMap<QuantumRegister>;
-    using ClassicalRegisterMap = RegisterMap<ClassicalRegister>;
-    using RegisterNames        = std::vector<std::pair<std::string, std::string>>;
-
-    using Targets = std::vector<Qubit>;
-
-    using BitString = std::bitset<128>;
-
-    // floating-point type used throughout the library
-    using fp = double;
-
-    constexpr fp PARAMETER_TOLERANCE = 1e-13;
-
-    static constexpr fp PI   = static_cast<fp>(3.141592653589793238462643383279502884197169399375105820974L);
-    static constexpr fp PI_2 = static_cast<fp>(1.570796326794896619231321691639751442098584699687552910487L);
-    static constexpr fp PI_4 = static_cast<fp>(0.785398163397448309615660845819875721049292349843776455243L);
-
-    // forward declaration
-    class Operation;
-
-    // supported file formats
-    enum class Format {
-        Real,
-        OpenQASM,
-        GRCS,
-        TFC,
-        QC,
-        Tensor
-    };
-
-    using DAG                 = std::vector<std::deque<std::unique_ptr<Operation>*>>;
-    using DAGIterator         = std::deque<std::unique_ptr<Operation>*>::iterator;
-    using DAGReverseIterator  = std::deque<std::unique_ptr<Operation>*>::reverse_iterator;
-    using DAGIterators        = std::vector<DAGIterator>;
-    using DAGReverseIterators = std::vector<DAGReverseIterator>;
-
-    using Symbolic           = sym::Expression<fp, fp>;
-    using VariableAssignment = std::unordered_map<sym::Variable, fp>;
-    using SymbolOrNumber     = std::variant<Symbolic, fp>;
+public:
+  explicit QFRException(std::string m)
+      : std::invalid_argument("QFR Exception"), msg(std::move(m)) {}
+
+  [[nodiscard]] const char* what() const noexcept override {
+    return msg.c_str();
+  }
+};
+
+using Qubit = std::uint32_t;
+using Bit = std::uint64_t;
+
+template <class IdxType, class SizeType>
+using Register = std::pair<IdxType, SizeType>;
+using QuantumRegister = Register<Qubit, std::size_t>;
+using ClassicalRegister = Register<Bit, std::size_t>;
+template <class RegisterType>
+using RegisterMap = std::map<std::string, RegisterType, std::greater<>>;
+using QuantumRegisterMap = RegisterMap<QuantumRegister>;
+using ClassicalRegisterMap = RegisterMap<ClassicalRegister>;
+using RegisterNames = std::vector<std::pair<std::string, std::string>>;
+
+using Targets = std::vector<Qubit>;
+
+using BitString = std::bitset<128>;
+
+// floating-point type used throughout the library
+using fp = double;
+
+constexpr fp PARAMETER_TOLERANCE = 1e-13;
+
+static constexpr fp PI = static_cast<fp>(
+    3.141592653589793238462643383279502884197169399375105820974L);
+static constexpr fp PI_2 = static_cast<fp>(
+    1.570796326794896619231321691639751442098584699687552910487L);
+static constexpr fp PI_4 = static_cast<fp>(
+    0.785398163397448309615660845819875721049292349843776455243L);
+
+// forward declaration
+class Operation;
+
+// supported file formats
+enum class Format { Real, OpenQASM, GRCS, TFC, QC, Tensor };
+
+using DAG = std::vector<std::deque<std::unique_ptr<Operation>*>>;
+using DAGIterator = std::deque<std::unique_ptr<Operation>*>::iterator;
+using DAGReverseIterator =
+    std::deque<std::unique_ptr<Operation>*>::reverse_iterator;
+using DAGIterators = std::vector<DAGIterator>;
+using DAGReverseIterators = std::vector<DAGReverseIterator>;
+
+using Symbolic = sym::Expression<fp, fp>;
+using VariableAssignment = std::unordered_map<sym::Variable, fp>;
+using SymbolOrNumber = std::variant<Symbolic, fp>;
 } // namespace qc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/include/QuantumComputation.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/QuantumComputation.hpp`

 * *Files 8% similar despite different names*

```diff
@@ -1,12 +1,7 @@
-/*
- * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
- */
-
 #pragma once
 
 #include "Definitions.hpp"
 #include "operations/ClassicControlledOperation.hpp"
 #include "operations/NonUnitaryOperation.hpp"
 #include "operations/StandardOperation.hpp"
 #include "operations/SymbolicOperation.hpp"
@@ -23,986 +18,1139 @@
 #include <optional>
 #include <random>
 #include <sstream>
 #include <string>
 #include <vector>
 
 namespace qc {
-    class CircuitOptimizer;
-
-    class QuantumComputation {
-    public:
-        using iterator       = typename std::vector<std::unique_ptr<Operation>>::iterator;
-        using const_iterator = typename std::vector<std::unique_ptr<Operation>>::const_iterator;
-
-        friend class CircuitOptimizer;
-
-    protected:
-        std::vector<std::unique_ptr<Operation>> ops{};
-        std::size_t                             nqubits     = 0;
-        std::size_t                             nclassics   = 0;
-        std::size_t                             nancillae   = 0;
-        std::size_t                             maxControls = 0;
-        std::string                             name;
-
-        // register names are used as keys, while the values are `{startIndex, length}` pairs
-        QuantumRegisterMap   qregs{};
-        ClassicalRegisterMap cregs{};
-        QuantumRegisterMap   ancregs{};
-
-        std::mt19937_64 mt;
-        std::size_t     seed = 0;
-
-        fp globalPhase = 0.;
-
-        std::unordered_set<sym::Variable> occuringVariables;
-
-        void importOpenQASM(std::istream& is);
-        void importReal(std::istream& is);
-        int  readRealHeader(std::istream& is);
-        void readRealGateDescriptions(std::istream& is, int line);
-        void importTFC(std::istream& is);
-        int  readTFCHeader(std::istream& is, std::map<std::string, Qubit>& varMap);
-        void readTFCGateDescriptions(std::istream& is, int line, std::map<std::string, Qubit>& varMap);
-        void importQC(std::istream& is);
-        int  readQCHeader(std::istream& is, std::map<std::string, Qubit>& varMap);
-        void readQCGateDescriptions(std::istream& is, int line, std::map<std::string, Qubit>& varMap);
-        void importGRCS(std::istream& is);
-
-        template<class RegisterType>
-        static void printSortedRegisters(const RegisterMap<RegisterType>& regmap, const std::string& identifier, std::ostream& of) {
-            // sort regs by start index
-            std::map<decltype(RegisterType::first), std::pair<std::string, RegisterType>> sortedRegs{};
-            for (const auto& reg: regmap) {
-                sortedRegs.insert({reg.second.first, reg});
-            }
-
-            for (const auto& reg: sortedRegs) {
-                of << identifier << " " << reg.second.first << "[" << reg.second.second.second << "];" << std::endl;
-            }
-        }
-        template<class RegisterType>
-        static void consolidateRegister(RegisterMap<RegisterType>& regs) {
-            bool finished = false;
-            while (!finished) {
-                for (const auto& qreg: regs) {
-                    finished     = true;
-                    auto regname = qreg.first;
-                    // check if lower part of register
-                    if (regname.length() > 2 && regname.compare(regname.size() - 2, 2, "_l") == 0) {
-                        auto lowidx = qreg.second.first;
-                        auto lownum = qreg.second.second;
-                        // search for higher part of register
-                        auto highname = regname.substr(0, regname.size() - 1) + 'h';
-                        auto it       = regs.find(highname);
-                        if (it != regs.end()) {
-                            auto highidx = it->second.first;
-                            auto highnum = it->second.second;
-                            // fusion of registers possible
-                            if (lowidx + lownum == highidx) {
-                                finished        = false;
-                                auto targetname = regname.substr(0, regname.size() - 2);
-                                auto targetidx  = lowidx;
-                                auto targetnum  = lownum + highnum;
-                                regs.insert({targetname, {targetidx, targetnum}});
-                                regs.erase(regname);
-                                regs.erase(highname);
-                            }
-                        }
-                        break;
-                    }
-                }
-            }
-        }
-
-        template<class RegisterType>
-        static void createRegisterArray(const RegisterMap<RegisterType>& regs, RegisterNames& regnames, decltype(RegisterType::second) defaultnumber, const std::string& defaultname) {
-            regnames.clear();
-
-            std::stringstream ss;
-            if (!regs.empty()) {
-                // sort regs by start index
-                std::map<decltype(RegisterType::first), std::pair<std::string, RegisterType>> sortedRegs{};
-                for (const auto& reg: regs) {
-                    sortedRegs.insert({reg.second.first, reg});
-                }
-
-                for (const auto& reg: sortedRegs) {
-                    for (decltype(RegisterType::second) i = 0; i < reg.second.second.second; i++) {
-                        ss << reg.second.first << "[" << i << "]";
-                        regnames.push_back(std::make_pair(reg.second.first, ss.str()));
-                        ss.str(std::string());
-                    }
-                }
-            } else {
-                for (decltype(RegisterType::second) i = 0; i < defaultnumber; i++) {
-                    ss << defaultname << "[" << i << "]";
-                    regnames.emplace_back(defaultname, ss.str());
-                    ss.str(std::string());
-                }
-            }
-        }
-
-        [[nodiscard]] std::size_t getSmallestAncillary() const {
-            for (std::size_t i = 0; i < ancillary.size(); ++i) {
-                if (ancillary[i]) {
-                    return i;
-                }
-            }
-            return ancillary.size();
-        }
-
-        [[nodiscard]] std::size_t getSmallestGarbage() const {
-            for (std::size_t i = 0; i < garbage.size(); ++i) {
-                if (garbage[i]) {
-                    return i;
-                }
-            }
-            return garbage.size();
-        }
-        [[nodiscard]] bool isLastOperationOnQubit(const const_iterator& opIt) const {
-            const auto end = ops.cend();
-            return isLastOperationOnQubit(opIt, end);
-        }
-        void checkQubitRange(Qubit qubit) const;
-        void checkQubitRange(Qubit qubit, const Controls& controls) const;
-        void checkQubitRange(Qubit qubit0, Qubit qubit1, const Controls& controls) const;
-        void checkQubitRange(const std::vector<Qubit>& qubits) const;
-
-    public:
-        QuantumComputation() = default;
-        explicit QuantumComputation(const std::size_t nq, const std::size_t s = 0):
-            seed(s) {
-            addQubitRegister(nq);
-            addClassicalRegister(nq);
-            if (seed != 0) {
-                mt.seed(seed);
-            } else {
-                // create and properly seed rng
-                std::array<std::mt19937_64::result_type, std::mt19937_64::state_size> randomData{};
-                std::random_device                                                    rd;
-                std::generate(std::begin(randomData), std::end(randomData), [&rd]() { return rd(); });
-                std::seed_seq seeds(std::begin(randomData), std::end(randomData));
-                mt.seed(seeds);
-            }
-        }
-        explicit QuantumComputation(const std::string& filename, const std::size_t s = 0U):
-            seed(s) {
-            import(filename);
-            if (seed != 0U) {
-                mt.seed(seed);
-            } else {
-                // create and properly seed rng
-                std::array<std::mt19937_64::result_type, std::mt19937_64::state_size> randomData{};
-                std::random_device                                                    rd;
-                std::generate(std::begin(randomData), std::end(randomData), [&rd]() { return rd(); });
-                std::seed_seq seeds(std::begin(randomData), std::end(randomData));
-                mt.seed(seeds);
-            }
-        }
-        QuantumComputation(const QuantumComputation& qc)     = delete;
-        QuantumComputation(QuantumComputation&& qc) noexcept = default;
-
-        QuantumComputation& operator=(const QuantumComputation& qc) = delete;
-
-        QuantumComputation& operator=(QuantumComputation&& qc) noexcept = default;
+class CircuitOptimizer;
 
-        virtual ~QuantumComputation() = default;
-
-        [[nodiscard]] QuantumComputation clone() const {
-            auto qc              = QuantumComputation(nqubits);
-            qc.nqubits           = nqubits;
-            qc.nclassics         = nclassics;
-            qc.nancillae         = nancillae;
-            qc.maxControls       = maxControls;
-            qc.name              = name;
-            qc.qregs             = qregs;
-            qc.cregs             = cregs;
-            qc.ancregs           = ancregs;
-            qc.initialLayout     = initialLayout;
-            qc.outputPermutation = outputPermutation;
-            qc.ancillary         = ancillary;
-            qc.garbage           = garbage;
-            qc.seed              = seed;
-            qc.mt                = mt;
-            qc.occuringVariables = occuringVariables;
-            qc.globalPhase       = globalPhase;
-
-            for (auto const& op: ops) {
-                qc.ops.emplace_back<>(op->clone());
-            }
-            return qc;
-        }
-
-        [[nodiscard]] virtual std::size_t         getNops() const { return ops.size(); }
-        [[nodiscard]] std::size_t                 getNqubits() const { return nqubits + nancillae; }
-        [[nodiscard]] std::size_t                 getNancillae() const { return nancillae; }
-        [[nodiscard]] std::size_t                 getNqubitsWithoutAncillae() const { return nqubits; }
-        [[nodiscard]] std::size_t                 getNcbits() const { return nclassics; }
-        [[nodiscard]] std::string                 getName() const { return name; }
-        [[nodiscard]] const QuantumRegisterMap&   getQregs() const { return qregs; }
-        [[nodiscard]] const ClassicalRegisterMap& getCregs() const { return cregs; }
-        [[nodiscard]] const QuantumRegisterMap&   getANCregs() const { return ancregs; }
-        [[nodiscard]] decltype(mt)&               getGenerator() { return mt; }
-
-        [[nodiscard]] fp getGlobalPhase() const { return globalPhase; }
-
-        void setName(const std::string& n) { name = n; }
-
-        // physical qubits are used as keys, logical qubits as values
-        Permutation initialLayout{};
-        Permutation outputPermutation{};
-
-        std::vector<bool> ancillary{};
-        std::vector<bool> garbage{};
-
-        [[nodiscard]] std::size_t getNindividualOps() const;
-        [[nodiscard]] std::size_t getNsingleQubitOps() const;
-        [[nodiscard]] std::size_t getDepth() const;
-
-        [[nodiscard]] std::string                   getQubitRegister(Qubit physicalQubitIndex) const;
-        [[nodiscard]] std::string                   getClassicalRegister(Bit classicalIndex) const;
-        [[gnu::pure]] static Qubit                  getHighestLogicalQubitIndex(const Permutation& permutation);
-        [[nodiscard]] Qubit                         getHighestLogicalQubitIndex() const { return getHighestLogicalQubitIndex(initialLayout); };
-        [[nodiscard]] std::pair<std::string, Qubit> getQubitRegisterAndIndex(Qubit physicalQubitIndex) const;
-        [[nodiscard]] std::pair<std::string, Bit>   getClassicalRegisterAndIndex(Bit classicalIndex) const;
-
-        [[nodiscard]] Qubit                    getIndexFromQubitRegister(const std::pair<std::string, Qubit>& qubit) const;
-        [[nodiscard]] Bit                      getIndexFromClassicalRegister(const std::pair<std::string, std::size_t>& clbit) const;
-        [[nodiscard]] bool                     isIdleQubit(Qubit physicalQubit) const;
-        [[nodiscard]] bool                     isLastOperationOnQubit(const const_iterator& opIt, const const_iterator& end) const;
-        [[nodiscard, gnu::pure]] bool          physicalQubitIsAncillary(Qubit physicalQubitIndex) const;
-        [[nodiscard]] bool                     logicalQubitIsAncillary(const Qubit logicalQubitIndex) const { return ancillary[logicalQubitIndex]; }
-        void                                   setLogicalQubitAncillary(const Qubit logicalQubitIndex) { ancillary[logicalQubitIndex] = true; }
-        [[nodiscard]] bool                     logicalQubitIsGarbage(const Qubit logicalQubitIndex) const { return garbage[logicalQubitIndex]; }
-        void                                   setLogicalQubitGarbage(Qubit logicalQubitIndex);
-        [[nodiscard]] const std::vector<bool>& getAncillary() const { return ancillary; }
-        [[nodiscard]] const std::vector<bool>& getGarbage() const { return garbage; }
-
-        /// checks whether the given logical qubit exists in the initial layout.
-        /// \param logicalQubitIndex the logical qubit index to check
-        /// \return whether the given logical qubit exists in the initial layout and to which physical qubit it is mapped
-        [[nodiscard, gnu::pure]] std::pair<bool, std::optional<Qubit>> containsLogicalQubit(Qubit logicalQubitIndex) const;
-
-        /// Adds a global phase to the quantum circuit.
-        /// \param angle the angle to add
-        void gphase(const fp& angle) {
-            globalPhase += angle;
-            // normalize to [0, 2pi)
-            while (globalPhase < 0) {
-                globalPhase += 2 * PI;
-            }
-            while (globalPhase >= 2 * PI) {
-                globalPhase -= 2 * PI;
+class QuantumComputation {
+public:
+  using iterator = typename std::vector<std::unique_ptr<Operation>>::iterator;
+  using const_iterator =
+      typename std::vector<std::unique_ptr<Operation>>::const_iterator;
+
+  friend class CircuitOptimizer;
+
+protected:
+  std::vector<std::unique_ptr<Operation>> ops{};
+  std::size_t nqubits = 0;
+  std::size_t nclassics = 0;
+  std::size_t nancillae = 0;
+  std::size_t maxControls = 0;
+  std::string name;
+
+  // register names are used as keys, while the values are `{startIndex,
+  // length}` pairs
+  QuantumRegisterMap qregs{};
+  ClassicalRegisterMap cregs{};
+  QuantumRegisterMap ancregs{};
+
+  std::mt19937_64 mt;
+  std::size_t seed = 0;
+
+  fp globalPhase = 0.;
+
+  std::unordered_set<sym::Variable> occuringVariables;
+
+  void importOpenQASM(std::istream& is);
+  void importReal(std::istream& is);
+  int readRealHeader(std::istream& is);
+  void readRealGateDescriptions(std::istream& is, int line);
+  void importTFC(std::istream& is);
+  int readTFCHeader(std::istream& is, std::map<std::string, Qubit>& varMap);
+  void readTFCGateDescriptions(std::istream& is, int line,
+                               std::map<std::string, Qubit>& varMap);
+  void importQC(std::istream& is);
+  int readQCHeader(std::istream& is, std::map<std::string, Qubit>& varMap);
+  void readQCGateDescriptions(std::istream& is, int line,
+                              std::map<std::string, Qubit>& varMap);
+  void importGRCS(std::istream& is);
+
+  template <class RegisterType>
+  static void printSortedRegisters(const RegisterMap<RegisterType>& regmap,
+                                   const std::string& identifier,
+                                   std::ostream& of) {
+    // sort regs by start index
+    std::map<decltype(RegisterType::first),
+             std::pair<std::string, RegisterType>>
+        sortedRegs{};
+    for (const auto& reg : regmap) {
+      sortedRegs.insert({reg.second.first, reg});
+    }
+
+    for (const auto& reg : sortedRegs) {
+      of << identifier << " " << reg.second.first << "["
+         << reg.second.second.second << "];" << std::endl;
+    }
+  }
+  template <class RegisterType>
+  static void consolidateRegister(RegisterMap<RegisterType>& regs) {
+    bool finished = false;
+    while (!finished) {
+      for (const auto& qreg : regs) {
+        finished = true;
+        auto regname = qreg.first;
+        // check if lower part of register
+        if (regname.length() > 2 &&
+            regname.compare(regname.size() - 2, 2, "_l") == 0) {
+          auto lowidx = qreg.second.first;
+          auto lownum = qreg.second.second;
+          // search for higher part of register
+          auto highname = regname.substr(0, regname.size() - 1) + 'h';
+          auto it = regs.find(highname);
+          if (it != regs.end()) {
+            auto highidx = it->second.first;
+            auto highnum = it->second.second;
+            // fusion of registers possible
+            if (lowidx + lownum == highidx) {
+              finished = false;
+              auto targetname = regname.substr(0, regname.size() - 2);
+              auto targetidx = lowidx;
+              auto targetnum = lownum + highnum;
+              regs.insert({targetname, {targetidx, targetnum}});
+              regs.erase(regname);
+              regs.erase(highname);
             }
+          }
+          break;
         }
-
-        void i(const Qubit target) {
-            i(target, Controls{});
-        }
-        void i(const Qubit target, const Control& control) {
-            i(target, Controls{control});
-        }
-        void i(const Qubit target, const Controls& controls) {
-            checkQubitRange(target, controls);
-            emplace_back<StandardOperation>(getNqubits(), controls, target, qc::I);
-        }
-
-        void h(const Qubit target) {
-            h(target, Controls{});
-        }
-        void h(const Qubit target, const Control& control) {
-            h(target, Controls{control});
-        }
-        void h(const Qubit target, const Controls& controls) {
-            checkQubitRange(target, controls);
-            emplace_back<StandardOperation>(getNqubits(), controls, target, qc::H);
-        }
-
-        void x(const Qubit target) {
-            x(target, Controls{});
-        }
-        void x(const Qubit target, const Control& control) {
-            x(target, Controls{control});
-        }
-        void x(const Qubit target, const Controls& controls) {
-            checkQubitRange(target, controls);
-            emplace_back<StandardOperation>(getNqubits(), controls, target, qc::X);
-        }
-
-        void y(const Qubit target) {
-            y(target, Controls{});
-        }
-        void y(const Qubit target, const Control& control) {
-            y(target, Controls{control});
-        }
-        void y(const Qubit target, const Controls& controls) {
-            checkQubitRange(target, controls);
-            emplace_back<StandardOperation>(getNqubits(), controls, target, qc::Y);
-        }
-
-        void z(const Qubit target) {
-            z(target, Controls{});
-        }
-        void z(const Qubit target, const Control& control) {
-            z(target, Controls{control});
-        }
-        void z(const Qubit target, const Controls& controls) {
-            checkQubitRange(target, controls);
-            emplace_back<StandardOperation>(getNqubits(), controls, target, qc::Z);
-        }
-
-        void s(const Qubit target) {
-            s(target, Controls{});
-        }
-        void s(const Qubit target, const Control& control) {
-            s(target, Controls{control});
-        }
-        void s(const Qubit target, const Controls& controls) {
-            checkQubitRange(target, controls);
-            emplace_back<StandardOperation>(getNqubits(), controls, target, qc::S);
-        }
-
-        void sdag(const Qubit target) {
-            sdag(target, Controls{});
-        }
-        void sdag(const Qubit target, const Control& control) {
-            sdag(target, Controls{control});
-        }
-        void sdag(const Qubit target, const Controls& controls) {
-            checkQubitRange(target, controls);
-            emplace_back<StandardOperation>(getNqubits(), controls, target, qc::Sdag);
-        }
-
-        void t(const Qubit target) {
-            t(target, Controls{});
-        }
-        void t(const Qubit target, const Control& control) {
-            t(target, Controls{control});
-        }
-        void t(const Qubit target, const Controls& controls) {
-            checkQubitRange(target, controls);
-            emplace_back<StandardOperation>(getNqubits(), controls, target, qc::T);
-        }
-
-        void tdag(const Qubit target) {
-            tdag(target, Controls{});
-        }
-        void tdag(const Qubit target, const Control& control) {
-            tdag(target, Controls{control});
-        }
-        void tdag(const Qubit target, const Controls& controls) {
-            checkQubitRange(target, controls);
-            emplace_back<StandardOperation>(getNqubits(), controls, target, qc::Tdag);
-        }
-
-        void v(const Qubit target) {
-            v(target, Controls{});
-        }
-        void v(const Qubit target, const Control& control) {
-            v(target, Controls{control});
-        }
-        void v(const Qubit target, const Controls& controls) {
-            checkQubitRange(target, controls);
-            emplace_back<StandardOperation>(getNqubits(), controls, target, qc::V);
-        }
-
-        void vdag(const Qubit target) {
-            vdag(target, Controls{});
-        }
-        void vdag(const Qubit target, const Control& control) {
-            vdag(target, Controls{control});
-        }
-        void vdag(const Qubit target, const Controls& controls) {
-            checkQubitRange(target, controls);
-            emplace_back<StandardOperation>(getNqubits(), controls, target, qc::Vdag);
-        }
-
-        void u3(const Qubit target, const fp theta, const fp phi, const fp lambda) {
-            u3(target, Controls{}, theta, phi, lambda);
-        }
-        void u3(const Qubit target, const Control& control, const fp theta, const fp phi, const fp lambda) {
-            u3(target, Controls{control}, theta, phi, lambda);
-        }
-        void u3(const Qubit target, const Controls& controls, const fp theta, const fp phi, const fp lambda) {
-            checkQubitRange(target, controls);
-            emplace_back<StandardOperation>(getNqubits(), controls, target, qc::U3, std::vector{theta, phi, lambda});
-        }
-        void u3(const Qubit target, const SymbolOrNumber& theta, const SymbolOrNumber& phi, const SymbolOrNumber& lambda) {
-            u3(target, Controls{}, theta, phi, lambda);
-        }
-        void u3(const Qubit target, const Control& control, const SymbolOrNumber& theta, const SymbolOrNumber& phi, const SymbolOrNumber& lambda) {
-            u3(target, Controls{control}, theta, phi, lambda);
-        }
-        void u3(const Qubit target, const Controls& controls, const SymbolOrNumber& theta, const SymbolOrNumber& phi, const SymbolOrNumber& lambda) {
-            checkQubitRange(target, controls);
-            addVariables(theta, phi, lambda);
-            emplace_back<SymbolicOperation>(getNqubits(), controls, target, qc::U3, std::vector{theta, phi, lambda});
-        }
-
-        void u2(const Qubit target, const fp phi, const fp lambda) {
-            u2(target, Controls{}, phi, lambda);
-        }
-        void u2(const Qubit target, const Control& control, const fp phi, const fp lambda) {
-            u2(target, Controls{control}, phi, lambda);
-        }
-        void u2(const Qubit target, const Controls& controls, const fp phi, const fp lambda) {
-            checkQubitRange(target, controls);
-            emplace_back<StandardOperation>(getNqubits(), controls, target, qc::U2, std::vector{phi, lambda});
-        }
-        void u2(const Qubit target, const SymbolOrNumber& phi, const SymbolOrNumber& lambda) {
-            u2(target, Controls{}, phi, lambda);
-        }
-        void u2(const Qubit target, const Control& control, const SymbolOrNumber& phi, const SymbolOrNumber& lambda) {
-            u2(target, Controls{control}, phi, lambda);
-        }
-        void u2(const Qubit target, const Controls& controls, const SymbolOrNumber& phi, const SymbolOrNumber& lambda) {
-            checkQubitRange(target, controls);
-            addVariables(phi, lambda);
-            emplace_back<SymbolicOperation>(getNqubits(), controls, target, qc::U2, std::vector{phi, lambda});
-        }
-
-        void phase(const Qubit target, const fp lambda) {
-            phase(target, Controls{}, lambda);
-        }
-        void phase(const Qubit target, const Control& control, const fp lambda) {
-            phase(target, Controls{control}, lambda);
-        }
-        void phase(const Qubit target, const Controls& controls, const fp lambda) {
-            checkQubitRange(target, controls);
-            emplace_back<StandardOperation>(getNqubits(), controls, target, qc::Phase, std::vector{lambda});
-        }
-        void phase(const Qubit target, const SymbolOrNumber& lambda) {
-            phase(target, Controls{}, lambda);
-        }
-        void phase(const Qubit target, const Control& control, const SymbolOrNumber& lambda) {
-            phase(target, Controls{control}, lambda);
-        }
-        void phase(const Qubit target, const Controls& controls, const SymbolOrNumber& lambda) {
-            checkQubitRange(target, controls);
-            addVariables(lambda);
-            emplace_back<SymbolicOperation>(getNqubits(), controls, target, qc::Phase, std::vector{lambda});
-        }
-
-        void sx(const Qubit target) {
-            sx(target, Controls{});
-        }
-        void sx(const Qubit target, const Control& control) {
-            sx(target, Controls{control});
-        }
-        void sx(const Qubit target, const Controls& controls) {
-            checkQubitRange(target, controls);
-            emplace_back<StandardOperation>(getNqubits(), controls, target, qc::SX);
-        }
-
-        void sxdag(const Qubit target) {
-            sxdag(target, Controls{});
-        }
-        void sxdag(const Qubit target, const Control& control) {
-            sxdag(target, Controls{control});
-        }
-        void sxdag(const Qubit target, const Controls& controls) {
-            checkQubitRange(target, controls);
-            emplace_back<StandardOperation>(getNqubits(), controls, target, qc::SXdag);
-        }
-
-        void rx(const Qubit target, const fp lambda) {
-            rx(target, Controls{}, lambda);
-        }
-        void rx(const Qubit target, const Control& control, const fp lambda) {
-            rx(target, Controls{control}, lambda);
-        }
-        void rx(const Qubit target, const Controls& controls, const fp lambda) {
-            checkQubitRange(target, controls);
-            emplace_back<StandardOperation>(getNqubits(), controls, target, qc::RX, std::vector{lambda});
-        }
-        void rx(const Qubit target, const SymbolOrNumber& lambda) {
-            rx(target, Controls{}, lambda);
-        }
-        void rx(const Qubit target, const Control& control, const SymbolOrNumber& lambda) {
-            rx(target, Controls{control}, lambda);
-        }
-        void rx(const Qubit target, const Controls& controls, const SymbolOrNumber& lambda) {
-            checkQubitRange(target, controls);
-            addVariables(lambda);
-            emplace_back<SymbolicOperation>(getNqubits(), controls, target, qc::RX, std::vector{lambda});
-        }
-
-        void ry(const Qubit target, const fp lambda) {
-            ry(target, Controls{}, lambda);
-        }
-        void ry(const Qubit target, const Control& control, const fp lambda) {
-            ry(target, Controls{control}, lambda);
-        }
-        void ry(const Qubit target, const Controls& controls, const fp lambda) {
-            checkQubitRange(target, controls);
-            emplace_back<StandardOperation>(getNqubits(), controls, target, qc::RY, std::vector{lambda});
-        }
-        void ry(const Qubit target, const SymbolOrNumber& lambda) {
-            ry(target, Controls{}, lambda);
-        }
-        void ry(const Qubit target, const Control& control, const SymbolOrNumber& lambda) {
-            ry(target, Controls{control}, lambda);
-        }
-        void ry(const Qubit target, const Controls& controls, const SymbolOrNumber& lambda) {
-            checkQubitRange(target, controls);
-            addVariables(lambda);
-            emplace_back<SymbolicOperation>(getNqubits(), controls, target, qc::RY, std::vector{lambda});
-        }
-
-        void rz(const Qubit target, const fp lambda) {
-            rz(target, Controls{}, lambda);
-        }
-        void rz(const Qubit target, const Control& control, const fp lambda) {
-            rz(target, Controls{control}, lambda);
-        }
-        void rz(const Qubit target, const Controls& controls, const fp lambda) {
-            checkQubitRange(target, controls);
-            emplace_back<StandardOperation>(getNqubits(), controls, target, qc::RZ, std::vector{lambda});
-        }
-        void rz(const Qubit target, const SymbolOrNumber& lambda) {
-            rz(target, Controls{}, lambda);
-        }
-        void rz(const Qubit target, const Control& control, const SymbolOrNumber& lambda) {
-            rz(target, Controls{control}, lambda);
-        }
-        void rz(const Qubit target, const Controls& controls, const SymbolOrNumber& lambda) {
-            checkQubitRange(target, controls);
-            addVariables(lambda);
-            emplace_back<SymbolicOperation>(getNqubits(), controls, target, qc::RZ, std::vector{lambda});
-        }
-
-        void swap(const Qubit target0, const Qubit target1) {
-            swap(target0, target1, Controls{});
-        }
-        void swap(const Qubit target0, const Qubit target1, const Control& control) {
-            swap(target0, target1, Controls{control});
-        }
-        void swap(const Qubit target0, const Qubit target1, const Controls& controls) {
-            checkQubitRange(target0, target1, controls);
-            emplace_back<StandardOperation>(getNqubits(), controls, target0, target1, qc::SWAP);
-        }
-
-        void iswap(const Qubit target0, const Qubit target1) {
-            iswap(target0, target1, Controls{});
-        }
-        void iswap(const Qubit target0, const Qubit target1, const Control& control) {
-            iswap(target0, target1, Controls{control});
-        }
-        void iswap(const Qubit target0, const Qubit target1, const Controls& controls) {
-            checkQubitRange(target0, target1, controls);
-            emplace_back<StandardOperation>(getNqubits(), controls, target0, target1, qc::iSWAP);
-        }
-
-        void peres(const Qubit target0, const Qubit target1) {
-            peres(target0, target1, Controls{});
-        }
-        void peres(const Qubit target0, const Qubit target1, const Control& control) {
-            peres(target0, target1, Controls{control});
-        }
-        void peres(const Qubit target0, const Qubit target1, const Controls& controls) {
-            checkQubitRange(target0, target1, controls);
-            emplace_back<StandardOperation>(getNqubits(), controls, target0, target1, qc::Peres);
-        }
-
-        void peresdag(const Qubit target0, const Qubit target1) {
-            peresdag(target0, target1, Controls{});
-        }
-        void peresdag(const Qubit target0, const Qubit target1, const Control& control) {
-            peresdag(target0, target1, Controls{control});
-        }
-        void peresdag(const Qubit target0, const Qubit target1, const Controls& controls) {
-            checkQubitRange(target0, target1, controls);
-            emplace_back<StandardOperation>(getNqubits(), controls, target0, target1, qc::Peresdag);
-        }
-
-        void dcx(const Qubit target0, const Qubit target1) {
-            dcx(target0, target1, Controls{});
-        }
-        void dcx(const Qubit target0, const Qubit target1, const Control& control) {
-            dcx(target0, target1, Controls{control});
-        }
-        void dcx(const Qubit target0, const Qubit target1, const Controls& controls) {
-            checkQubitRange(target0, target1, controls);
-            emplace_back<StandardOperation>(getNqubits(), controls, target0, target1, qc::DCX);
-        }
-
-        void ecr(const Qubit target0, const Qubit target1) {
-            ecr(target0, target1, Controls{});
-        }
-        void ecr(const Qubit target0, const Qubit target1, const Control& control) {
-            ecr(target0, target1, Controls{control});
-        }
-        void ecr(const Qubit target0, const Qubit target1, const Controls& controls) {
-            checkQubitRange(target0, target1, controls);
-            emplace_back<StandardOperation>(getNqubits(), controls, target0, target1, qc::ECR);
-        }
-
-        void rxx(const Qubit target0, const Qubit target1, const fp theta) {
-            rxx(target0, target1, Controls{}, theta);
-        }
-        void rxx(const Qubit target0, const Qubit target1, const Control& control, const fp theta) {
-            rxx(target0, target1, Controls{control}, theta);
-        }
-        void rxx(const Qubit target0, const Qubit target1, const Controls& controls, const fp theta) {
-            checkQubitRange(target0, target1, controls);
-            emplace_back<StandardOperation>(getNqubits(), controls, target0, target1, qc::RXX, std::vector{theta});
-        }
-        void rxx(const Qubit target0, const Qubit target1, const SymbolOrNumber& theta) {
-            rxx(target0, target1, Controls{}, theta);
-        }
-        void rxx(const Qubit target0, const Qubit target1, const Control& control, const SymbolOrNumber& theta) {
-            rxx(target0, target1, Controls{control}, theta);
-        }
-        void rxx(const Qubit target0, const Qubit target1, const Controls& controls, const SymbolOrNumber& theta) {
-            checkQubitRange(target0, target1, controls);
-            addVariables(theta);
-            emplace_back<SymbolicOperation>(getNqubits(), controls, target0, target1, qc::RXX, std::vector{theta});
-        }
-
-        void ryy(const Qubit target0, const Qubit target1, const fp theta) {
-            ryy(target0, target1, Controls{}, theta);
-        }
-        void ryy(const Qubit target0, const Qubit target1, const Control& control, const fp theta) {
-            ryy(target0, target1, Controls{control}, theta);
-        }
-        void ryy(const Qubit target0, const Qubit target1, const Controls& controls, const fp theta) {
-            checkQubitRange(target0, target1, controls);
-            emplace_back<StandardOperation>(getNqubits(), controls, target0, target1, qc::RYY, std::vector{theta});
-        }
-        void ryy(const Qubit target0, const Qubit target1, const SymbolOrNumber& theta) {
-            ryy(target0, target1, Controls{}, theta);
-        }
-        void ryy(const Qubit target0, const Qubit target1, const Control& control, const SymbolOrNumber& theta) {
-            ryy(target0, target1, Controls{control}, theta);
-        }
-        void ryy(const Qubit target0, const Qubit target1, const Controls& controls, const SymbolOrNumber& theta) {
-            checkQubitRange(target0, target1, controls);
-            addVariables(theta);
-            emplace_back<SymbolicOperation>(getNqubits(), controls, target0, target1, qc::RYY, std::vector{theta});
-        }
-
-        void rzz(const Qubit target0, const Qubit target1, const fp theta) {
-            rzz(target0, target1, Controls{}, theta);
-        }
-        void rzz(const Qubit target0, const Qubit target1, const Control& control, const fp theta) {
-            rzz(target0, target1, Controls{control}, theta);
-        }
-        void rzz(const Qubit target0, const Qubit target1, const Controls& controls, const fp theta) {
-            checkQubitRange(target0, target1, controls);
-            emplace_back<StandardOperation>(getNqubits(), controls, target0, target1, qc::RZZ, std::vector{theta});
-        }
-        void rzz(const Qubit target0, const Qubit target1, const SymbolOrNumber& theta) {
-            rzz(target0, target1, Controls{}, theta);
-        }
-        void rzz(const Qubit target0, const Qubit target1, const Control& control, const SymbolOrNumber& theta) {
-            rzz(target0, target1, Controls{control}, theta);
-        }
-        void rzz(const Qubit target0, const Qubit target1, const Controls& controls, const SymbolOrNumber& theta) {
-            checkQubitRange(target0, target1, controls);
-            addVariables(theta);
-            emplace_back<SymbolicOperation>(getNqubits(), controls, target0, target1, qc::RZZ, std::vector{theta});
-        }
-
-        void rzx(const Qubit target0, const Qubit target1, const fp theta) {
-            rzx(target0, target1, Controls{}, theta);
-        }
-        void rzx(const Qubit target0, const Qubit target1, const Control& control, const fp theta) {
-            rzx(target0, target1, Controls{control}, theta);
-        }
-        void rzx(const Qubit target0, const Qubit target1, const Controls& controls, const fp theta) {
-            checkQubitRange(target0, target1, controls);
-            emplace_back<StandardOperation>(getNqubits(), controls, target0, target1, qc::RZX, std::vector{theta});
-        }
-        void rzx(const Qubit target0, const Qubit target1, const SymbolOrNumber& theta) {
-            rzx(target0, target1, Controls{}, theta);
-        }
-        void rzx(const Qubit target0, const Qubit target1, const Control& control, const SymbolOrNumber& theta) {
-            rzx(target0, target1, Controls{control}, theta);
-        }
-        void rzx(const Qubit target0, const Qubit target1, const Controls& controls, const SymbolOrNumber& theta) {
-            checkQubitRange(target0, target1, controls);
-            addVariables(theta);
-            emplace_back<SymbolicOperation>(getNqubits(), controls, target0, target1, qc::RZX, std::vector{theta});
-        }
-
-        // NOLINTBEGIN(readability-identifier-naming)
-        void xx_minus_yy(const Qubit target0, const Qubit target1, const fp theta, const fp beta) {
-            xx_minus_yy(target0, target1, Controls{}, theta, beta);
-        }
-        void xx_minus_yy(const Qubit target0, const Qubit target1, const Control& control, const fp theta, const fp beta) {
-            xx_minus_yy(target0, target1, Controls{control}, theta, beta);
-        }
-        void xx_minus_yy(const Qubit target0, const Qubit target1, const Controls& controls, const fp theta, const fp beta) {
-            checkQubitRange(target0, target1, controls);
-            emplace_back<StandardOperation>(getNqubits(), controls, target0, target1, qc::XXminusYY, std::vector{theta, beta});
-        }
-        void xx_minus_yy(const Qubit target0, const Qubit target1, const SymbolOrNumber& theta, const SymbolOrNumber& beta) {
-            xx_minus_yy(target0, target1, Controls{}, theta, beta);
-        }
-        void xx_minus_yy(const Qubit target0, const Qubit target1, const Control& control, const SymbolOrNumber& theta, const SymbolOrNumber& beta) {
-            xx_minus_yy(target0, target1, Controls{control}, theta, beta);
-        }
-        void xx_minus_yy(const Qubit target0, const Qubit target1, const Controls& controls, const SymbolOrNumber& theta, const SymbolOrNumber& beta) {
-            checkQubitRange(target0, target1, controls);
-            addVariables(theta, beta);
-            emplace_back<SymbolicOperation>(getNqubits(), controls, target0, target1, qc::XXminusYY, std::vector{theta, beta});
-        }
-
-        void xx_plus_yy(const Qubit target0, const Qubit target1, const fp theta, const fp beta) {
-            xx_plus_yy(target0, target1, Controls{}, theta, beta);
-        }
-        void xx_plus_yy(const Qubit target0, const Qubit target1, const Control& control, const fp theta, const fp beta) {
-            xx_plus_yy(target0, target1, Controls{control}, theta, beta);
-        }
-        void xx_plus_yy(const Qubit target0, const Qubit target1, const Controls& controls, const fp theta, const fp beta) {
-            checkQubitRange(target0, target1, controls);
-            emplace_back<StandardOperation>(getNqubits(), controls, target0, target1, qc::XXplusYY, std::vector{theta, beta});
-        }
-        void xx_plus_yy(const Qubit target0, const Qubit target1, const SymbolOrNumber& theta, const SymbolOrNumber& beta) {
-            xx_plus_yy(target0, target1, Controls{}, theta, beta);
-        }
-        void xx_plus_yy(const Qubit target0, const Qubit target1, const Control& control, const SymbolOrNumber& theta, const SymbolOrNumber& beta) {
-            xx_plus_yy(target0, target1, Controls{control}, theta, beta);
-        }
-        void xx_plus_yy(const Qubit target0, const Qubit target1, const Controls& controls, const SymbolOrNumber& theta, const SymbolOrNumber& beta) {
-            checkQubitRange(target0, target1, controls);
-            addVariables(theta, beta);
-            emplace_back<SymbolicOperation>(getNqubits(), controls, target0, target1, qc::XXplusYY, std::vector{theta, beta});
-        }
-        // NOLINTEND(readability-identifier-naming)
-
-        void measure(const Qubit qubit, const std::size_t clbit) {
-            checkQubitRange(qubit);
-            emplace_back<NonUnitaryOperation>(getNqubits(), qubit, clbit);
-        }
-
-        void measure(const Qubit qubit, const std::pair<std::string, Bit>& clbit) {
-            checkQubitRange(qubit);
-            if (const auto cRegister = cregs.find(clbit.first); cRegister != cregs.end()) {
-                if (clbit.second >= cRegister->second.second) {
-                    std::cerr << "The classical register \"" << clbit.first << "\" is too small!" << std::endl;
-                }
-                emplace_back<NonUnitaryOperation>(getNqubits(), qubit, cRegister->second.first + clbit.second);
-
-            } else {
-                std::cerr << "The classical register \"" << clbit.first << "\" does not exist!" << std::endl;
-            }
-        }
-
-        void measure(const std::vector<Qubit>& qubitRegister,
-                     const std::vector<Bit>&   classicalRegister) {
-            checkQubitRange(qubitRegister);
-            emplace_back<NonUnitaryOperation>(getNqubits(), qubitRegister,
-                                              classicalRegister);
-        }
-
-        void reset(const Qubit target) {
-            checkQubitRange(target);
-            emplace_back<NonUnitaryOperation>(getNqubits(), std::vector<Qubit>{target}, qc::Reset);
-        }
-        void reset(const std::vector<Qubit>& targets) {
-            checkQubitRange(targets);
-            emplace_back<NonUnitaryOperation>(getNqubits(), targets, qc::Reset);
-        }
-
-        void barrier(const Qubit target) {
-            checkQubitRange(target);
-            emplace_back<NonUnitaryOperation>(getNqubits(), std::vector<Qubit>{target}, qc::Barrier);
-        }
-        void barrier(const std::vector<Qubit>& targets) {
-            checkQubitRange(targets);
-            emplace_back<NonUnitaryOperation>(getNqubits(), targets, qc::Barrier);
-        }
-
-        void classicControlled(const OpType op, const Qubit target, const ClassicalRegister& controlRegister, const std::uint64_t expectedValue = 1U, const std::vector<fp>& params = {}) {
-            classicControlled(op, target, Controls{}, controlRegister, expectedValue, params);
-        }
-        void classicControlled(const OpType op, const Qubit target, const Control control, const ClassicalRegister& controlRegister, const std::uint64_t expectedValue = 1U, const std::vector<fp>& params = {}) {
-            classicControlled(op, target, Controls{control}, controlRegister, expectedValue, params);
-        }
-        void classicControlled(const OpType op, const Qubit target, const Controls& controls, const ClassicalRegister& controlRegister, const std::uint64_t expectedValue = 1U, const std::vector<fp>& params = {}) {
-            checkQubitRange(target, controls);
-            std::unique_ptr<Operation> gate = std::make_unique<StandardOperation>(getNqubits(), controls, target, op, params);
-            emplace_back<ClassicControlledOperation>(std::move(gate), controlRegister, expectedValue);
-        }
-
-        /// strip away qubits with no operations applied to them and which do not pop up in the output permutation
-        /// \param force if true, also strip away idle qubits occurring in the output permutation
-        void stripIdleQubits(bool force = false, bool reduceIOpermutations = true);
-
-        void import(const std::string& filename);
-        void import(const std::string& filename, Format format);
-        void import(std::istream& is, Format format) {
-            import(std::move(is), format);
-        }
-        void import(std::istream&& is, Format format);
-        void initializeIOMapping();
-        // append measurements to the end of the circuit according to the tracked output permutation
-        void appendMeasurementsAccordingToOutputPermutation(const std::string& registerName = "c");
-        // search for current position of target value in map and afterwards exchange it with the value at new position
-        static void findAndSWAP(Qubit targetValue, Qubit newPosition, Permutation& map) {
-            for (const auto& q: map) {
-                if (q.second == targetValue) {
-                    std::swap(map.at(newPosition), map.at(q.first));
-                    break;
-                }
-            }
-        }
-
-        // this function augments a given circuit by additional registers
-        void addQubitRegister(std::size_t, const std::string& regName = "q");
-        void addClassicalRegister(std::size_t nc, const std::string& regName = "c");
-        void addAncillaryRegister(std::size_t nq, const std::string& regName = "anc");
-        // a function to combine all quantum registers (qregs and ancregs) into a single register (useful for circuits mapped to a device)
-        void unifyQuantumRegisters(const std::string& regName = "q");
-
-        // removes a specific logical qubit and returns the index of the physical qubit in the initial layout
-        // as well as the index of the removed physical qubit's output permutation
-        // i.e., initialLayout[physical_qubit] = logical_qubit and outputPermutation[physicalQubit] = output_qubit
-        std::pair<Qubit, std::optional<Qubit>> removeQubit(Qubit logicalQubitIndex);
-
-        // adds physical qubit as ancillary qubit and gives it the appropriate output mapping
-        void addAncillaryQubit(Qubit physicalQubitIndex, std::optional<Qubit> outputQubitIndex);
-        // try to add logical qubit to circuit and assign it to physical qubit with certain output permutation value
-        void addQubit(Qubit logicalQubitIndex, Qubit physicalQubitIndex, std::optional<Qubit> outputQubitIndex);
-
-        void updateMaxControls(const std::size_t ncontrols) {
-            maxControls = std::max(ncontrols, maxControls);
-        }
-
-        void instantiate(const VariableAssignment& assignment);
-
-        void addVariable(const SymbolOrNumber& expr);
-
-        template<typename... Vars>
-        void addVariables(const Vars&... vars) {
-            (addVariable(vars), ...);
-        }
-
-        [[nodiscard]] bool isVariableFree() const {
-            return std::all_of(ops.begin(), ops.end(), [](const auto& op) { return !op->isSymbolicOperation(); });
-        }
-
-        [[nodiscard]] const std::unordered_set<sym::Variable>& getVariables() const {
-            return occuringVariables;
-        }
-
-        /**
-         * printing
-         */
-        virtual std::ostream& print(std::ostream& os) const;
-
-        friend std::ostream& operator<<(std::ostream& os, const QuantumComputation& qc) { return qc.print(os); }
-
-        static void printBin(std::size_t n, std::stringstream& ss);
-
-        virtual std::ostream& printStatistics(std::ostream& os) const;
-
-        std::ostream& printRegisters(std::ostream& os = std::cout) const;
-
-        static std::ostream& printPermutation(const Permutation& permutation, std::ostream& os = std::cout);
-
-        virtual void dump(const std::string& filename, Format format);
-        virtual void dump(const std::string& filename);
-        virtual void dump(std::ostream& of, Format format) {
-            dump(std::move(of), format);
-        }
-        virtual void dump(std::ostream&& of, Format format);
-        virtual void dumpOpenQASM(std::ostream& of);
-
-        // this convenience method allows to turn a circuit into a compound operation.
-        std::unique_ptr<CompoundOperation> asCompoundOperation() {
-            return std::make_unique<CompoundOperation>(getNqubits(), std::move(ops));
-        }
-
-        // this convenience method allows to turn a circuit into an operation.
-        std::unique_ptr<Operation> asOperation() {
-            if (ops.empty()) {
-                return {};
-            }
-            if (ops.size() == 1) {
-                auto op = std::move(ops.front());
-                ops.clear();
-                return op;
-            }
-            return asCompoundOperation();
-        }
-
-        virtual void reset() {
-            ops.clear();
-            nqubits   = 0;
-            nclassics = 0;
-            nancillae = 0;
-            qregs.clear();
-            cregs.clear();
-            ancregs.clear();
-            initialLayout.clear();
-            outputPermutation.clear();
-        }
-
-        /**
-         * Pass-Through
-         */
-
-        // Iterators (pass-through)
-        auto               begin() noexcept { return ops.begin(); }
-        [[nodiscard]] auto begin() const noexcept { return ops.begin(); }
-        [[nodiscard]] auto cbegin() const noexcept { return ops.cbegin(); }
-        auto               end() noexcept { return ops.end(); }
-        [[nodiscard]] auto end() const noexcept { return ops.end(); }
-        [[nodiscard]] auto cend() const noexcept { return ops.cend(); }
-        auto               rbegin() noexcept { return ops.rbegin(); }
-        [[nodiscard]] auto rbegin() const noexcept { return ops.rbegin(); }
-        [[nodiscard]] auto crbegin() const noexcept { return ops.crbegin(); }
-        auto               rend() noexcept { return ops.rend(); }
-        [[nodiscard]] auto rend() const noexcept { return ops.rend(); }
-        [[nodiscard]] auto crend() const noexcept { return ops.crend(); }
-
-        // Capacity (pass-through)
-        [[nodiscard]] bool        empty() const noexcept { return ops.empty(); }
-        [[nodiscard]] std::size_t size() const noexcept { return ops.size(); }
-        [[nodiscard]] std::size_t max_size() const noexcept { return ops.max_size(); } // NOLINT (readability-identifier-naming)
-        [[nodiscard]] std::size_t capacity() const noexcept { return ops.capacity(); }
-
-        void reserve(const std::size_t newCap) { ops.reserve(newCap); }
-        void shrink_to_fit() { ops.shrink_to_fit(); } // NOLINT (readability-identifier-naming)
-
-        // Modifiers (pass-through)
-        void     clear() noexcept { ops.clear(); }
-        void     pop_back() { return ops.pop_back(); } // NOLINT (readability-identifier-naming)
-        void     resize(std::size_t count) { ops.resize(count); }
-        iterator erase(const_iterator pos) { return ops.erase(pos); }
-        iterator erase(const_iterator first, const_iterator last) { return ops.erase(first, last); }
-
-        template<class T>
-        void push_back(const T& op) { // NOLINT (readability-identifier-naming)
-            if (!ops.empty() && !op.isControlled() && !ops.back()->isControlled()) {
-                std::cerr << op.getName() << std::endl;
-            }
-
-            ops.push_back(std::make_unique<T>(op));
-        }
-
-        template<class T, class... Args>
-        void emplace_back(Args&&... args) { // NOLINT (readability-identifier-naming)
-            ops.emplace_back(std::make_unique<T>(args...));
-        }
-
-        template<class T>
-        void emplace_back(std::unique_ptr<T>& op) { // NOLINT (readability-identifier-naming)
-            ops.emplace_back(std::move(op));
-        }
-
-        template<class T>
-        void emplace_back(std::unique_ptr<T>&& op) { // NOLINT (readability-identifier-naming)
-            ops.emplace_back(std::move(op));
-        }
-
-        template<class T>
-        iterator insert(const_iterator pos, T&& op) { return ops.insert(pos, std::forward<T>(op)); }
-
-        [[nodiscard]] const auto& at(const std::size_t i) const { return ops.at(i); }
-        [[nodiscard]] const auto& front() const { return ops.front(); }
-        [[nodiscard]] const auto& back() const { return ops.back(); }
-    };
+      }
+    }
+  }
+
+  template <class RegisterType>
+  static void createRegisterArray(const RegisterMap<RegisterType>& regs,
+                                  RegisterNames& regnames,
+                                  decltype(RegisterType::second) defaultnumber,
+                                  const std::string& defaultname) {
+    regnames.clear();
+
+    std::stringstream ss;
+    if (!regs.empty()) {
+      // sort regs by start index
+      std::map<decltype(RegisterType::first),
+               std::pair<std::string, RegisterType>>
+          sortedRegs{};
+      for (const auto& reg : regs) {
+        sortedRegs.insert({reg.second.first, reg});
+      }
+
+      for (const auto& reg : sortedRegs) {
+        for (decltype(RegisterType::second) i = 0; i < reg.second.second.second;
+             i++) {
+          ss << reg.second.first << "[" << i << "]";
+          regnames.push_back(std::make_pair(reg.second.first, ss.str()));
+          ss.str(std::string());
+        }
+      }
+    } else {
+      for (decltype(RegisterType::second) i = 0; i < defaultnumber; i++) {
+        ss << defaultname << "[" << i << "]";
+        regnames.emplace_back(defaultname, ss.str());
+        ss.str(std::string());
+      }
+    }
+  }
+
+  [[nodiscard]] std::size_t getSmallestAncillary() const {
+    for (std::size_t i = 0; i < ancillary.size(); ++i) {
+      if (ancillary[i]) {
+        return i;
+      }
+    }
+    return ancillary.size();
+  }
+
+  [[nodiscard]] std::size_t getSmallestGarbage() const {
+    for (std::size_t i = 0; i < garbage.size(); ++i) {
+      if (garbage[i]) {
+        return i;
+      }
+    }
+    return garbage.size();
+  }
+  [[nodiscard]] bool isLastOperationOnQubit(const const_iterator& opIt) const {
+    const auto end = ops.cend();
+    return isLastOperationOnQubit(opIt, end);
+  }
+  void checkQubitRange(Qubit qubit) const;
+  void checkQubitRange(Qubit qubit, const Controls& controls) const;
+  void checkQubitRange(Qubit qubit0, Qubit qubit1,
+                       const Controls& controls) const;
+  void checkQubitRange(const std::vector<Qubit>& qubits) const;
+
+public:
+  QuantumComputation() = default;
+  explicit QuantumComputation(const std::size_t nq, const std::size_t s = 0)
+      : seed(s) {
+    addQubitRegister(nq);
+    addClassicalRegister(nq);
+    if (seed != 0) {
+      mt.seed(seed);
+    } else {
+      // create and properly seed rng
+      std::array<std::mt19937_64::result_type, std::mt19937_64::state_size>
+          randomData{};
+      std::random_device rd;
+      std::generate(std::begin(randomData), std::end(randomData),
+                    [&rd]() { return rd(); });
+      std::seed_seq seeds(std::begin(randomData), std::end(randomData));
+      mt.seed(seeds);
+    }
+  }
+  explicit QuantumComputation(const std::string& filename,
+                              const std::size_t s = 0U)
+      : seed(s) {
+    import(filename);
+    if (seed != 0U) {
+      mt.seed(seed);
+    } else {
+      // create and properly seed rng
+      std::array<std::mt19937_64::result_type, std::mt19937_64::state_size>
+          randomData{};
+      std::random_device rd;
+      std::generate(std::begin(randomData), std::end(randomData),
+                    [&rd]() { return rd(); });
+      std::seed_seq seeds(std::begin(randomData), std::end(randomData));
+      mt.seed(seeds);
+    }
+  }
+  QuantumComputation(const QuantumComputation& qc) = delete;
+  QuantumComputation(QuantumComputation&& qc) noexcept = default;
+
+  QuantumComputation& operator=(const QuantumComputation& qc) = delete;
+
+  QuantumComputation& operator=(QuantumComputation&& qc) noexcept = default;
+
+  virtual ~QuantumComputation() = default;
+
+  [[nodiscard]] QuantumComputation clone() const {
+    auto qc = QuantumComputation(nqubits);
+    qc.nqubits = nqubits;
+    qc.nclassics = nclassics;
+    qc.nancillae = nancillae;
+    qc.maxControls = maxControls;
+    qc.name = name;
+    qc.qregs = qregs;
+    qc.cregs = cregs;
+    qc.ancregs = ancregs;
+    qc.initialLayout = initialLayout;
+    qc.outputPermutation = outputPermutation;
+    qc.ancillary = ancillary;
+    qc.garbage = garbage;
+    qc.seed = seed;
+    qc.mt = mt;
+    qc.occuringVariables = occuringVariables;
+    qc.globalPhase = globalPhase;
+
+    for (auto const& op : ops) {
+      qc.ops.emplace_back<>(op->clone());
+    }
+    return qc;
+  }
+
+  [[nodiscard]] virtual std::size_t getNops() const { return ops.size(); }
+  [[nodiscard]] std::size_t getNqubits() const { return nqubits + nancillae; }
+  [[nodiscard]] std::size_t getNancillae() const { return nancillae; }
+  [[nodiscard]] std::size_t getNqubitsWithoutAncillae() const {
+    return nqubits;
+  }
+  [[nodiscard]] std::size_t getNcbits() const { return nclassics; }
+  [[nodiscard]] std::string getName() const { return name; }
+  [[nodiscard]] const QuantumRegisterMap& getQregs() const { return qregs; }
+  [[nodiscard]] const ClassicalRegisterMap& getCregs() const { return cregs; }
+  [[nodiscard]] const QuantumRegisterMap& getANCregs() const { return ancregs; }
+  [[nodiscard]] decltype(mt)& getGenerator() { return mt; }
+
+  [[nodiscard]] fp getGlobalPhase() const { return globalPhase; }
+
+  void setName(const std::string& n) { name = n; }
+
+  // physical qubits are used as keys, logical qubits as values
+  Permutation initialLayout{};
+  Permutation outputPermutation{};
+
+  std::vector<bool> ancillary{};
+  std::vector<bool> garbage{};
+
+  [[nodiscard]] std::size_t getNindividualOps() const;
+  [[nodiscard]] std::size_t getNsingleQubitOps() const;
+  [[nodiscard]] std::size_t getDepth() const;
+
+  [[nodiscard]] std::string getQubitRegister(Qubit physicalQubitIndex) const;
+  [[nodiscard]] std::string getClassicalRegister(Bit classicalIndex) const;
+  [[gnu::pure]] static Qubit
+  getHighestLogicalQubitIndex(const Permutation& permutation);
+  [[nodiscard]] Qubit getHighestLogicalQubitIndex() const {
+    return getHighestLogicalQubitIndex(initialLayout);
+  };
+  [[nodiscard]] std::pair<std::string, Qubit>
+  getQubitRegisterAndIndex(Qubit physicalQubitIndex) const;
+  [[nodiscard]] std::pair<std::string, Bit>
+  getClassicalRegisterAndIndex(Bit classicalIndex) const;
+
+  [[nodiscard]] Qubit
+  getIndexFromQubitRegister(const std::pair<std::string, Qubit>& qubit) const;
+  [[nodiscard]] Bit getIndexFromClassicalRegister(
+      const std::pair<std::string, std::size_t>& clbit) const;
+  [[nodiscard]] bool isIdleQubit(Qubit physicalQubit) const;
+  [[nodiscard]] bool isLastOperationOnQubit(const const_iterator& opIt,
+                                            const const_iterator& end) const;
+  [[nodiscard, gnu::pure]] bool
+  physicalQubitIsAncillary(Qubit physicalQubitIndex) const;
+  [[nodiscard]] bool
+  logicalQubitIsAncillary(const Qubit logicalQubitIndex) const {
+    return ancillary[logicalQubitIndex];
+  }
+  void setLogicalQubitAncillary(const Qubit logicalQubitIndex) {
+    ancillary[logicalQubitIndex] = true;
+  }
+  [[nodiscard]] bool
+  logicalQubitIsGarbage(const Qubit logicalQubitIndex) const {
+    return garbage[logicalQubitIndex];
+  }
+  void setLogicalQubitGarbage(Qubit logicalQubitIndex);
+  [[nodiscard]] const std::vector<bool>& getAncillary() const {
+    return ancillary;
+  }
+  [[nodiscard]] const std::vector<bool>& getGarbage() const { return garbage; }
+
+  /// checks whether the given logical qubit exists in the initial layout.
+  /// \param logicalQubitIndex the logical qubit index to check
+  /// \return whether the given logical qubit exists in the initial layout and
+  /// to which physical qubit it is mapped
+  [[nodiscard, gnu::pure]] std::pair<bool, std::optional<Qubit>>
+  containsLogicalQubit(Qubit logicalQubitIndex) const;
+
+  /// Adds a global phase to the quantum circuit.
+  /// \param angle the angle to add
+  void gphase(const fp& angle) {
+    globalPhase += angle;
+    // normalize to [0, 2pi)
+    while (globalPhase < 0) {
+      globalPhase += 2 * PI;
+    }
+    while (globalPhase >= 2 * PI) {
+      globalPhase -= 2 * PI;
+    }
+  }
+
+  void i(const Qubit target) { i(target, Controls{}); }
+  void i(const Qubit target, const Control& control) {
+    i(target, Controls{control});
+  }
+  void i(const Qubit target, const Controls& controls) {
+    checkQubitRange(target, controls);
+    emplace_back<StandardOperation>(getNqubits(), controls, target, qc::I);
+  }
+
+  void h(const Qubit target) { h(target, Controls{}); }
+  void h(const Qubit target, const Control& control) {
+    h(target, Controls{control});
+  }
+  void h(const Qubit target, const Controls& controls) {
+    checkQubitRange(target, controls);
+    emplace_back<StandardOperation>(getNqubits(), controls, target, qc::H);
+  }
+
+  void x(const Qubit target) { x(target, Controls{}); }
+  void x(const Qubit target, const Control& control) {
+    x(target, Controls{control});
+  }
+  void x(const Qubit target, const Controls& controls) {
+    checkQubitRange(target, controls);
+    emplace_back<StandardOperation>(getNqubits(), controls, target, qc::X);
+  }
+
+  void y(const Qubit target) { y(target, Controls{}); }
+  void y(const Qubit target, const Control& control) {
+    y(target, Controls{control});
+  }
+  void y(const Qubit target, const Controls& controls) {
+    checkQubitRange(target, controls);
+    emplace_back<StandardOperation>(getNqubits(), controls, target, qc::Y);
+  }
+
+  void z(const Qubit target) { z(target, Controls{}); }
+  void z(const Qubit target, const Control& control) {
+    z(target, Controls{control});
+  }
+  void z(const Qubit target, const Controls& controls) {
+    checkQubitRange(target, controls);
+    emplace_back<StandardOperation>(getNqubits(), controls, target, qc::Z);
+  }
+
+  void s(const Qubit target) { s(target, Controls{}); }
+  void s(const Qubit target, const Control& control) {
+    s(target, Controls{control});
+  }
+  void s(const Qubit target, const Controls& controls) {
+    checkQubitRange(target, controls);
+    emplace_back<StandardOperation>(getNqubits(), controls, target, qc::S);
+  }
+
+  void sdag(const Qubit target) { sdag(target, Controls{}); }
+  void sdag(const Qubit target, const Control& control) {
+    sdag(target, Controls{control});
+  }
+  void sdag(const Qubit target, const Controls& controls) {
+    checkQubitRange(target, controls);
+    emplace_back<StandardOperation>(getNqubits(), controls, target, qc::Sdag);
+  }
+
+  void t(const Qubit target) { t(target, Controls{}); }
+  void t(const Qubit target, const Control& control) {
+    t(target, Controls{control});
+  }
+  void t(const Qubit target, const Controls& controls) {
+    checkQubitRange(target, controls);
+    emplace_back<StandardOperation>(getNqubits(), controls, target, qc::T);
+  }
+
+  void tdag(const Qubit target) { tdag(target, Controls{}); }
+  void tdag(const Qubit target, const Control& control) {
+    tdag(target, Controls{control});
+  }
+  void tdag(const Qubit target, const Controls& controls) {
+    checkQubitRange(target, controls);
+    emplace_back<StandardOperation>(getNqubits(), controls, target, qc::Tdag);
+  }
+
+  void v(const Qubit target) { v(target, Controls{}); }
+  void v(const Qubit target, const Control& control) {
+    v(target, Controls{control});
+  }
+  void v(const Qubit target, const Controls& controls) {
+    checkQubitRange(target, controls);
+    emplace_back<StandardOperation>(getNqubits(), controls, target, qc::V);
+  }
+
+  void vdag(const Qubit target) { vdag(target, Controls{}); }
+  void vdag(const Qubit target, const Control& control) {
+    vdag(target, Controls{control});
+  }
+  void vdag(const Qubit target, const Controls& controls) {
+    checkQubitRange(target, controls);
+    emplace_back<StandardOperation>(getNqubits(), controls, target, qc::Vdag);
+  }
+
+  void u3(const Qubit target, const fp theta, const fp phi, const fp lambda) {
+    u3(target, Controls{}, theta, phi, lambda);
+  }
+  void u3(const Qubit target, const Control& control, const fp theta,
+          const fp phi, const fp lambda) {
+    u3(target, Controls{control}, theta, phi, lambda);
+  }
+  void u3(const Qubit target, const Controls& controls, const fp theta,
+          const fp phi, const fp lambda) {
+    checkQubitRange(target, controls);
+    emplace_back<StandardOperation>(getNqubits(), controls, target, qc::U3,
+                                    std::vector{theta, phi, lambda});
+  }
+  void u3(const Qubit target, const SymbolOrNumber& theta,
+          const SymbolOrNumber& phi, const SymbolOrNumber& lambda) {
+    u3(target, Controls{}, theta, phi, lambda);
+  }
+  void u3(const Qubit target, const Control& control,
+          const SymbolOrNumber& theta, const SymbolOrNumber& phi,
+          const SymbolOrNumber& lambda) {
+    u3(target, Controls{control}, theta, phi, lambda);
+  }
+  void u3(const Qubit target, const Controls& controls,
+          const SymbolOrNumber& theta, const SymbolOrNumber& phi,
+          const SymbolOrNumber& lambda) {
+    checkQubitRange(target, controls);
+    addVariables(theta, phi, lambda);
+    emplace_back<SymbolicOperation>(getNqubits(), controls, target, qc::U3,
+                                    std::vector{theta, phi, lambda});
+  }
+
+  void u2(const Qubit target, const fp phi, const fp lambda) {
+    u2(target, Controls{}, phi, lambda);
+  }
+  void u2(const Qubit target, const Control& control, const fp phi,
+          const fp lambda) {
+    u2(target, Controls{control}, phi, lambda);
+  }
+  void u2(const Qubit target, const Controls& controls, const fp phi,
+          const fp lambda) {
+    checkQubitRange(target, controls);
+    emplace_back<StandardOperation>(getNqubits(), controls, target, qc::U2,
+                                    std::vector{phi, lambda});
+  }
+  void u2(const Qubit target, const SymbolOrNumber& phi,
+          const SymbolOrNumber& lambda) {
+    u2(target, Controls{}, phi, lambda);
+  }
+  void u2(const Qubit target, const Control& control, const SymbolOrNumber& phi,
+          const SymbolOrNumber& lambda) {
+    u2(target, Controls{control}, phi, lambda);
+  }
+  void u2(const Qubit target, const Controls& controls,
+          const SymbolOrNumber& phi, const SymbolOrNumber& lambda) {
+    checkQubitRange(target, controls);
+    addVariables(phi, lambda);
+    emplace_back<SymbolicOperation>(getNqubits(), controls, target, qc::U2,
+                                    std::vector{phi, lambda});
+  }
+
+  void phase(const Qubit target, const fp lambda) {
+    phase(target, Controls{}, lambda);
+  }
+  void phase(const Qubit target, const Control& control, const fp lambda) {
+    phase(target, Controls{control}, lambda);
+  }
+  void phase(const Qubit target, const Controls& controls, const fp lambda) {
+    checkQubitRange(target, controls);
+    emplace_back<StandardOperation>(getNqubits(), controls, target, qc::Phase,
+                                    std::vector{lambda});
+  }
+  void phase(const Qubit target, const SymbolOrNumber& lambda) {
+    phase(target, Controls{}, lambda);
+  }
+  void phase(const Qubit target, const Control& control,
+             const SymbolOrNumber& lambda) {
+    phase(target, Controls{control}, lambda);
+  }
+  void phase(const Qubit target, const Controls& controls,
+             const SymbolOrNumber& lambda) {
+    checkQubitRange(target, controls);
+    addVariables(lambda);
+    emplace_back<SymbolicOperation>(getNqubits(), controls, target, qc::Phase,
+                                    std::vector{lambda});
+  }
+
+  void sx(const Qubit target) { sx(target, Controls{}); }
+  void sx(const Qubit target, const Control& control) {
+    sx(target, Controls{control});
+  }
+  void sx(const Qubit target, const Controls& controls) {
+    checkQubitRange(target, controls);
+    emplace_back<StandardOperation>(getNqubits(), controls, target, qc::SX);
+  }
+
+  void sxdag(const Qubit target) { sxdag(target, Controls{}); }
+  void sxdag(const Qubit target, const Control& control) {
+    sxdag(target, Controls{control});
+  }
+  void sxdag(const Qubit target, const Controls& controls) {
+    checkQubitRange(target, controls);
+    emplace_back<StandardOperation>(getNqubits(), controls, target, qc::SXdag);
+  }
+
+  void rx(const Qubit target, const fp lambda) {
+    rx(target, Controls{}, lambda);
+  }
+  void rx(const Qubit target, const Control& control, const fp lambda) {
+    rx(target, Controls{control}, lambda);
+  }
+  void rx(const Qubit target, const Controls& controls, const fp lambda) {
+    checkQubitRange(target, controls);
+    emplace_back<StandardOperation>(getNqubits(), controls, target, qc::RX,
+                                    std::vector{lambda});
+  }
+  void rx(const Qubit target, const SymbolOrNumber& lambda) {
+    rx(target, Controls{}, lambda);
+  }
+  void rx(const Qubit target, const Control& control,
+          const SymbolOrNumber& lambda) {
+    rx(target, Controls{control}, lambda);
+  }
+  void rx(const Qubit target, const Controls& controls,
+          const SymbolOrNumber& lambda) {
+    checkQubitRange(target, controls);
+    addVariables(lambda);
+    emplace_back<SymbolicOperation>(getNqubits(), controls, target, qc::RX,
+                                    std::vector{lambda});
+  }
+
+  void ry(const Qubit target, const fp lambda) {
+    ry(target, Controls{}, lambda);
+  }
+  void ry(const Qubit target, const Control& control, const fp lambda) {
+    ry(target, Controls{control}, lambda);
+  }
+  void ry(const Qubit target, const Controls& controls, const fp lambda) {
+    checkQubitRange(target, controls);
+    emplace_back<StandardOperation>(getNqubits(), controls, target, qc::RY,
+                                    std::vector{lambda});
+  }
+  void ry(const Qubit target, const SymbolOrNumber& lambda) {
+    ry(target, Controls{}, lambda);
+  }
+  void ry(const Qubit target, const Control& control,
+          const SymbolOrNumber& lambda) {
+    ry(target, Controls{control}, lambda);
+  }
+  void ry(const Qubit target, const Controls& controls,
+          const SymbolOrNumber& lambda) {
+    checkQubitRange(target, controls);
+    addVariables(lambda);
+    emplace_back<SymbolicOperation>(getNqubits(), controls, target, qc::RY,
+                                    std::vector{lambda});
+  }
+
+  void rz(const Qubit target, const fp lambda) {
+    rz(target, Controls{}, lambda);
+  }
+  void rz(const Qubit target, const Control& control, const fp lambda) {
+    rz(target, Controls{control}, lambda);
+  }
+  void rz(const Qubit target, const Controls& controls, const fp lambda) {
+    checkQubitRange(target, controls);
+    emplace_back<StandardOperation>(getNqubits(), controls, target, qc::RZ,
+                                    std::vector{lambda});
+  }
+  void rz(const Qubit target, const SymbolOrNumber& lambda) {
+    rz(target, Controls{}, lambda);
+  }
+  void rz(const Qubit target, const Control& control,
+          const SymbolOrNumber& lambda) {
+    rz(target, Controls{control}, lambda);
+  }
+  void rz(const Qubit target, const Controls& controls,
+          const SymbolOrNumber& lambda) {
+    checkQubitRange(target, controls);
+    addVariables(lambda);
+    emplace_back<SymbolicOperation>(getNqubits(), controls, target, qc::RZ,
+                                    std::vector{lambda});
+  }
+
+  void swap(const Qubit target0, const Qubit target1) {
+    swap(target0, target1, Controls{});
+  }
+  void swap(const Qubit target0, const Qubit target1, const Control& control) {
+    swap(target0, target1, Controls{control});
+  }
+  void swap(const Qubit target0, const Qubit target1,
+            const Controls& controls) {
+    checkQubitRange(target0, target1, controls);
+    emplace_back<StandardOperation>(getNqubits(), controls, target0, target1,
+                                    qc::SWAP);
+  }
+
+  void iswap(const Qubit target0, const Qubit target1) {
+    iswap(target0, target1, Controls{});
+  }
+  void iswap(const Qubit target0, const Qubit target1, const Control& control) {
+    iswap(target0, target1, Controls{control});
+  }
+  void iswap(const Qubit target0, const Qubit target1,
+             const Controls& controls) {
+    checkQubitRange(target0, target1, controls);
+    emplace_back<StandardOperation>(getNqubits(), controls, target0, target1,
+                                    qc::iSWAP);
+  }
+
+  void peres(const Qubit target0, const Qubit target1) {
+    peres(target0, target1, Controls{});
+  }
+  void peres(const Qubit target0, const Qubit target1, const Control& control) {
+    peres(target0, target1, Controls{control});
+  }
+  void peres(const Qubit target0, const Qubit target1,
+             const Controls& controls) {
+    checkQubitRange(target0, target1, controls);
+    emplace_back<StandardOperation>(getNqubits(), controls, target0, target1,
+                                    qc::Peres);
+  }
+
+  void peresdag(const Qubit target0, const Qubit target1) {
+    peresdag(target0, target1, Controls{});
+  }
+  void peresdag(const Qubit target0, const Qubit target1,
+                const Control& control) {
+    peresdag(target0, target1, Controls{control});
+  }
+  void peresdag(const Qubit target0, const Qubit target1,
+                const Controls& controls) {
+    checkQubitRange(target0, target1, controls);
+    emplace_back<StandardOperation>(getNqubits(), controls, target0, target1,
+                                    qc::Peresdag);
+  }
+
+  void dcx(const Qubit target0, const Qubit target1) {
+    dcx(target0, target1, Controls{});
+  }
+  void dcx(const Qubit target0, const Qubit target1, const Control& control) {
+    dcx(target0, target1, Controls{control});
+  }
+  void dcx(const Qubit target0, const Qubit target1, const Controls& controls) {
+    checkQubitRange(target0, target1, controls);
+    emplace_back<StandardOperation>(getNqubits(), controls, target0, target1,
+                                    qc::DCX);
+  }
+
+  void ecr(const Qubit target0, const Qubit target1) {
+    ecr(target0, target1, Controls{});
+  }
+  void ecr(const Qubit target0, const Qubit target1, const Control& control) {
+    ecr(target0, target1, Controls{control});
+  }
+  void ecr(const Qubit target0, const Qubit target1, const Controls& controls) {
+    checkQubitRange(target0, target1, controls);
+    emplace_back<StandardOperation>(getNqubits(), controls, target0, target1,
+                                    qc::ECR);
+  }
+
+  void rxx(const Qubit target0, const Qubit target1, const fp theta) {
+    rxx(target0, target1, Controls{}, theta);
+  }
+  void rxx(const Qubit target0, const Qubit target1, const Control& control,
+           const fp theta) {
+    rxx(target0, target1, Controls{control}, theta);
+  }
+  void rxx(const Qubit target0, const Qubit target1, const Controls& controls,
+           const fp theta) {
+    checkQubitRange(target0, target1, controls);
+    emplace_back<StandardOperation>(getNqubits(), controls, target0, target1,
+                                    qc::RXX, std::vector{theta});
+  }
+  void rxx(const Qubit target0, const Qubit target1,
+           const SymbolOrNumber& theta) {
+    rxx(target0, target1, Controls{}, theta);
+  }
+  void rxx(const Qubit target0, const Qubit target1, const Control& control,
+           const SymbolOrNumber& theta) {
+    rxx(target0, target1, Controls{control}, theta);
+  }
+  void rxx(const Qubit target0, const Qubit target1, const Controls& controls,
+           const SymbolOrNumber& theta) {
+    checkQubitRange(target0, target1, controls);
+    addVariables(theta);
+    emplace_back<SymbolicOperation>(getNqubits(), controls, target0, target1,
+                                    qc::RXX, std::vector{theta});
+  }
+
+  void ryy(const Qubit target0, const Qubit target1, const fp theta) {
+    ryy(target0, target1, Controls{}, theta);
+  }
+  void ryy(const Qubit target0, const Qubit target1, const Control& control,
+           const fp theta) {
+    ryy(target0, target1, Controls{control}, theta);
+  }
+  void ryy(const Qubit target0, const Qubit target1, const Controls& controls,
+           const fp theta) {
+    checkQubitRange(target0, target1, controls);
+    emplace_back<StandardOperation>(getNqubits(), controls, target0, target1,
+                                    qc::RYY, std::vector{theta});
+  }
+  void ryy(const Qubit target0, const Qubit target1,
+           const SymbolOrNumber& theta) {
+    ryy(target0, target1, Controls{}, theta);
+  }
+  void ryy(const Qubit target0, const Qubit target1, const Control& control,
+           const SymbolOrNumber& theta) {
+    ryy(target0, target1, Controls{control}, theta);
+  }
+  void ryy(const Qubit target0, const Qubit target1, const Controls& controls,
+           const SymbolOrNumber& theta) {
+    checkQubitRange(target0, target1, controls);
+    addVariables(theta);
+    emplace_back<SymbolicOperation>(getNqubits(), controls, target0, target1,
+                                    qc::RYY, std::vector{theta});
+  }
+
+  void rzz(const Qubit target0, const Qubit target1, const fp theta) {
+    rzz(target0, target1, Controls{}, theta);
+  }
+  void rzz(const Qubit target0, const Qubit target1, const Control& control,
+           const fp theta) {
+    rzz(target0, target1, Controls{control}, theta);
+  }
+  void rzz(const Qubit target0, const Qubit target1, const Controls& controls,
+           const fp theta) {
+    checkQubitRange(target0, target1, controls);
+    emplace_back<StandardOperation>(getNqubits(), controls, target0, target1,
+                                    qc::RZZ, std::vector{theta});
+  }
+  void rzz(const Qubit target0, const Qubit target1,
+           const SymbolOrNumber& theta) {
+    rzz(target0, target1, Controls{}, theta);
+  }
+  void rzz(const Qubit target0, const Qubit target1, const Control& control,
+           const SymbolOrNumber& theta) {
+    rzz(target0, target1, Controls{control}, theta);
+  }
+  void rzz(const Qubit target0, const Qubit target1, const Controls& controls,
+           const SymbolOrNumber& theta) {
+    checkQubitRange(target0, target1, controls);
+    addVariables(theta);
+    emplace_back<SymbolicOperation>(getNqubits(), controls, target0, target1,
+                                    qc::RZZ, std::vector{theta});
+  }
+
+  void rzx(const Qubit target0, const Qubit target1, const fp theta) {
+    rzx(target0, target1, Controls{}, theta);
+  }
+  void rzx(const Qubit target0, const Qubit target1, const Control& control,
+           const fp theta) {
+    rzx(target0, target1, Controls{control}, theta);
+  }
+  void rzx(const Qubit target0, const Qubit target1, const Controls& controls,
+           const fp theta) {
+    checkQubitRange(target0, target1, controls);
+    emplace_back<StandardOperation>(getNqubits(), controls, target0, target1,
+                                    qc::RZX, std::vector{theta});
+  }
+  void rzx(const Qubit target0, const Qubit target1,
+           const SymbolOrNumber& theta) {
+    rzx(target0, target1, Controls{}, theta);
+  }
+  void rzx(const Qubit target0, const Qubit target1, const Control& control,
+           const SymbolOrNumber& theta) {
+    rzx(target0, target1, Controls{control}, theta);
+  }
+  void rzx(const Qubit target0, const Qubit target1, const Controls& controls,
+           const SymbolOrNumber& theta) {
+    checkQubitRange(target0, target1, controls);
+    addVariables(theta);
+    emplace_back<SymbolicOperation>(getNqubits(), controls, target0, target1,
+                                    qc::RZX, std::vector{theta});
+  }
+
+  // NOLINTBEGIN(readability-identifier-naming)
+  void xx_minus_yy(const Qubit target0, const Qubit target1, const fp theta,
+                   const fp beta) {
+    xx_minus_yy(target0, target1, Controls{}, theta, beta);
+  }
+  void xx_minus_yy(const Qubit target0, const Qubit target1,
+                   const Control& control, const fp theta, const fp beta) {
+    xx_minus_yy(target0, target1, Controls{control}, theta, beta);
+  }
+  void xx_minus_yy(const Qubit target0, const Qubit target1,
+                   const Controls& controls, const fp theta, const fp beta) {
+    checkQubitRange(target0, target1, controls);
+    emplace_back<StandardOperation>(getNqubits(), controls, target0, target1,
+                                    qc::XXminusYY, std::vector{theta, beta});
+  }
+  void xx_minus_yy(const Qubit target0, const Qubit target1,
+                   const SymbolOrNumber& theta, const SymbolOrNumber& beta) {
+    xx_minus_yy(target0, target1, Controls{}, theta, beta);
+  }
+  void xx_minus_yy(const Qubit target0, const Qubit target1,
+                   const Control& control, const SymbolOrNumber& theta,
+                   const SymbolOrNumber& beta) {
+    xx_minus_yy(target0, target1, Controls{control}, theta, beta);
+  }
+  void xx_minus_yy(const Qubit target0, const Qubit target1,
+                   const Controls& controls, const SymbolOrNumber& theta,
+                   const SymbolOrNumber& beta) {
+    checkQubitRange(target0, target1, controls);
+    addVariables(theta, beta);
+    emplace_back<SymbolicOperation>(getNqubits(), controls, target0, target1,
+                                    qc::XXminusYY, std::vector{theta, beta});
+  }
+
+  void xx_plus_yy(const Qubit target0, const Qubit target1, const fp theta,
+                  const fp beta) {
+    xx_plus_yy(target0, target1, Controls{}, theta, beta);
+  }
+  void xx_plus_yy(const Qubit target0, const Qubit target1,
+                  const Control& control, const fp theta, const fp beta) {
+    xx_plus_yy(target0, target1, Controls{control}, theta, beta);
+  }
+  void xx_plus_yy(const Qubit target0, const Qubit target1,
+                  const Controls& controls, const fp theta, const fp beta) {
+    checkQubitRange(target0, target1, controls);
+    emplace_back<StandardOperation>(getNqubits(), controls, target0, target1,
+                                    qc::XXplusYY, std::vector{theta, beta});
+  }
+  void xx_plus_yy(const Qubit target0, const Qubit target1,
+                  const SymbolOrNumber& theta, const SymbolOrNumber& beta) {
+    xx_plus_yy(target0, target1, Controls{}, theta, beta);
+  }
+  void xx_plus_yy(const Qubit target0, const Qubit target1,
+                  const Control& control, const SymbolOrNumber& theta,
+                  const SymbolOrNumber& beta) {
+    xx_plus_yy(target0, target1, Controls{control}, theta, beta);
+  }
+  void xx_plus_yy(const Qubit target0, const Qubit target1,
+                  const Controls& controls, const SymbolOrNumber& theta,
+                  const SymbolOrNumber& beta) {
+    checkQubitRange(target0, target1, controls);
+    addVariables(theta, beta);
+    emplace_back<SymbolicOperation>(getNqubits(), controls, target0, target1,
+                                    qc::XXplusYY, std::vector{theta, beta});
+  }
+  // NOLINTEND(readability-identifier-naming)
+
+  void measure(const Qubit qubit, const std::size_t clbit) {
+    checkQubitRange(qubit);
+    emplace_back<NonUnitaryOperation>(getNqubits(), qubit, clbit);
+  }
+
+  void measure(const Qubit qubit, const std::pair<std::string, Bit>& clbit) {
+    checkQubitRange(qubit);
+    if (const auto cRegister = cregs.find(clbit.first);
+        cRegister != cregs.end()) {
+      if (clbit.second >= cRegister->second.second) {
+        std::cerr << "The classical register \"" << clbit.first
+                  << "\" is too small!" << std::endl;
+      }
+      emplace_back<NonUnitaryOperation>(getNqubits(), qubit,
+                                        cRegister->second.first + clbit.second);
+
+    } else {
+      std::cerr << "The classical register \"" << clbit.first
+                << "\" does not exist!" << std::endl;
+    }
+  }
+
+  void measure(const std::vector<Qubit>& qubitRegister,
+               const std::vector<Bit>& classicalRegister) {
+    checkQubitRange(qubitRegister);
+    emplace_back<NonUnitaryOperation>(getNqubits(), qubitRegister,
+                                      classicalRegister);
+  }
+
+  void reset(const Qubit target) {
+    checkQubitRange(target);
+    emplace_back<NonUnitaryOperation>(getNqubits(), std::vector<Qubit>{target},
+                                      qc::Reset);
+  }
+  void reset(const std::vector<Qubit>& targets) {
+    checkQubitRange(targets);
+    emplace_back<NonUnitaryOperation>(getNqubits(), targets, qc::Reset);
+  }
+
+  void barrier(const Qubit target) {
+    checkQubitRange(target);
+    emplace_back<NonUnitaryOperation>(getNqubits(), std::vector<Qubit>{target},
+                                      qc::Barrier);
+  }
+  void barrier(const std::vector<Qubit>& targets) {
+    checkQubitRange(targets);
+    emplace_back<NonUnitaryOperation>(getNqubits(), targets, qc::Barrier);
+  }
+
+  void classicControlled(const OpType op, const Qubit target,
+                         const ClassicalRegister& controlRegister,
+                         const std::uint64_t expectedValue = 1U,
+                         const std::vector<fp>& params = {}) {
+    classicControlled(op, target, Controls{}, controlRegister, expectedValue,
+                      params);
+  }
+  void classicControlled(const OpType op, const Qubit target,
+                         const Control control,
+                         const ClassicalRegister& controlRegister,
+                         const std::uint64_t expectedValue = 1U,
+                         const std::vector<fp>& params = {}) {
+    classicControlled(op, target, Controls{control}, controlRegister,
+                      expectedValue, params);
+  }
+  void classicControlled(const OpType op, const Qubit target,
+                         const Controls& controls,
+                         const ClassicalRegister& controlRegister,
+                         const std::uint64_t expectedValue = 1U,
+                         const std::vector<fp>& params = {}) {
+    checkQubitRange(target, controls);
+    std::unique_ptr<Operation> gate = std::make_unique<StandardOperation>(
+        getNqubits(), controls, target, op, params);
+    emplace_back<ClassicControlledOperation>(std::move(gate), controlRegister,
+                                             expectedValue);
+  }
+
+  /// strip away qubits with no operations applied to them and which do not pop
+  /// up in the output permutation \param force if true, also strip away idle
+  /// qubits occurring in the output permutation
+  void stripIdleQubits(bool force = false, bool reduceIOpermutations = true);
+
+  void import(const std::string& filename);
+  void import(const std::string& filename, Format format);
+  void import(std::istream& is, Format format) {
+    import(std::move(is), format);
+  }
+  void import(std::istream&& is, Format format);
+  void initializeIOMapping();
+  // append measurements to the end of the circuit according to the tracked
+  // output permutation
+  void appendMeasurementsAccordingToOutputPermutation(
+      const std::string& registerName = "c");
+  // search for current position of target value in map and afterwards exchange
+  // it with the value at new position
+  static void findAndSWAP(Qubit targetValue, Qubit newPosition,
+                          Permutation& map) {
+    for (const auto& q : map) {
+      if (q.second == targetValue) {
+        std::swap(map.at(newPosition), map.at(q.first));
+        break;
+      }
+    }
+  }
+
+  // this function augments a given circuit by additional registers
+  void addQubitRegister(std::size_t, const std::string& regName = "q");
+  void addClassicalRegister(std::size_t nc, const std::string& regName = "c");
+  void addAncillaryRegister(std::size_t nq, const std::string& regName = "anc");
+  // a function to combine all quantum registers (qregs and ancregs) into a
+  // single register (useful for circuits mapped to a device)
+  void unifyQuantumRegisters(const std::string& regName = "q");
+
+  // removes a specific logical qubit and returns the index of the physical
+  // qubit in the initial layout as well as the index of the removed physical
+  // qubit's output permutation i.e., initialLayout[physical_qubit] =
+  // logical_qubit and outputPermutation[physicalQubit] = output_qubit
+  std::pair<Qubit, std::optional<Qubit>> removeQubit(Qubit logicalQubitIndex);
+
+  // adds physical qubit as ancillary qubit and gives it the appropriate output
+  // mapping
+  void addAncillaryQubit(Qubit physicalQubitIndex,
+                         std::optional<Qubit> outputQubitIndex);
+  // try to add logical qubit to circuit and assign it to physical qubit with
+  // certain output permutation value
+  void addQubit(Qubit logicalQubitIndex, Qubit physicalQubitIndex,
+                std::optional<Qubit> outputQubitIndex);
+
+  void updateMaxControls(const std::size_t ncontrols) {
+    maxControls = std::max(ncontrols, maxControls);
+  }
+
+  void instantiate(const VariableAssignment& assignment);
+
+  void addVariable(const SymbolOrNumber& expr);
+
+  template <typename... Vars> void addVariables(const Vars&... vars) {
+    (addVariable(vars), ...);
+  }
+
+  [[nodiscard]] bool isVariableFree() const {
+    return std::all_of(ops.begin(), ops.end(), [](const auto& op) {
+      return !op->isSymbolicOperation();
+    });
+  }
+
+  [[nodiscard]] const std::unordered_set<sym::Variable>& getVariables() const {
+    return occuringVariables;
+  }
+
+  /**
+   * printing
+   */
+  virtual std::ostream& print(std::ostream& os) const;
+
+  friend std::ostream& operator<<(std::ostream& os,
+                                  const QuantumComputation& qc) {
+    return qc.print(os);
+  }
+
+  static void printBin(std::size_t n, std::stringstream& ss);
+
+  virtual std::ostream& printStatistics(std::ostream& os) const;
+
+  std::ostream& printRegisters(std::ostream& os = std::cout) const;
+
+  static std::ostream& printPermutation(const Permutation& permutation,
+                                        std::ostream& os = std::cout);
+
+  virtual void dump(const std::string& filename, Format format);
+  virtual void dump(const std::string& filename);
+  virtual void dump(std::ostream& of, Format format) {
+    dump(std::move(of), format);
+  }
+  virtual void dump(std::ostream&& of, Format format);
+  virtual void dumpOpenQASM(std::ostream& of);
+
+  // this convenience method allows to turn a circuit into a compound operation.
+  std::unique_ptr<CompoundOperation> asCompoundOperation() {
+    return std::make_unique<CompoundOperation>(getNqubits(), std::move(ops));
+  }
+
+  // this convenience method allows to turn a circuit into an operation.
+  std::unique_ptr<Operation> asOperation() {
+    if (ops.empty()) {
+      return {};
+    }
+    if (ops.size() == 1) {
+      auto op = std::move(ops.front());
+      ops.clear();
+      return op;
+    }
+    return asCompoundOperation();
+  }
+
+  virtual void reset() {
+    ops.clear();
+    nqubits = 0;
+    nclassics = 0;
+    nancillae = 0;
+    qregs.clear();
+    cregs.clear();
+    ancregs.clear();
+    initialLayout.clear();
+    outputPermutation.clear();
+  }
+
+  /**
+   * Pass-Through
+   */
+
+  // Iterators (pass-through)
+  auto begin() noexcept { return ops.begin(); }
+  [[nodiscard]] auto begin() const noexcept { return ops.begin(); }
+  [[nodiscard]] auto cbegin() const noexcept { return ops.cbegin(); }
+  auto end() noexcept { return ops.end(); }
+  [[nodiscard]] auto end() const noexcept { return ops.end(); }
+  [[nodiscard]] auto cend() const noexcept { return ops.cend(); }
+  auto rbegin() noexcept { return ops.rbegin(); }
+  [[nodiscard]] auto rbegin() const noexcept { return ops.rbegin(); }
+  [[nodiscard]] auto crbegin() const noexcept { return ops.crbegin(); }
+  auto rend() noexcept { return ops.rend(); }
+  [[nodiscard]] auto rend() const noexcept { return ops.rend(); }
+  [[nodiscard]] auto crend() const noexcept { return ops.crend(); }
+
+  // Capacity (pass-through)
+  [[nodiscard]] bool empty() const noexcept { return ops.empty(); }
+  [[nodiscard]] std::size_t size() const noexcept { return ops.size(); }
+  // NOLINTNEXTLINE(readability-identifier-naming)
+  [[nodiscard]] std::size_t max_size() const noexcept { return ops.max_size(); }
+  [[nodiscard]] std::size_t capacity() const noexcept { return ops.capacity(); }
+
+  void reserve(const std::size_t newCap) { ops.reserve(newCap); }
+  // NOLINTNEXTLINE(readability-identifier-naming)
+  void shrink_to_fit() { ops.shrink_to_fit(); }
+
+  // Modifiers (pass-through)
+  void clear() noexcept { ops.clear(); }
+  // NOLINTNEXTLINE(readability-identifier-naming)
+  void pop_back() { return ops.pop_back(); }
+  void resize(std::size_t count) { ops.resize(count); }
+  iterator erase(const_iterator pos) { return ops.erase(pos); }
+  iterator erase(const_iterator first, const_iterator last) {
+    return ops.erase(first, last);
+  }
+
+  // NOLINTNEXTLINE(readability-identifier-naming)
+  template <class T> void push_back(const T& op) {
+    if (!ops.empty() && !op.isControlled() && !ops.back()->isControlled()) {
+      std::cerr << op.getName() << std::endl;
+    }
+
+    ops.push_back(std::make_unique<T>(op));
+  }
+
+  // NOLINTNEXTLINE(readability-identifier-naming)
+  template <class T, class... Args> void emplace_back(Args&&... args) {
+    ops.emplace_back(std::make_unique<T>(args...));
+  }
+
+  // NOLINTNEXTLINE(readability-identifier-naming)
+  template <class T> void emplace_back(std::unique_ptr<T>& op) {
+    ops.emplace_back(std::move(op));
+  }
+
+  // NOLINTNEXTLINE(readability-identifier-naming)
+  template <class T> void emplace_back(std::unique_ptr<T>&& op) {
+    ops.emplace_back(std::move(op));
+  }
+
+  template <class T> iterator insert(const_iterator pos, T&& op) {
+    return ops.insert(pos, std::forward<T>(op));
+  }
+
+  [[nodiscard]] const auto& at(const std::size_t i) const { return ops.at(i); }
+  [[nodiscard]] const auto& front() const { return ops.front(); }
+  [[nodiscard]] const auto& back() const { return ops.back(); }
+};
 } // namespace qc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/include/algorithms/GoogleRandomCircuitSampling.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/algorithms/GoogleRandomCircuitSampling.hpp`

 * *Files 23% similar despite different names*

```diff
@@ -1,49 +1,49 @@
-/*
- * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
- */
-
 #pragma once
 
 #include <QuantumComputation.hpp>
 #include <chrono>
 
 namespace qc {
-    enum Layout { Rectangular,
-                  Bristlecone };
+enum Layout { Rectangular, Bristlecone };
 
-    class GoogleRandomCircuitSampling: public QuantumComputation {
-    public:
-        std::vector<std::vector<std::unique_ptr<Operation>>> cycles{};
-        Layout                                               layout     = Rectangular;
-        std::string                                          pathPrefix = "../../../Benchmarks/GoogleRandomCircuitSampling/inst/";
-
-        explicit GoogleRandomCircuitSampling(const std::string& filename);
-
-        GoogleRandomCircuitSampling(std::string prefix, std::uint16_t device, std::uint16_t depth, std::uint16_t instance);
-
-        GoogleRandomCircuitSampling(std::string prefix, std::uint16_t x, std::uint16_t y, std::uint16_t depth, std::uint16_t instance);
-
-        void importGRCS(const std::string& filename);
-
-        [[nodiscard, gnu::pure]] size_t getNops() const override;
-
-        std::ostream& print(std::ostream& os) const override;
-
-        std::ostream& printStatistics(std::ostream& os) const override;
-
-        void removeCycles(const std::size_t ncycles) {
-            if (ncycles > cycles.size() - 2) {
-                std::stringstream ss{};
-                ss << "Cannot remove " << ncycles << " cycles out of a circuit containing 1+" << cycles.size() - 2 << "+1 cycles.";
-                throw QFRException(ss.str());
-            }
-            auto last = std::move(cycles.back());
-            cycles.pop_back();
-            for (std::size_t i = 0; i < ncycles; ++i) {
-                cycles.pop_back();
-            }
-            cycles.emplace_back(std::move(last));
-        }
-    };
+class GoogleRandomCircuitSampling : public QuantumComputation {
+public:
+  std::vector<std::vector<std::unique_ptr<Operation>>> cycles{};
+  Layout layout = Rectangular;
+  std::string pathPrefix =
+      "../../../Benchmarks/GoogleRandomCircuitSampling/inst/";
+
+  explicit GoogleRandomCircuitSampling(const std::string& filename);
+
+  GoogleRandomCircuitSampling(std::string prefix, std::uint16_t device,
+                              std::uint16_t depth, std::uint16_t instance);
+
+  GoogleRandomCircuitSampling(std::string prefix, std::uint16_t x,
+                              std::uint16_t y, std::uint16_t depth,
+                              std::uint16_t instance);
+
+  void importGRCS(const std::string& filename);
+
+  [[nodiscard, gnu::pure]] size_t getNops() const override;
+
+  std::ostream& print(std::ostream& os) const override;
+
+  std::ostream& printStatistics(std::ostream& os) const override;
+
+  void removeCycles(const std::size_t ncycles) {
+    if (ncycles > cycles.size() - 2) {
+      std::stringstream ss{};
+      ss << "Cannot remove " << ncycles
+         << " cycles out of a circuit containing 1+" << cycles.size() - 2
+         << "+1 cycles.";
+      throw QFRException(ss.str());
+    }
+    auto last = std::move(cycles.back());
+    cycles.pop_back();
+    for (std::size_t i = 0; i < ncycles; ++i) {
+      cycles.pop_back();
+    }
+    cycles.emplace_back(std::move(last));
+  }
+};
 } // namespace qc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/include/dd/FunctionalityConstruction.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/dd/FunctionalityConstruction.hpp`

 * *Files 24% similar despite different names*

```diff
@@ -1,51 +1,57 @@
-/*
-* This file is part of MQT QFR library which is released under the MIT license.
-* See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
-*/
-
 #pragma once
 
 #include "QuantumComputation.hpp"
 #include "algorithms/GoogleRandomCircuitSampling.hpp"
 #include "algorithms/Grover.hpp"
 #include "dd/Operations.hpp"
 
 namespace dd {
-    using namespace qc;
-
-    template<class Config>
-    MatrixDD buildFunctionality(const QuantumComputation* qc, std::unique_ptr<dd::Package<Config>>& dd);
-
-    template<class Config>
-    MatrixDD buildFunctionalityRecursive(const QuantumComputation* qc, std::unique_ptr<dd::Package<Config>>& dd);
+using namespace qc;
 
-    template<class Config>
-    bool buildFunctionalityRecursive(const QuantumComputation* qc, std::size_t depth, std::size_t opIdx, std::stack<MatrixDD>& s, Permutation& permutation, std::unique_ptr<dd::Package<Config>>& dd);
-
-    template<class Config>
-    MatrixDD buildFunctionality(const qc::Grover* qc, std::unique_ptr<dd::Package<Config>>& dd);
-
-    template<class Config>
-    MatrixDD buildFunctionalityRecursive(const qc::Grover* qc, std::unique_ptr<dd::Package<Config>>& dd);
-
-    template<class DDPackage>
-    MatrixDD buildFunctionality(GoogleRandomCircuitSampling* qc, std::unique_ptr<DDPackage>& dd, std::optional<std::size_t> ncycles = std::nullopt);
-
-    inline void dumpTensorNetwork(std::ostream& of, const QuantumComputation& qc) {
-        of << "{\"tensors\": [\n";
-
-        // initialize an index for every qubit
-        auto        inds    = std::vector<std::size_t>(qc.getNqubits(), 0U);
-        std::size_t gateIdx = 0U;
-        auto        dd      = std::make_unique<dd::Package<>>(qc.getNqubits());
-        for (const auto& op: qc) {
-            const auto type = op->getType();
-            if (op != qc.front() && (type != Measure && type != Barrier && type != ShowProbabilities && type != Snapshot)) {
-                of << ",\n";
-            }
-            dumpTensor(op.get(), of, inds, gateIdx, dd);
-        }
-        of << "\n]}\n";
+template <class Config>
+MatrixDD buildFunctionality(const QuantumComputation* qc,
+                            std::unique_ptr<dd::Package<Config>>& dd);
+
+template <class Config>
+MatrixDD buildFunctionalityRecursive(const QuantumComputation* qc,
+                                     std::unique_ptr<dd::Package<Config>>& dd);
+
+template <class Config>
+bool buildFunctionalityRecursive(const QuantumComputation* qc,
+                                 std::size_t depth, std::size_t opIdx,
+                                 std::stack<MatrixDD>& s,
+                                 Permutation& permutation,
+                                 std::unique_ptr<dd::Package<Config>>& dd);
+
+template <class Config>
+MatrixDD buildFunctionality(const qc::Grover* qc,
+                            std::unique_ptr<dd::Package<Config>>& dd);
+
+template <class Config>
+MatrixDD buildFunctionalityRecursive(const qc::Grover* qc,
+                                     std::unique_ptr<dd::Package<Config>>& dd);
+
+template <class DDPackage>
+MatrixDD buildFunctionality(GoogleRandomCircuitSampling* qc,
+                            std::unique_ptr<DDPackage>& dd,
+                            std::optional<std::size_t> ncycles = std::nullopt);
+
+inline void dumpTensorNetwork(std::ostream& of, const QuantumComputation& qc) {
+  of << "{\"tensors\": [\n";
+
+  // initialize an index for every qubit
+  auto inds = std::vector<std::size_t>(qc.getNqubits(), 0U);
+  std::size_t gateIdx = 0U;
+  auto dd = std::make_unique<dd::Package<>>(qc.getNqubits());
+  for (const auto& op : qc) {
+    const auto type = op->getType();
+    if (op != qc.front() && (type != Measure && type != Barrier &&
+                             type != ShowProbabilities && type != Snapshot)) {
+      of << ",\n";
     }
+    dumpTensor(op.get(), of, inds, gateIdx, dd);
+  }
+  of << "\n]}\n";
+}
 
 } // namespace dd
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/include/dd/NoiseFunctionality.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/dd/NoiseFunctionality.hpp`

 * *Files 13% similar despite different names*

```diff
@@ -1,696 +1,780 @@
-/*
-* This file is part of the MQT DD Package which is released under the MIT license.
-* See file README.md or go to https://www.cda.cit.tum.de/research/quantum_dd/ for more information.
-*/
-
 #pragma once
 
 #include "dd/Definitions.hpp"
 #include "dd/Export.hpp"
 #include "dd/Operations.hpp"
 #include "dd/Package.hpp"
 #include "operations/OpType.hpp"
 #include "operations/Operation.hpp"
 
 #include <random>
 #include <utility>
 
-using CN           = dd::ComplexNumbers;
-using ArrayOfEdges = std::array<qc::DensityMatrixDD, std::tuple_size_v<decltype(dd::dNode::e)>>;
+using CN = dd::ComplexNumbers;
+using ArrayOfEdges =
+    std::array<qc::DensityMatrixDD, std::tuple_size_v<decltype(dd::dNode::e)>>;
 
 namespace dd {
 
-    // noise operations available for deterministic noise aware quantum circuit simulation
-    enum NoiseOperations : std::uint8_t {
-        AmplitudeDamping,
-        PhaseFlip,
-        Depolarization,
-        Identity
-    };
-
-    template<class Config>
-    class StochasticNoiseFunctionality {
-    public:
-        StochasticNoiseFunctionality(const std::unique_ptr<dd::Package<Config>>& dd,
-                                     dd::QubitCount                              nq,
-                                     double                                      gateNoiseProbability,
-                                     double                                      amplitudeDampingProb,
-                                     double                                      multiQubitGateFactor,
-                                     std::vector<dd::NoiseOperations>            effects):
-            package(dd),
-            nQubits(nq),
-            dist(0.0, 1.0L),
-            noiseProbability(gateNoiseProbability),
-            noiseProbabilityMulti(gateNoiseProbability * multiQubitGateFactor),
-            sqrtAmplitudeDampingProbability({std::sqrt(amplitudeDampingProb), 0}),
-            oneMinusSqrtAmplitudeDampingProbability({std::sqrt(1 - amplitudeDampingProb), 0}),
-            sqrtAmplitudeDampingProbabilityMulti({std::sqrt(gateNoiseProbability) * multiQubitGateFactor, 0}),
-            oneMinusSqrtAmplitudeDampingProbabilityMulti({std::sqrt(1 - multiQubitGateFactor * amplitudeDampingProb), 0}),
-            ampDampingTrue(dd::GateMatrix({dd::complex_zero, sqrtAmplitudeDampingProbability, dd::complex_zero, dd::complex_zero})),
-            ampDampingTrueMulti(dd::GateMatrix({dd::complex_zero, sqrtAmplitudeDampingProbabilityMulti, dd::complex_zero, dd::complex_zero})),
-            ampDampingFalse(dd::GateMatrix({dd::complex_one, dd::complex_zero, dd::complex_zero, oneMinusSqrtAmplitudeDampingProbability})),
-            ampDampingFalseMulti(dd::GateMatrix({dd::complex_one, dd::complex_zero, dd::complex_zero, oneMinusSqrtAmplitudeDampingProbabilityMulti})),
-            noiseEffects(std::move(effects)), identityDD(package->makeIdent(nQubits)) {
-            package->incRef(identityDD);
-        }
-
-        ~StochasticNoiseFunctionality() {
-            package->decRef(identityDD);
-        }
-
-    protected:
-        const std::unique_ptr<dd::Package<Config>>& package;
-        dd::QubitCount                              nQubits;
-        std::uniform_real_distribution<dd::fp>      dist;
-
-        double                           noiseProbability;
-        double                           noiseProbabilityMulti;
-        dd::ComplexValue                 sqrtAmplitudeDampingProbability;
-        dd::ComplexValue                 oneMinusSqrtAmplitudeDampingProbability;
-        dd::ComplexValue                 sqrtAmplitudeDampingProbabilityMulti;
-        dd::ComplexValue                 oneMinusSqrtAmplitudeDampingProbabilityMulti;
-        dd::GateMatrix                   ampDampingTrue{};
-        dd::GateMatrix                   ampDampingTrueMulti{};
-        dd::GateMatrix                   ampDampingFalse{};
-        dd::GateMatrix                   ampDampingFalseMulti{};
-        std::vector<dd::NoiseOperations> noiseEffects;
-        dd::mEdge                        identityDD;
-
-        [[nodiscard]] dd::QubitCount getNumberOfQubits() const { return nQubits; }
-        [[nodiscard]] double         getNoiseProbability(bool multiQubitNoiseFlag) const { return multiQubitNoiseFlag ? noiseProbabilityMulti : noiseProbability; }
-
-        [[nodiscard]] qc::OpType getAmplitudeDampingOperationType(bool multiQubitNoiseFlag, bool amplitudeDampingFlag) const {
-            if (amplitudeDampingFlag) {
-                return multiQubitNoiseFlag ? qc::MultiATrue : qc::ATrue;
-            }
-            return multiQubitNoiseFlag ? qc::MultiAFalse : qc::AFalse;
-        }
-
-        [[nodiscard]] dd::GateMatrix getAmplitudeDampingOperationMatrix(bool multiQubitNoiseFlag, bool amplitudeDampingFlag) const {
-            if (amplitudeDampingFlag) {
-                return multiQubitNoiseFlag ? ampDampingTrueMulti : ampDampingTrue;
-            }
-            return multiQubitNoiseFlag ? ampDampingFalseMulti : ampDampingFalse;
-        }
-
-    public:
-        [[nodiscard]] dd::mEdge getIdentityDD() const { return identityDD; }
-        void                    setNoiseEffects(std::vector<dd::NoiseOperations> newNoiseEffects) { noiseEffects = std::move(newNoiseEffects); }
-
-        void applyNoiseOperation(const std::set<qc::Qubit>& targets, dd::mEdge operation, dd::vEdge& state, std::mt19937_64& generator) {
-            const bool multiQubitOperation = targets.size() > 1;
-
-            for (const auto& target: targets) {
-                auto stackedOperation = generateNoiseOperation(operation, static_cast<dd::Qubit>(target), generator, false, multiQubitOperation);
-                auto tmp              = package->multiply(stackedOperation, state);
-
-                if (dd::ComplexNumbers::mag2(tmp.w) < dist(generator)) {
-                    // The probability of amplitude damping does not only depend on the noise probability, but also the quantum state.
-                    // Due to the normalization constraint of decision diagrams the probability for applying amplitude damping stands in the root edge weight,
-                    // of the dd after the noise has been applied
-                    stackedOperation = generateNoiseOperation(operation, static_cast<dd::Qubit>(target), generator, true, multiQubitOperation);
-                    tmp              = package->multiply(stackedOperation, state);
-                }
-                tmp.w = dd::Complex::one;
-
-                package->incRef(tmp);
-                package->decRef(state);
-                state = tmp;
-
-                // I only need to apply the operations once
-                operation = identityDD;
-            }
-        }
-
-    protected:
-        [[nodiscard]] dd::mEdge stackOperation(dd::mEdge operation, const dd::Qubit target, const qc::OpType noiseOperation, const GateMatrix matrix) {
-            auto tmpOperation = package->stochasticNoiseOperationCache.lookup(noiseOperation, target);
-            if (tmpOperation.p == nullptr) {
-                tmpOperation = package->makeGateDD(matrix, getNumberOfQubits(), target);
-                package->stochasticNoiseOperationCache.insert(noiseOperation, target, tmpOperation);
-            }
-            return package->multiply(tmpOperation, operation);
-        }
-
-        dd::mEdge generateNoiseOperation(dd::mEdge        operation,
-                                         dd::Qubit        target,
-                                         std::mt19937_64& generator,
-                                         bool             amplitudeDamping,
-                                         bool             multiQubitOperation) {
-            for (const auto& noiseType: noiseEffects) {
-                const auto effect = noiseType == dd::AmplitudeDamping ? getAmplitudeDampingOperationType(multiQubitOperation, amplitudeDamping) : returnNoiseOperation(noiseType, dist(generator), multiQubitOperation);
-                switch (effect) {
-                    case (qc::I): {
-                        continue;
-                    }
-                    case (qc::MultiATrue):
-                    case (qc::ATrue): {
-                        const GateMatrix amplitudeDampingMatrix = getAmplitudeDampingOperationMatrix(multiQubitOperation, true);
-                        operation                               = stackOperation(operation, target, effect, amplitudeDampingMatrix);
-                        break;
-                    }
-                    case (qc::MultiAFalse):
-                    case (qc::AFalse): {
-                        const GateMatrix amplitudeDampingMatrix = getAmplitudeDampingOperationMatrix(multiQubitOperation, false);
-                        operation                               = stackOperation(operation, target, effect, amplitudeDampingMatrix);
-                        break;
-                    }
-                    case (qc::X): {
-                        operation = stackOperation(operation, target, effect, Xmat);
-                        break;
-                    }
-                    case (qc::Y): {
-                        operation = stackOperation(operation, target, effect, Ymat);
-                        break;
-                    }
-                    case (qc::Z): {
-                        operation = stackOperation(operation, target, effect, Zmat);
-                        break;
-                    }
-                    default: {
-                        throw std::runtime_error("Unknown noise operation '" + std::to_string(effect) + "'\n");
-                    }
-                }
-            }
-            return operation;
-        }
-
-        [[nodiscard]] qc::OpType returnNoiseOperation(dd::NoiseOperations noiseOperation, double prob, bool multiQubitNoiseFlag) const {
-            switch (noiseOperation) {
-                case dd::NoiseOperations::Depolarization: {
-                    if (prob >= (getNoiseProbability(multiQubitNoiseFlag) * 0.75)) {
-                        // prob > prob apply qc::I, also 25 % of the time when depolarization is applied nothing happens
-                        return qc::I;
-                    }
-                    if (prob < (getNoiseProbability(multiQubitNoiseFlag) * 0.25)) {
-                        // if 0 < prob < 0.25 (25 % of the time when applying depolarization) apply qc::X
-                        return qc::X;
-                    }
-                    if (prob < (getNoiseProbability(multiQubitNoiseFlag) * 0.5)) {
-                        // if 0.25 < prob < 0.5 (25 % of the time when applying depolarization) apply qc::Y
-                        return qc::Y;
-                    }
-                    // if 0.5 < prob < 0.75 (25 % of the time when applying depolarization) apply qc::Z
-                    return qc::Z;
-                }
-                case dd::NoiseOperations::PhaseFlip: {
-                    if (prob > getNoiseProbability(multiQubitNoiseFlag)) {
-                        return qc::I;
-                    }
-                    return qc::Z;
-                }
-                case dd::NoiseOperations::Identity: {
-                    return qc::I;
-                }
-                default:
-                    throw std::runtime_error(std::string{"Unknown noise effect '"} + std::to_string(noiseOperation) + "'");
-            }
-        }
-    };
-
-    template<class Config>
-    class DeterministicNoiseFunctionality {
-    public:
-        DeterministicNoiseFunctionality(const std::unique_ptr<dd::Package<Config>>& dd,
-                                        dd::QubitCount                              nq,
-                                        double                                      noiseProbabilitySingleQubit,
-                                        double                                      noiseProbabilityMultiQubit,
-                                        double                                      ampDampProbSingleQubit,
-                                        double                                      ampDampProbMultiQubit,
-                                        std::vector<dd::NoiseOperations>            effects,
-                                        bool                                        useDensityMatType,
-                                        bool                                        seqApplyNoise):
-            package(dd),
-            nQubits(nq),
-            noiseProbSingleQubit(noiseProbabilitySingleQubit),
-            noiseProbMultiQubit(noiseProbabilityMultiQubit),
-            ampDampingProbSingleQubit(ampDampProbSingleQubit),
-            ampDampingProbMultiQubit(ampDampProbMultiQubit),
-            noiseEffects(std::move(effects)),
-            useDensityMatrixType(useDensityMatType),
-            sequentiallyApplyNoise(seqApplyNoise) {
-        }
-
-    protected:
-        const std::unique_ptr<dd::Package<Config>>& package;
-        dd::QubitCount                              nQubits;
-
-        double noiseProbSingleQubit;
-        double noiseProbMultiQubit;
-        double ampDampingProbSingleQubit;
-        double ampDampingProbMultiQubit;
-
-        std::vector<dd::NoiseOperations> noiseEffects;
-        bool                             useDensityMatrixType;
-        bool                             sequentiallyApplyNoise;
-
-        inline static const std::map<dd::NoiseOperations, std::size_t> SEQUENTIAL_NOISE_MAP = {
-                {dd::Identity, 1},         //Identity Noise
-                {dd::PhaseFlip, 2},        //Phase-flip
-                {dd::AmplitudeDamping, 2}, //Amplitude Damping
-                {dd::Depolarization, 4},   //Depolarisation
-        };
-
-        [[nodiscard]] dd::QubitCount getNumberOfQubits() const {
-            return nQubits;
-        }
-
-    public:
-        void applyNoiseEffects(qc::DensityMatrixDD& originalEdge, const std::unique_ptr<qc::Operation>& qcOperation) {
-            auto usedQubits = qcOperation->getUsedQubits();
-
-            [[maybe_unused]] const auto cacheSizeBefore = package->cn.cacheCount();
-
-            if (sequentiallyApplyNoise) {
-                applyDetNoiseSequential(originalEdge, usedQubits);
-            } else {
-                qc::DensityMatrixDD nodeAfterNoise = {};
-                if (useDensityMatrixType) {
-                    qc::DensityMatrixDD::applyDmChangesToEdge(originalEdge);
-                    nodeAfterNoise = applyNoiseEffects(originalEdge, usedQubits, false);
-                    qc::DensityMatrixDD::revertDmChangesToEdge(originalEdge);
-                } else {
-                    nodeAfterNoise = applyNoiseEffects(originalEdge, usedQubits, true);
-                }
-                if (!nodeAfterNoise.w.exactlyZero() && !nodeAfterNoise.w.exactlyOne()) {
-                    const auto tmpComplexValue = package->cn.getTemporary(CTEntry::val(nodeAfterNoise.w.r), CTEntry::val(nodeAfterNoise.w.i));
-                    package->cn.returnToCache(nodeAfterNoise.w);
-                    nodeAfterNoise.w = package->cn.lookup(tmpComplexValue);
-                }
-
-                package->incRef(nodeAfterNoise);
-                qc::DensityMatrixDD::alignDensityEdge(originalEdge);
-                package->decRef(originalEdge);
-                originalEdge = nodeAfterNoise;
-                if (useDensityMatrixType) {
-                    qc::DensityMatrixDD::setDensityMatrixTrue(originalEdge);
-                }
-            }
-            [[maybe_unused]] const auto cacheSizeAfter = package->cn.cacheCount();
-            assert(cacheSizeAfter == cacheSizeBefore);
-        }
-
-    private:
-        qc::DensityMatrixDD applyNoiseEffects(qc::DensityMatrixDD& originalEdge, const std::set<qc::Qubit>& usedQubits, bool firstPathEdge) {
-            if (originalEdge.p->v < static_cast<dd::Qubit>(*usedQubits.begin())) {
-                qc::DensityMatrixDD tmp{};
-                if (originalEdge.w.exactlyZero() || originalEdge.w.exactlyOne()) {
-                    tmp.w = originalEdge.w;
-                } else {
-                    tmp.w = package->cn.getCached(CTEntry::val(originalEdge.w.r), CTEntry::val(originalEdge.w.i));
-                }
-                if (originalEdge.isTerminal()) {
-                    return qc::DensityMatrixDD::terminal(tmp.w);
-                }
-                tmp.p = originalEdge.p;
-                return tmp;
-            }
-            auto originalCopy = originalEdge;
-            originalCopy.w    = dd::Complex::one;
-
-            ArrayOfEdges newEdges{};
-            for (size_t i = 0; i < newEdges.size(); i++) {
-                if (firstPathEdge || i == 1) {
-                    // If I am to the firstPathEdge I cannot minimize the necessary operations anymore
-                    qc::DensityMatrixDD::applyDmChangesToEdge(originalCopy.p->e.at(i));
-                    newEdges[i] = applyNoiseEffects(originalCopy.p->e.at(i), usedQubits, true);
-                    qc::DensityMatrixDD::revertDmChangesToEdge(originalCopy.p->e.at(i));
-                } else if (i == 2) {
-                    // Since e[1] == e[2] (due to density matrix representation), I can skip calculating e[2]
-                    newEdges[2].p = newEdges[1].p;
-                    newEdges[2].w = package->cn.getCached(CTEntry::val(newEdges[1].w.r), CTEntry::val(newEdges[1].w.i));
-                } else {
-                    qc::DensityMatrixDD::applyDmChangesToEdge(originalCopy.p->e.at(i));
-                    newEdges[i] = applyNoiseEffects(originalCopy.p->e.at(i), usedQubits, false);
-                    qc::DensityMatrixDD::revertDmChangesToEdge(originalCopy.p->e.at(i));
-                }
-            }
-            qc::DensityMatrixDD e = {};
-            if (std::any_of(usedQubits.begin(), usedQubits.end(), [originalEdge](dd::Qubit qubit) { return originalEdge.p->v == qubit; })) {
-                for (auto const& type: noiseEffects) {
-                    switch (type) {
-                        case dd::AmplitudeDamping:
-                            applyAmplitudeDampingToEdges(newEdges, (usedQubits.size() == 1) ? ampDampingProbSingleQubit : ampDampingProbMultiQubit);
-                            break;
-                        case dd::PhaseFlip:
-                            applyPhaseFlipToEdges(newEdges, (usedQubits.size() == 1) ? noiseProbSingleQubit : noiseProbMultiQubit);
-                            break;
-                        case dd::Depolarization:
-                            applyDepolarisationToEdges(newEdges, (usedQubits.size() == 1) ? noiseProbSingleQubit : noiseProbMultiQubit);
-                            break;
-                        case dd::Identity:
-                            continue;
-                    }
-                }
-            }
-
-            e = package->makeDDNode(originalCopy.p->v, newEdges, true, firstPathEdge);
-
-            // Multiplying the old edge weight with the new one and looking up in the complex numbers table
-            if (!e.w.exactlyZero()) {
-                if (e.w.exactlyOne()) {
-                    e.w = package->cn.getCached(CTEntry::val(originalEdge.w.r), CTEntry::val(originalEdge.w.i));
-                } else {
-                    CN::mul(e.w, e.w, originalEdge.w);
-                }
-            }
-            return e;
-        }
-
-        void
-        applyPhaseFlipToEdges(ArrayOfEdges& e, double probability) {
-            dd::Complex complexProb = package->cn.getCached();
-
-            //e[0] = e[0]
-
-            //e[1] = (1-2p)*e[1]
-            if (!e[1].w.approximatelyZero()) {
-                complexProb.r->value = 1 - 2 * probability;
-                complexProb.i->value = 0;
-                CN::mul(e[1].w, complexProb, e[1].w);
-            }
-
-            //e[2] = (1-2p)*e[2]
-            if (!e[2].w.approximatelyZero()) {
-                if (e[1].w.approximatelyZero()) {
-                    complexProb.r->value = 1 - 2 * probability;
-                    complexProb.i->value = 0;
-                }
-                CN::mul(e[2].w, complexProb, e[2].w);
-            }
-
-            //e[3] = e[3]
-
-            package->cn.returnToCache(complexProb);
-        }
-
-        void applyAmplitudeDampingToEdges(ArrayOfEdges& e, double probability) {
-            dd::Complex         complexProb = package->cn.getCached();
-            qc::DensityMatrixDD helperEdge;
-            helperEdge.w = package->cn.getCached();
-
-            // e[0] = e[0] + p*e[3]
-            if (!e[3].w.exactlyZero()) {
-                complexProb.r->value = probability;
-                complexProb.i->value = 0;
-                if (!e[0].w.exactlyZero()) {
-                    CN::mul(helperEdge.w, complexProb, e[3].w);
-                    helperEdge.p = e[3].p;
-                    auto tmp     = package->add2(e[0], helperEdge);
-                    if (!e[0].w.exactlyZero() && !e[0].w.exactlyOne()) {
-                        package->cn.returnToCache(e[0].w);
-                    }
-                    e[0] = tmp;
-                } else {
-                    // e[0].w is exactly zero therefore I need to get a new cached value
-                    e[0].w = package->cn.getCached();
-                    CN::mul(e[0].w, complexProb, e[3].w);
-                    e[0].p = e[3].p;
-                }
-            }
-
-            //e[1] = sqrt(1-p)*e[1]
-            if (!e[1].w.exactlyZero()) {
-                complexProb.r->value = std::sqrt(1 - probability);
-                complexProb.i->value = 0;
-                if (e[1].w.exactlyOne()) {
-                    e[1].w = package->cn.getCached(CTEntry::val(complexProb.r), CTEntry::val(complexProb.i));
-                } else {
-                    CN::mul(e[1].w, complexProb, e[1].w);
-                }
-            }
-
-            //e[2] = sqrt(1-p)*e[2]
-            if (!e[2].w.exactlyZero()) {
-                if (e[1].w.exactlyZero()) {
-                    complexProb.r->value = std::sqrt(1 - probability);
-                    complexProb.i->value = 0;
-                }
-                if (e[2].w.exactlyOne()) {
-                    e[2].w = package->cn.getCached(CTEntry::val(complexProb.r), CTEntry::val(complexProb.i));
-                } else {
-                    CN::mul(e[2].w, complexProb, e[2].w);
-                }
-            }
-
-            //e[3] = (1-p)*e[3]
-            if (!e[3].w.exactlyZero()) {
-                complexProb.r->value = 1 - probability;
-                if (e[3].w.exactlyOne()) {
-                    e[3].w = package->cn.getCached(CTEntry::val(complexProb.r), CTEntry::val(complexProb.i));
-                } else {
-                    CN::mul(e[3].w, complexProb, e[3].w);
-                }
-            }
-            package->cn.returnToCache(helperEdge.w);
-            package->cn.returnToCache(complexProb);
-        }
-
-        void applyDepolarisationToEdges(ArrayOfEdges& e, double probability) {
-            std::array<qc::DensityMatrixDD, 2> helperEdge{};
-            dd::Complex                        complexProb = package->cn.getCached();
-            complexProb.i->value                           = 0;
-
-            qc::DensityMatrixDD oldE0Edge;
-            oldE0Edge.w = package->cn.getCached(dd::CTEntry::val(e[0].w.r), dd::CTEntry::val(e[0].w.i));
-            oldE0Edge.p = e[0].p;
-
-            //e[0] = 0.5*((2-p)*e[0] + p*e[3])
-            {
-                helperEdge[0].w = dd::Complex::zero;
-                helperEdge[1].w = dd::Complex::zero;
-
-                //helperEdge[0] = 0.5*((2-p)*e[0]
-                if (!e[0].w.exactlyZero()) {
-                    helperEdge[0].w      = package->cn.getCached();
-                    complexProb.r->value = (2 - probability) * 0.5;
-                    CN::mul(helperEdge[0].w, complexProb, e[0].w);
-                }
-                helperEdge[0].p = e[0].p;
-
-                //helperEdge[1] = 0.5*p*e[3]
-                if (!e[3].w.exactlyZero()) {
-                    helperEdge[1].w      = package->cn.getCached();
-                    complexProb.r->value = probability * 0.5;
-                    CN::mul(helperEdge[1].w, complexProb, e[3].w);
-                }
-                helperEdge[1].p = e[3].p;
-
-                //e[0] = helperEdge[0] + helperEdge[1]
-                if (!e[0].w.exactlyZero() && !e[0].w.exactlyOne()) {
-                    package->cn.returnToCache(e[0].w);
-                }
-                e[0] = package->add2(helperEdge[0], helperEdge[1]);
-
-                if (!helperEdge[0].w.exactlyZero() && !helperEdge[0].w.exactlyOne()) {
-                    package->cn.returnToCache(helperEdge[0].w);
-                }
-                if (!helperEdge[1].w.exactlyZero() && !helperEdge[1].w.exactlyOne()) {
-                    package->cn.returnToCache(helperEdge[1].w);
-                }
-            }
-
-            //e[1]=1-p*e[1]
-            if (!e[1].w.exactlyZero()) {
-                complexProb.r->value = 1 - probability;
-                if (e[1].w.exactlyOne()) {
-                    e[1].w = package->cn.getCached(CTEntry::val(complexProb.r), CTEntry::val(complexProb.i));
-                } else {
-                    CN::mul(e[1].w, e[1].w, complexProb);
-                }
-            }
-            //e[2]=1-p*e[2]
-            if (!e[2].w.exactlyZero()) {
-                if (e[1].w.exactlyZero()) {
-                    complexProb.r->value = std::sqrt(1 - probability);
-                }
-                if (e[2].w.exactlyOne()) {
-                    e[2].w = package->cn.getCached(CTEntry::val(complexProb.r), CTEntry::val(complexProb.i));
-                } else {
-                    CN::mul(e[2].w, e[2].w, complexProb);
-                }
-            }
-
-            //e[3] = 0.5*((2-p)*e[3]) + 0.5*(p*e[0])
-            {
-                helperEdge[0].w = dd::Complex::zero;
-                helperEdge[1].w = dd::Complex::zero;
-
-                //helperEdge[0] = 0.5*((2-p)*e[3])
-                if (!e[3].w.exactlyZero()) {
-                    helperEdge[0].w      = package->cn.getCached();
-                    complexProb.r->value = (2 - probability) * 0.5;
-                    CN::mul(helperEdge[0].w, complexProb, e[3].w);
-                }
-                helperEdge[0].p = e[3].p;
-                //helperEdge[1] = 0.5*p*e[0]
-                if (!oldE0Edge.w.exactlyZero()) {
-                    helperEdge[1].w      = package->cn.getCached();
-                    complexProb.r->value = probability * 0.5;
-                    CN::mul(helperEdge[1].w, complexProb, oldE0Edge.w);
-                }
-                helperEdge[1].p = oldE0Edge.p;
-
-                //e[3] = helperEdge[0] + helperEdge[1]
-                if (!e[3].w.exactlyZero() && !e[3].w.exactlyOne()) {
-                    package->cn.returnToCache(e[3].w);
-                }
-                e[3] = package->add2(helperEdge[0], helperEdge[1]);
-                if (!helperEdge[0].w.exactlyZero() && !helperEdge[0].w.exactlyOne()) {
-                    package->cn.returnToCache(helperEdge[0].w);
-                }
-                if (!helperEdge[1].w.exactlyZero() && !helperEdge[1].w.exactlyOne()) {
-                    package->cn.returnToCache(helperEdge[1].w);
-                }
-            }
-            package->cn.returnToCache(oldE0Edge.w);
-            package->cn.returnToCache(complexProb);
-        }
-
-        void applyDetNoiseSequential(qc::DensityMatrixDD& originalEdge, const std::set<qc::Qubit>& targets) {
-            qc::DensityMatrixDD tmp = {};
-
-            std::array<mEdge, std::tuple_size_v<decltype(dd::dNode::e)>> idleOperation{};
-
-            // Iterate over qubits and check if the qubit had been used
-            for (const auto targetQubit: targets) {
-                for (auto const& type: noiseEffects) {
-                    generateGate(idleOperation, type, static_cast<dd::Qubit>(targetQubit), getNoiseProbability(type, targets));
-                    tmp.p = nullptr;
-                    //Apply all noise matrices of the current noise effect
-                    for (std::size_t m = 0; m < SEQUENTIAL_NOISE_MAP.find(type)->second; m++) {
-                        auto tmp0 = package->conjugateTranspose(idleOperation.at(m));
-                        auto tmp1 = package->multiply(originalEdge, dd::densityFromMatrixEdge(tmp0), 0, false);
-                        auto tmp2 = package->multiply(dd::densityFromMatrixEdge(idleOperation.at(m)), tmp1, 0, useDensityMatrixType);
-                        if (tmp.p == nullptr) {
-                            tmp = tmp2;
-                        } else {
-                            tmp = package->add(tmp2, tmp);
-                        }
-                    }
-                    package->incRef(tmp);
-                    qc::DensityMatrixDD::alignDensityEdge(originalEdge);
-                    package->decRef(originalEdge);
-                    originalEdge = tmp;
-                    if (useDensityMatrixType) {
-                        qc::DensityMatrixDD::setDensityMatrixTrue(originalEdge);
-                    }
-                }
-            }
-        }
-
-        void generateDepolarizationGate(std::array<mEdge, std::tuple_size_v<decltype(dd::dNode::e)>>& pointerForMatrices, const dd::Qubit target,
-                                        const double probability) {
-            std::array<dd::GateMatrix, std::tuple_size_v<decltype(dd::dNode::e)>> idleNoiseGate{};
-            dd::ComplexValue                                                      tmp = {};
-
-            tmp.r = std::sqrt(1 - ((3 * probability) / 4)) * dd::complex_one.r;
-            //                   (1 0)
-            // sqrt(1- ((3p)/4))*(0 1)
-            idleNoiseGate[0][0] = idleNoiseGate[0][3] = tmp;
-            idleNoiseGate[0][1] = idleNoiseGate[0][2] = dd::complex_zero;
-
-            pointerForMatrices[0] = package->makeGateDD(idleNoiseGate[0], getNumberOfQubits(), target);
-
-            //                      (0 1)
-            // sqrt(probability/4))*(1 0)
-            tmp.r               = std::sqrt(probability / 4) * dd::complex_one.r;
-            idleNoiseGate[1][1] = idleNoiseGate[1][2] = tmp;
-            idleNoiseGate[1][0] = idleNoiseGate[1][3] = dd::complex_zero;
-
-            pointerForMatrices[1] = package->makeGateDD(idleNoiseGate[1], getNumberOfQubits(), target);
-
-            //                      (1 0)
-            // sqrt(probability/4))*(0 -1)
-            tmp.r               = std::sqrt(probability / 4) * dd::complex_one.r;
-            idleNoiseGate[2][0] = tmp;
-            tmp.r               = tmp.r * -1;
-            idleNoiseGate[2][3] = tmp;
-            idleNoiseGate[2][1] = idleNoiseGate[2][2] = dd::complex_zero;
-
-            pointerForMatrices[3] = package->makeGateDD(idleNoiseGate[2], getNumberOfQubits(), target);
-
-            //                      (0 -i)
-            // sqrt(probability/4))*(i 0)
-            tmp.r               = dd::complex_zero.r;
-            tmp.i               = std::sqrt(probability / 4) * 1;
-            idleNoiseGate[3][2] = tmp;
-            tmp.i               = tmp.i * -1;
-            idleNoiseGate[3][1] = tmp;
-            idleNoiseGate[3][0] = idleNoiseGate[3][3] = dd::complex_zero;
-
-            pointerForMatrices[2] = package->makeGateDD(idleNoiseGate[3], getNumberOfQubits(), target);
-        }
-
-        void generateGate(std::array<mEdge, std::tuple_size_v<decltype(dd::dNode::e)>>& pointerForMatrices,
-                          const dd::NoiseOperations                                     noiseType,
-                          const dd::Qubit                                               target,
-                          const double                                                  probability) {
-            std::array<dd::GateMatrix, std::tuple_size_v<decltype(dd::dNode::e)>> idleNoiseGate{};
-            dd::ComplexValue                                                      tmp = {};
-
-            switch (noiseType) {
-                    // identity noise (for testing)
-                    //                  (1  0)
-                    //                  (0  1),
-                case dd::Identity: {
-                    idleNoiseGate[0][0] = idleNoiseGate[0][3] = dd::complex_one;
-                    idleNoiseGate[0][1] = idleNoiseGate[0][2] = dd::complex_zero;
-
-                    pointerForMatrices[0] = package->makeGateDD(idleNoiseGate[0], getNumberOfQubits(), target);
-
-                    break;
-                }
-                    // phase flip
-                    //                          (1  0)                         (1  0)
-                    //  e0= sqrt(1-probability)*(0  1), e1=  sqrt(probability)*(0 -1)
-                case dd::PhaseFlip: {
-                    tmp.r               = std::sqrt(1 - probability) * dd::complex_one.r;
-                    idleNoiseGate[0][0] = idleNoiseGate[0][3] = tmp;
-                    idleNoiseGate[0][1] = idleNoiseGate[0][2] = dd::complex_zero;
-                    tmp.r                                     = std::sqrt(probability) * dd::complex_one.r;
-                    idleNoiseGate[1][0]                       = tmp;
-                    tmp.r *= -1;
-                    idleNoiseGate[1][3] = tmp;
-                    idleNoiseGate[1][1] = idleNoiseGate[1][2] = dd::complex_zero;
-
-                    pointerForMatrices[0] = package->makeGateDD(idleNoiseGate[0], getNumberOfQubits(), target);
-                    pointerForMatrices[1] = package->makeGateDD(idleNoiseGate[1], getNumberOfQubits(), target);
-
-                    break;
-                }
-                    // amplitude damping
-                    //      (1                  0)       (0      sqrt(probability))
-                    //  e0= (0 sqrt(1-probability), e1=  (0                      0)
-                case dd::AmplitudeDamping: {
-                    tmp.r               = std::sqrt(1 - probability) * dd::complex_one.r;
-                    idleNoiseGate[0][0] = dd::complex_one;
-                    idleNoiseGate[0][1] = idleNoiseGate[0][2] = dd::complex_zero;
-                    idleNoiseGate[0][3]                       = tmp;
-
-                    tmp.r               = std::sqrt(probability) * dd::complex_one.r;
-                    idleNoiseGate[1][0] = idleNoiseGate[1][3] = idleNoiseGate[1][2] = dd::complex_zero;
-                    idleNoiseGate[1][1]                                             = tmp;
-
-                    pointerForMatrices[0] = package->makeGateDD(idleNoiseGate[0], getNumberOfQubits(), target);
-                    pointerForMatrices[1] = package->makeGateDD(idleNoiseGate[1], getNumberOfQubits(), target);
-                    break;
-                }
-                    // depolarization
-                case dd::Depolarization:
-                    generateDepolarizationGate(pointerForMatrices, target, probability);
-                    break;
-                default:
-                    throw std::runtime_error("Unknown noise effect received.");
-            }
-        }
-
-        double getNoiseProbability(const dd::NoiseOperations type, const std::set<qc::Qubit>& targets) {
-            if (type == dd::AmplitudeDamping) {
-                return (targets.size() == 1) ? ampDampingProbSingleQubit : ampDampingProbMultiQubit;
-            }
-            return (targets.size() == 1) ? noiseProbSingleQubit : noiseProbMultiQubit;
-        }
-    };
+// noise operations available for deterministic noise aware quantum circuit
+// simulation
+enum NoiseOperations : std::uint8_t {
+  AmplitudeDamping,
+  PhaseFlip,
+  Depolarization,
+  Identity
+};
+
+template <class Config> class StochasticNoiseFunctionality {
+public:
+  StochasticNoiseFunctionality(const std::unique_ptr<dd::Package<Config>>& dd,
+                               dd::QubitCount nq, double gateNoiseProbability,
+                               double amplitudeDampingProb,
+                               double multiQubitGateFactor,
+                               std::vector<dd::NoiseOperations> effects)
+      : package(dd), nQubits(nq), dist(0.0, 1.0L),
+        noiseProbability(gateNoiseProbability),
+        noiseProbabilityMulti(gateNoiseProbability * multiQubitGateFactor),
+        sqrtAmplitudeDampingProbability({std::sqrt(amplitudeDampingProb), 0}),
+        oneMinusSqrtAmplitudeDampingProbability(
+            {std::sqrt(1 - amplitudeDampingProb), 0}),
+        sqrtAmplitudeDampingProbabilityMulti(
+            {std::sqrt(gateNoiseProbability) * multiQubitGateFactor, 0}),
+        oneMinusSqrtAmplitudeDampingProbabilityMulti(
+            {std::sqrt(1 - multiQubitGateFactor * amplitudeDampingProb), 0}),
+        ampDampingTrue(
+            dd::GateMatrix({dd::complex_zero, sqrtAmplitudeDampingProbability,
+                            dd::complex_zero, dd::complex_zero})),
+        ampDampingTrueMulti(dd::GateMatrix(
+            {dd::complex_zero, sqrtAmplitudeDampingProbabilityMulti,
+             dd::complex_zero, dd::complex_zero})),
+        ampDampingFalse(
+            dd::GateMatrix({dd::complex_one, dd::complex_zero, dd::complex_zero,
+                            oneMinusSqrtAmplitudeDampingProbability})),
+        ampDampingFalseMulti(
+            dd::GateMatrix({dd::complex_one, dd::complex_zero, dd::complex_zero,
+                            oneMinusSqrtAmplitudeDampingProbabilityMulti})),
+        noiseEffects(std::move(effects)),
+        identityDD(package->makeIdent(nQubits)) {
+    package->incRef(identityDD);
+  }
+
+  ~StochasticNoiseFunctionality() { package->decRef(identityDD); }
+
+protected:
+  // NOLINTNEXTLINE(cppcoreguidelines-avoid-const-or-ref-data-members)
+  const std::unique_ptr<dd::Package<Config>>& package;
+  dd::QubitCount nQubits;
+  std::uniform_real_distribution<dd::fp> dist;
+
+  double noiseProbability;
+  double noiseProbabilityMulti;
+  dd::ComplexValue sqrtAmplitudeDampingProbability;
+  dd::ComplexValue oneMinusSqrtAmplitudeDampingProbability;
+  dd::ComplexValue sqrtAmplitudeDampingProbabilityMulti;
+  dd::ComplexValue oneMinusSqrtAmplitudeDampingProbabilityMulti;
+  dd::GateMatrix ampDampingTrue{};
+  dd::GateMatrix ampDampingTrueMulti{};
+  dd::GateMatrix ampDampingFalse{};
+  dd::GateMatrix ampDampingFalseMulti{};
+  std::vector<dd::NoiseOperations> noiseEffects;
+  dd::mEdge identityDD;
+
+  [[nodiscard]] dd::QubitCount getNumberOfQubits() const { return nQubits; }
+  [[nodiscard]] double getNoiseProbability(bool multiQubitNoiseFlag) const {
+    return multiQubitNoiseFlag ? noiseProbabilityMulti : noiseProbability;
+  }
+
+  [[nodiscard]] qc::OpType
+  getAmplitudeDampingOperationType(bool multiQubitNoiseFlag,
+                                   bool amplitudeDampingFlag) const {
+    if (amplitudeDampingFlag) {
+      return multiQubitNoiseFlag ? qc::MultiATrue : qc::ATrue;
+    }
+    return multiQubitNoiseFlag ? qc::MultiAFalse : qc::AFalse;
+  }
+
+  [[nodiscard]] dd::GateMatrix
+  getAmplitudeDampingOperationMatrix(bool multiQubitNoiseFlag,
+                                     bool amplitudeDampingFlag) const {
+    if (amplitudeDampingFlag) {
+      return multiQubitNoiseFlag ? ampDampingTrueMulti : ampDampingTrue;
+    }
+    return multiQubitNoiseFlag ? ampDampingFalseMulti : ampDampingFalse;
+  }
+
+public:
+  [[nodiscard]] dd::mEdge getIdentityDD() const { return identityDD; }
+  void setNoiseEffects(std::vector<dd::NoiseOperations> newNoiseEffects) {
+    noiseEffects = std::move(newNoiseEffects);
+  }
+
+  void applyNoiseOperation(const std::set<qc::Qubit>& targets,
+                           dd::mEdge operation, dd::vEdge& state,
+                           std::mt19937_64& generator) {
+    const bool multiQubitOperation = targets.size() > 1;
+
+    for (const auto& target : targets) {
+      auto stackedOperation =
+          generateNoiseOperation(operation, static_cast<dd::Qubit>(target),
+                                 generator, false, multiQubitOperation);
+      auto tmp = package->multiply(stackedOperation, state);
+
+      if (dd::ComplexNumbers::mag2(tmp.w) < dist(generator)) {
+        // The probability of amplitude damping does not only depend on the
+        // noise probability, but also the quantum state. Due to the
+        // normalization constraint of decision diagrams the probability for
+        // applying amplitude damping stands in the root edge weight, of the dd
+        // after the noise has been applied
+        stackedOperation =
+            generateNoiseOperation(operation, static_cast<dd::Qubit>(target),
+                                   generator, true, multiQubitOperation);
+        tmp = package->multiply(stackedOperation, state);
+      }
+      tmp.w = dd::Complex::one;
+
+      package->incRef(tmp);
+      package->decRef(state);
+      state = tmp;
+
+      // I only need to apply the operations once
+      operation = identityDD;
+    }
+  }
+
+protected:
+  [[nodiscard]] dd::mEdge stackOperation(dd::mEdge operation,
+                                         const dd::Qubit target,
+                                         const qc::OpType noiseOperation,
+                                         const GateMatrix matrix) {
+    auto tmpOperation =
+        package->stochasticNoiseOperationCache.lookup(noiseOperation, target);
+    if (tmpOperation.p == nullptr) {
+      tmpOperation = package->makeGateDD(matrix, getNumberOfQubits(), target);
+      package->stochasticNoiseOperationCache.insert(noiseOperation, target,
+                                                    tmpOperation);
+    }
+    return package->multiply(tmpOperation, operation);
+  }
+
+  dd::mEdge generateNoiseOperation(dd::mEdge operation, dd::Qubit target,
+                                   std::mt19937_64& generator,
+                                   bool amplitudeDamping,
+                                   bool multiQubitOperation) {
+    for (const auto& noiseType : noiseEffects) {
+      const auto effect = noiseType == dd::AmplitudeDamping
+                              ? getAmplitudeDampingOperationType(
+                                    multiQubitOperation, amplitudeDamping)
+                              : returnNoiseOperation(noiseType, dist(generator),
+                                                     multiQubitOperation);
+      switch (effect) {
+      case (qc::I): {
+        continue;
+      }
+      case (qc::MultiATrue):
+      case (qc::ATrue): {
+        const GateMatrix amplitudeDampingMatrix =
+            getAmplitudeDampingOperationMatrix(multiQubitOperation, true);
+        operation =
+            stackOperation(operation, target, effect, amplitudeDampingMatrix);
+        break;
+      }
+      case (qc::MultiAFalse):
+      case (qc::AFalse): {
+        const GateMatrix amplitudeDampingMatrix =
+            getAmplitudeDampingOperationMatrix(multiQubitOperation, false);
+        operation =
+            stackOperation(operation, target, effect, amplitudeDampingMatrix);
+        break;
+      }
+      case (qc::X): {
+        operation = stackOperation(operation, target, effect, Xmat);
+        break;
+      }
+      case (qc::Y): {
+        operation = stackOperation(operation, target, effect, Ymat);
+        break;
+      }
+      case (qc::Z): {
+        operation = stackOperation(operation, target, effect, Zmat);
+        break;
+      }
+      default: {
+        throw std::runtime_error("Unknown noise operation '" +
+                                 std::to_string(effect) + "'\n");
+      }
+      }
+    }
+    return operation;
+  }
+
+  [[nodiscard]] qc::OpType
+  returnNoiseOperation(dd::NoiseOperations noiseOperation, double prob,
+                       bool multiQubitNoiseFlag) const {
+    switch (noiseOperation) {
+    case dd::NoiseOperations::Depolarization: {
+      if (prob >= (getNoiseProbability(multiQubitNoiseFlag) * 0.75)) {
+        // prob > prob apply qc::I, also 25 % of the time when depolarization is
+        // applied nothing happens
+        return qc::I;
+      }
+      if (prob < (getNoiseProbability(multiQubitNoiseFlag) * 0.25)) {
+        // if 0 < prob < 0.25 (25 % of the time when applying depolarization)
+        // apply qc::X
+        return qc::X;
+      }
+      if (prob < (getNoiseProbability(multiQubitNoiseFlag) * 0.5)) {
+        // if 0.25 < prob < 0.5 (25 % of the time when applying depolarization)
+        // apply qc::Y
+        return qc::Y;
+      }
+      // if 0.5 < prob < 0.75 (25 % of the time when applying depolarization)
+      // apply qc::Z
+      return qc::Z;
+    }
+    case dd::NoiseOperations::PhaseFlip: {
+      if (prob > getNoiseProbability(multiQubitNoiseFlag)) {
+        return qc::I;
+      }
+      return qc::Z;
+    }
+    case dd::NoiseOperations::Identity: {
+      return qc::I;
+    }
+    default:
+      throw std::runtime_error(std::string{"Unknown noise effect '"} +
+                               std::to_string(noiseOperation) + "'");
+    }
+  }
+};
+
+template <class Config> class DeterministicNoiseFunctionality {
+public:
+  DeterministicNoiseFunctionality(
+      const std::unique_ptr<dd::Package<Config>>& dd, dd::QubitCount nq,
+      double noiseProbabilitySingleQubit, double noiseProbabilityMultiQubit,
+      double ampDampProbSingleQubit, double ampDampProbMultiQubit,
+      std::vector<dd::NoiseOperations> effects, bool useDensityMatType,
+      bool seqApplyNoise)
+      : package(dd), nQubits(nq),
+        noiseProbSingleQubit(noiseProbabilitySingleQubit),
+        noiseProbMultiQubit(noiseProbabilityMultiQubit),
+        ampDampingProbSingleQubit(ampDampProbSingleQubit),
+        ampDampingProbMultiQubit(ampDampProbMultiQubit),
+        noiseEffects(std::move(effects)),
+        useDensityMatrixType(useDensityMatType),
+        sequentiallyApplyNoise(seqApplyNoise) {}
+
+protected:
+  // NOLINTNEXTLINE(cppcoreguidelines-avoid-const-or-ref-data-members)
+  const std::unique_ptr<dd::Package<Config>>& package;
+  dd::QubitCount nQubits;
+
+  double noiseProbSingleQubit;
+  double noiseProbMultiQubit;
+  double ampDampingProbSingleQubit;
+  double ampDampingProbMultiQubit;
+
+  std::vector<dd::NoiseOperations> noiseEffects;
+  bool useDensityMatrixType;
+  bool sequentiallyApplyNoise;
+
+  inline static const std::map<dd::NoiseOperations, std::size_t>
+      SEQUENTIAL_NOISE_MAP = {
+          {dd::Identity, 1},         // Identity Noise
+          {dd::PhaseFlip, 2},        // Phase-flip
+          {dd::AmplitudeDamping, 2}, // Amplitude Damping
+          {dd::Depolarization, 4},   // Depolarisation
+  };
+
+  [[nodiscard]] dd::QubitCount getNumberOfQubits() const { return nQubits; }
+
+public:
+  void applyNoiseEffects(qc::DensityMatrixDD& originalEdge,
+                         const std::unique_ptr<qc::Operation>& qcOperation) {
+    auto usedQubits = qcOperation->getUsedQubits();
+
+    [[maybe_unused]] const auto cacheSizeBefore = package->cn.cacheCount();
+
+    if (sequentiallyApplyNoise) {
+      applyDetNoiseSequential(originalEdge, usedQubits);
+    } else {
+      qc::DensityMatrixDD nodeAfterNoise = {};
+      if (useDensityMatrixType) {
+        qc::DensityMatrixDD::applyDmChangesToEdge(originalEdge);
+        nodeAfterNoise = applyNoiseEffects(originalEdge, usedQubits, false);
+        qc::DensityMatrixDD::revertDmChangesToEdge(originalEdge);
+      } else {
+        nodeAfterNoise = applyNoiseEffects(originalEdge, usedQubits, true);
+      }
+      if (!nodeAfterNoise.w.exactlyZero() && !nodeAfterNoise.w.exactlyOne()) {
+        const auto tmpComplexValue = package->cn.getTemporary(
+            CTEntry::val(nodeAfterNoise.w.r), CTEntry::val(nodeAfterNoise.w.i));
+        package->cn.returnToCache(nodeAfterNoise.w);
+        nodeAfterNoise.w = package->cn.lookup(tmpComplexValue);
+      }
+
+      package->incRef(nodeAfterNoise);
+      qc::DensityMatrixDD::alignDensityEdge(originalEdge);
+      package->decRef(originalEdge);
+      originalEdge = nodeAfterNoise;
+      if (useDensityMatrixType) {
+        qc::DensityMatrixDD::setDensityMatrixTrue(originalEdge);
+      }
+    }
+    [[maybe_unused]] const auto cacheSizeAfter = package->cn.cacheCount();
+    assert(cacheSizeAfter == cacheSizeBefore);
+  }
+
+private:
+  qc::DensityMatrixDD applyNoiseEffects(qc::DensityMatrixDD& originalEdge,
+                                        const std::set<qc::Qubit>& usedQubits,
+                                        bool firstPathEdge) {
+    if (originalEdge.p->v < static_cast<dd::Qubit>(*usedQubits.begin())) {
+      qc::DensityMatrixDD tmp{};
+      if (originalEdge.w.exactlyZero() || originalEdge.w.exactlyOne()) {
+        tmp.w = originalEdge.w;
+      } else {
+        tmp.w = package->cn.getCached(CTEntry::val(originalEdge.w.r),
+                                      CTEntry::val(originalEdge.w.i));
+      }
+      if (originalEdge.isTerminal()) {
+        return qc::DensityMatrixDD::terminal(tmp.w);
+      }
+      tmp.p = originalEdge.p;
+      return tmp;
+    }
+    auto originalCopy = originalEdge;
+    originalCopy.w = dd::Complex::one;
+
+    ArrayOfEdges newEdges{};
+    for (size_t i = 0; i < newEdges.size(); i++) {
+      if (firstPathEdge || i == 1) {
+        // If I am to the firstPathEdge I cannot minimize the necessary
+        // operations anymore
+        qc::DensityMatrixDD::applyDmChangesToEdge(originalCopy.p->e.at(i));
+        newEdges[i] =
+            applyNoiseEffects(originalCopy.p->e.at(i), usedQubits, true);
+        qc::DensityMatrixDD::revertDmChangesToEdge(originalCopy.p->e.at(i));
+      } else if (i == 2) {
+        // Since e[1] == e[2] (due to density matrix representation), I can skip
+        // calculating e[2]
+        newEdges[2].p = newEdges[1].p;
+        newEdges[2].w = package->cn.getCached(CTEntry::val(newEdges[1].w.r),
+                                              CTEntry::val(newEdges[1].w.i));
+      } else {
+        qc::DensityMatrixDD::applyDmChangesToEdge(originalCopy.p->e.at(i));
+        newEdges[i] =
+            applyNoiseEffects(originalCopy.p->e.at(i), usedQubits, false);
+        qc::DensityMatrixDD::revertDmChangesToEdge(originalCopy.p->e.at(i));
+      }
+    }
+    qc::DensityMatrixDD e = {};
+    if (std::any_of(usedQubits.begin(), usedQubits.end(),
+                    [originalEdge](dd::Qubit qubit) {
+                      return originalEdge.p->v == qubit;
+                    })) {
+      for (auto const& type : noiseEffects) {
+        switch (type) {
+        case dd::AmplitudeDamping:
+          applyAmplitudeDampingToEdges(
+              newEdges, (usedQubits.size() == 1) ? ampDampingProbSingleQubit
+                                                 : ampDampingProbMultiQubit);
+          break;
+        case dd::PhaseFlip:
+          applyPhaseFlipToEdges(newEdges, (usedQubits.size() == 1)
+                                              ? noiseProbSingleQubit
+                                              : noiseProbMultiQubit);
+          break;
+        case dd::Depolarization:
+          applyDepolarisationToEdges(newEdges, (usedQubits.size() == 1)
+                                                   ? noiseProbSingleQubit
+                                                   : noiseProbMultiQubit);
+          break;
+        case dd::Identity:
+          continue;
+        }
+      }
+    }
+
+    e = package->makeDDNode(originalCopy.p->v, newEdges, true, firstPathEdge);
+
+    // Multiplying the old edge weight with the new one and looking up in the
+    // complex numbers table
+    if (!e.w.exactlyZero()) {
+      if (e.w.exactlyOne()) {
+        e.w = package->cn.getCached(CTEntry::val(originalEdge.w.r),
+                                    CTEntry::val(originalEdge.w.i));
+      } else {
+        CN::mul(e.w, e.w, originalEdge.w);
+      }
+    }
+    return e;
+  }
+
+  void applyPhaseFlipToEdges(ArrayOfEdges& e, double probability) {
+    dd::Complex complexProb = package->cn.getCached();
+
+    // e[0] = e[0]
+
+    // e[1] = (1-2p)*e[1]
+    if (!e[1].w.approximatelyZero()) {
+      complexProb.r->value = 1 - 2 * probability;
+      complexProb.i->value = 0;
+      CN::mul(e[1].w, complexProb, e[1].w);
+    }
+
+    // e[2] = (1-2p)*e[2]
+    if (!e[2].w.approximatelyZero()) {
+      if (e[1].w.approximatelyZero()) {
+        complexProb.r->value = 1 - 2 * probability;
+        complexProb.i->value = 0;
+      }
+      CN::mul(e[2].w, complexProb, e[2].w);
+    }
+
+    // e[3] = e[3]
+
+    package->cn.returnToCache(complexProb);
+  }
+
+  void applyAmplitudeDampingToEdges(ArrayOfEdges& e, double probability) {
+    dd::Complex complexProb = package->cn.getCached();
+    qc::DensityMatrixDD helperEdge;
+    helperEdge.w = package->cn.getCached();
+
+    // e[0] = e[0] + p*e[3]
+    if (!e[3].w.exactlyZero()) {
+      complexProb.r->value = probability;
+      complexProb.i->value = 0;
+      if (!e[0].w.exactlyZero()) {
+        CN::mul(helperEdge.w, complexProb, e[3].w);
+        helperEdge.p = e[3].p;
+        auto tmp = package->add2(e[0], helperEdge);
+        if (!e[0].w.exactlyZero() && !e[0].w.exactlyOne()) {
+          package->cn.returnToCache(e[0].w);
+        }
+        e[0] = tmp;
+      } else {
+        // e[0].w is exactly zero therefore I need to get a new cached value
+        e[0].w = package->cn.getCached();
+        CN::mul(e[0].w, complexProb, e[3].w);
+        e[0].p = e[3].p;
+      }
+    }
+
+    // e[1] = sqrt(1-p)*e[1]
+    if (!e[1].w.exactlyZero()) {
+      complexProb.r->value = std::sqrt(1 - probability);
+      complexProb.i->value = 0;
+      if (e[1].w.exactlyOne()) {
+        e[1].w = package->cn.getCached(CTEntry::val(complexProb.r),
+                                       CTEntry::val(complexProb.i));
+      } else {
+        CN::mul(e[1].w, complexProb, e[1].w);
+      }
+    }
+
+    // e[2] = sqrt(1-p)*e[2]
+    if (!e[2].w.exactlyZero()) {
+      if (e[1].w.exactlyZero()) {
+        complexProb.r->value = std::sqrt(1 - probability);
+        complexProb.i->value = 0;
+      }
+      if (e[2].w.exactlyOne()) {
+        e[2].w = package->cn.getCached(CTEntry::val(complexProb.r),
+                                       CTEntry::val(complexProb.i));
+      } else {
+        CN::mul(e[2].w, complexProb, e[2].w);
+      }
+    }
+
+    // e[3] = (1-p)*e[3]
+    if (!e[3].w.exactlyZero()) {
+      complexProb.r->value = 1 - probability;
+      if (e[3].w.exactlyOne()) {
+        e[3].w = package->cn.getCached(CTEntry::val(complexProb.r),
+                                       CTEntry::val(complexProb.i));
+      } else {
+        CN::mul(e[3].w, complexProb, e[3].w);
+      }
+    }
+    package->cn.returnToCache(helperEdge.w);
+    package->cn.returnToCache(complexProb);
+  }
+
+  void applyDepolarisationToEdges(ArrayOfEdges& e, double probability) {
+    std::array<qc::DensityMatrixDD, 2> helperEdge{};
+    dd::Complex complexProb = package->cn.getCached();
+    complexProb.i->value = 0;
+
+    qc::DensityMatrixDD oldE0Edge;
+    oldE0Edge.w = package->cn.getCached(dd::CTEntry::val(e[0].w.r),
+                                        dd::CTEntry::val(e[0].w.i));
+    oldE0Edge.p = e[0].p;
+
+    // e[0] = 0.5*((2-p)*e[0] + p*e[3])
+    {
+      helperEdge[0].w = dd::Complex::zero;
+      helperEdge[1].w = dd::Complex::zero;
+
+      // helperEdge[0] = 0.5*((2-p)*e[0]
+      if (!e[0].w.exactlyZero()) {
+        helperEdge[0].w = package->cn.getCached();
+        complexProb.r->value = (2 - probability) * 0.5;
+        CN::mul(helperEdge[0].w, complexProb, e[0].w);
+      }
+      helperEdge[0].p = e[0].p;
+
+      // helperEdge[1] = 0.5*p*e[3]
+      if (!e[3].w.exactlyZero()) {
+        helperEdge[1].w = package->cn.getCached();
+        complexProb.r->value = probability * 0.5;
+        CN::mul(helperEdge[1].w, complexProb, e[3].w);
+      }
+      helperEdge[1].p = e[3].p;
+
+      // e[0] = helperEdge[0] + helperEdge[1]
+      if (!e[0].w.exactlyZero() && !e[0].w.exactlyOne()) {
+        package->cn.returnToCache(e[0].w);
+      }
+      e[0] = package->add2(helperEdge[0], helperEdge[1]);
+
+      if (!helperEdge[0].w.exactlyZero() && !helperEdge[0].w.exactlyOne()) {
+        package->cn.returnToCache(helperEdge[0].w);
+      }
+      if (!helperEdge[1].w.exactlyZero() && !helperEdge[1].w.exactlyOne()) {
+        package->cn.returnToCache(helperEdge[1].w);
+      }
+    }
+
+    // e[1]=1-p*e[1]
+    if (!e[1].w.exactlyZero()) {
+      complexProb.r->value = 1 - probability;
+      if (e[1].w.exactlyOne()) {
+        e[1].w = package->cn.getCached(CTEntry::val(complexProb.r),
+                                       CTEntry::val(complexProb.i));
+      } else {
+        CN::mul(e[1].w, e[1].w, complexProb);
+      }
+    }
+    // e[2]=1-p*e[2]
+    if (!e[2].w.exactlyZero()) {
+      if (e[1].w.exactlyZero()) {
+        complexProb.r->value = std::sqrt(1 - probability);
+      }
+      if (e[2].w.exactlyOne()) {
+        e[2].w = package->cn.getCached(CTEntry::val(complexProb.r),
+                                       CTEntry::val(complexProb.i));
+      } else {
+        CN::mul(e[2].w, e[2].w, complexProb);
+      }
+    }
+
+    // e[3] = 0.5*((2-p)*e[3]) + 0.5*(p*e[0])
+    {
+      helperEdge[0].w = dd::Complex::zero;
+      helperEdge[1].w = dd::Complex::zero;
+
+      // helperEdge[0] = 0.5*((2-p)*e[3])
+      if (!e[3].w.exactlyZero()) {
+        helperEdge[0].w = package->cn.getCached();
+        complexProb.r->value = (2 - probability) * 0.5;
+        CN::mul(helperEdge[0].w, complexProb, e[3].w);
+      }
+      helperEdge[0].p = e[3].p;
+      // helperEdge[1] = 0.5*p*e[0]
+      if (!oldE0Edge.w.exactlyZero()) {
+        helperEdge[1].w = package->cn.getCached();
+        complexProb.r->value = probability * 0.5;
+        CN::mul(helperEdge[1].w, complexProb, oldE0Edge.w);
+      }
+      helperEdge[1].p = oldE0Edge.p;
+
+      // e[3] = helperEdge[0] + helperEdge[1]
+      if (!e[3].w.exactlyZero() && !e[3].w.exactlyOne()) {
+        package->cn.returnToCache(e[3].w);
+      }
+      e[3] = package->add2(helperEdge[0], helperEdge[1]);
+      if (!helperEdge[0].w.exactlyZero() && !helperEdge[0].w.exactlyOne()) {
+        package->cn.returnToCache(helperEdge[0].w);
+      }
+      if (!helperEdge[1].w.exactlyZero() && !helperEdge[1].w.exactlyOne()) {
+        package->cn.returnToCache(helperEdge[1].w);
+      }
+    }
+    package->cn.returnToCache(oldE0Edge.w);
+    package->cn.returnToCache(complexProb);
+  }
+
+  void applyDetNoiseSequential(qc::DensityMatrixDD& originalEdge,
+                               const std::set<qc::Qubit>& targets) {
+    qc::DensityMatrixDD tmp = {};
+
+    std::array<mEdge, std::tuple_size_v<decltype(dd::dNode::e)>>
+        idleOperation{};
+
+    // Iterate over qubits and check if the qubit had been used
+    for (const auto targetQubit : targets) {
+      for (auto const& type : noiseEffects) {
+        generateGate(idleOperation, type, static_cast<dd::Qubit>(targetQubit),
+                     getNoiseProbability(type, targets));
+        tmp.p = nullptr;
+        // Apply all noise matrices of the current noise effect
+        for (std::size_t m = 0; m < SEQUENTIAL_NOISE_MAP.find(type)->second;
+             m++) {
+          auto tmp0 = package->conjugateTranspose(idleOperation.at(m));
+          auto tmp1 = package->multiply(
+              originalEdge, dd::densityFromMatrixEdge(tmp0), 0, false);
+          auto tmp2 =
+              package->multiply(dd::densityFromMatrixEdge(idleOperation.at(m)),
+                                tmp1, 0, useDensityMatrixType);
+          if (tmp.p == nullptr) {
+            tmp = tmp2;
+          } else {
+            tmp = package->add(tmp2, tmp);
+          }
+        }
+        package->incRef(tmp);
+        qc::DensityMatrixDD::alignDensityEdge(originalEdge);
+        package->decRef(originalEdge);
+        originalEdge = tmp;
+        if (useDensityMatrixType) {
+          qc::DensityMatrixDD::setDensityMatrixTrue(originalEdge);
+        }
+      }
+    }
+  }
+
+  void generateDepolarizationGate(
+      std::array<mEdge, std::tuple_size_v<decltype(dd::dNode::e)>>&
+          pointerForMatrices,
+      const dd::Qubit target, const double probability) {
+    std::array<dd::GateMatrix, std::tuple_size_v<decltype(dd::dNode::e)>>
+        idleNoiseGate{};
+    dd::ComplexValue tmp = {};
+
+    tmp.r = std::sqrt(1 - ((3 * probability) / 4)) * dd::complex_one.r;
+    //                   (1 0)
+    // sqrt(1- ((3p)/4))*(0 1)
+    idleNoiseGate[0][0] = idleNoiseGate[0][3] = tmp;
+    idleNoiseGate[0][1] = idleNoiseGate[0][2] = dd::complex_zero;
+
+    pointerForMatrices[0] =
+        package->makeGateDD(idleNoiseGate[0], getNumberOfQubits(), target);
+
+    //                      (0 1)
+    // sqrt(probability/4))*(1 0)
+    tmp.r = std::sqrt(probability / 4) * dd::complex_one.r;
+    idleNoiseGate[1][1] = idleNoiseGate[1][2] = tmp;
+    idleNoiseGate[1][0] = idleNoiseGate[1][3] = dd::complex_zero;
+
+    pointerForMatrices[1] =
+        package->makeGateDD(idleNoiseGate[1], getNumberOfQubits(), target);
+
+    //                      (1 0)
+    // sqrt(probability/4))*(0 -1)
+    tmp.r = std::sqrt(probability / 4) * dd::complex_one.r;
+    idleNoiseGate[2][0] = tmp;
+    tmp.r = tmp.r * -1;
+    idleNoiseGate[2][3] = tmp;
+    idleNoiseGate[2][1] = idleNoiseGate[2][2] = dd::complex_zero;
+
+    pointerForMatrices[3] =
+        package->makeGateDD(idleNoiseGate[2], getNumberOfQubits(), target);
+
+    //                      (0 -i)
+    // sqrt(probability/4))*(i 0)
+    tmp.r = dd::complex_zero.r;
+    tmp.i = std::sqrt(probability / 4) * 1;
+    idleNoiseGate[3][2] = tmp;
+    tmp.i = tmp.i * -1;
+    idleNoiseGate[3][1] = tmp;
+    idleNoiseGate[3][0] = idleNoiseGate[3][3] = dd::complex_zero;
+
+    pointerForMatrices[2] =
+        package->makeGateDD(idleNoiseGate[3], getNumberOfQubits(), target);
+  }
+
+  void
+  generateGate(std::array<mEdge, std::tuple_size_v<decltype(dd::dNode::e)>>&
+                   pointerForMatrices,
+               const dd::NoiseOperations noiseType, const dd::Qubit target,
+               const double probability) {
+    std::array<dd::GateMatrix, std::tuple_size_v<decltype(dd::dNode::e)>>
+        idleNoiseGate{};
+    dd::ComplexValue tmp = {};
+
+    switch (noiseType) {
+      // identity noise (for testing)
+      //                  (1  0)
+      //                  (0  1),
+    case dd::Identity: {
+      idleNoiseGate[0][0] = idleNoiseGate[0][3] = dd::complex_one;
+      idleNoiseGate[0][1] = idleNoiseGate[0][2] = dd::complex_zero;
+
+      pointerForMatrices[0] =
+          package->makeGateDD(idleNoiseGate[0], getNumberOfQubits(), target);
+
+      break;
+    }
+      // phase flip
+      //                          (1  0)                         (1  0)
+      //  e0= sqrt(1-probability)*(0  1), e1=  sqrt(probability)*(0 -1)
+    case dd::PhaseFlip: {
+      tmp.r = std::sqrt(1 - probability) * dd::complex_one.r;
+      idleNoiseGate[0][0] = idleNoiseGate[0][3] = tmp;
+      idleNoiseGate[0][1] = idleNoiseGate[0][2] = dd::complex_zero;
+      tmp.r = std::sqrt(probability) * dd::complex_one.r;
+      idleNoiseGate[1][0] = tmp;
+      tmp.r *= -1;
+      idleNoiseGate[1][3] = tmp;
+      idleNoiseGate[1][1] = idleNoiseGate[1][2] = dd::complex_zero;
+
+      pointerForMatrices[0] =
+          package->makeGateDD(idleNoiseGate[0], getNumberOfQubits(), target);
+      pointerForMatrices[1] =
+          package->makeGateDD(idleNoiseGate[1], getNumberOfQubits(), target);
+
+      break;
+    }
+      // amplitude damping
+      //      (1                  0)       (0      sqrt(probability))
+      //  e0= (0 sqrt(1-probability), e1=  (0                      0)
+    case dd::AmplitudeDamping: {
+      tmp.r = std::sqrt(1 - probability) * dd::complex_one.r;
+      idleNoiseGate[0][0] = dd::complex_one;
+      idleNoiseGate[0][1] = idleNoiseGate[0][2] = dd::complex_zero;
+      idleNoiseGate[0][3] = tmp;
+
+      tmp.r = std::sqrt(probability) * dd::complex_one.r;
+      idleNoiseGate[1][0] = idleNoiseGate[1][3] = idleNoiseGate[1][2] =
+          dd::complex_zero;
+      idleNoiseGate[1][1] = tmp;
+
+      pointerForMatrices[0] =
+          package->makeGateDD(idleNoiseGate[0], getNumberOfQubits(), target);
+      pointerForMatrices[1] =
+          package->makeGateDD(idleNoiseGate[1], getNumberOfQubits(), target);
+      break;
+    }
+      // depolarization
+    case dd::Depolarization:
+      generateDepolarizationGate(pointerForMatrices, target, probability);
+      break;
+    default:
+      throw std::runtime_error("Unknown noise effect received.");
+    }
+  }
+
+  double getNoiseProbability(const dd::NoiseOperations type,
+                             const std::set<qc::Qubit>& targets) {
+    if (type == dd::AmplitudeDamping) {
+      return (targets.size() == 1) ? ampDampingProbSingleQubit
+                                   : ampDampingProbMultiQubit;
+    }
+    return (targets.size() == 1) ? noiseProbSingleQubit : noiseProbMultiQubit;
+  }
+};
 
 } // namespace dd
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/include/dd/Operations.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/dd/Operations.hpp`

 * *Files 14% similar despite different names*

```diff
@@ -1,344 +1,447 @@
-/*
-* This file is part of MQT QFR library which is released under the MIT license.
-* See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
-*/
-
 #pragma once
 
 #include "Definitions.hpp"
 #include "dd/GateMatrixDefinitions.hpp"
 #include "dd/Package.hpp"
 #include "operations/ClassicControlledOperation.hpp"
 #include "operations/CompoundOperation.hpp"
 #include "operations/NonUnitaryOperation.hpp"
 #include "operations/StandardOperation.hpp"
 
 #include <variant>
 
 namespace qc {
-    using VectorDD        = dd::vEdge;
-    using MatrixDD        = dd::mEdge;
-    using DensityMatrixDD = dd::dEdge;
+using VectorDD = dd::vEdge;
+using MatrixDD = dd::mEdge;
+using DensityMatrixDD = dd::dEdge;
 } // namespace qc
 
 namespace dd {
-    // single-target Operations
-    template<class Config>
-    qc::MatrixDD getStandardOperationDD(const qc::StandardOperation* op, std::unique_ptr<dd::Package<Config>>& dd, const dd::Controls& controls, dd::Qubit target, bool inverse) {
-        GateMatrix gm;
-
-        const auto  type       = op->getType();
-        const auto  nqubits    = static_cast<dd::QubitCount>(op->getNqubits());
-        const auto  startQubit = static_cast<std::size_t>(op->getStartingQubit());
-        const auto& parameter  = op->getParameter();
-
-        switch (type) {
-            case qc::I: gm = dd::Imat; break;
-            case qc::H: gm = dd::Hmat; break;
-            case qc::X: {
-                qc::MatrixDD e{};
-                if (controls.size() > 1U) { // Toffoli
-                    e = dd->toffoliTable.lookup(nqubits, controls, target);
-                    if (e.p == nullptr) {
-                        e = dd->makeGateDD(dd::Xmat, nqubits, controls, target, startQubit);
-                        dd->toffoliTable.insert(nqubits, controls, target, e);
-                    }
-                    return e;
-                }
-                gm = dd::Xmat;
-                break;
-            }
-            case qc::Y: gm = dd::Ymat; break;
-            case qc::Z: gm = dd::Zmat; break;
-            case qc::S: gm = inverse ? dd::Sdagmat : dd::Smat; break;
-            case qc::Sdag: gm = inverse ? dd::Smat : dd::Sdagmat; break;
-            case qc::T: gm = inverse ? dd::Tdagmat : dd::Tmat; break;
-            case qc::Tdag: gm = inverse ? dd::Tmat : dd::Tdagmat; break;
-            case qc::V: gm = inverse ? dd::Vdagmat : dd::Vmat; break;
-            case qc::Vdag: gm = inverse ? dd::Vmat : dd::Vdagmat; break;
-            case qc::U3: gm = inverse ? dd::U3mat(-parameter[1U], -parameter[2U], -parameter[0U]) : dd::U3mat(parameter[2U], parameter[1U], parameter[0U]); break;
-            case qc::U2: gm = inverse ? dd::U2mat(-parameter[0U] + dd::PI, -parameter[1U] - dd::PI) : dd::U2mat(parameter[1U], parameter[0U]); break;
-            case qc::Phase: gm = inverse ? dd::Phasemat(-parameter[0U]) : dd::Phasemat(parameter[0U]); break;
-            case qc::SX: gm = inverse ? dd::SXdagmat : dd::SXmat; break;
-            case qc::SXdag: gm = inverse ? dd::SXmat : dd::SXdagmat; break;
-            case qc::RX: gm = inverse ? dd::RXmat(-parameter[0U]) : dd::RXmat(parameter[0U]); break;
-            case qc::RY: gm = inverse ? dd::RYmat(-parameter[0U]) : dd::RYmat(parameter[0U]); break;
-            case qc::RZ: gm = inverse ? dd::RZmat(-parameter[0U]) : dd::RZmat(parameter[0U]); break;
-            default:
-                std::ostringstream oss{};
-                oss << "DD for gate" << op->getName() << " not available!";
-                throw qc::QFRException(oss.str());
-        }
-        return dd->makeGateDD(gm, nqubits, controls, target, startQubit);
-    }
-
-    // two-target Operations
-    template<class Config>
-    qc::MatrixDD getStandardOperationDD(const qc::StandardOperation* op, std::unique_ptr<dd::Package<Config>>& dd, const dd::Controls& controls, dd::Qubit target0, dd::Qubit target1, bool inverse) {
-        const auto  type       = op->getType();
-        const auto  nqubits    = static_cast<dd::QubitCount>(op->getNqubits());
-        const auto  startQubit = static_cast<std::size_t>(op->getStartingQubit());
-        const auto& parameter  = op->getParameter();
-
-        if (type == qc::DCX && inverse) {
-            // DCX is not self-inverse, but the inverse is just swapping the targets
-            std::swap(target0, target1);
-        }
-
-        if (controls.empty()) {
-            // the DD creation without controls is faster, so we use it if possible
-            // and only use the DD creation with controls if necessary
-            TwoQubitGateMatrix gm;
-            bool               definitionFound = true;
-            switch (type) {
-                case qc::SWAP: gm = dd::SWAPmat; break;
-                case qc::iSWAP: gm = inverse ? dd::iSWAPinvmat : dd::iSWAPmat; break;
-                case qc::DCX: gm = dd::DCXmat; break;
-                case qc::ECR: gm = dd::ECRmat; break;
-                case qc::RXX: gm = inverse ? dd::RXXmat(-parameter[0U]) : dd::RXXmat(parameter[0U]); break;
-                case qc::RYY: gm = inverse ? dd::RYYmat(-parameter[0U]) : dd::RYYmat(parameter[0U]); break;
-                case qc::RZZ: gm = inverse ? dd::RZZmat(-parameter[0U]) : dd::RZZmat(parameter[0U]); break;
-                case qc::RZX: gm = inverse ? dd::RZXmat(-parameter[0U]) : dd::RZXmat(parameter[0U]); break;
-                case qc::XXminusYY: gm = inverse ? dd::XXMinusYYmat(-parameter[0U], parameter[1U]) : dd::XXMinusYYmat(parameter[0U], parameter[1U]); break;
-                case qc::XXplusYY: gm = inverse ? dd::XXPlusYYmat(-parameter[0U], parameter[1U]) : dd::XXPlusYYmat(parameter[0U], parameter[1U]); break;
-                default: definitionFound = false;
-            }
-            if (definitionFound) {
-                return dd->makeTwoQubitGateDD(gm, nqubits, target0, target1, startQubit);
-            }
-        }
-
-        switch (type) {
-            case qc::SWAP:
-                // SWAP is self-inverse
-                return dd->makeSWAPDD(nqubits, controls, target0, target1, startQubit);
-            case qc::iSWAP:
-                if (inverse) {
-                    return dd->makeiSWAPinvDD(nqubits, controls, target0, target1, startQubit);
-                }
-                return dd->makeiSWAPDD(nqubits, controls, target0, target1, startQubit);
-            case qc::Peres:
-                if (inverse) {
-                    return dd->makePeresdagDD(nqubits, controls, target0, target1, startQubit);
-                }
-                return dd->makePeresDD(nqubits, controls, target0, target1, startQubit);
-            case qc::Peresdag:
-                if (inverse) {
-                    return dd->makePeresDD(nqubits, controls, target0, target1, startQubit);
-                }
-                return dd->makePeresdagDD(nqubits, controls, target0, target1, startQubit);
-            case qc::DCX:
-                return dd->makeDCXDD(nqubits, controls, target0, target1, startQubit);
-            case qc::ECR:
-                // ECR is self-inverse
-                return dd->makeECRDD(nqubits, controls, target0, target1, startQubit);
-            case qc::RXX: {
-                if (inverse) {
-                    return dd->makeRXXDD(nqubits, controls, target0, target1, -parameter[0U], startQubit);
-                }
-                return dd->makeRXXDD(nqubits, controls, target0, target1, parameter[0U], startQubit);
-            }
-            case qc::RYY: {
-                if (inverse) {
-                    return dd->makeRYYDD(nqubits, controls, target0, target1, -parameter[0U], startQubit);
-                }
-                return dd->makeRYYDD(nqubits, controls, target0, target1, parameter[0U], startQubit);
-            }
-            case qc::RZZ: {
-                if (inverse) {
-                    return dd->makeRZZDD(nqubits, controls, target0, target1, -parameter[0U], startQubit);
-                }
-                return dd->makeRZZDD(nqubits, controls, target0, target1, parameter[0U], startQubit);
-            }
-            case qc::RZX: {
-                if (inverse) {
-                    return dd->makeRZXDD(nqubits, controls, target0, target1, -parameter[0U], startQubit);
-                }
-                return dd->makeRZXDD(nqubits, controls, target0, target1, parameter[0U], startQubit);
-            }
-            case qc::XXminusYY: {
-                if (inverse) {
-                    return dd->makeXXMinusYYDD(nqubits, controls, target0, target1, -parameter[0U], parameter[1U], startQubit);
-                }
-                return dd->makeXXMinusYYDD(nqubits, controls, target0, target1, parameter[0U], parameter[1U], startQubit);
-            }
-            case qc::XXplusYY: {
-                if (inverse) {
-                    return dd->makeXXPlusYYDD(nqubits, controls, target0, target1, -parameter[0U], parameter[1U], startQubit);
-                }
-                return dd->makeXXPlusYYDD(nqubits, controls, target0, target1, parameter[0U], parameter[1U], startQubit);
-            }
-            default:
-                std::ostringstream oss{};
-                oss << "DD for gate" << op->getName() << " not available!";
-                throw qc::QFRException(oss.str());
-        }
-    }
-
-    // The methods with a permutation parameter apply these Operations according to the mapping specified by the permutation, e.g.
-    //      if perm[0] = 1 and perm[1] = 0
-    //      then cx 0 1 will be translated to cx perm[0] perm[1] == cx 1 0
-
-    template<class Config>
-    qc::MatrixDD getDD(const qc::Operation* op, std::unique_ptr<dd::Package<Config>>& dd, qc::Permutation& permutation, bool inverse = false) {
-        const auto type    = op->getType();
-        const auto nqubits = op->getNqubits();
-
-        // check whether the operation can be handled by the underlying DD package
-        if (nqubits > dd::Package<Config>::MAX_POSSIBLE_QUBITS) {
-            throw qc::QFRException("Requested too many qubits to be handled by the DD package. Qubit datatype only allows up to " +
-                                   std::to_string(dd::Package<Config>::MAX_POSSIBLE_QUBITS) + " qubits, while " +
-                                   std::to_string(nqubits) + " were requested. If you want to use more than " +
-                                   std::to_string(dd::Package<Config>::MAX_POSSIBLE_QUBITS) + " qubits, you have to recompile the package with a wider Qubit type in `export/dd_package/include/dd/Definitions.hpp!`");
-        }
-
-        // if a permutation is provided and the current operation is a SWAP, this routine just updates the permutation
-        if (!permutation.empty() && type == qc::SWAP && !op->isControlled()) {
-            const auto& targets = op->getTargets();
-
-            const auto target0 = targets.at(0U);
-            const auto target1 = targets.at(1U);
-            // update permutation
-            std::swap(permutation.at(target0), permutation.at(target1));
-            return dd->makeIdent(static_cast<dd::QubitCount>(nqubits));
-        }
-
-        if (type == qc::ShowProbabilities || type == qc::Barrier || type == qc::Snapshot) {
-            return dd->makeIdent(static_cast<dd::QubitCount>(nqubits));
-        }
-
-        if (type == qc::GPhase) {
-            auto phase = op->getParameter()[0U];
-            if (inverse) {
-                phase = -phase;
-            }
-            auto id = dd->makeIdent(static_cast<dd::QubitCount>(nqubits));
-            id.w    = dd->cn.lookup(std::cos(phase), std::sin(phase));
-            return id;
-        }
-
-        if (const auto* standardOp = dynamic_cast<const qc::StandardOperation*>(op)) {
-            auto targets  = op->getTargets();
-            auto controls = op->getControls();
-            if (!permutation.empty()) {
-                targets  = permutation.apply(targets);
-                controls = permutation.apply(controls);
-            }
-
-            // convert controls to DD controls
-            dd::Controls ddControls{};
-            for (const auto& c: controls) {
-                const auto& qubit = static_cast<dd::Qubit>(c.qubit);
-                if (c.type == qc::Control::Type::Pos) {
-                    ddControls.emplace(dd::Control{qubit, dd::Control::Type::pos});
-                } else {
-                    ddControls.emplace(dd::Control{qubit, dd::Control::Type::neg});
-                }
-            }
-
-            if (qc::isTwoQubitGate(type)) {
-                assert(targets.size() == 2);
-                const auto target0 = static_cast<dd::Qubit>(targets[0U]);
-                const auto target1 = static_cast<dd::Qubit>(targets[1U]);
-                return getStandardOperationDD(standardOp, dd, ddControls, target0, target1, inverse);
-            }
-            assert(targets.size() == 1);
-            const auto target0 = static_cast<dd::Qubit>(targets[0U]);
-            return getStandardOperationDD(standardOp, dd, ddControls, target0, inverse);
-        }
-
-        if (const auto* compoundOp = dynamic_cast<const qc::CompoundOperation*>(op)) {
-            auto e = dd->makeIdent(static_cast<dd::QubitCount>(op->getNqubits()));
-            if (inverse) {
-                for (const auto& operation: *compoundOp) {
-                    e = dd->multiply(e, getInverseDD(operation.get(), dd, permutation));
-                }
-            } else {
-                for (const auto& operation: *compoundOp) {
-                    e = dd->multiply(getDD(operation.get(), dd, permutation), e);
-                }
-            }
-            return e;
-        }
-
-        if (const auto* classicOp = dynamic_cast<const qc::ClassicControlledOperation*>(op)) {
-            return getDD(classicOp->getOperation(), dd, permutation, inverse);
-        }
-
-        assert(op->isNonUnitaryOperation());
-        throw qc::QFRException("DD for non-unitary operation not available!");
-    }
-
-    template<class Config>
-    qc::MatrixDD getDD(const qc::Operation* op, std::unique_ptr<dd::Package<Config>>& dd, bool inverse = false) {
-        qc::Permutation perm{};
-        return getDD(op, dd, perm, inverse);
-    }
-
-    template<class Config>
-    qc::MatrixDD getInverseDD(const qc::Operation* op, std::unique_ptr<dd::Package<Config>>& dd) {
-        return getDD(op, dd, true);
-    }
-
-    template<class Config>
-    qc::MatrixDD getInverseDD(const qc::Operation* op, std::unique_ptr<dd::Package<Config>>& dd, qc::Permutation& permutation) {
-        return getDD(op, dd, permutation, true);
-    }
-
-    template<class Config>
-    void dumpTensor(qc::Operation* op, std::ostream& of, std::vector<std::size_t>& inds, std::size_t& gateIdx, std::unique_ptr<dd::Package<Config>>& dd);
-
-    // apply swaps 'on' DD in order to change 'from' to 'to'
-    // where |from| >= |to|
-    template<class DDType, class Config>
-    void changePermutation(DDType& on, qc::Permutation& from, const qc::Permutation& to, std::unique_ptr<dd::Package<Config>>& dd, bool regular = true) {
-        assert(from.size() >= to.size());
-
-        // iterate over (k,v) pairs of second permutation
-        for (const auto& [i, goal]: to) {
-            // search for key in the first map
-            auto it = from.find(i);
-            if (it == from.end()) {
-                throw qc::QFRException("[changePermutation] Key " + std::to_string(it->first) + " was not found in first permutation. This should never happen.");
-            }
-            auto current = it->second;
-
-            // permutations agree for this key value
-            if (current == goal) {
-                continue;
-            }
-
-            // search for goal value in first permutation
-            qc::Qubit j = 0;
-            for (const auto& [key, value]: from) {
-                if (value == goal) {
-                    j = key;
-                    break;
-                }
-            }
-
-            // swap i and j
-            auto       saved  = on;
-            const auto swapDD = dd->makeSWAPDD(static_cast<dd::QubitCount>(on.p->v + 1), dd::Controls{}, static_cast<dd::Qubit>(from.at(i)), static_cast<dd::Qubit>(from.at(j)));
-            if constexpr (std::is_same_v<DDType, qc::VectorDD>) {
-                on = dd->multiply(swapDD, on);
-            } else {
-                // the regular flag only has an effect on matrix DDs
-                if (regular) {
-                    on = dd->multiply(swapDD, on);
-                } else {
-                    on = dd->multiply(on, swapDD);
-                }
-            }
-
-            dd->incRef(on);
-            dd->decRef(saved);
-            dd->garbageCollect();
-
-            // update permutation
-            from.at(i) = goal;
-            from.at(j) = current;
-        }
+// single-target Operations
+template <class Config>
+qc::MatrixDD getStandardOperationDD(const qc::StandardOperation* op,
+                                    std::unique_ptr<dd::Package<Config>>& dd,
+                                    const dd::Controls& controls,
+                                    dd::Qubit target, bool inverse) {
+  GateMatrix gm;
+
+  const auto type = op->getType();
+  const auto nqubits = static_cast<dd::QubitCount>(op->getNqubits());
+  const auto startQubit = static_cast<std::size_t>(op->getStartingQubit());
+  const auto& parameter = op->getParameter();
+
+  switch (type) {
+  case qc::I:
+    gm = dd::Imat;
+    break;
+  case qc::H:
+    gm = dd::Hmat;
+    break;
+  case qc::X: {
+    qc::MatrixDD e{};
+    if (controls.size() > 1U) { // Toffoli
+      e = dd->toffoliTable.lookup(nqubits, controls, target);
+      if (e.p == nullptr) {
+        e = dd->makeGateDD(dd::Xmat, nqubits, controls, target, startQubit);
+        dd->toffoliTable.insert(nqubits, controls, target, e);
+      }
+      return e;
+    }
+    gm = dd::Xmat;
+    break;
+  }
+  case qc::Y:
+    gm = dd::Ymat;
+    break;
+  case qc::Z:
+    gm = dd::Zmat;
+    break;
+  case qc::S:
+    gm = inverse ? dd::Sdagmat : dd::Smat;
+    break;
+  case qc::Sdag:
+    gm = inverse ? dd::Smat : dd::Sdagmat;
+    break;
+  case qc::T:
+    gm = inverse ? dd::Tdagmat : dd::Tmat;
+    break;
+  case qc::Tdag:
+    gm = inverse ? dd::Tmat : dd::Tdagmat;
+    break;
+  case qc::V:
+    gm = inverse ? dd::Vdagmat : dd::Vmat;
+    break;
+  case qc::Vdag:
+    gm = inverse ? dd::Vmat : dd::Vdagmat;
+    break;
+  case qc::U3:
+    gm = inverse ? dd::U3mat(-parameter[1U], -parameter[2U], -parameter[0U])
+                 : dd::U3mat(parameter[2U], parameter[1U], parameter[0U]);
+    break;
+  case qc::U2:
+    gm = inverse ? dd::U2mat(-parameter[0U] + dd::PI, -parameter[1U] - dd::PI)
+                 : dd::U2mat(parameter[1U], parameter[0U]);
+    break;
+  case qc::Phase:
+    gm = inverse ? dd::Phasemat(-parameter[0U]) : dd::Phasemat(parameter[0U]);
+    break;
+  case qc::SX:
+    gm = inverse ? dd::SXdagmat : dd::SXmat;
+    break;
+  case qc::SXdag:
+    gm = inverse ? dd::SXmat : dd::SXdagmat;
+    break;
+  case qc::RX:
+    gm = inverse ? dd::RXmat(-parameter[0U]) : dd::RXmat(parameter[0U]);
+    break;
+  case qc::RY:
+    gm = inverse ? dd::RYmat(-parameter[0U]) : dd::RYmat(parameter[0U]);
+    break;
+  case qc::RZ:
+    gm = inverse ? dd::RZmat(-parameter[0U]) : dd::RZmat(parameter[0U]);
+    break;
+  default:
+    std::ostringstream oss{};
+    oss << "DD for gate" << op->getName() << " not available!";
+    throw qc::QFRException(oss.str());
+  }
+  return dd->makeGateDD(gm, nqubits, controls, target, startQubit);
+}
+
+// two-target Operations
+template <class Config>
+qc::MatrixDD getStandardOperationDD(const qc::StandardOperation* op,
+                                    std::unique_ptr<dd::Package<Config>>& dd,
+                                    const dd::Controls& controls,
+                                    dd::Qubit target0, dd::Qubit target1,
+                                    bool inverse) {
+  const auto type = op->getType();
+  const auto nqubits = static_cast<dd::QubitCount>(op->getNqubits());
+  const auto startQubit = static_cast<std::size_t>(op->getStartingQubit());
+  const auto& parameter = op->getParameter();
+
+  if (type == qc::DCX && inverse) {
+    // DCX is not self-inverse, but the inverse is just swapping the targets
+    std::swap(target0, target1);
+  }
+
+  if (controls.empty()) {
+    // the DD creation without controls is faster, so we use it if possible
+    // and only use the DD creation with controls if necessary
+    TwoQubitGateMatrix gm;
+    bool definitionFound = true;
+    switch (type) {
+    case qc::SWAP:
+      gm = dd::SWAPmat;
+      break;
+    case qc::iSWAP:
+      gm = inverse ? dd::iSWAPinvmat : dd::iSWAPmat;
+      break;
+    case qc::DCX:
+      gm = dd::DCXmat;
+      break;
+    case qc::ECR:
+      gm = dd::ECRmat;
+      break;
+    case qc::RXX:
+      gm = inverse ? dd::RXXmat(-parameter[0U]) : dd::RXXmat(parameter[0U]);
+      break;
+    case qc::RYY:
+      gm = inverse ? dd::RYYmat(-parameter[0U]) : dd::RYYmat(parameter[0U]);
+      break;
+    case qc::RZZ:
+      gm = inverse ? dd::RZZmat(-parameter[0U]) : dd::RZZmat(parameter[0U]);
+      break;
+    case qc::RZX:
+      gm = inverse ? dd::RZXmat(-parameter[0U]) : dd::RZXmat(parameter[0U]);
+      break;
+    case qc::XXminusYY:
+      gm = inverse ? dd::XXMinusYYmat(-parameter[0U], parameter[1U])
+                   : dd::XXMinusYYmat(parameter[0U], parameter[1U]);
+      break;
+    case qc::XXplusYY:
+      gm = inverse ? dd::XXPlusYYmat(-parameter[0U], parameter[1U])
+                   : dd::XXPlusYYmat(parameter[0U], parameter[1U]);
+      break;
+    default:
+      definitionFound = false;
+    }
+    if (definitionFound) {
+      return dd->makeTwoQubitGateDD(gm, nqubits, target0, target1, startQubit);
+    }
+  }
+
+  switch (type) {
+  case qc::SWAP:
+    // SWAP is self-inverse
+    return dd->makeSWAPDD(nqubits, controls, target0, target1, startQubit);
+  case qc::iSWAP:
+    if (inverse) {
+      return dd->makeiSWAPinvDD(nqubits, controls, target0, target1,
+                                startQubit);
+    }
+    return dd->makeiSWAPDD(nqubits, controls, target0, target1, startQubit);
+  case qc::Peres:
+    if (inverse) {
+      return dd->makePeresdagDD(nqubits, controls, target0, target1,
+                                startQubit);
+    }
+    return dd->makePeresDD(nqubits, controls, target0, target1, startQubit);
+  case qc::Peresdag:
+    if (inverse) {
+      return dd->makePeresDD(nqubits, controls, target0, target1, startQubit);
+    }
+    return dd->makePeresdagDD(nqubits, controls, target0, target1, startQubit);
+  case qc::DCX:
+    return dd->makeDCXDD(nqubits, controls, target0, target1, startQubit);
+  case qc::ECR:
+    // ECR is self-inverse
+    return dd->makeECRDD(nqubits, controls, target0, target1, startQubit);
+  case qc::RXX: {
+    if (inverse) {
+      return dd->makeRXXDD(nqubits, controls, target0, target1, -parameter[0U],
+                           startQubit);
+    }
+    return dd->makeRXXDD(nqubits, controls, target0, target1, parameter[0U],
+                         startQubit);
+  }
+  case qc::RYY: {
+    if (inverse) {
+      return dd->makeRYYDD(nqubits, controls, target0, target1, -parameter[0U],
+                           startQubit);
+    }
+    return dd->makeRYYDD(nqubits, controls, target0, target1, parameter[0U],
+                         startQubit);
+  }
+  case qc::RZZ: {
+    if (inverse) {
+      return dd->makeRZZDD(nqubits, controls, target0, target1, -parameter[0U],
+                           startQubit);
+    }
+    return dd->makeRZZDD(nqubits, controls, target0, target1, parameter[0U],
+                         startQubit);
+  }
+  case qc::RZX: {
+    if (inverse) {
+      return dd->makeRZXDD(nqubits, controls, target0, target1, -parameter[0U],
+                           startQubit);
+    }
+    return dd->makeRZXDD(nqubits, controls, target0, target1, parameter[0U],
+                         startQubit);
+  }
+  case qc::XXminusYY: {
+    if (inverse) {
+      return dd->makeXXMinusYYDD(nqubits, controls, target0, target1,
+                                 -parameter[0U], parameter[1U], startQubit);
+    }
+    return dd->makeXXMinusYYDD(nqubits, controls, target0, target1,
+                               parameter[0U], parameter[1U], startQubit);
+  }
+  case qc::XXplusYY: {
+    if (inverse) {
+      return dd->makeXXPlusYYDD(nqubits, controls, target0, target1,
+                                -parameter[0U], parameter[1U], startQubit);
+    }
+    return dd->makeXXPlusYYDD(nqubits, controls, target0, target1,
+                              parameter[0U], parameter[1U], startQubit);
+  }
+  default:
+    std::ostringstream oss{};
+    oss << "DD for gate" << op->getName() << " not available!";
+    throw qc::QFRException(oss.str());
+  }
+}
+
+// The methods with a permutation parameter apply these Operations according to
+// the mapping specified by the permutation, e.g.
+//      if perm[0] = 1 and perm[1] = 0
+//      then cx 0 1 will be translated to cx perm[0] perm[1] == cx 1 0
+
+template <class Config>
+qc::MatrixDD getDD(const qc::Operation* op,
+                   std::unique_ptr<dd::Package<Config>>& dd,
+                   qc::Permutation& permutation, bool inverse = false) {
+  const auto type = op->getType();
+  const auto nqubits = op->getNqubits();
+
+  // check whether the operation can be handled by the underlying DD package
+  if (nqubits > dd::Package<Config>::MAX_POSSIBLE_QUBITS) {
+    throw qc::QFRException(
+        "Requested too many qubits to be handled by the DD package. Qubit "
+        "datatype only allows up to " +
+        std::to_string(dd::Package<Config>::MAX_POSSIBLE_QUBITS) +
+        " qubits, while " + std::to_string(nqubits) +
+        " were requested. If you want to use more than " +
+        std::to_string(dd::Package<Config>::MAX_POSSIBLE_QUBITS) +
+        " qubits, you have to recompile the package with a wider Qubit type in "
+        "`export/dd_package/include/dd/Definitions.hpp!`");
+  }
+
+  // if a permutation is provided and the current operation is a SWAP, this
+  // routine just updates the permutation
+  if (!permutation.empty() && type == qc::SWAP && !op->isControlled()) {
+    const auto& targets = op->getTargets();
+
+    const auto target0 = targets.at(0U);
+    const auto target1 = targets.at(1U);
+    // update permutation
+    std::swap(permutation.at(target0), permutation.at(target1));
+    return dd->makeIdent(static_cast<dd::QubitCount>(nqubits));
+  }
+
+  if (type == qc::ShowProbabilities || type == qc::Barrier ||
+      type == qc::Snapshot) {
+    return dd->makeIdent(static_cast<dd::QubitCount>(nqubits));
+  }
+
+  if (type == qc::GPhase) {
+    auto phase = op->getParameter()[0U];
+    if (inverse) {
+      phase = -phase;
+    }
+    auto id = dd->makeIdent(static_cast<dd::QubitCount>(nqubits));
+    id.w = dd->cn.lookup(std::cos(phase), std::sin(phase));
+    return id;
+  }
+
+  if (const auto* standardOp = dynamic_cast<const qc::StandardOperation*>(op)) {
+    auto targets = op->getTargets();
+    auto controls = op->getControls();
+    if (!permutation.empty()) {
+      targets = permutation.apply(targets);
+      controls = permutation.apply(controls);
     }
 
+    // convert controls to DD controls
+    dd::Controls ddControls{};
+    for (const auto& c : controls) {
+      const auto& qubit = static_cast<dd::Qubit>(c.qubit);
+      if (c.type == qc::Control::Type::Pos) {
+        ddControls.emplace(dd::Control{qubit, dd::Control::Type::pos});
+      } else {
+        ddControls.emplace(dd::Control{qubit, dd::Control::Type::neg});
+      }
+    }
+
+    if (qc::isTwoQubitGate(type)) {
+      assert(targets.size() == 2);
+      const auto target0 = static_cast<dd::Qubit>(targets[0U]);
+      const auto target1 = static_cast<dd::Qubit>(targets[1U]);
+      return getStandardOperationDD(standardOp, dd, ddControls, target0,
+                                    target1, inverse);
+    }
+    assert(targets.size() == 1);
+    const auto target0 = static_cast<dd::Qubit>(targets[0U]);
+    return getStandardOperationDD(standardOp, dd, ddControls, target0, inverse);
+  }
+
+  if (const auto* compoundOp = dynamic_cast<const qc::CompoundOperation*>(op)) {
+    auto e = dd->makeIdent(static_cast<dd::QubitCount>(op->getNqubits()));
+    if (inverse) {
+      for (const auto& operation : *compoundOp) {
+        e = dd->multiply(e, getInverseDD(operation.get(), dd, permutation));
+      }
+    } else {
+      for (const auto& operation : *compoundOp) {
+        e = dd->multiply(getDD(operation.get(), dd, permutation), e);
+      }
+    }
+    return e;
+  }
+
+  if (const auto* classicOp =
+          dynamic_cast<const qc::ClassicControlledOperation*>(op)) {
+    return getDD(classicOp->getOperation(), dd, permutation, inverse);
+  }
+
+  assert(op->isNonUnitaryOperation());
+  throw qc::QFRException("DD for non-unitary operation not available!");
+}
+
+template <class Config>
+qc::MatrixDD getDD(const qc::Operation* op,
+                   std::unique_ptr<dd::Package<Config>>& dd,
+                   bool inverse = false) {
+  qc::Permutation perm{};
+  return getDD(op, dd, perm, inverse);
+}
+
+template <class Config>
+qc::MatrixDD getInverseDD(const qc::Operation* op,
+                          std::unique_ptr<dd::Package<Config>>& dd) {
+  return getDD(op, dd, true);
+}
+
+template <class Config>
+qc::MatrixDD getInverseDD(const qc::Operation* op,
+                          std::unique_ptr<dd::Package<Config>>& dd,
+                          qc::Permutation& permutation) {
+  return getDD(op, dd, permutation, true);
+}
+
+template <class Config>
+void dumpTensor(qc::Operation* op, std::ostream& of,
+                std::vector<std::size_t>& inds, std::size_t& gateIdx,
+                std::unique_ptr<dd::Package<Config>>& dd);
+
+// apply swaps 'on' DD in order to change 'from' to 'to'
+// where |from| >= |to|
+template <class DDType, class Config>
+void changePermutation(DDType& on, qc::Permutation& from,
+                       const qc::Permutation& to,
+                       std::unique_ptr<dd::Package<Config>>& dd,
+                       bool regular = true) {
+  assert(from.size() >= to.size());
+
+  // iterate over (k,v) pairs of second permutation
+  for (const auto& [i, goal] : to) {
+    // search for key in the first map
+    auto it = from.find(i);
+    if (it == from.end()) {
+      throw qc::QFRException(
+          "[changePermutation] Key " + std::to_string(it->first) +
+          " was not found in first permutation. This should never happen.");
+    }
+    auto current = it->second;
+
+    // permutations agree for this key value
+    if (current == goal) {
+      continue;
+    }
+
+    // search for goal value in first permutation
+    qc::Qubit j = 0;
+    for (const auto& [key, value] : from) {
+      if (value == goal) {
+        j = key;
+        break;
+      }
+    }
+
+    // swap i and j
+    auto saved = on;
+    const auto swapDD = dd->makeSWAPDD(
+        static_cast<dd::QubitCount>(on.p->v + 1), dd::Controls{},
+        static_cast<dd::Qubit>(from.at(i)), static_cast<dd::Qubit>(from.at(j)));
+    if constexpr (std::is_same_v<DDType, qc::VectorDD>) {
+      on = dd->multiply(swapDD, on);
+    } else {
+      // the regular flag only has an effect on matrix DDs
+      if (regular) {
+        on = dd->multiply(swapDD, on);
+      } else {
+        on = dd->multiply(on, swapDD);
+      }
+    }
+
+    dd->incRef(on);
+    dd->decRef(saved);
+    dd->garbageCollect();
+
+    // update permutation
+    from.at(i) = goal;
+    from.at(j) = current;
+  }
+}
+
 } // namespace dd
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/include/dd/Simulation.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/dd/Simulation.hpp`

 * *Files 22% similar despite different names*

```diff
@@ -1,49 +1,56 @@
-/*
-* This file is part of MQT QFR library which is released under the MIT license.
-* See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
-*/
-
 #pragma once
 
 #include "QuantumComputation.hpp"
 #include "algorithms/GoogleRandomCircuitSampling.hpp"
 #include "dd/Operations.hpp"
 
 namespace dd {
-    using namespace qc;
-
-    template<class Config>
-    VectorDD simulate(const QuantumComputation* qc, const VectorDD& in, std::unique_ptr<dd::Package<Config>>& dd) {
-        // measurements are currently not supported here
-        auto permutation = qc->initialLayout;
-        auto e           = in;
-        dd->incRef(e);
-
-        for (const auto& op: *qc) {
-            auto tmp = dd->multiply(getDD(op.get(), dd, permutation), e);
-            dd->incRef(tmp);
-            dd->decRef(e);
-            e = tmp;
-
-            dd->garbageCollect();
-        }
-
-        // correct permutation if necessary
-        changePermutation(e, permutation, qc->outputPermutation, dd);
-        e = dd->reduceGarbage(e, qc->garbage);
-
-        return e;
-    }
-
-    template<class Config>
-    std::map<std::string, std::size_t> simulate(const QuantumComputation* qc, const VectorDD& in, std::unique_ptr<dd::Package<Config>>& dd, std::size_t shots, std::size_t seed = 0U);
-
-    template<class Config>
-    void extractProbabilityVector(const QuantumComputation* qc, const VectorDD& in, dd::ProbabilityVector& probVector, std::unique_ptr<dd::Package<Config>>& dd);
-
-    template<class Config>
-    void extractProbabilityVectorRecursive(const QuantumComputation* qc, const VectorDD& currentState, decltype(qc->begin()) currentIt, std::map<std::size_t, char> measurements, dd::fp commonFactor, dd::ProbabilityVector& probVector, std::unique_ptr<dd::Package<Config>>& dd);
+using namespace qc;
 
-    template<class Config>
-    VectorDD simulate(GoogleRandomCircuitSampling* qc, const VectorDD& in, std::unique_ptr<dd::Package<Config>>& dd, std::optional<std::size_t> ncycles = std::nullopt);
+template <class Config>
+VectorDD simulate(const QuantumComputation* qc, const VectorDD& in,
+                  std::unique_ptr<dd::Package<Config>>& dd) {
+  // measurements are currently not supported here
+  auto permutation = qc->initialLayout;
+  auto e = in;
+  dd->incRef(e);
+
+  for (const auto& op : *qc) {
+    auto tmp = dd->multiply(getDD(op.get(), dd, permutation), e);
+    dd->incRef(tmp);
+    dd->decRef(e);
+    e = tmp;
+
+    dd->garbageCollect();
+  }
+
+  // correct permutation if necessary
+  changePermutation(e, permutation, qc->outputPermutation, dd);
+  e = dd->reduceGarbage(e, qc->garbage);
+
+  return e;
+}
+
+template <class Config>
+std::map<std::string, std::size_t>
+simulate(const QuantumComputation* qc, const VectorDD& in,
+         std::unique_ptr<dd::Package<Config>>& dd, std::size_t shots,
+         std::size_t seed = 0U);
+
+template <class Config>
+void extractProbabilityVector(const QuantumComputation* qc, const VectorDD& in,
+                              dd::ProbabilityVector& probVector,
+                              std::unique_ptr<dd::Package<Config>>& dd);
+
+template <class Config>
+void extractProbabilityVectorRecursive(
+    const QuantumComputation* qc, const VectorDD& currentState,
+    decltype(qc->begin()) currentIt, std::map<std::size_t, char> measurements,
+    dd::fp commonFactor, dd::ProbabilityVector& probVector,
+    std::unique_ptr<dd::Package<Config>>& dd);
+
+template <class Config>
+VectorDD simulate(GoogleRandomCircuitSampling* qc, const VectorDD& in,
+                  std::unique_ptr<dd::Package<Config>>& dd,
+                  std::optional<std::size_t> ncycles = std::nullopt);
 } // namespace dd
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/include/ecc/Ecc.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/ecc/Ecc.hpp`

 * *Files 20% similar despite different names*

```diff
@@ -1,109 +1,111 @@
-/*
-* This file is part of MQT QFR library which is released under the MIT license.
-* See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
-*/
-
 #pragma once
 
 #include "QuantumComputation.hpp"
 
 namespace ecc {
-    using Qubit      = qc::Qubit;
-    using QubitCount = std::size_t;
+using Qubit = qc::Qubit;
+using QubitCount = std::size_t;
 
-    class Ecc {
-    public:
-        enum class ID {
-            Id,
-            Q3Shor,
-            Q9Shor,
-            Q5Laflamme,
-            Q7Steane,
-            Q9Surface,
-            Q18Surface
-        };
-        struct Info {
-            ID                                               id;
-            std::size_t                                      nRedundantQubits; //usually number of physical qubits per (encoded) logical qubit
-            std::size_t                                      nCorrectingBits;  //usually number of classical bits needed for correcting one qubit
-            std::string                                      name;
-            std::vector<std::pair<std::size_t, std::string>> classicalRegisters;
-        };
-
-        Ecc(Info newEcc, std::shared_ptr<qc::QuantumComputation> qc, std::size_t newMeasureFrequency):
-            qcOriginal(std::move(qc)), measureFrequency(newMeasureFrequency), ecc(std::move(newEcc)) {
-            qcMapped = std::make_shared<qc::QuantumComputation>();
-        }
-        virtual ~Ecc() = default;
-
-        std::shared_ptr<qc::QuantumComputation> apply();
-
-        [[nodiscard]] std::shared_ptr<qc::QuantumComputation> getOriginalCircuit() const {
-            return qcOriginal;
-        }
-
-        [[nodiscard]] std::shared_ptr<qc::QuantumComputation> getMappedCircuit() const {
-            return qcMapped;
-        }
-
-        virtual std::string getName() {
-            return ecc.name;
-        }
-
-        virtual std::size_t getNOutputQubits(std::size_t nInputQubits) {
-            return nInputQubits * ecc.nRedundantQubits + ecc.nCorrectingBits;
-        }
-
-        [[nodiscard]] std::vector<Qubit> getDataQubits() const {
-            auto               numberOfDataQubits = qcOriginal->getNqubits() * ecc.nRedundantQubits;
-            std::vector<Qubit> dataQubits(numberOfDataQubits);
-            std::iota(std::begin(dataQubits), std::end(dataQubits), 0);
-            return dataQubits;
-        }
-
-        std::shared_ptr<qc::QuantumComputation> qcOriginal;
-        std::shared_ptr<qc::QuantumComputation> qcMapped;
-        std::size_t                             measureFrequency;
-        bool                                    isDecoded    = true;
-        bool                                    gatesWritten = false;
-        Info                                    ecc;
-
-    protected:
-        void initMappedCircuit();
-
-        /**
-     * prepares an encoded logical |0> state in the qcMapped circuit.
-     * May, but does not have to be overridden by subclasses.
-     * */
-        virtual void writeEncoding() {
-            if (!isDecoded) {
-                return;
-            }
-            isDecoded = false;
-            measureAndCorrect();
-        }
-
-        /**
-     * in case of an error, calling this function creates a 'clean' state again. Usual structure:
-     *
-     * for each logical qubit i:
-     * -- reset ancilla qubits
-     * -- measure physical data qubits of logical qubit[i] onto ancilla qubits
-     * -- correct data qubits based on measurement results of ancilla qubits
-     * */
-        virtual void measureAndCorrect() = 0;
-
-        /**
-     * moves encoded state information back to original qubits (i.e. 1 qubit per logical qubit)
-     * */
-        virtual void writeDecoding() = 0;
-
-        virtual void mapGate(const qc::Operation& gate) = 0;
-
-        void gateNotAvailableError(const qc::Operation& gate) const {
-            std::stringstream stream;
-            stream << "Gate " << gate << " not supported to encode in error code " << ecc.name << "!";
-            throw qc::QFRException(stream.str());
-        }
-    };
+class Ecc {
+public:
+  enum class ID {
+    Id,
+    Q3Shor,
+    Q9Shor,
+    Q5Laflamme,
+    Q7Steane,
+    Q9Surface,
+    Q18Surface
+  };
+  struct Info {
+    ID id;
+    std::size_t nRedundantQubits; // usually number of physical qubits per
+                                  // (encoded) logical qubit
+    std::size_t nCorrectingBits;  // usually number of classical bits needed for
+                                  // correcting one qubit
+    std::string name;
+    std::vector<std::pair<std::size_t, std::string>> classicalRegisters;
+  };
+
+  Ecc(Info newEcc, std::shared_ptr<qc::QuantumComputation> qc,
+      std::size_t newMeasureFrequency)
+      : qcOriginal(std::move(qc)), measureFrequency(newMeasureFrequency),
+        ecc(std::move(newEcc)) {
+    qcMapped = std::make_shared<qc::QuantumComputation>();
+  }
+  virtual ~Ecc() = default;
+
+  std::shared_ptr<qc::QuantumComputation> apply();
+
+  [[nodiscard]] std::shared_ptr<qc::QuantumComputation>
+  getOriginalCircuit() const {
+    return qcOriginal;
+  }
+
+  [[nodiscard]] std::shared_ptr<qc::QuantumComputation>
+  getMappedCircuit() const {
+    return qcMapped;
+  }
+
+  virtual std::string getName() { return ecc.name; }
+
+  virtual std::size_t getNOutputQubits(std::size_t nInputQubits) {
+    return nInputQubits * ecc.nRedundantQubits + ecc.nCorrectingBits;
+  }
+
+  [[nodiscard]] std::vector<Qubit> getDataQubits() const {
+    auto numberOfDataQubits = qcOriginal->getNqubits() * ecc.nRedundantQubits;
+    std::vector<Qubit> dataQubits(numberOfDataQubits);
+    std::iota(std::begin(dataQubits), std::end(dataQubits), 0);
+    return dataQubits;
+  }
+
+  std::shared_ptr<qc::QuantumComputation> qcOriginal;
+  std::shared_ptr<qc::QuantumComputation> qcMapped;
+  std::size_t measureFrequency;
+  bool isDecoded = true;
+  bool gatesWritten = false;
+  Info ecc;
+
+protected:
+  void initMappedCircuit();
+
+  /**
+   * prepares an encoded logical |0> state in the qcMapped circuit.
+   * May, but does not have to be overridden by subclasses.
+   * */
+  virtual void writeEncoding() {
+    if (!isDecoded) {
+      return;
+    }
+    isDecoded = false;
+    measureAndCorrect();
+  }
+
+  /**
+   * in case of an error, calling this function creates a 'clean' state again.
+   * Usual structure:
+   *
+   * for each logical qubit i:
+   * -- reset ancilla qubits
+   * -- measure physical data qubits of logical qubit[i] onto ancilla qubits
+   * -- correct data qubits based on measurement results of ancilla qubits
+   * */
+  virtual void measureAndCorrect() = 0;
+
+  /**
+   * moves encoded state information back to original qubits (i.e. 1 qubit per
+   * logical qubit)
+   * */
+  virtual void writeDecoding() = 0;
+
+  virtual void mapGate(const qc::Operation& gate) = 0;
+
+  void gateNotAvailableError(const qc::Operation& gate) const {
+    std::stringstream stream;
+    stream << "Gate " << gate << " not supported to encode in error code "
+           << ecc.name << "!";
+    throw qc::QFRException(stream.str());
+  }
+};
 } // namespace ecc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/include/ecc/Q18Surface.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/ecc/Q18Surface.hpp`

 * *Files 12% similar despite different names*

```diff
@@ -1,75 +1,69 @@
-/*
-* This file is part of MQT QFR library which is released under the MIT license.
-* See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
-*/
-
 #pragma once
 
 #include "Ecc.hpp"
 #include "QuantumComputation.hpp"
 namespace ecc {
-    class Q18Surface: public Ecc {
-    public:
-        Q18Surface(std::shared_ptr<qc::QuantumComputation> qc, std::size_t measureFq):
-            Ecc({ID::Q18Surface, N_REDUNDANT_QUBITS, 0, "Q18Surface", {{ANCILLA_WIDTH, "qeccX"}}}, std::move(qc), measureFq) {}
-
-        constexpr static QubitCount N_DATA_QUBITS      = 18;
-        constexpr static QubitCount N_ANCILLA_QUBITS   = 18;
-        constexpr static QubitCount N_REDUNDANT_QUBITS = N_DATA_QUBITS + N_ANCILLA_QUBITS;
-        constexpr static QubitCount ANCILLA_WIDTH      = 8;
-
-        constexpr static std::array<Qubit, N_DATA_QUBITS>    DATA_QUBITS           = {1, 3, 5, 6, 8, 10, 13, 15, 17, 18, 20, 22, 25, 27, 29, 30, 32, 34};
-        constexpr static std::array<Qubit, N_ANCILLA_QUBITS> ANCILLA_INDICES       = {0, 2, 4, 7, 9, 11, 12, 14, 16, 19, 21, 23, 24, 26, 28, 31, 33, 35};
-        constexpr static std::array<Qubit, 4>                ANCILLA_QUBITS_DECODE = {8, 13, 15, 20};
-        constexpr static Qubit                               X_INFORMATION         = 14;
-        constexpr static std::array<Qubit, 3>                LOGICAL_X             = {5, 10, 15};
-        constexpr static std::array<Qubit, 3>                LOGICAL_Z             = {20, 25, 30};
-
-        //{a,{b,c}} == qubit a is checked by b and c
-        std::map<std::size_t, std::vector<std::size_t>> qubitCorrectionX = {
-                {1, {0, 2}},
-                {3, {2, 4}},
-                {5, {4}},
-                {6, {0, 12}},
-                {8, {2}},
-                {10, {4, 16}},
-                {13, {12}},
-                {15, {16}},
-                {18, {12, 24}},
-                {20, {26}},
-                {22, {16, 28}},
-                {25, {24, 26}},
-                {27, {26, 28}},
-                {29, {28}},
-                {30, {24}}};
-
-        //temporarily deactivating phase correction
-        /*std::map<std::size_t, std::vector<std::size_t>> qubitCorrectionZ = {
-                {5, {11}},
-                {6, {7}},
-                {8, {7, 9}},
-                {10, {9, 11}},
-                {13, {7, 19}},
-                {15, {9}},
-                {17, {11, 23}},
-                {20, {19}},
-                {22, {23}},
-                {25, {19, 31}},
-                {27, {33}},
-                {29, {23, 35}},
-                {30, {31}},
-                {32, {31, 33}},
-                {34, {33, 35}}};*/
-
-        static constexpr std::array<std::size_t, ANCILLA_WIDTH> X_CHECKS = {0, 2, 4, 12, 16, 24, 26, 28};
-        //temporarily deactivating phase correction
-        //static constexpr std::array<std::size_t, ANCILLA_WIDTH> zChecks = {7, 9, 11, 19, 23, 31, 33, 35};
+class Q18Surface : public Ecc {
+public:
+  Q18Surface(std::shared_ptr<qc::QuantumComputation> qc, std::size_t measureFq)
+      : Ecc({ID::Q18Surface,
+             N_REDUNDANT_QUBITS,
+             0,
+             "Q18Surface",
+             {{ANCILLA_WIDTH, "qeccX"}}},
+            std::move(qc), measureFq) {}
+
+  constexpr static QubitCount N_DATA_QUBITS = 18;
+  constexpr static QubitCount N_ANCILLA_QUBITS = 18;
+  constexpr static QubitCount N_REDUNDANT_QUBITS =
+      N_DATA_QUBITS + N_ANCILLA_QUBITS;
+  constexpr static QubitCount ANCILLA_WIDTH = 8;
+
+  constexpr static std::array<Qubit, N_DATA_QUBITS> DATA_QUBITS = {
+      1, 3, 5, 6, 8, 10, 13, 15, 17, 18, 20, 22, 25, 27, 29, 30, 32, 34};
+  constexpr static std::array<Qubit, N_ANCILLA_QUBITS> ANCILLA_INDICES = {
+      0, 2, 4, 7, 9, 11, 12, 14, 16, 19, 21, 23, 24, 26, 28, 31, 33, 35};
+  constexpr static std::array<Qubit, 4> ANCILLA_QUBITS_DECODE = {8, 13, 15, 20};
+  constexpr static Qubit X_INFORMATION = 14;
+  constexpr static std::array<Qubit, 3> LOGICAL_X = {5, 10, 15};
+  constexpr static std::array<Qubit, 3> LOGICAL_Z = {20, 25, 30};
+
+  //{a,{b,c}} == qubit a is checked by b and c
+  std::map<std::size_t, std::vector<std::size_t>> qubitCorrectionX = {
+      {1, {0, 2}},    {3, {2, 4}},   {5, {4}},       {6, {0, 12}},
+      {8, {2}},       {10, {4, 16}}, {13, {12}},     {15, {16}},
+      {18, {12, 24}}, {20, {26}},    {22, {16, 28}}, {25, {24, 26}},
+      {27, {26, 28}}, {29, {28}},    {30, {24}}};
+
+  // temporarily deactivating phase correction
+  /*std::map<std::size_t, std::vector<std::size_t>> qubitCorrectionZ = {
+          {5, {11}},
+          {6, {7}},
+          {8, {7, 9}},
+          {10, {9, 11}},
+          {13, {7, 19}},
+          {15, {9}},
+          {17, {11, 23}},
+          {20, {19}},
+          {22, {23}},
+          {25, {19, 31}},
+          {27, {33}},
+          {29, {23, 35}},
+          {30, {31}},
+          {32, {31, 33}},
+          {34, {33, 35}}};*/
+
+  static constexpr std::array<std::size_t, ANCILLA_WIDTH> X_CHECKS = {
+      0, 2, 4, 12, 16, 24, 26, 28};
+  // temporarily deactivating phase correction
+  // static constexpr std::array<std::size_t, ANCILLA_WIDTH> zChecks = {7, 9,
+  // 11, 19, 23, 31, 33, 35};
 
-    protected:
-        void measureAndCorrect() override;
+protected:
+  void measureAndCorrect() override;
 
-        void writeDecoding() override;
+  void writeDecoding() override;
 
-        void mapGate(const qc::Operation& gate) override;
-    };
+  void mapGate(const qc::Operation& gate) override;
+};
 } // namespace ecc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/include/ecc/Q5Laflamme.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/ecc/Q5Laflamme.hpp`

 * *Files 14% similar despite different names*

```diff
@@ -1,37 +1,39 @@
-/*
-* This file is part of MQT QFR library which is released under the MIT license.
-* See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
-*/
-
 #pragma once
 
 #include "Ecc.hpp"
 #include "QuantumComputation.hpp"
 namespace ecc {
-    class Q5Laflamme: public Ecc {
-    public:
-        Q5Laflamme(std::shared_ptr<qc::QuantumComputation> qc, std::size_t measureFq):
-            Ecc({ID::Q5Laflamme, N_REDUNDANT_QUBITS, N_CORRECTING_BITS, "Q5Laflamme", {{N_CORRECTING_BITS, "qecc"}, {1, "encode"}}}, std::move(qc), measureFq) {}
-
-    protected:
-        void writeEncoding() override;
-
-        void measureAndCorrect() override;
-
-        void writeDecoding() override;
-
-        void mapGate(const qc::Operation& gate) override;
-
-        static constexpr std::size_t N_REDUNDANT_QUBITS = 5;
-        static constexpr std::size_t N_CORRECTING_BITS  = 4;
-
-        static constexpr std::array<std::array<qc::OpType, N_REDUNDANT_QUBITS>, 4> STABILIZER_MATRIX = {{
-                {qc::X, qc::Z, qc::Z, qc::X, qc::I}, //c0
-                {qc::I, qc::X, qc::Z, qc::Z, qc::X}, //c1
-                {qc::X, qc::I, qc::X, qc::Z, qc::Z}, //c2
-                {qc::Z, qc::X, qc::I, qc::X, qc::Z}  //c3
-        }};
-
-        static constexpr std::array<Qubit, 8> DECODING_CORRECTION_VALUES = {1, 2, 4, 7, 8, 11, 13, 14}; //values with odd amount of '1' bits
-    };
+class Q5Laflamme : public Ecc {
+public:
+  Q5Laflamme(std::shared_ptr<qc::QuantumComputation> qc, std::size_t measureFq)
+      : Ecc({ID::Q5Laflamme,
+             N_REDUNDANT_QUBITS,
+             N_CORRECTING_BITS,
+             "Q5Laflamme",
+             {{N_CORRECTING_BITS, "qecc"}, {1, "encode"}}},
+            std::move(qc), measureFq) {}
+
+protected:
+  void writeEncoding() override;
+
+  void measureAndCorrect() override;
+
+  void writeDecoding() override;
+
+  void mapGate(const qc::Operation& gate) override;
+
+  static constexpr std::size_t N_REDUNDANT_QUBITS = 5;
+  static constexpr std::size_t N_CORRECTING_BITS = 4;
+
+  static constexpr std::array<std::array<qc::OpType, N_REDUNDANT_QUBITS>, 4>
+      STABILIZER_MATRIX = {{
+          {qc::X, qc::Z, qc::Z, qc::X, qc::I}, // c0
+          {qc::I, qc::X, qc::Z, qc::Z, qc::X}, // c1
+          {qc::X, qc::I, qc::X, qc::Z, qc::Z}, // c2
+          {qc::Z, qc::X, qc::I, qc::X, qc::Z}  // c3
+      }};
+
+  static constexpr std::array<Qubit, 8> DECODING_CORRECTION_VALUES = {
+      1, 2, 4, 7, 8, 11, 13, 14}; // values with odd amount of '1' bits
+};
 } // namespace ecc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/include/ecc/Q7Steane.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/ecc/Q7Steane.hpp`

 * *Files 24% similar despite different names*

```diff
@@ -1,32 +1,32 @@
-/*
-* This file is part of MQT QFR library which is released under the MIT license.
-* See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
-*/
-
 #pragma once
 
 #include "Ecc.hpp"
 #include "QuantumComputation.hpp"
 namespace ecc {
-    class Q7Steane: public Ecc {
-    public:
-        Q7Steane(std::shared_ptr<qc::QuantumComputation> qc, std::size_t measureFq):
-            Ecc(
-                    {ID::Q7Steane, N_REDUNDANT_QUBITS, N_CORRECTING_BITS, "Q7Steane", {{N_CORRECTING_BITS, "qecc"}}}, std::move(qc), measureFq) {}
-
-    protected:
-        void writeEncoding() override;
-
-        void measureAndCorrect() override;
-        void measureAndCorrectSingle(bool xSyndrome);
-
-        void writeDecoding() override;
-
-        void mapGate(const qc::Operation& gate) override;
-
-        static constexpr std::size_t N_REDUNDANT_QUBITS = 7;
-        static constexpr std::size_t N_CORRECTING_BITS  = 3;
-
-        static constexpr std::array<Qubit, 4> DECODING_CORRECTION_VALUES = {1, 2, 4, 7}; //values with odd amount of '1' bits
-    };
+class Q7Steane : public Ecc {
+public:
+  Q7Steane(std::shared_ptr<qc::QuantumComputation> qc, std::size_t measureFq)
+      : Ecc({ID::Q7Steane,
+             N_REDUNDANT_QUBITS,
+             N_CORRECTING_BITS,
+             "Q7Steane",
+             {{N_CORRECTING_BITS, "qecc"}}},
+            std::move(qc), measureFq) {}
+
+protected:
+  void writeEncoding() override;
+
+  void measureAndCorrect() override;
+  void measureAndCorrectSingle(bool xSyndrome);
+
+  void writeDecoding() override;
+
+  void mapGate(const qc::Operation& gate) override;
+
+  static constexpr std::size_t N_REDUNDANT_QUBITS = 7;
+  static constexpr std::size_t N_CORRECTING_BITS = 3;
+
+  static constexpr std::array<Qubit, 4> DECODING_CORRECTION_VALUES = {
+      1, 2, 4, 7}; // values with odd amount of '1' bits
+};
 } // namespace ecc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/include/ecc/Q9Surface.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/ecc/Q9Surface.hpp`

 * *Files 12% similar despite different names*

```diff
@@ -1,41 +1,46 @@
-/*
-* This file is part of MQT QFR library which is released under the MIT license.
-* See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
-*/
-
 #pragma once
 
 #include "Ecc.hpp"
 #include "QuantumComputation.hpp"
 
-//Reference to this ecc in https://arxiv.org/pdf/1608.05053.pdf
+// Reference to this ecc in https://arxiv.org/pdf/1608.05053.pdf
 namespace ecc {
-    class Q9Surface: public Ecc {
-    public:
-        Q9Surface(std::shared_ptr<qc::QuantumComputation> qc, std::size_t measureFq):
-            Ecc({ID::Q9Surface, N_REDUNDANT_QUBITS, N_CORRECTING_BITS, "Q9Surface", {{ANCILLA_WIDTH, "qeccX"}, {ANCILLA_WIDTH, "qeccZ"}}}, std::move(qc), measureFq) {}
-
-    protected:
-        void measureAndCorrect() override;
-
-        void writeDecoding() override;
-
-        void mapGate(const qc::Operation& gate) override;
-
-    private:
-        //{a,{b,c}} == qubit a is checked by b and c
-        static constexpr std::size_t N_REDUNDANT_QUBITS = 9;
-        static constexpr std::size_t N_CORRECTING_BITS  = 8;
-        static constexpr std::size_t ANCILLA_WIDTH      = 4;
-
-        std::array<std::set<std::size_t>, N_REDUNDANT_QUBITS>   qubitCorrectionX   = {{{1}, {3}, {3}, {1, 4}, {3, 4}, {3, 6}, {4}, {4}, {6}}};
-        std::array<std::set<std::size_t>, N_REDUNDANT_QUBITS>   qubitCorrectionZ   = {{{2}, {0, 2}, {0}, {2}, {2, 5}, {5}, {7}, {5, 7}, {5}}};
-        static constexpr std::array<Qubit, ANCILLA_WIDTH>       X_ANCILLA_QUBITS   = {1, 3, 4, 6};
-        static constexpr std::array<Qubit, ANCILLA_WIDTH>       Z_ANCILLA_QUBITS   = {0, 2, 5, 7};
-        std::set<Qubit>                                         uncorrectedXQubits = {2, 6};
-        std::set<Qubit>                                         uncorrectedZQubits = {0, 8};
-        static constexpr std::array<Qubit, 3>                   LOGICAL_X          = {2, 4, 6};
-        static constexpr std::array<Qubit, 3>                   LOGICAL_Z          = {0, 4, 8};
-        static constexpr std::array<std::pair<Qubit, Qubit>, 4> SWAP_INDICES       = {{{0, 6}, {3, 7}, {2, 8}, {1, 5}}};
-    };
+class Q9Surface : public Ecc {
+public:
+  Q9Surface(std::shared_ptr<qc::QuantumComputation> qc, std::size_t measureFq)
+      : Ecc({ID::Q9Surface,
+             N_REDUNDANT_QUBITS,
+             N_CORRECTING_BITS,
+             "Q9Surface",
+             {{ANCILLA_WIDTH, "qeccX"}, {ANCILLA_WIDTH, "qeccZ"}}},
+            std::move(qc), measureFq) {}
+
+protected:
+  void measureAndCorrect() override;
+
+  void writeDecoding() override;
+
+  void mapGate(const qc::Operation& gate) override;
+
+private:
+  //{a,{b,c}} == qubit a is checked by b and c
+  static constexpr std::size_t N_REDUNDANT_QUBITS = 9;
+  static constexpr std::size_t N_CORRECTING_BITS = 8;
+  static constexpr std::size_t ANCILLA_WIDTH = 4;
+
+  std::array<std::set<std::size_t>, N_REDUNDANT_QUBITS> qubitCorrectionX = {
+      {{1}, {3}, {3}, {1, 4}, {3, 4}, {3, 6}, {4}, {4}, {6}}};
+  std::array<std::set<std::size_t>, N_REDUNDANT_QUBITS> qubitCorrectionZ = {
+      {{2}, {0, 2}, {0}, {2}, {2, 5}, {5}, {7}, {5, 7}, {5}}};
+  static constexpr std::array<Qubit, ANCILLA_WIDTH> X_ANCILLA_QUBITS = {1, 3, 4,
+                                                                        6};
+  static constexpr std::array<Qubit, ANCILLA_WIDTH> Z_ANCILLA_QUBITS = {0, 2, 5,
+                                                                        7};
+  std::set<Qubit> uncorrectedXQubits = {2, 6};
+  std::set<Qubit> uncorrectedZQubits = {0, 8};
+  static constexpr std::array<Qubit, 3> LOGICAL_X = {2, 4, 6};
+  static constexpr std::array<Qubit, 3> LOGICAL_Z = {0, 4, 8};
+  static constexpr std::array<std::pair<Qubit, Qubit>, 4> SWAP_INDICES = {
+      {{0, 6}, {3, 7}, {2, 8}, {1, 5}}};
+};
 } // namespace ecc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/include/operations/ClassicControlledOperation.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/operations/ClassicControlledOperation.hpp`

 * *Files 16% similar despite different names*

```diff
@@ -1,116 +1,106 @@
-/*
- * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
- */
-
 #pragma once
 
 #include "Operation.hpp"
 
 #include <utility>
 
 namespace qc {
 
-    class ClassicControlledOperation final: public Operation {
-    private:
-        std::unique_ptr<Operation> op;
-        ClassicalRegister          controlRegister{};
-        std::uint64_t              expectedValue = 1U;
-
-    public:
-        // Applies operation `_op` if the creg starting at index `control` has the expected value
-        ClassicControlledOperation(std::unique_ptr<qc::Operation>& operation, ClassicalRegister controlReg, std::uint64_t expectedVal = 1U):
-            op(std::move(operation)), controlRegister(std::move(controlReg)), expectedValue(expectedVal) {
-            nqubits = op->getNqubits();
-            name    = "c_" + op->getName();
-            parameter.reserve(3);
-            parameter.emplace_back(static_cast<fp>(controlRegister.first));
-            parameter.emplace_back(static_cast<fp>(controlRegister.second));
-            parameter.emplace_back(static_cast<fp>(expectedValue));
-            type = ClassicControlled;
-        }
-
-        [[nodiscard]] std::unique_ptr<Operation> clone() const override {
-            auto opCloned = op->clone();
-            return std::make_unique<ClassicControlledOperation>(opCloned, controlRegister, expectedValue);
-        }
-
-        [[nodiscard]] auto getControlRegister() const {
-            return controlRegister;
-        }
-
-        [[nodiscard]] auto getExpectedValue() const {
-            return expectedValue;
-        }
-
-        [[nodiscard]] auto getOperation() const {
-            return op.get();
-        }
-
-        void setNqubits(std::size_t nq) override {
-            nqubits = nq;
-            op->setNqubits(nq);
-        }
-
-        [[nodiscard]] const Targets& getTargets() const override {
-            return op->getTargets();
-        }
-
-        Targets& getTargets() override {
-            return op->getTargets();
-        }
-
-        [[nodiscard]] std::size_t getNtargets() const override {
-            return op->getNtargets();
-        }
-
-        [[nodiscard]] const Controls& getControls() const override {
-            return op->getControls();
-        }
-
-        Controls& getControls() override {
-            return op->getControls();
-        }
-
-        [[nodiscard]] std::size_t getNcontrols() const override {
-            return controls.size();
-        }
-
-        [[nodiscard]] bool isUnitary() const override {
-            return false;
-        }
-
-        [[nodiscard]] bool isClassicControlledOperation() const override {
-            return true;
-        }
-
-        [[nodiscard]] bool actsOn(Qubit i) const override {
-            return op->actsOn(i);
-        }
-
-        [[nodiscard]] bool equals(const Operation& operation, const Permutation& perm1, const Permutation& perm2) const override {
-            if (const auto* classic = dynamic_cast<const ClassicControlledOperation*>(&operation)) {
-                if (controlRegister != classic->controlRegister) {
-                    return false;
-                }
-
-                if (expectedValue != classic->expectedValue) {
-                    return false;
-                }
-
-                return op->equals(*classic->op, perm1, perm2);
-            }
-            return false;
-        }
-        [[nodiscard]] bool equals(const Operation& operation) const override {
-            return equals(operation, {}, {});
-        }
-
-        void dumpOpenQASM(std::ostream& of, const RegisterNames& qreg, const RegisterNames& creg) const override {
-            of << "if(";
-            of << creg[controlRegister.first].first;
-            of << " == " << expectedValue << ") ";
-            op->dumpOpenQASM(of, qreg, creg);
-        }
-    };
+class ClassicControlledOperation final : public Operation {
+private:
+  std::unique_ptr<Operation> op;
+  ClassicalRegister controlRegister{};
+  std::uint64_t expectedValue = 1U;
+
+public:
+  // Applies operation `_op` if the creg starting at index `control` has the
+  // expected value
+  ClassicControlledOperation(std::unique_ptr<qc::Operation>& operation,
+                             ClassicalRegister controlReg,
+                             std::uint64_t expectedVal = 1U)
+      : op(std::move(operation)), controlRegister(std::move(controlReg)),
+        expectedValue(expectedVal) {
+    nqubits = op->getNqubits();
+    name = "c_" + op->getName();
+    parameter.reserve(3);
+    parameter.emplace_back(static_cast<fp>(controlRegister.first));
+    parameter.emplace_back(static_cast<fp>(controlRegister.second));
+    parameter.emplace_back(static_cast<fp>(expectedValue));
+    type = ClassicControlled;
+  }
+
+  [[nodiscard]] std::unique_ptr<Operation> clone() const override {
+    auto opCloned = op->clone();
+    return std::make_unique<ClassicControlledOperation>(
+        opCloned, controlRegister, expectedValue);
+  }
+
+  [[nodiscard]] auto getControlRegister() const { return controlRegister; }
+
+  [[nodiscard]] auto getExpectedValue() const { return expectedValue; }
+
+  [[nodiscard]] auto getOperation() const { return op.get(); }
+
+  void setNqubits(std::size_t nq) override {
+    nqubits = nq;
+    op->setNqubits(nq);
+  }
+
+  [[nodiscard]] const Targets& getTargets() const override {
+    return op->getTargets();
+  }
+
+  Targets& getTargets() override { return op->getTargets(); }
+
+  [[nodiscard]] std::size_t getNtargets() const override {
+    return op->getNtargets();
+  }
+
+  [[nodiscard]] const Controls& getControls() const override {
+    return op->getControls();
+  }
+
+  Controls& getControls() override { return op->getControls(); }
+
+  [[nodiscard]] std::size_t getNcontrols() const override {
+    return controls.size();
+  }
+
+  [[nodiscard]] bool isUnitary() const override { return false; }
+
+  [[nodiscard]] bool isClassicControlledOperation() const override {
+    return true;
+  }
+
+  [[nodiscard]] bool actsOn(Qubit i) const override { return op->actsOn(i); }
+
+  [[nodiscard]] bool equals(const Operation& operation,
+                            const Permutation& perm1,
+                            const Permutation& perm2) const override {
+    if (const auto* classic =
+            dynamic_cast<const ClassicControlledOperation*>(&operation)) {
+      if (controlRegister != classic->controlRegister) {
+        return false;
+      }
+
+      if (expectedValue != classic->expectedValue) {
+        return false;
+      }
+
+      return op->equals(*classic->op, perm1, perm2);
+    }
+    return false;
+  }
+  [[nodiscard]] bool equals(const Operation& operation) const override {
+    return equals(operation, {}, {});
+  }
+
+  void dumpOpenQASM(std::ostream& of, const RegisterNames& qreg,
+                    const RegisterNames& creg) const override {
+    of << "if(";
+    of << creg[controlRegister.first].first;
+    of << " == " << expectedValue << ") ";
+    op->dumpOpenQASM(of, qreg, creg);
+  }
+};
 } // namespace qc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/include/operations/CompoundOperation.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/operations/CompoundOperation.hpp`

 * *Files 9% similar despite different names*

```diff
@@ -1,178 +1,194 @@
-/*
- * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
- */
-
 #pragma once
 
 #include "Operation.hpp"
 
 namespace qc {
 
-    class CompoundOperation final: public Operation {
-    private:
-        std::vector<std::unique_ptr<Operation>> ops{};
-
-    public:
-        explicit CompoundOperation(const std::size_t nq) {
-            name    = "Compound operation:";
-            nqubits = nq;
-            type    = Compound;
-        }
-
-        explicit CompoundOperation(const std::size_t nq, std::vector<std::unique_ptr<Operation>>&& operations):
-            CompoundOperation(nq) {
-            ops = std::move(operations); // NOLINT (cppcoreguidelines-prefer-member-initializer)
-        }
-
-        [[nodiscard]] std::unique_ptr<Operation> clone() const override {
-            auto clonedCo = std::make_unique<CompoundOperation>(nqubits);
-            clonedCo->reserve(ops.size());
-
-            for (const auto& op: ops) {
-                clonedCo->ops.emplace_back<>(op->clone());
-            }
-            return clonedCo;
-        }
-
-        void setNqubits(const std::size_t nq) override {
-            nqubits = nq;
-            for (auto& op: ops) {
-                op->setNqubits(nq);
-            }
-        }
-
-        [[nodiscard]] bool isCompoundOperation() const override {
-            return true;
-        }
-
-        [[nodiscard]] bool isNonUnitaryOperation() const override {
-            return std::any_of(ops.cbegin(), ops.cend(), [](const auto& op) { return op->isNonUnitaryOperation(); });
-        }
-
-        [[nodiscard]] inline bool isSymbolicOperation() const override {
-            return std::any_of(ops.begin(), ops.end(), [](const auto& op) { return op->isSymbolicOperation(); });
-        }
-
-        [[nodiscard]] bool equals(const Operation& op, const Permutation& perm1, const Permutation& perm2) const override {
-            if (const auto* comp = dynamic_cast<const CompoundOperation*>(&op)) {
-                if (comp->ops.size() != ops.size()) {
-                    return false;
-                }
-
-                auto it = comp->ops.cbegin();
-                for (const auto& operation: ops) {
-                    if (!operation->equals(**it, perm1, perm2)) {
-                        return false;
-                    }
-                    ++it;
-                }
-                return true;
-            }
-            return false;
-        }
-        [[nodiscard]] bool equals(const Operation& operation) const override {
-            return equals(operation, {}, {});
-        }
-
-        std::ostream& print(std::ostream& os) const override {
-            os << name;
-            for (const auto& op: ops) {
-                os << std::endl
-                   << "\t";
-                op->print(os);
-            }
-
-            return os;
-        }
-
-        std::ostream& print(std::ostream& os, const Permutation& permutation) const override {
-            os << name;
-            for (const auto& op: ops) {
-                os << std::endl
-                   << "\t";
-                op->print(os, permutation);
-            }
-
-            return os;
-        }
-
-        [[nodiscard]] bool actsOn(const Qubit i) const override {
-            return std::any_of(ops.cbegin(), ops.cend(), [&i](const auto& op) { return op->actsOn(i); });
-        }
-
-        void addDepthContribution(std::vector<std::size_t>& depths) const override {
-            for (const auto& op: ops) {
-                op->addDepthContribution(depths);
-            }
-        }
-
-        void dumpOpenQASM(std::ostream& of, const RegisterNames& qreg, const RegisterNames& creg) const override {
-            for (const auto& op: ops) {
-                op->dumpOpenQASM(of, qreg, creg);
-            }
-        }
-
-        /**
-                 * Pass-Through
-                 */
-
-        // Iterators (pass-through)
-        auto               begin() noexcept { return ops.begin(); }
-        [[nodiscard]] auto begin() const noexcept { return ops.begin(); }
-        [[nodiscard]] auto cbegin() const noexcept { return ops.cbegin(); }
-        auto               end() noexcept { return ops.end(); }
-        [[nodiscard]] auto end() const noexcept { return ops.end(); }
-        [[nodiscard]] auto cend() const noexcept { return ops.cend(); }
-        auto               rbegin() noexcept { return ops.rbegin(); }
-        [[nodiscard]] auto rbegin() const noexcept { return ops.rbegin(); }
-        [[nodiscard]] auto crbegin() const noexcept { return ops.crbegin(); }
-        auto               rend() noexcept { return ops.rend(); }
-        [[nodiscard]] auto rend() const noexcept { return ops.rend(); }
-        [[nodiscard]] auto crend() const noexcept { return ops.crend(); }
-
-        // Capacity (pass-through)
-        [[nodiscard]] bool        empty() const noexcept { return ops.empty(); }
-        [[nodiscard]] std::size_t size() const noexcept { return ops.size(); }
-        [[nodiscard]] std::size_t max_size() const noexcept { return ops.max_size(); } // NOLINT (readability-identifier-naming)
-        [[nodiscard]] std::size_t capacity() const noexcept { return ops.capacity(); }
-
-        void reserve(std::size_t newCap) { ops.reserve(newCap); }
-        void shrink_to_fit() { ops.shrink_to_fit(); } // NOLINT (readability-identifier-naming)
-
-        // Modifiers (pass-through)
-        void                                              clear() noexcept { ops.clear(); }
-        void                                              pop_back() { return ops.pop_back(); } // NOLINT (readability-identifier-naming)
-        void                                              resize(std::size_t count) { ops.resize(count); }
-        std::vector<std::unique_ptr<Operation>>::iterator erase(std::vector<std::unique_ptr<Operation>>::const_iterator pos) { return ops.erase(pos); }
-        std::vector<std::unique_ptr<Operation>>::iterator erase(std::vector<std::unique_ptr<Operation>>::const_iterator first, std::vector<std::unique_ptr<Operation>>::const_iterator last) { return ops.erase(first, last); }
-        template<class T>
-        void emplace_back(std::unique_ptr<T>& op) { // NOLINT (readability-identifier-naming)
-            ops.emplace_back(std::move(op));
-        }
-        template<class T, class... Args>
-        void emplace_back(Args&&... args) { // NOLINT (readability-identifier-naming)
-            ops.emplace_back(std::make_unique<T>(args...));
-        }
-        template<class T, class... Args>
-        std::vector<std::unique_ptr<Operation>>::iterator insert(std::vector<std::unique_ptr<Operation>>::const_iterator iterator, Args&&... args) {
-            return ops.insert(iterator, std::make_unique<T>(args...));
-        }
-        template<class T>
-        std::vector<std::unique_ptr<Operation>>::iterator insert(std::vector<std::unique_ptr<Operation>>::const_iterator iterator, std::unique_ptr<T>& op) {
-            return ops.insert(iterator, std::move(op));
-        }
-
-        [[nodiscard]] const auto& at(std::size_t i) const { return ops.at(i); }
-
-        std::vector<std::unique_ptr<Operation>>& getOps() { return ops; }
-
-        [[nodiscard]] std::set<Qubit> getUsedQubits() const override {
-            std::set<Qubit> usedQubits{};
-            for (const auto& op: ops) {
-                usedQubits.merge(op->getUsedQubits());
-            }
-            return usedQubits;
-        }
-    };
+class CompoundOperation final : public Operation {
+private:
+  std::vector<std::unique_ptr<Operation>> ops{};
+
+public:
+  explicit CompoundOperation(const std::size_t nq) {
+    name = "Compound operation:";
+    nqubits = nq;
+    type = Compound;
+  }
+
+  explicit CompoundOperation(
+      const std::size_t nq,
+      std::vector<std::unique_ptr<Operation>>&& operations)
+      : CompoundOperation(nq) {
+    // NOLINTNEXTLINE(cppcoreguidelines-prefer-member-initializer)
+    ops = std::move(operations);
+  }
+
+  [[nodiscard]] std::unique_ptr<Operation> clone() const override {
+    auto clonedCo = std::make_unique<CompoundOperation>(nqubits);
+    clonedCo->reserve(ops.size());
+
+    for (const auto& op : ops) {
+      clonedCo->ops.emplace_back<>(op->clone());
+    }
+    return clonedCo;
+  }
+
+  void setNqubits(const std::size_t nq) override {
+    nqubits = nq;
+    for (auto& op : ops) {
+      op->setNqubits(nq);
+    }
+  }
+
+  [[nodiscard]] bool isCompoundOperation() const override { return true; }
+
+  [[nodiscard]] bool isNonUnitaryOperation() const override {
+    return std::any_of(ops.cbegin(), ops.cend(), [](const auto& op) {
+      return op->isNonUnitaryOperation();
+    });
+  }
+
+  [[nodiscard]] inline bool isSymbolicOperation() const override {
+    return std::any_of(ops.begin(), ops.end(), [](const auto& op) {
+      return op->isSymbolicOperation();
+    });
+  }
+
+  [[nodiscard]] bool equals(const Operation& op, const Permutation& perm1,
+                            const Permutation& perm2) const override {
+    if (const auto* comp = dynamic_cast<const CompoundOperation*>(&op)) {
+      if (comp->ops.size() != ops.size()) {
+        return false;
+      }
+
+      auto it = comp->ops.cbegin();
+      for (const auto& operation : ops) {
+        if (!operation->equals(**it, perm1, perm2)) {
+          return false;
+        }
+        ++it;
+      }
+      return true;
+    }
+    return false;
+  }
+  [[nodiscard]] bool equals(const Operation& operation) const override {
+    return equals(operation, {}, {});
+  }
+
+  std::ostream& print(std::ostream& os) const override {
+    os << name;
+    for (const auto& op : ops) {
+      os << std::endl << "\t";
+      op->print(os);
+    }
+
+    return os;
+  }
+
+  std::ostream& print(std::ostream& os,
+                      const Permutation& permutation) const override {
+    os << name;
+    for (const auto& op : ops) {
+      os << std::endl << "\t";
+      op->print(os, permutation);
+    }
+
+    return os;
+  }
+
+  [[nodiscard]] bool actsOn(const Qubit i) const override {
+    return std::any_of(ops.cbegin(), ops.cend(),
+                       [&i](const auto& op) { return op->actsOn(i); });
+  }
+
+  void addDepthContribution(std::vector<std::size_t>& depths) const override {
+    for (const auto& op : ops) {
+      op->addDepthContribution(depths);
+    }
+  }
+
+  void dumpOpenQASM(std::ostream& of, const RegisterNames& qreg,
+                    const RegisterNames& creg) const override {
+    for (const auto& op : ops) {
+      op->dumpOpenQASM(of, qreg, creg);
+    }
+  }
+
+  /**
+   * Pass-Through
+   */
+
+  // Iterators (pass-through)
+  auto begin() noexcept { return ops.begin(); }
+  [[nodiscard]] auto begin() const noexcept { return ops.begin(); }
+  [[nodiscard]] auto cbegin() const noexcept { return ops.cbegin(); }
+  auto end() noexcept { return ops.end(); }
+  [[nodiscard]] auto end() const noexcept { return ops.end(); }
+  [[nodiscard]] auto cend() const noexcept { return ops.cend(); }
+  auto rbegin() noexcept { return ops.rbegin(); }
+  [[nodiscard]] auto rbegin() const noexcept { return ops.rbegin(); }
+  [[nodiscard]] auto crbegin() const noexcept { return ops.crbegin(); }
+  auto rend() noexcept { return ops.rend(); }
+  [[nodiscard]] auto rend() const noexcept { return ops.rend(); }
+  [[nodiscard]] auto crend() const noexcept { return ops.crend(); }
+
+  // Capacity (pass-through)
+  [[nodiscard]] bool empty() const noexcept { return ops.empty(); }
+  [[nodiscard]] std::size_t size() const noexcept { return ops.size(); }
+  // NOLINTNEXTLINE(readability-identifier-naming)
+  [[nodiscard]] std::size_t max_size() const noexcept { return ops.max_size(); }
+  [[nodiscard]] std::size_t capacity() const noexcept { return ops.capacity(); }
+
+  void reserve(std::size_t newCap) { ops.reserve(newCap); }
+  // NOLINTNEXTLINE(readability-identifier-naming)
+  void shrink_to_fit() { ops.shrink_to_fit(); }
+
+  // Modifiers (pass-through)
+  void clear() noexcept { ops.clear(); }
+  // NOLINTNEXTLINE(readability-identifier-naming)
+  void pop_back() { return ops.pop_back(); }
+  void resize(std::size_t count) { ops.resize(count); }
+  std::vector<std::unique_ptr<Operation>>::iterator
+  erase(std::vector<std::unique_ptr<Operation>>::const_iterator pos) {
+    return ops.erase(pos);
+  }
+  std::vector<std::unique_ptr<Operation>>::iterator
+  erase(std::vector<std::unique_ptr<Operation>>::const_iterator first,
+        std::vector<std::unique_ptr<Operation>>::const_iterator last) {
+    return ops.erase(first, last);
+  }
+  // NOLINTNEXTLINE(readability-identifier-naming)
+  template <class T> void emplace_back(std::unique_ptr<T>& op) {
+    ops.emplace_back(std::move(op));
+  }
+  // NOLINTNEXTLINE(readability-identifier-naming)
+  template <class T, class... Args> void emplace_back(Args&&... args) {
+    ops.emplace_back(std::make_unique<T>(args...));
+  }
+  template <class T, class... Args>
+  std::vector<std::unique_ptr<Operation>>::iterator
+  insert(std::vector<std::unique_ptr<Operation>>::const_iterator iterator,
+         Args&&... args) {
+    return ops.insert(iterator, std::make_unique<T>(args...));
+  }
+  template <class T>
+  std::vector<std::unique_ptr<Operation>>::iterator
+  insert(std::vector<std::unique_ptr<Operation>>::const_iterator iterator,
+         std::unique_ptr<T>& op) {
+    return ops.insert(iterator, std::move(op));
+  }
+
+  [[nodiscard]] const auto& at(std::size_t i) const { return ops.at(i); }
+
+  std::vector<std::unique_ptr<Operation>>& getOps() { return ops; }
+
+  [[nodiscard]] std::set<Qubit> getUsedQubits() const override {
+    std::set<Qubit> usedQubits{};
+    for (const auto& op : ops) {
+      usedQubits.merge(op->getUsedQubits());
+    }
+    return usedQubits;
+  }
+};
 } // namespace qc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/include/operations/NonUnitaryOperation.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/operations/NonUnitaryOperation.hpp`

 * *Files 10% similar despite different names*

```diff
@@ -1,114 +1,116 @@
-/*
- * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
- */
-
 #pragma once
 
 #include "Operation.hpp"
 
 namespace qc {
 
-    class NonUnitaryOperation final: public Operation {
-    protected:
-        std::vector<Qubit> qubits{};   // vector for the qubits to measure (necessary since std::set does not preserve the order of inserted elements)
-        std::vector<Bit>   classics{}; // vector for the classical bits to measure into
-
-        std::ostream& printNonUnitary(std::ostream& os, const std::vector<Qubit>& q, const std::vector<Bit>& c = {}, const Permutation& permutation = {}) const;
-        void          printMeasurement(std::ostream& os, const std::vector<Qubit>& q, const std::vector<Bit>& c, const Permutation& permutation) const;
-        void          printResetBarrierOrSnapshot(std::ostream& os, const std::vector<Qubit>& q, const Permutation& permutation) const;
-
-    public:
-        // Measurement constructor
-        NonUnitaryOperation(std::size_t nq, std::vector<Qubit> qubitRegister, std::vector<Bit> classicalRegister);
-        NonUnitaryOperation(std::size_t nq, Qubit qubit, Bit cbit);
-
-        // Snapshot constructor
-        NonUnitaryOperation(std::size_t nq, const std::vector<Qubit>& qubitRegister, std::size_t n);
-
-        // ShowProbabilities constructor
-        explicit NonUnitaryOperation(const std::size_t nq) {
-            nqubits = nq;
-            type    = ShowProbabilities;
-        }
-
-        // General constructor
-        NonUnitaryOperation(std::size_t nq, const std::vector<Qubit>& qubitRegister, OpType op = Reset);
-
-        [[nodiscard]] std::unique_ptr<Operation> clone() const override {
-            if (getType() == qc::Measure) {
-                return std::make_unique<NonUnitaryOperation>(getNqubits(), getTargets(), getClassics());
-            }
-            if (getType() == qc::Snapshot) {
-                return std::make_unique<NonUnitaryOperation>(getNqubits(), getTargets(), getParameter().at(0));
-            }
-            if (getType() == qc::ShowProbabilities) {
-                return std::make_unique<NonUnitaryOperation>(getNqubits());
-            }
-            return std::make_unique<NonUnitaryOperation>(getNqubits(), getTargets(), getType());
-        }
-
-        [[nodiscard]] bool isUnitary() const override {
-            return false;
-        }
-
-        [[nodiscard]] bool isNonUnitaryOperation() const override {
-            return true;
-        }
-
-        [[nodiscard]] const Targets& getTargets() const override {
-            if (type == Measure) {
-                return qubits;
-            }
-            return targets;
-        }
-        Targets& getTargets() override {
-            if (type == Measure) {
-                return qubits;
-            }
-            return targets;
-        }
-        [[nodiscard]] std::size_t getNtargets() const override {
-            return getTargets().size();
-        }
-
-        [[nodiscard]] const std::vector<Bit>& getClassics() const {
-            return classics;
-        }
-        std::vector<Bit>& getClassics() {
-            return classics;
-        }
-        [[nodiscard]] size_t getNclassics() const {
-            return classics.size();
-        }
-
-        [[nodiscard, gnu::pure]] bool actsOn(Qubit i) const override;
-
-        void addDepthContribution(std::vector<std::size_t>& depths) const override;
-
-        [[nodiscard]] bool equals(const Operation& op, const Permutation& perm1, const Permutation& perm2) const override;
-        [[nodiscard]] bool equals(const Operation& operation) const override {
-            return equals(operation, {}, {});
-        }
-
-        std::ostream& print(std::ostream& os) const override {
-            if (type == Measure) {
-                return printNonUnitary(os, qubits, classics);
-            }
-            return printNonUnitary(os, targets);
-        }
-        std::ostream& print(std::ostream& os, const Permutation& permutation) const override {
-            if (type == Measure) {
-                return printNonUnitary(os, qubits, classics, permutation);
-            }
-            return printNonUnitary(os, targets, {}, permutation);
-        }
-
-        void dumpOpenQASM(std::ostream& of, const RegisterNames& qreg, const RegisterNames& creg) const override;
-
-        [[nodiscard]] std::set<Qubit> getUsedQubits() const override {
-            const auto& ts = getTargets();
-            return {ts.begin(), ts.end()};
-        }
-    };
+class NonUnitaryOperation final : public Operation {
+protected:
+  std::vector<Qubit>
+      qubits{}; // vector for the qubits to measure (necessary since std::set
+                // does not preserve the order of inserted elements)
+  std::vector<Bit> classics{}; // vector for the classical bits to measure into
+
+  std::ostream& printNonUnitary(std::ostream& os, const std::vector<Qubit>& q,
+                                const std::vector<Bit>& c = {},
+                                const Permutation& permutation = {}) const;
+  void printMeasurement(std::ostream& os, const std::vector<Qubit>& q,
+                        const std::vector<Bit>& c,
+                        const Permutation& permutation) const;
+  void printResetBarrierOrSnapshot(std::ostream& os,
+                                   const std::vector<Qubit>& q,
+                                   const Permutation& permutation) const;
+
+public:
+  // Measurement constructor
+  NonUnitaryOperation(std::size_t nq, std::vector<Qubit> qubitRegister,
+                      std::vector<Bit> classicalRegister);
+  NonUnitaryOperation(std::size_t nq, Qubit qubit, Bit cbit);
+
+  // Snapshot constructor
+  NonUnitaryOperation(std::size_t nq, const std::vector<Qubit>& qubitRegister,
+                      std::size_t n);
+
+  // ShowProbabilities constructor
+  explicit NonUnitaryOperation(const std::size_t nq) {
+    nqubits = nq;
+    type = ShowProbabilities;
+  }
+
+  // General constructor
+  NonUnitaryOperation(std::size_t nq, const std::vector<Qubit>& qubitRegister,
+                      OpType op = Reset);
+
+  [[nodiscard]] std::unique_ptr<Operation> clone() const override {
+    if (getType() == qc::Measure) {
+      return std::make_unique<NonUnitaryOperation>(getNqubits(), getTargets(),
+                                                   getClassics());
+    }
+    if (getType() == qc::Snapshot) {
+      return std::make_unique<NonUnitaryOperation>(getNqubits(), getTargets(),
+                                                   getParameter().at(0));
+    }
+    if (getType() == qc::ShowProbabilities) {
+      return std::make_unique<NonUnitaryOperation>(getNqubits());
+    }
+    return std::make_unique<NonUnitaryOperation>(getNqubits(), getTargets(),
+                                                 getType());
+  }
+
+  [[nodiscard]] bool isUnitary() const override { return false; }
+
+  [[nodiscard]] bool isNonUnitaryOperation() const override { return true; }
+
+  [[nodiscard]] const Targets& getTargets() const override {
+    if (type == Measure) {
+      return qubits;
+    }
+    return targets;
+  }
+  Targets& getTargets() override {
+    if (type == Measure) {
+      return qubits;
+    }
+    return targets;
+  }
+  [[nodiscard]] std::size_t getNtargets() const override {
+    return getTargets().size();
+  }
+
+  [[nodiscard]] const std::vector<Bit>& getClassics() const { return classics; }
+  std::vector<Bit>& getClassics() { return classics; }
+  [[nodiscard]] size_t getNclassics() const { return classics.size(); }
+
+  [[nodiscard, gnu::pure]] bool actsOn(Qubit i) const override;
+
+  void addDepthContribution(std::vector<std::size_t>& depths) const override;
+
+  [[nodiscard]] bool equals(const Operation& op, const Permutation& perm1,
+                            const Permutation& perm2) const override;
+  [[nodiscard]] bool equals(const Operation& operation) const override {
+    return equals(operation, {}, {});
+  }
+
+  std::ostream& print(std::ostream& os) const override {
+    if (type == Measure) {
+      return printNonUnitary(os, qubits, classics);
+    }
+    return printNonUnitary(os, targets);
+  }
+  std::ostream& print(std::ostream& os,
+                      const Permutation& permutation) const override {
+    if (type == Measure) {
+      return printNonUnitary(os, qubits, classics, permutation);
+    }
+    return printNonUnitary(os, targets, {}, permutation);
+  }
+
+  void dumpOpenQASM(std::ostream& of, const RegisterNames& qreg,
+                    const RegisterNames& creg) const override;
+
+  [[nodiscard]] std::set<Qubit> getUsedQubits() const override {
+    const auto& ts = getTargets();
+    return {ts.begin(), ts.end()};
+  }
+};
 } // namespace qc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/include/operations/OpType.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/operations/OpType.hpp`

 * *Files 22% similar despite different names*

```diff
@@ -1,236 +1,275 @@
-/*
-* This file is part of MQT QFR library which is released under the MIT license.
-* See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
-*/
-
 #pragma once
 
 #include <cstdint>
 #include <functional>
 #include <iostream>
 #include <string>
 
 namespace qc {
-    // Natively supported operations of the QFR library
-    enum OpType : std::uint8_t {
-        None,
-        // Standard Operations
-        GPhase,
-        I,
-        H,
-        X,
-        Y,
-        Z,
-        S,
-        Sdag,
-        T,
-        Tdag,
-        V,
-        Vdag,
-        U3,
-        U2,
-        Phase,
-        SX,
-        SXdag,
-        RX,
-        RY,
-        RZ,
-        SWAP,
-        iSWAP, // NOLINT (readability-identifier-naming)
-        Peres,
-        Peresdag,
-        DCX,
-        ECR,
-        RXX,
-        RYY,
-        RZZ,
-        RZX,
-        XXminusYY,
-        XXplusYY,
-        // Compound Operation
-        Compound,
-        // Non Unitary Operations
-        Measure,
-        Reset,
-        Snapshot,
-        ShowProbabilities,
-        Barrier,
-        Teleportation,
-        // Classically-controlled Operation
-        ClassicControlled,
-        // Noise operations
-        ATrue,
-        AFalse,
-        MultiATrue,
-        MultiAFalse,
-        // Number of OpTypes
-        OpCount
-    };
-
-    inline std::string toString(const OpType& opType) {
-        switch (opType) {
-            case None: return "none";
-            case GPhase: return "gphase";
-            case I: return "i";
-            case H: return "h";
-            case X: return "x";
-            case Y: return "y";
-            case Z: return "z";
-            case S: return "s";
-            case Sdag: return "sdg";
-            case T: return "t";
-            case Tdag: return "tdg";
-            case V: return "v";
-            case Vdag: return "vdg";
-            case U3: return "u3";
-            case U2: return "u2";
-            case Phase: return "p";
-            case SX: return "sx";
-            case SXdag: return "sxdg";
-            case RX: return "rx";
-            case RY: return "ry";
-            case RZ: return "rz";
-            case SWAP: return "swap";
-            case iSWAP: return "iswap";
-            case Peres: return "peres";
-            case Peresdag: return "peresdg";
-            case DCX: return "dcx";
-            case ECR: return "ecr";
-            case RXX: return "rxx";
-            case RYY: return "ryy";
-            case RZZ: return "rzz";
-            case RZX: return "rzx";
-            case XXminusYY: return "xx_minus_yy";
-            case XXplusYY: return "xx_plus_yy";
-            case Compound: return "compound";
-            case Measure: return "measure";
-            case Reset: return "reset";
-            case Snapshot: return "snapshot";
-            case ShowProbabilities: return "show probabilities";
-            case Barrier: return "barrier";
-            case Teleportation: return "teleportation";
-            case ClassicControlled: return "classic controlled";
-            default:
-                throw std::invalid_argument("Invalid OpType!");
-        }
-    }
-
-    inline bool isTwoQubitGate(const OpType& opType) {
-        switch (opType) {
-            case SWAP:
-            case iSWAP:
-            case Peres:
-            case Peresdag:
-            case DCX:
-            case ECR:
-            case RXX:
-            case RYY:
-            case RZZ:
-            case RZX:
-            case XXminusYY:
-            case XXplusYY:
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    inline std::ostream& operator<<(std::ostream& out, OpType& opType) {
-        out << toString(opType);
-        return out;
-    }
-
-    const inline static std::unordered_map<std::string, qc::OpType> OP_NAME_TO_TYPE = {
-            {"none", OpType::None},
-            {"gphase", OpType::GPhase},
-            {"i", OpType::I},
-            {"id", OpType::I},
-            {"h", OpType::H},
-            {"ch", OpType::H},
-            {"x", OpType::X},
-            {"cnot", OpType::X},
-            {"cx", OpType::X},
-            {"mcx", OpType::X},
-            {"y", OpType::Y},
-            {"cy", OpType::Y},
-            {"z", OpType::Z},
-            {"cz", OpType::Z},
-            {"s", OpType::S},
-            {"cs", OpType::S},
-            {"sdg", OpType::Sdag},
-            {"csdg", OpType::Sdag},
-            {"t", OpType::T},
-            {"ct", OpType::T},
-            {"tdg", OpType::Tdag},
-            {"ctdg", OpType::Tdag},
-            {"v", OpType::V},
-            {"vdg", OpType::Vdag},
-            {"u", OpType::U3},
-            {"cu", OpType::U3},
-            {"u3", OpType::U3},
-            {"cu3", OpType::U3},
-            {"u2", OpType::U2},
-            {"cu2", OpType::U2},
-            {"p", OpType::Phase},
-            {"cp", OpType::Phase},
-            {"mcp", OpType::Phase},
-            {"phase", OpType::Phase},
-            {"cphase", OpType::Phase},
-            {"mcphase", OpType::Phase},
-            {"u1", OpType::Phase},
-            {"cu1", OpType::Phase},
-            {"sx", OpType::SX},
-            {"csx", OpType::SX},
-            {"sxdg", OpType::SXdag},
-            {"csxdg", OpType::SXdag},
-            {"rx", OpType::RX},
-            {"crx", OpType::RX},
-            {"ry", OpType::RY},
-            {"cry", OpType::RY},
-            {"rz", OpType::RZ},
-            {"crz", OpType::RZ},
-            {"swap", OpType::SWAP},
-            {"cswap", OpType::SWAP},
-            {"iswap", OpType::iSWAP},
-            {"peres", OpType::Peres},
-            {"peresdg", OpType::Peresdag},
-            {"dcx", OpType::DCX},
-            {"ecr", OpType::ECR},
-            {"rxx", OpType::RXX},
-            {"ryy", OpType::RYY},
-            {"rzz", OpType::RZZ},
-            {"rzx", OpType::RZX},
-            {"xx_minus_yy", OpType::XXminusYY},
-            {"xx_plus_yy", OpType::XXplusYY},
-            {"measure", OpType::Measure},
-            {"reset", OpType::Reset},
-            {"snapshot", OpType::Snapshot},
-            {"show probabilities", OpType::ShowProbabilities},
-            {"barrier", OpType::Barrier},
-            {"teleportation", OpType::Teleportation},
-            {"classic controlled", OpType::ClassicControlled},
-            {"compound", OpType::Compound},
-    };
-
-    [[nodiscard]] inline OpType opTypeFromString(const std::string& opType) {
-        // try to find the operation type in the map of known operation types and return it if found or throw an exception otherwise.
-        if (const auto it = OP_NAME_TO_TYPE.find(opType); it != OP_NAME_TO_TYPE.end()) {
-            return OP_NAME_TO_TYPE.at(opType);
-        }
-        throw std::invalid_argument("Unsupported operation type: " + opType);
-    }
-
-    inline std::istream& operator>>(std::istream& in, OpType& opType) {
-        std::string opTypeStr;
-        in >> opTypeStr;
-
-        if (opTypeStr.empty()) {
-            in.setstate(std::istream::failbit);
-            return in;
-        }
-
-        opType = opTypeFromString(opTypeStr);
-        return in;
-    }
+// Natively supported operations of the QFR library
+enum OpType : std::uint8_t {
+  None,
+  // Standard Operations
+  GPhase,
+  I,
+  H,
+  X,
+  Y,
+  Z,
+  S,
+  Sdag,
+  T,
+  Tdag,
+  V,
+  Vdag,
+  U3,
+  U2,
+  Phase,
+  SX,
+  SXdag,
+  RX,
+  RY,
+  RZ,
+  SWAP,
+  iSWAP, // NOLINT (readability-identifier-naming)
+  Peres,
+  Peresdag,
+  DCX,
+  ECR,
+  RXX,
+  RYY,
+  RZZ,
+  RZX,
+  XXminusYY,
+  XXplusYY,
+  // Compound Operation
+  Compound,
+  // Non Unitary Operations
+  Measure,
+  Reset,
+  Snapshot,
+  ShowProbabilities,
+  Barrier,
+  Teleportation,
+  // Classically-controlled Operation
+  ClassicControlled,
+  // Noise operations
+  ATrue,
+  AFalse,
+  MultiATrue,
+  MultiAFalse,
+  // Number of OpTypes
+  OpCount
+};
+
+inline std::string toString(const OpType& opType) {
+  switch (opType) {
+  case None:
+    return "none";
+  case GPhase:
+    return "gphase";
+  case I:
+    return "i";
+  case H:
+    return "h";
+  case X:
+    return "x";
+  case Y:
+    return "y";
+  case Z:
+    return "z";
+  case S:
+    return "s";
+  case Sdag:
+    return "sdg";
+  case T:
+    return "t";
+  case Tdag:
+    return "tdg";
+  case V:
+    return "v";
+  case Vdag:
+    return "vdg";
+  case U3:
+    return "u3";
+  case U2:
+    return "u2";
+  case Phase:
+    return "p";
+  case SX:
+    return "sx";
+  case SXdag:
+    return "sxdg";
+  case RX:
+    return "rx";
+  case RY:
+    return "ry";
+  case RZ:
+    return "rz";
+  case SWAP:
+    return "swap";
+  case iSWAP:
+    return "iswap";
+  case Peres:
+    return "peres";
+  case Peresdag:
+    return "peresdg";
+  case DCX:
+    return "dcx";
+  case ECR:
+    return "ecr";
+  case RXX:
+    return "rxx";
+  case RYY:
+    return "ryy";
+  case RZZ:
+    return "rzz";
+  case RZX:
+    return "rzx";
+  case XXminusYY:
+    return "xx_minus_yy";
+  case XXplusYY:
+    return "xx_plus_yy";
+  case Compound:
+    return "compound";
+  case Measure:
+    return "measure";
+  case Reset:
+    return "reset";
+  case Snapshot:
+    return "snapshot";
+  case ShowProbabilities:
+    return "show probabilities";
+  case Barrier:
+    return "barrier";
+  case Teleportation:
+    return "teleportation";
+  case ClassicControlled:
+    return "classic controlled";
+  default:
+    throw std::invalid_argument("Invalid OpType!");
+  }
+}
+
+inline bool isTwoQubitGate(const OpType& opType) {
+  switch (opType) {
+  case SWAP:
+  case iSWAP:
+  case Peres:
+  case Peresdag:
+  case DCX:
+  case ECR:
+  case RXX:
+  case RYY:
+  case RZZ:
+  case RZX:
+  case XXminusYY:
+  case XXplusYY:
+    return true;
+  default:
+    return false;
+  }
+}
+
+inline std::ostream& operator<<(std::ostream& out, OpType& opType) {
+  out << toString(opType);
+  return out;
+}
+
+const inline static std::unordered_map<std::string, qc::OpType>
+    OP_NAME_TO_TYPE = {
+        {"none", OpType::None},
+        {"gphase", OpType::GPhase},
+        {"i", OpType::I},
+        {"id", OpType::I},
+        {"h", OpType::H},
+        {"ch", OpType::H},
+        {"x", OpType::X},
+        {"cnot", OpType::X},
+        {"cx", OpType::X},
+        {"mcx", OpType::X},
+        {"y", OpType::Y},
+        {"cy", OpType::Y},
+        {"z", OpType::Z},
+        {"cz", OpType::Z},
+        {"s", OpType::S},
+        {"cs", OpType::S},
+        {"sdg", OpType::Sdag},
+        {"csdg", OpType::Sdag},
+        {"t", OpType::T},
+        {"ct", OpType::T},
+        {"tdg", OpType::Tdag},
+        {"ctdg", OpType::Tdag},
+        {"v", OpType::V},
+        {"vdg", OpType::Vdag},
+        {"u", OpType::U3},
+        {"cu", OpType::U3},
+        {"u3", OpType::U3},
+        {"cu3", OpType::U3},
+        {"u2", OpType::U2},
+        {"cu2", OpType::U2},
+        {"p", OpType::Phase},
+        {"cp", OpType::Phase},
+        {"mcp", OpType::Phase},
+        {"phase", OpType::Phase},
+        {"cphase", OpType::Phase},
+        {"mcphase", OpType::Phase},
+        {"u1", OpType::Phase},
+        {"cu1", OpType::Phase},
+        {"sx", OpType::SX},
+        {"csx", OpType::SX},
+        {"sxdg", OpType::SXdag},
+        {"csxdg", OpType::SXdag},
+        {"rx", OpType::RX},
+        {"crx", OpType::RX},
+        {"ry", OpType::RY},
+        {"cry", OpType::RY},
+        {"rz", OpType::RZ},
+        {"crz", OpType::RZ},
+        {"swap", OpType::SWAP},
+        {"cswap", OpType::SWAP},
+        {"iswap", OpType::iSWAP},
+        {"peres", OpType::Peres},
+        {"peresdg", OpType::Peresdag},
+        {"dcx", OpType::DCX},
+        {"ecr", OpType::ECR},
+        {"rxx", OpType::RXX},
+        {"ryy", OpType::RYY},
+        {"rzz", OpType::RZZ},
+        {"rzx", OpType::RZX},
+        {"xx_minus_yy", OpType::XXminusYY},
+        {"xx_plus_yy", OpType::XXplusYY},
+        {"measure", OpType::Measure},
+        {"reset", OpType::Reset},
+        {"snapshot", OpType::Snapshot},
+        {"show probabilities", OpType::ShowProbabilities},
+        {"barrier", OpType::Barrier},
+        {"teleportation", OpType::Teleportation},
+        {"classic controlled", OpType::ClassicControlled},
+        {"compound", OpType::Compound},
+};
+
+[[nodiscard]] inline OpType opTypeFromString(const std::string& opType) {
+  // try to find the operation type in the map of known operation types and
+  // return it if found or throw an exception otherwise.
+  if (const auto it = OP_NAME_TO_TYPE.find(opType);
+      it != OP_NAME_TO_TYPE.end()) {
+    return OP_NAME_TO_TYPE.at(opType);
+  }
+  throw std::invalid_argument("Unsupported operation type: " + opType);
+}
+
+inline std::istream& operator>>(std::istream& in, OpType& opType) {
+  std::string opTypeStr;
+  in >> opTypeStr;
+
+  if (opTypeStr.empty()) {
+    in.setstate(std::istream::failbit);
+    return in;
+  }
+
+  opType = opTypeFromString(opTypeStr);
+  return in;
+}
 
 } // namespace qc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/include/operations/Operation.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/operations/Operation.hpp`

 * *Files 17% similar despite different names*

```diff
@@ -1,12 +1,7 @@
-/*
- * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
- */
-
 #pragma once
 
 #include "Definitions.hpp"
 #include "OpType.hpp"
 #include "Permutation.hpp"
 
 #include <array>
@@ -16,169 +11,148 @@
 #include <iostream>
 #include <map>
 #include <memory>
 #include <set>
 #include <vector>
 
 namespace qc {
-    class Operation {
-    protected:
-        Controls        controls{};
-        Targets         targets{};
-        std::vector<fp> parameter{};
-
-        std::size_t nqubits    = 0;
-        Qubit       startQubit = 0;
-        OpType      type       = None;
-        std::string name{};
-
-        static bool isWholeQubitRegister(const RegisterNames& reg, std::size_t start, std::size_t end) {
-            return !reg.empty() && reg[start].first == reg[end].first && (start == 0 || reg[start].first != reg[start - 1].first) && (end == reg.size() - 1 || reg[end].first != reg[end + 1].first);
-        }
-
-    public:
-        Operation() = default;
-
-        Operation(const Operation& op)     = delete;
-        Operation(Operation&& op) noexcept = default;
-
-        Operation& operator=(const Operation& op) = delete;
-
-        Operation& operator=(Operation&& op) noexcept = default;
-
-        // Virtual Destructor
-        virtual ~Operation() = default;
-
-        [[nodiscard]] virtual std::unique_ptr<Operation> clone() const = 0;
-
-        // Getters
-        [[nodiscard]] virtual const Targets& getTargets() const {
-            return targets;
-        }
-        virtual Targets& getTargets() {
-            return targets;
-        }
-        [[nodiscard]] virtual std::size_t getNtargets() const {
-            return targets.size();
-        }
-
-        [[nodiscard]] virtual const Controls& getControls() const {
-            return controls;
-        }
-        virtual Controls& getControls() {
-            return controls;
-        }
-        [[nodiscard]] virtual std::size_t getNcontrols() const {
-            return controls.size();
-        }
-
-        [[nodiscard]] std::size_t getNqubits() const {
-            return nqubits;
-        }
-
-        [[nodiscard]] const std::vector<fp>& getParameter() const {
-            return parameter;
-        }
-        std::vector<fp>& getParameter() {
-            return parameter;
-        }
-
-        [[nodiscard]] const std::string& getName() const {
-            return name;
-        }
-        [[nodiscard]] virtual OpType getType() const {
-            return type;
-        }
-
-        [[nodiscard]] virtual Qubit getStartingQubit() const {
-            return startQubit;
-        }
-
-        [[nodiscard]] virtual std::set<Qubit> getUsedQubits() const {
-            const auto&     opTargets  = getTargets();
-            const auto&     opControls = getControls();
-            std::set<Qubit> usedQubits = {opTargets.begin(), opTargets.end()};
-            for (const auto& control: opControls) {
-                usedQubits.insert(control.qubit);
-            }
-            return usedQubits;
-        }
-
-        // Setter
-        virtual void setNqubits(const std::size_t nq) {
-            nqubits = nq;
-        }
-
-        virtual void setTargets(const Targets& t) {
-            targets = t;
-        }
-
-        virtual void setControls(const Controls& c) {
-            controls = c;
-        }
-
-        virtual void setName();
-
-        virtual void setGate(const OpType g) {
-            type = g;
-            setName();
-        }
-
-        virtual void setParameter(const std::vector<fp>& p) {
-            parameter = p;
-        }
-
-        [[nodiscard]] inline virtual bool isUnitary() const {
-            return true;
-        }
-
-        [[nodiscard]] inline virtual bool isStandardOperation() const {
-            return false;
-        }
-
-        [[nodiscard]] inline virtual bool isCompoundOperation() const {
-            return false;
-        }
-
-        [[nodiscard]] inline virtual bool isNonUnitaryOperation() const {
-            return false;
-        }
-
-        [[nodiscard]] inline virtual bool isClassicControlledOperation() const {
-            return false;
-        }
-
-        [[nodiscard]] inline virtual bool isSymbolicOperation() const {
-            return false;
-        }
-
-        [[nodiscard]] inline virtual bool isControlled() const {
-            return !controls.empty();
-        }
-
-        [[nodiscard]] inline virtual bool actsOn(const Qubit i) const {
-            for (const auto& t: targets) {
-                if (t == i) {
-                    return true;
-                }
-            }
-            return controls.count(i) > 0;
-        }
-
-        virtual void addDepthContribution(std::vector<std::size_t>& depths) const;
-
-        [[nodiscard]] virtual bool equals(const Operation& op, const Permutation& perm1, const Permutation& perm2) const;
-        [[nodiscard]] virtual bool equals(const Operation& op) const {
-            return equals(op, {}, {});
-        }
-
-        virtual std::ostream& printParameters(std::ostream& os) const;
-        virtual std::ostream& print(std::ostream& os) const;
-        virtual std::ostream& print(std::ostream& os, const Permutation& permutation) const;
-
-        friend std::ostream& operator<<(std::ostream& os, const Operation& op) {
-            return op.print(os);
-        }
-
-        virtual void dumpOpenQASM(std::ostream& of, const RegisterNames& qreg, const RegisterNames& creg) const = 0;
-    };
+class Operation {
+protected:
+  Controls controls{};
+  Targets targets{};
+  std::vector<fp> parameter{};
+
+  std::size_t nqubits = 0;
+  Qubit startQubit = 0;
+  OpType type = None;
+  std::string name{};
+
+  static bool isWholeQubitRegister(const RegisterNames& reg, std::size_t start,
+                                   std::size_t end) {
+    return !reg.empty() && reg[start].first == reg[end].first &&
+           (start == 0 || reg[start].first != reg[start - 1].first) &&
+           (end == reg.size() - 1 || reg[end].first != reg[end + 1].first);
+  }
+
+public:
+  Operation() = default;
+
+  Operation(const Operation& op) = delete;
+  Operation(Operation&& op) noexcept = default;
+
+  Operation& operator=(const Operation& op) = delete;
+
+  Operation& operator=(Operation&& op) noexcept = default;
+
+  // Virtual Destructor
+  virtual ~Operation() = default;
+
+  [[nodiscard]] virtual std::unique_ptr<Operation> clone() const = 0;
+
+  // Getters
+  [[nodiscard]] virtual const Targets& getTargets() const { return targets; }
+  virtual Targets& getTargets() { return targets; }
+  [[nodiscard]] virtual std::size_t getNtargets() const {
+    return targets.size();
+  }
+
+  [[nodiscard]] virtual const Controls& getControls() const { return controls; }
+  virtual Controls& getControls() { return controls; }
+  [[nodiscard]] virtual std::size_t getNcontrols() const {
+    return controls.size();
+  }
+
+  [[nodiscard]] std::size_t getNqubits() const { return nqubits; }
+
+  [[nodiscard]] const std::vector<fp>& getParameter() const {
+    return parameter;
+  }
+  std::vector<fp>& getParameter() { return parameter; }
+
+  [[nodiscard]] const std::string& getName() const { return name; }
+  [[nodiscard]] virtual OpType getType() const { return type; }
+
+  [[nodiscard]] virtual Qubit getStartingQubit() const { return startQubit; }
+
+  [[nodiscard]] virtual std::set<Qubit> getUsedQubits() const {
+    const auto& opTargets = getTargets();
+    const auto& opControls = getControls();
+    std::set<Qubit> usedQubits = {opTargets.begin(), opTargets.end()};
+    for (const auto& control : opControls) {
+      usedQubits.insert(control.qubit);
+    }
+    return usedQubits;
+  }
+
+  // Setter
+  virtual void setNqubits(const std::size_t nq) { nqubits = nq; }
+
+  virtual void setTargets(const Targets& t) { targets = t; }
+
+  virtual void setControls(const Controls& c) { controls = c; }
+
+  virtual void setName();
+
+  virtual void setGate(const OpType g) {
+    type = g;
+    setName();
+  }
+
+  virtual void setParameter(const std::vector<fp>& p) { parameter = p; }
+
+  [[nodiscard]] inline virtual bool isUnitary() const { return true; }
+
+  [[nodiscard]] inline virtual bool isStandardOperation() const {
+    return false;
+  }
+
+  [[nodiscard]] inline virtual bool isCompoundOperation() const {
+    return false;
+  }
+
+  [[nodiscard]] inline virtual bool isNonUnitaryOperation() const {
+    return false;
+  }
+
+  [[nodiscard]] inline virtual bool isClassicControlledOperation() const {
+    return false;
+  }
+
+  [[nodiscard]] inline virtual bool isSymbolicOperation() const {
+    return false;
+  }
+
+  [[nodiscard]] inline virtual bool isControlled() const {
+    return !controls.empty();
+  }
+
+  [[nodiscard]] inline virtual bool actsOn(const Qubit i) const {
+    for (const auto& t : targets) {
+      if (t == i) {
+        return true;
+      }
+    }
+    return controls.count(i) > 0;
+  }
+
+  virtual void addDepthContribution(std::vector<std::size_t>& depths) const;
+
+  [[nodiscard]] virtual bool equals(const Operation& op,
+                                    const Permutation& perm1,
+                                    const Permutation& perm2) const;
+  [[nodiscard]] virtual bool equals(const Operation& op) const {
+    return equals(op, {}, {});
+  }
+
+  virtual std::ostream& printParameters(std::ostream& os) const;
+  virtual std::ostream& print(std::ostream& os) const;
+  virtual std::ostream& print(std::ostream& os,
+                              const Permutation& permutation) const;
+
+  friend std::ostream& operator<<(std::ostream& os, const Operation& op) {
+    return op.print(os);
+  }
+
+  virtual void dumpOpenQASM(std::ostream& of, const RegisterNames& qreg,
+                            const RegisterNames& creg) const = 0;
+};
 } // namespace qc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/include/operations/SymbolicOperation.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/operations/SymbolicOperation.hpp`

 * *Files 14% similar despite different names*

```diff
@@ -7,117 +7,139 @@
 #include <algorithm>
 #include <cstddef>
 #include <optional>
 #include <unordered_set>
 #include <variant>
 
 namespace qc {
-    // Overload pattern for std::visit
-    template<typename... Ts>
-    struct Overload: Ts... {
-        using Ts::operator()...;
-    };
-    template<class... Ts>
-    Overload(Ts...) -> Overload<Ts...>;
-
-    class SymbolicOperation final: public StandardOperation {
-    protected:
-        std::vector<std::optional<Symbolic>> symbolicParameter{};
-
-        static OpType parseU3(const Symbolic& theta, fp& phi, fp& lambda);
-        static OpType parseU3(fp& theta, const Symbolic& phi, fp& lambda);
-        static OpType parseU3(fp& theta, fp& phi, const Symbolic& lambda);
-        static OpType parseU3(const Symbolic& theta, const Symbolic& phi, fp& lambda);
-        static OpType parseU3(const Symbolic& theta, fp& phi, const Symbolic& lambda);
-        static OpType parseU3(fp& theta, const Symbolic& phi, const Symbolic& lambda);
-
-        [[gnu::const]] static OpType parseU2(const Symbolic& phi, const Symbolic& lambda);
-        static OpType                parseU2(const Symbolic& phi, fp& lambda);
-        static OpType                parseU2(fp& phi, const Symbolic& lambda);
-
-        [[gnu::const]] static OpType parseU1(const Symbolic& lambda);
-
-        void checkSymbolicUgate();
-
-        void storeSymbolOrNumber(const SymbolOrNumber& param, std::size_t i);
-
-        [[nodiscard]] bool isSymbolicParameter(const std::size_t i) const {
-            return symbolicParameter.at(i).has_value();
-        }
-
-        static bool isSymbol(const SymbolOrNumber& param) {
-            return std::holds_alternative<Symbolic>(param);
-        }
-
-        static Symbolic& getSymbol(SymbolOrNumber& param) {
-            return std::get<Symbolic>(param);
-        }
-
-        static fp& getNumber(SymbolOrNumber& param) {
-            return std::get<fp>(param);
-        }
-
-        void setup(std::size_t nq, const std::vector<SymbolOrNumber>& params, Qubit startingQubit = 0);
-
-        [[nodiscard]] static fp getInstantiation(const SymbolOrNumber& symOrNum, const VariableAssignment& assignment);
-
-    public:
-        SymbolicOperation() = default;
-
-        [[nodiscard]] SymbolOrNumber getParameter(const std::size_t i) const {
-            if (symbolicParameter.at(i).has_value()) {
-                return symbolicParameter.at(i).value();
-            }
-            return parameter.at(i);
-        }
-
-        [[nodiscard]] std::vector<SymbolOrNumber> getParameters() const {
-            std::vector<SymbolOrNumber> params{};
-            for (std::size_t i = 0; i < parameter.size(); ++i) {
-                params.emplace_back(getParameter(i));
-            }
-            return params;
-        }
-
-        void setSymbolicParameter(const Symbolic& par, const std::size_t i) {
-            symbolicParameter.at(i) = par;
-        }
-
-        // Standard Constructors
-        SymbolicOperation(std::size_t nq, Qubit target, OpType g, const std::vector<SymbolOrNumber>& params = {}, Qubit startingQubit = 0);
-        SymbolicOperation(std::size_t nq, const Targets& targ, OpType g, const std::vector<SymbolOrNumber>& params = {}, Qubit startingQubit = 0);
-
-        SymbolicOperation(std::size_t nq, Control control, Qubit target, OpType g, const std::vector<SymbolOrNumber>& params = {}, Qubit startingQubit = 0);
-        SymbolicOperation(std::size_t nq, Control control, const Targets& targ, OpType g, const std::vector<SymbolOrNumber>& params = {}, Qubit startingQubit = 0);
-
-        SymbolicOperation(std::size_t nq, const Controls& c, Qubit target, OpType g, const std::vector<SymbolOrNumber>& params = {}, Qubit startingQubit = 0);
-        SymbolicOperation(std::size_t nq, const Controls& c, const Targets& targ, OpType g, const std::vector<SymbolOrNumber>& params = {}, Qubit startingQubit = 0);
-
-        // MCF (cSWAP), Peres, parameterized two target Constructor
-        SymbolicOperation(std::size_t nq, const Controls& c, Qubit target0, Qubit target1, OpType g, const std::vector<SymbolOrNumber>& params = {}, Qubit startingQubit = 0);
-
-        [[nodiscard]] std::unique_ptr<Operation> clone() const override {
-            return std::make_unique<SymbolicOperation>(getNqubits(), getControls(), getTargets(), getType(), getParameters(), getStartingQubit());
-        }
-
-        [[nodiscard]] inline bool isSymbolicOperation() const override {
-            return true;
-        }
-
-        [[nodiscard]] inline bool isStandardOperation() const override {
-            return std::all_of(symbolicParameter.begin(), symbolicParameter.end(), [](const auto& sym) { return !sym.has_value(); });
-        }
-
-        [[nodiscard]] bool        equals(const Operation& op, const Permutation& perm1, const Permutation& perm2) const override;
-        [[nodiscard]] inline bool equals(const Operation& op) const override {
-            return equals(op, {}, {});
-        }
-
-        [[noreturn]] void dumpOpenQASM(std::ostream& of, const RegisterNames& qreg, const RegisterNames& creg) const override;
-
-        [[nodiscard]] StandardOperation getInstantiatedOperation(const VariableAssignment& assignment) const;
-
-        // Instantiates this Operation
-        // Afterwards casting to StandardOperation can be done if assignment is total
-        void instantiate(const VariableAssignment& assignment);
-    };
+// Overload pattern for std::visit
+template <typename... Ts> struct Overload : Ts... {
+  using Ts::operator()...;
+};
+template <class... Ts> Overload(Ts...) -> Overload<Ts...>;
+
+class SymbolicOperation final : public StandardOperation {
+protected:
+  std::vector<std::optional<Symbolic>> symbolicParameter{};
+
+  static OpType parseU3(const Symbolic& theta, fp& phi, fp& lambda);
+  static OpType parseU3(fp& theta, const Symbolic& phi, fp& lambda);
+  static OpType parseU3(fp& theta, fp& phi, const Symbolic& lambda);
+  static OpType parseU3(const Symbolic& theta, const Symbolic& phi, fp& lambda);
+  static OpType parseU3(const Symbolic& theta, fp& phi, const Symbolic& lambda);
+  static OpType parseU3(fp& theta, const Symbolic& phi, const Symbolic& lambda);
+
+  [[gnu::const]] static OpType parseU2(const Symbolic& phi,
+                                       const Symbolic& lambda);
+  static OpType parseU2(const Symbolic& phi, fp& lambda);
+  static OpType parseU2(fp& phi, const Symbolic& lambda);
+
+  [[gnu::const]] static OpType parseU1(const Symbolic& lambda);
+
+  void checkSymbolicUgate();
+
+  void storeSymbolOrNumber(const SymbolOrNumber& param, std::size_t i);
+
+  [[nodiscard]] bool isSymbolicParameter(const std::size_t i) const {
+    return symbolicParameter.at(i).has_value();
+  }
+
+  static bool isSymbol(const SymbolOrNumber& param) {
+    return std::holds_alternative<Symbolic>(param);
+  }
+
+  static Symbolic& getSymbol(SymbolOrNumber& param) {
+    return std::get<Symbolic>(param);
+  }
+
+  static fp& getNumber(SymbolOrNumber& param) { return std::get<fp>(param); }
+
+  void setup(std::size_t nq, const std::vector<SymbolOrNumber>& params,
+             Qubit startingQubit = 0);
+
+  [[nodiscard]] static fp
+  getInstantiation(const SymbolOrNumber& symOrNum,
+                   const VariableAssignment& assignment);
+
+public:
+  SymbolicOperation() = default;
+
+  [[nodiscard]] SymbolOrNumber getParameter(const std::size_t i) const {
+    const auto& param = symbolicParameter.at(i);
+    if (param.has_value()) {
+      return *param;
+    }
+    return parameter.at(i);
+  }
+
+  [[nodiscard]] std::vector<SymbolOrNumber> getParameters() const {
+    std::vector<SymbolOrNumber> params{};
+    for (std::size_t i = 0; i < parameter.size(); ++i) {
+      params.emplace_back(getParameter(i));
+    }
+    return params;
+  }
+
+  void setSymbolicParameter(const Symbolic& par, const std::size_t i) {
+    symbolicParameter.at(i) = par;
+  }
+
+  // Standard Constructors
+  SymbolicOperation(std::size_t nq, Qubit target, OpType g,
+                    const std::vector<SymbolOrNumber>& params = {},
+                    Qubit startingQubit = 0);
+  SymbolicOperation(std::size_t nq, const Targets& targ, OpType g,
+                    const std::vector<SymbolOrNumber>& params = {},
+                    Qubit startingQubit = 0);
+
+  SymbolicOperation(std::size_t nq, Control control, Qubit target, OpType g,
+                    const std::vector<SymbolOrNumber>& params = {},
+                    Qubit startingQubit = 0);
+  SymbolicOperation(std::size_t nq, Control control, const Targets& targ,
+                    OpType g, const std::vector<SymbolOrNumber>& params = {},
+                    Qubit startingQubit = 0);
+
+  SymbolicOperation(std::size_t nq, const Controls& c, Qubit target, OpType g,
+                    const std::vector<SymbolOrNumber>& params = {},
+                    Qubit startingQubit = 0);
+  SymbolicOperation(std::size_t nq, const Controls& c, const Targets& targ,
+                    OpType g, const std::vector<SymbolOrNumber>& params = {},
+                    Qubit startingQubit = 0);
+
+  // MCF (cSWAP), Peres, parameterized two target Constructor
+  SymbolicOperation(std::size_t nq, const Controls& c, Qubit target0,
+                    Qubit target1, OpType g,
+                    const std::vector<SymbolOrNumber>& params = {},
+                    Qubit startingQubit = 0);
+
+  [[nodiscard]] std::unique_ptr<Operation> clone() const override {
+    return std::make_unique<SymbolicOperation>(
+        getNqubits(), getControls(), getTargets(), getType(), getParameters(),
+        getStartingQubit());
+  }
+
+  [[nodiscard]] inline bool isSymbolicOperation() const override {
+    return true;
+  }
+
+  [[nodiscard]] inline bool isStandardOperation() const override {
+    return std::all_of(symbolicParameter.begin(), symbolicParameter.end(),
+                       [](const auto& sym) { return !sym.has_value(); });
+  }
+
+  [[nodiscard]] bool equals(const Operation& op, const Permutation& perm1,
+                            const Permutation& perm2) const override;
+  [[nodiscard]] inline bool equals(const Operation& op) const override {
+    return equals(op, {}, {});
+  }
+
+  [[noreturn]] void dumpOpenQASM(std::ostream& of, const RegisterNames& qreg,
+                                 const RegisterNames& creg) const override;
+
+  [[nodiscard]] StandardOperation
+  getInstantiatedOperation(const VariableAssignment& assignment) const;
+
+  // Instantiates this Operation
+  // Afterwards casting to StandardOperation can be done if assignment is total
+  void instantiate(const VariableAssignment& assignment);
+};
 } // namespace qc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/include/parsers/qasm_parser/Parser.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/parsers/qasm_parser/Parser.hpp`

 * *Files 16% similar despite different names*

```diff
@@ -1,12 +1,7 @@
-/*
- * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
- */
-
 #pragma once
 
 #include "Definitions.hpp"
 #include "Scanner.hpp"
 #include "operations/CompoundOperation.hpp"
 #include "operations/NonUnitaryOperation.hpp"
 #include "operations/StandardOperation.hpp"
@@ -17,206 +12,224 @@
 #include <set>
 #include <sstream>
 #include <stdexcept>
 #include <utility>
 #include <vector>
 
 namespace qasm {
-    class Parser {
-        struct GateInfo {
-            std::size_t nControls;
-            std::size_t nTargets;
-            std::size_t nParameters;
-            qc::OpType  type;
-        };
-
-        struct Expr {
-            enum class Kind {
-                Number,
-                Plus,
-                Minus,
-                Sign,
-                Times,
-                Sin,
-                Cos,
-                Tan,
-                Exp,
-                Ln,
-                Sqrt,
-                Div,
-                Power,
-                Id
-            };
-            qc::fp                num;
-            Kind                  kind;
-            std::shared_ptr<Expr> op1 = nullptr;
-            std::shared_ptr<Expr> op2 = nullptr;
-            std::string           id;
-
-            explicit Expr(const Kind k, const qc::fp n = 0., std::shared_ptr<Expr> operation1 = nullptr, std::shared_ptr<Expr> operation2 = nullptr, std::string identifier = ""):
-                num(n), kind(k), op1(std::move(operation1)), op2(std::move(operation2)), id(std::move(identifier)) {}
-            Expr(const Expr& expr):
-                num(expr.num), kind(expr.kind), id(expr.id) {
-                if (expr.op1 != nullptr) {
-                    op1 = expr.op1;
-                }
-                if (expr.op2 != nullptr) {
-                    op2 = expr.op2;
-                }
-            }
-            Expr& operator=(const Expr& expr) {
-                if (&expr == this) {
-                    return *this;
-                }
-
-                num  = expr.num;
-                kind = expr.kind;
-                id   = expr.id;
-
-                op1 = expr.op1;
-                op2 = expr.op2;
-
-                return *this;
-            }
-
-            virtual ~Expr() = default;
-        };
-
-        struct BasisGate {
-            virtual ~BasisGate() = default;
-        };
-
-        struct StandardGate: public BasisGate {
-            GateInfo                           info;
-            std::vector<std::shared_ptr<Expr>> parameters;
-            std::vector<std::string>           controls;
-            std::vector<std::string>           targets;
-        };
-
-        struct CompoundGate {
-            std::vector<std::string>                parameterNames;
-            std::vector<std::string>                argumentNames;
-            std::vector<std::shared_ptr<BasisGate>> gates;
-        };
-
-        std::istream&                       in;
-        std::set<Token::Kind>               unaryops{Token::Kind::Sin, Token::Kind::Cos, Token::Kind::Tan, Token::Kind::Exp, Token::Kind::Ln, Token::Kind::Sqrt};
-        std::map<std::string, CompoundGate> compoundGates;
-
-        std::shared_ptr<Expr> exponentiation();
-        std::shared_ptr<Expr> factor();
-        std::shared_ptr<Expr> term();
-        std::shared_ptr<Expr> expr();
-
-        static std::shared_ptr<Expr> rewriteExpr(const std::shared_ptr<Expr>& expr, std::map<std::string, std::shared_ptr<Expr>>& exprMap);
-
-    public:
-        Token                     la, t;
-        Token::Kind               sym = Token::Kind::None;
-        std::shared_ptr<Scanner>  scanner;
-        qc::QuantumRegisterMap&   qregs;
-        qc::ClassicalRegisterMap& cregs;
-        std::size_t               nqubits   = 0;
-        std::size_t               nclassics = 0;
-        qc::Permutation           initialLayout{};
-        qc::Permutation           outputPermutation{};
-
-        static const inline std::unordered_map<std::string, GateInfo> GATE_MAP = {
-                {"gphase", {0, 0, 1, qc::GPhase}},
-                {"i", {0, 1, 0, qc::I}},
-                {"id", {0, 1, 0, qc::I}},
-                {"x", {0, 1, 0, qc::X}},
-                {"y", {0, 1, 0, qc::Y}},
-                {"z", {0, 1, 0, qc::Z}},
-                {"h", {0, 1, 0, qc::H}},
-                {"s", {0, 1, 0, qc::S}},
-                {"sdg", {0, 1, 0, qc::Sdag}},
-                {"t", {0, 1, 0, qc::T}},
-                {"tdg", {0, 1, 0, qc::Tdag}},
-                {"sx", {0, 1, 0, qc::SX}},
-                {"sxdg", {0, 1, 0, qc::SXdag}},
-                {"rx", {0, 1, 1, qc::RX}},
-                {"ry", {0, 1, 1, qc::RY}},
-                {"rz", {0, 1, 1, qc::RZ}},
-                {"u1", {0, 1, 1, qc::Phase}},
-                {"p", {0, 1, 1, qc::Phase}},
-                {"u2", {0, 1, 2, qc::U2}},
-                {"u3", {0, 1, 3, qc::U3}},
-                {"U", {0, 1, 3, qc::U3}},
-                {"u", {0, 1, 3, qc::U3}},
-                {"teleport", {0, 3, 0, qc::Teleportation}},
-                {"swap", {0, 2, 0, qc::SWAP}},
-                {"iswap", {0, 2, 0, qc::iSWAP}},
-                {"cnot", {1, 1, 0, qc::X}},
-                {"CX", {1, 1, 0, qc::X}},
-                {"cx", {1, 1, 0, qc::X}},
-                {"dcx", {0, 2, 0, qc::DCX}},
-                {"ecr", {0, 2, 0, qc::ECR}},
-                {"rxx", {0, 2, 1, qc::RXX}},
-                {"ryy", {0, 2, 1, qc::RYY}},
-                {"rzz", {0, 2, 1, qc::RZZ}},
-                {"rzx", {0, 2, 1, qc::RZX}},
-                {"xx_minus_yy", {0, 2, 2, qc::XXminusYY}},
-                {"xx_plus_yy", {0, 2, 2, qc::XXplusYY}}};
-
-        explicit Parser(std::istream& is, qc::QuantumRegisterMap& q, qc::ClassicalRegisterMap& c):
-            in(is), qregs(q), cregs(c) {
-            scanner = std::make_shared<Scanner>(in);
-        }
-
-        virtual ~Parser() = default;
-
-        void scan();
-
-        void check(Token::Kind expected);
-
-        qc::QuantumRegister argumentQreg();
-
-        qc::ClassicalRegister argumentCreg();
-
-        void expList(std::vector<std::shared_ptr<Expr>>& expressions);
-
-        void argList(std::vector<qc::QuantumRegister>& arguments);
-
-        void idList(std::vector<std::string>& identifiers);
-
-        std::unique_ptr<qc::Operation> gate();
-
-        void opaqueGateDecl();
-
-        void gateDecl();
-
-        std::unique_ptr<qc::Operation> qop();
-
-        static bool gateInfo(const std::string& name, GateInfo& info);
-
-        void parseParameters(const GateInfo& info, std::vector<qc::fp>& parameters);
-
-        void parseArguments(const GateInfo& info, std::vector<qc::fp>& parameters, std::vector<qc::QuantumRegister>& controlRegisters, std::vector<qc::QuantumRegister>& targetRegisters);
-
-        std::unique_ptr<qc::Operation> knownGate(const GateInfo& info, const std::vector<qc::fp>& parameters, const std::vector<qc::QuantumRegister>& controlRegisters, const std::vector<qc::QuantumRegister>& targetRegisters);
-
-        std::unique_ptr<qc::Operation> knownGate(const GateInfo& info) {
-            std::vector<qc::fp>              parameters{};
-            std::vector<qc::QuantumRegister> controlRegisters{};
-            std::vector<qc::QuantumRegister> targetRegisters{};
-            parseArguments(info, parameters, controlRegisters, targetRegisters);
-            return knownGate(info, parameters, controlRegisters, targetRegisters);
-        }
-
-        void error [[noreturn]] (const std::string& msg) const {
-            std::ostringstream oss{};
-            oss << "[qasm parser] l:" << t.line << " c:" << t.col << " msg: " << msg;
-            throw std::runtime_error(oss.str());
-        }
-
-        void handleComment();
-        // check string for I/O layout information of the form
-        //      'i Q_i Q_j ... Q_k' meaning, e.g. q_0 is mapped to Q_i, q_1 to Q_j, etc.
-        //      'o Q_i Q_j ... Q_k' meaning, e.g. q_0 is found at Q_i, q_1 at Q_j, etc.
-        // where i describes the initial layout, e.g. 'i 2 1 0' means q0 -> Q2, q1 -> Q1, q2 -> Q0
-        // and o describes the output permutation, e.g. 'o 2 1 0' means  q0 is expected at Q2, q1 at Q1, and q2 at Q0
-        static qc::Permutation checkForInitialLayout(std::string comment);
-        static qc::Permutation checkForOutputPermutation(std::string comment);
+class Parser {
+  struct GateInfo {
+    std::size_t nControls;
+    std::size_t nTargets;
+    std::size_t nParameters;
+    qc::OpType type;
+  };
+
+  struct Expr {
+    enum class Kind {
+      Number,
+      Plus,
+      Minus,
+      Sign,
+      Times,
+      Sin,
+      Cos,
+      Tan,
+      Exp,
+      Ln,
+      Sqrt,
+      Div,
+      Power,
+      Id
     };
+    qc::fp num;
+    Kind kind;
+    std::shared_ptr<Expr> op1 = nullptr;
+    std::shared_ptr<Expr> op2 = nullptr;
+    std::string id;
+
+    explicit Expr(const Kind k, const qc::fp n = 0.,
+                  std::shared_ptr<Expr> operation1 = nullptr,
+                  std::shared_ptr<Expr> operation2 = nullptr,
+                  std::string identifier = "")
+        : num(n), kind(k), op1(std::move(operation1)),
+          op2(std::move(operation2)), id(std::move(identifier)) {}
+    Expr(const Expr& expr) : num(expr.num), kind(expr.kind), id(expr.id) {
+      if (expr.op1 != nullptr) {
+        op1 = expr.op1;
+      }
+      if (expr.op2 != nullptr) {
+        op2 = expr.op2;
+      }
+    }
+    Expr& operator=(const Expr& expr) {
+      if (&expr == this) {
+        return *this;
+      }
+
+      num = expr.num;
+      kind = expr.kind;
+      id = expr.id;
+
+      op1 = expr.op1;
+      op2 = expr.op2;
+
+      return *this;
+    }
+
+    virtual ~Expr() = default;
+  };
+
+  struct BasisGate {
+    virtual ~BasisGate() = default;
+  };
+
+  struct StandardGate : public BasisGate {
+    GateInfo info;
+    std::vector<std::shared_ptr<Expr>> parameters;
+    std::vector<std::string> controls;
+    std::vector<std::string> targets;
+  };
+
+  struct CompoundGate {
+    std::vector<std::string> parameterNames;
+    std::vector<std::string> argumentNames;
+    std::vector<std::shared_ptr<BasisGate>> gates;
+  };
+
+  // NOLINTNEXTLINE(cppcoreguidelines-avoid-const-or-ref-data-members)
+  std::istream& in;
+  std::set<Token::Kind> unaryops{Token::Kind::Sin, Token::Kind::Cos,
+                                 Token::Kind::Tan, Token::Kind::Exp,
+                                 Token::Kind::Ln,  Token::Kind::Sqrt};
+  std::map<std::string, CompoundGate> compoundGates;
+
+  std::shared_ptr<Expr> exponentiation();
+  std::shared_ptr<Expr> factor();
+  std::shared_ptr<Expr> term();
+  std::shared_ptr<Expr> expr();
+
+  static std::shared_ptr<Expr>
+  rewriteExpr(const std::shared_ptr<Expr>& expr,
+              std::map<std::string, std::shared_ptr<Expr>>& exprMap);
+
+public:
+  Token la, t;
+  Token::Kind sym = Token::Kind::None;
+  std::shared_ptr<Scanner> scanner;
+  // NOLINTNEXTLINE(cppcoreguidelines-avoid-const-or-ref-data-members)
+  qc::QuantumRegisterMap& qregs;
+  // NOLINTNEXTLINE(cppcoreguidelines-avoid-const-or-ref-data-members)
+  qc::ClassicalRegisterMap& cregs;
+  std::size_t nqubits = 0;
+  std::size_t nclassics = 0;
+  qc::Permutation initialLayout{};
+  qc::Permutation outputPermutation{};
+
+  static const inline std::unordered_map<std::string, GateInfo> GATE_MAP = {
+      {"gphase", {0, 0, 1, qc::GPhase}},
+      {"i", {0, 1, 0, qc::I}},
+      {"id", {0, 1, 0, qc::I}},
+      {"x", {0, 1, 0, qc::X}},
+      {"y", {0, 1, 0, qc::Y}},
+      {"z", {0, 1, 0, qc::Z}},
+      {"h", {0, 1, 0, qc::H}},
+      {"s", {0, 1, 0, qc::S}},
+      {"sdg", {0, 1, 0, qc::Sdag}},
+      {"t", {0, 1, 0, qc::T}},
+      {"tdg", {0, 1, 0, qc::Tdag}},
+      {"sx", {0, 1, 0, qc::SX}},
+      {"sxdg", {0, 1, 0, qc::SXdag}},
+      {"rx", {0, 1, 1, qc::RX}},
+      {"ry", {0, 1, 1, qc::RY}},
+      {"rz", {0, 1, 1, qc::RZ}},
+      {"u1", {0, 1, 1, qc::Phase}},
+      {"p", {0, 1, 1, qc::Phase}},
+      {"u2", {0, 1, 2, qc::U2}},
+      {"u3", {0, 1, 3, qc::U3}},
+      {"U", {0, 1, 3, qc::U3}},
+      {"u", {0, 1, 3, qc::U3}},
+      {"teleport", {0, 3, 0, qc::Teleportation}},
+      {"swap", {0, 2, 0, qc::SWAP}},
+      {"iswap", {0, 2, 0, qc::iSWAP}},
+      {"cnot", {1, 1, 0, qc::X}},
+      {"CX", {1, 1, 0, qc::X}},
+      {"cx", {1, 1, 0, qc::X}},
+      {"dcx", {0, 2, 0, qc::DCX}},
+      {"ecr", {0, 2, 0, qc::ECR}},
+      {"rxx", {0, 2, 1, qc::RXX}},
+      {"ryy", {0, 2, 1, qc::RYY}},
+      {"rzz", {0, 2, 1, qc::RZZ}},
+      {"rzx", {0, 2, 1, qc::RZX}},
+      {"xx_minus_yy", {0, 2, 2, qc::XXminusYY}},
+      {"xx_plus_yy", {0, 2, 2, qc::XXplusYY}}};
+
+  explicit Parser(std::istream& is, qc::QuantumRegisterMap& q,
+                  qc::ClassicalRegisterMap& c)
+      : in(is), qregs(q), cregs(c) {
+    scanner = std::make_shared<Scanner>(in);
+  }
+
+  virtual ~Parser() = default;
+
+  void scan();
+
+  void check(Token::Kind expected);
+
+  qc::QuantumRegister argumentQreg();
+
+  qc::ClassicalRegister argumentCreg();
+
+  void expList(std::vector<std::shared_ptr<Expr>>& expressions);
+
+  void argList(std::vector<qc::QuantumRegister>& arguments);
+
+  void idList(std::vector<std::string>& identifiers);
+
+  std::unique_ptr<qc::Operation> gate();
+
+  void opaqueGateDecl();
+
+  void gateDecl();
+
+  std::unique_ptr<qc::Operation> qop();
+
+  static bool gateInfo(const std::string& name, GateInfo& info);
+
+  void parseParameters(const GateInfo& info, std::vector<qc::fp>& parameters);
+
+  void parseArguments(const GateInfo& info, std::vector<qc::fp>& parameters,
+                      std::vector<qc::QuantumRegister>& controlRegisters,
+                      std::vector<qc::QuantumRegister>& targetRegisters);
+
+  std::unique_ptr<qc::Operation>
+  knownGate(const GateInfo& info, const std::vector<qc::fp>& parameters,
+            const std::vector<qc::QuantumRegister>& controlRegisters,
+            const std::vector<qc::QuantumRegister>& targetRegisters);
+
+  std::unique_ptr<qc::Operation> knownGate(const GateInfo& info) {
+    std::vector<qc::fp> parameters{};
+    std::vector<qc::QuantumRegister> controlRegisters{};
+    std::vector<qc::QuantumRegister> targetRegisters{};
+    parseArguments(info, parameters, controlRegisters, targetRegisters);
+    return knownGate(info, parameters, controlRegisters, targetRegisters);
+  }
+
+  void error [[noreturn]] (const std::string& msg) const {
+    std::ostringstream oss{};
+    oss << "[qasm parser] l:" << t.line << " c:" << t.col << " msg: " << msg;
+    throw std::runtime_error(oss.str());
+  }
+
+  void handleComment();
+  // check string for I/O layout information of the form
+  //      'i Q_i Q_j ... Q_k' meaning, e.g. q_0 is mapped to Q_i, q_1 to Q_j,
+  //      etc. 'o Q_i Q_j ... Q_k' meaning, e.g. q_0 is found at Q_i, q_1 at
+  //      Q_j, etc.
+  // where i describes the initial layout, e.g. 'i 2 1 0' means q0 -> Q2, q1 ->
+  // Q1, q2 -> Q0 and o describes the output permutation, e.g. 'o 2 1 0' means
+  // q0 is expected at Q2, q1 at Q1, and q2 at Q0
+  static qc::Permutation checkForInitialLayout(std::string comment);
+  static qc::Permutation checkForOutputPermutation(std::string comment);
+};
 
 } // namespace qasm
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/include/parsers/qasm_parser/Token.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/parsers/qasm_parser/Token.hpp`

 * *Files 16% similar despite different names*

```diff
@@ -1,124 +1,118 @@
-/*
- * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
- */
-
 #pragma once
 
 #include "Definitions.hpp"
 
 #include <map>
 #include <string>
 
 namespace qasm {
 
-    struct Token {
-        enum class Kind {
-            Include,
-            None,
-            Identifier,
-            Number,
-            Plus,
-            Semicolon,
-            Eof,
-            Lpar,
-            Rpar,
-            Lbrack,
-            Rbrack,
-            Lbrace,
-            Rbrace,
-            Comma,
-            Minus,
-            Times,
-            Nninteger,
-            Real,
-            Qreg,
-            Creg,
-            Gate,
-            Pi,
-            Measure,
-            Openqasm,
-            Probabilities,
-            Sin,
-            Cos,
-            Tan,
-            Exp,
-            Ln,
-            Sqrt,
-            Div,
-            Power,
-            String,
-            Gt,
-            Barrier,
-            Opaque,
-            If,
-            Eq,
-            Reset,
-            Snapshot,
-            McxGray,
-            McxRecursive,
-            McxVchain,
-            Mcphase,
-            Comment
-        };
-
-        Kind        kind    = Kind::None;
-        int         line    = 0;
-        int         col     = 0;
-        int         val     = 0;
-        qc::fp      valReal = 0.0;
-        std::string str;
-
-        Token() = default;
-        Token(Kind k, int l, int c):
-            kind(k), line(l), col(c) {}
-    };
-
-    static inline const std::map<Token::Kind, std::string> KIND_NAMES{
-            {Token::Kind::None, "none"},
-            {Token::Kind::Include, "include"},
-            {Token::Kind::Identifier, "<identifier>"},
-            {Token::Kind::Number, "<number>"},
-            {Token::Kind::Plus, "+"},
-            {Token::Kind::Semicolon, ";"},
-            {Token::Kind::Eof, "EOF"},
-            {Token::Kind::Lpar, "("},
-            {Token::Kind::Rpar, ")"},
-            {Token::Kind::Lbrack, "["},
-            {Token::Kind::Rbrack, "]"},
-            {Token::Kind::Lbrace, "{"},
-            {Token::Kind::Rbrace, "}"},
-            {Token::Kind::Comma, ","},
-            {Token::Kind::Minus, "-"},
-            {Token::Kind::Times, "*"},
-            {Token::Kind::Nninteger, "<nninteger>"},
-            {Token::Kind::Real, "<real>"},
-            {Token::Kind::Qreg, "qreg"},
-            {Token::Kind::Creg, "creg"},
-            {Token::Kind::Gate, "gate"},
-            {Token::Kind::McxGray, "mcx_gray"},
-            {Token::Kind::McxRecursive, "mcx_recursive"},
-            {Token::Kind::McxVchain, "mcx_vchain"},
-            {Token::Kind::Mcphase, "mcphase"},
-            {Token::Kind::Pi, "pi"},
-            {Token::Kind::Measure, "measure"},
-            {Token::Kind::Openqasm, "openqasm"},
-            {Token::Kind::Probabilities, "probabilities"},
-            {Token::Kind::Opaque, "opaque"},
-            {Token::Kind::Sin, "sin"},
-            {Token::Kind::Cos, "cos"},
-            {Token::Kind::Tan, "tan"},
-            {Token::Kind::Exp, "exp"},
-            {Token::Kind::Ln, "ln"},
-            {Token::Kind::Sqrt, "sqrt"},
-            {Token::Kind::Div, "/"},
-            {Token::Kind::Power, "^"},
-            {Token::Kind::String, "string"},
-            {Token::Kind::Gt, ">"},
-            {Token::Kind::Barrier, "barrier"},
-            {Token::Kind::If, "if"},
-            {Token::Kind::Eq, "=="},
-            {Token::Kind::Reset, "reset"},
-            {Token::Kind::Comment, "//"}};
+struct Token {
+  enum class Kind {
+    Include,
+    None,
+    Identifier,
+    Number,
+    Plus,
+    Semicolon,
+    Eof,
+    Lpar,
+    Rpar,
+    Lbrack,
+    Rbrack,
+    Lbrace,
+    Rbrace,
+    Comma,
+    Minus,
+    Times,
+    Nninteger,
+    Real,
+    Qreg,
+    Creg,
+    Gate,
+    Pi,
+    Measure,
+    Openqasm,
+    Probabilities,
+    Sin,
+    Cos,
+    Tan,
+    Exp,
+    Ln,
+    Sqrt,
+    Div,
+    Power,
+    String,
+    Gt,
+    Barrier,
+    Opaque,
+    If,
+    Eq,
+    Reset,
+    Snapshot,
+    McxGray,
+    McxRecursive,
+    McxVchain,
+    Mcphase,
+    Comment
+  };
+
+  Kind kind = Kind::None;
+  int line = 0;
+  int col = 0;
+  int val = 0;
+  qc::fp valReal = 0.0;
+  std::string str;
+
+  Token() = default;
+  Token(Kind k, int l, int c) : kind(k), line(l), col(c) {}
+};
+
+static inline const std::map<Token::Kind, std::string> KIND_NAMES{
+    {Token::Kind::None, "none"},
+    {Token::Kind::Include, "include"},
+    {Token::Kind::Identifier, "<identifier>"},
+    {Token::Kind::Number, "<number>"},
+    {Token::Kind::Plus, "+"},
+    {Token::Kind::Semicolon, ";"},
+    {Token::Kind::Eof, "EOF"},
+    {Token::Kind::Lpar, "("},
+    {Token::Kind::Rpar, ")"},
+    {Token::Kind::Lbrack, "["},
+    {Token::Kind::Rbrack, "]"},
+    {Token::Kind::Lbrace, "{"},
+    {Token::Kind::Rbrace, "}"},
+    {Token::Kind::Comma, ","},
+    {Token::Kind::Minus, "-"},
+    {Token::Kind::Times, "*"},
+    {Token::Kind::Nninteger, "<nninteger>"},
+    {Token::Kind::Real, "<real>"},
+    {Token::Kind::Qreg, "qreg"},
+    {Token::Kind::Creg, "creg"},
+    {Token::Kind::Gate, "gate"},
+    {Token::Kind::McxGray, "mcx_gray"},
+    {Token::Kind::McxRecursive, "mcx_recursive"},
+    {Token::Kind::McxVchain, "mcx_vchain"},
+    {Token::Kind::Mcphase, "mcphase"},
+    {Token::Kind::Pi, "pi"},
+    {Token::Kind::Measure, "measure"},
+    {Token::Kind::Openqasm, "openqasm"},
+    {Token::Kind::Probabilities, "probabilities"},
+    {Token::Kind::Opaque, "opaque"},
+    {Token::Kind::Sin, "sin"},
+    {Token::Kind::Cos, "cos"},
+    {Token::Kind::Tan, "tan"},
+    {Token::Kind::Exp, "exp"},
+    {Token::Kind::Ln, "ln"},
+    {Token::Kind::Sqrt, "sqrt"},
+    {Token::Kind::Div, "/"},
+    {Token::Kind::Power, "^"},
+    {Token::Kind::String, "string"},
+    {Token::Kind::Gt, ">"},
+    {Token::Kind::Barrier, "barrier"},
+    {Token::Kind::If, "if"},
+    {Token::Kind::Eq, "=="},
+    {Token::Kind::Reset, "reset"},
+    {Token::Kind::Comment, "//"}};
 
 } // namespace qasm
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/include/zx/FunctionalityConstruction.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/include/zx/FunctionalityConstruction.hpp`

 * *Files 25% similar despite different names*

```diff
@@ -1,47 +1,44 @@
-/*
-* This file is part of MQT QFR library which is released under the MIT license.
-* See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
-*/
-
 #pragma once
 
 #include "QuantumComputation.hpp"
-#include "ZXDiagram.hpp"
+#include "zx/ZXDiagram.hpp"
 
 #include <cstddef>
 
 namespace zx {
-    class FunctionalityConstruction {
-        using op_it = qc::QuantumComputation::const_iterator;
+class FunctionalityConstruction {
+  using op_it = qc::QuantumComputation::const_iterator;
 
-    public:
-        static ZXDiagram buildFunctionality(const qc::QuantumComputation* qc);
+public:
+  static ZXDiagram buildFunctionality(const qc::QuantumComputation* qc);
 
-        static bool transformableToZX(const qc::QuantumComputation* qc);
+  static bool transformableToZX(const qc::QuantumComputation* qc);
 
-        static bool transformableToZX(const qc::Operation* op);
-
-    protected:
-        static bool
-                     checkSwap(const op_it& it, const op_it& end, Qubit ctrl, Qubit target, const qc::Permutation& p);
-        static void  addZSpider(ZXDiagram& diag, zx::Qubit qubit,
-                                std::vector<Vertex>& qubits,
-                                const PiExpression& phase = PiExpression(), EdgeType type = EdgeType::Simple);
-        static void  addXSpider(ZXDiagram& diag, Qubit qubit,
-                                std::vector<Vertex>& qubits,
-                                const PiExpression& phase = PiExpression(), EdgeType type = EdgeType::Simple);
-        static void  addCnot(ZXDiagram& diag, Qubit ctrl, Qubit target,
-                             std::vector<Vertex>& qubits);
-        static void  addCphase(ZXDiagram& diag, const PiExpression& phase, Qubit ctrl, Qubit target,
-                               std::vector<Vertex>& qubits);
-        static void  addSwap(ZXDiagram& diag, Qubit target, Qubit target2,
-                             std::vector<Vertex>& qubits);
-        static void  addCcx(ZXDiagram& diag, Qubit ctrl0, Qubit ctrl1, Qubit target,
-                            std::vector<Vertex>& qubits);
-        static op_it parseOp(ZXDiagram& diag, op_it it, op_it end,
-                             std::vector<Vertex>& qubits, const qc::Permutation& p);
-
-        static PiExpression toPiExpr(const qc::SymbolOrNumber& param);
-        static PiExpression parseParam(const qc::Operation* op, std::size_t i);
-    };
+  static bool transformableToZX(const qc::Operation* op);
+
+protected:
+  static bool checkSwap(const op_it& it, const op_it& end, Qubit ctrl,
+                        Qubit target, const qc::Permutation& p);
+  static void addZSpider(ZXDiagram& diag, zx::Qubit qubit,
+                         std::vector<Vertex>& qubits,
+                         const PiExpression& phase = PiExpression(),
+                         EdgeType type = EdgeType::Simple);
+  static void addXSpider(ZXDiagram& diag, Qubit qubit,
+                         std::vector<Vertex>& qubits,
+                         const PiExpression& phase = PiExpression(),
+                         EdgeType type = EdgeType::Simple);
+  static void addCnot(ZXDiagram& diag, Qubit ctrl, Qubit target,
+                      std::vector<Vertex>& qubits);
+  static void addCphase(ZXDiagram& diag, const PiExpression& phase, Qubit ctrl,
+                        Qubit target, std::vector<Vertex>& qubits);
+  static void addSwap(ZXDiagram& diag, Qubit target, Qubit target2,
+                      std::vector<Vertex>& qubits);
+  static void addCcx(ZXDiagram& diag, Qubit ctrl0, Qubit ctrl1, Qubit target,
+                     std::vector<Vertex>& qubits);
+  static op_it parseOp(ZXDiagram& diag, op_it it, op_it end,
+                       std::vector<Vertex>& qubits, const qc::Permutation& p);
+
+  static PiExpression toPiExpr(const qc::SymbolOrNumber& param);
+  static PiExpression parseParam(const qc::Operation* op, std::size_t i);
+};
 } // namespace zx
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/mqt/qfr/qiskit/QasmQobjExperiment.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/python/qiskit/QasmQobjExperiment.cpp`

 * *Files 6% similar despite different names*

```diff
@@ -1,198 +1,219 @@
-/*
- * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
- */
-
-#ifndef QFR_QASMQOBJEXPERIMENT_HPP
-#define QFR_QASMQOBJEXPERIMENT_HPP
-
-#include "pybind11/pybind11.h"
-
-namespace py = pybind11;
-
-#include "QuantumComputation.hpp"
-
-namespace qc::qiskit {
-    using namespace pybind11::literals;
-
-    class QasmQobjExperiment {
-    public:
-        static void import(QuantumComputation& qc, const py::object& circ) {
-            qc.reset();
-
-            const py::object pyQasmQobjExperiment = py::module::import("qiskit.qobj").attr("QasmQobjExperiment");
-
-            if (!py::isinstance(circ, pyQasmQobjExperiment)) {
-                throw QFRException("[import] Python object needs to be a Qiskit QasmQobjExperiment");
-            }
-
-            auto&& header       = circ.attr("header");
-            auto&& instructions = circ.attr("instructions");
-
-            auto&& circQregs = header.attr("qreg_sizes");
-            for (const auto qreg: circQregs) {
-                qc.addQubitRegister(qreg.cast<py::list>()[1].cast<std::size_t>(), qreg.cast<py::list>()[0].cast<std::string>());
-            }
-
-            auto&& circCregs = header.attr("creg_sizes");
-            for (const auto creg: circCregs) {
-                qc.addClassicalRegister(creg.cast<py::list>()[1].cast<std::size_t>(), creg.cast<py::list>()[0].cast<std::string>());
-            }
-
-            for (const auto instruction: instructions) {
-                emplaceInstruction(qc, instruction.cast<py::object>());
-            }
-            qc.initializeIOMapping();
-        }
-
-    protected:
-        static void emplaceInstruction(QuantumComputation& qc, const py::object& instruction) {
-            static const auto NATIVELY_SUPPORTED_GATES = std::set<std::string>{"i", "id", "iden", "x", "y", "z", "h", "s", "sdg", "t", "tdg", "p", "u1", "rx", "ry", "rz", "u2", "u", "u3", "cx", "cy", "cz", "cp", "cu1", "ch", "crx", "cry", "crz", "cu3", "ccx", "swap", "cswap", "iswap", "sx", "sxdg", "csx", "mcx", "mcx_gray", "mcx_recursive", "mcx_vchain", "mcphase", "mcrx", "mcry", "mcrz", "dcx", "ecr", "rxx", "ryy", "rzx", "rzz", "xx_minus_yy", "xx_plus_yy"};
-
-            auto instructionName = instruction.attr("name").cast<std::string>();
-            if (instructionName == "measure") {
-                auto qubit = instruction.attr("qubits").cast<py::list>()[0].cast<Qubit>();
-                auto clbit = instruction.attr("memory").cast<py::list>()[0].cast<std::size_t>();
-                qc.emplace_back<NonUnitaryOperation>(qc.getNqubits(), qubit, clbit);
-            } else if (instructionName == "barrier") {
-                Targets targets{};
-                for (const auto qubit: instruction.attr("qubits")) {
-                    auto target = qubit.cast<Qubit>();
-                    targets.emplace_back(target);
-                }
-                qc.emplace_back<NonUnitaryOperation>(qc.getNqubits(), targets, Barrier);
-            } else if (instructionName == "reset") {
-                Targets targets{};
-                for (const auto qubit: instruction.attr("qubits")) {
-                    auto target = qubit.cast<Qubit>();
-                    targets.emplace_back(target);
-                }
-                qc.reset(targets);
-            } else if (NATIVELY_SUPPORTED_GATES.count(instructionName) != 0) {
-                auto&&   qubits = instruction.attr("qubits").cast<py::list>();
-                py::list params{};
-                if (py::hasattr(instruction, "params")) {
-                    params = instruction.attr("params");
-                }
-                // natively supported operations
-                if (instructionName == "i" || instructionName == "id" || instructionName == "iden") {
-                    addOperation(qc, I, qubits, params);
-                } else if (instructionName == "x" || instructionName == "cx" || instructionName == "ccx" || instructionName == "mcx_gray" || instructionName == "mcx") {
-                    addOperation(qc, X, qubits, params);
-                } else if (instructionName == "y" || instructionName == "cy") {
-                    addOperation(qc, Y, qubits, params);
-                } else if (instructionName == "z" || instructionName == "cz") {
-                    addOperation(qc, Z, qubits, params);
-                } else if (instructionName == "h" || instructionName == "ch") {
-                    addOperation(qc, H, qubits, params);
-                } else if (instructionName == "s") {
-                    addOperation(qc, S, qubits, params);
-                } else if (instructionName == "sdg") {
-                    addOperation(qc, Sdag, qubits, params);
-                } else if (instructionName == "t") {
-                    addOperation(qc, T, qubits, params);
-                } else if (instructionName == "tdg") {
-                    addOperation(qc, Tdag, qubits, params);
-                } else if (instructionName == "rx" || instructionName == "crx" || instructionName == "mcrx") {
-                    params = instruction.attr("params").cast<py::list>();
-                    addOperation(qc, RX, qubits, params);
-                } else if (instructionName == "ry" || instructionName == "cry" || instructionName == "mcry") {
-                    params = instruction.attr("params").cast<py::list>();
-                    addOperation(qc, RY, qubits, params);
-                } else if (instructionName == "rz" || instructionName == "crz" || instructionName == "mcrz") {
-                    params = instruction.attr("params").cast<py::list>();
-                    addOperation(qc, RZ, qubits, params);
-                } else if (instructionName == "p" || instructionName == "u1" || instructionName == "cp" || instructionName == "cu1" || instructionName == "mcphase") {
-                    params = instruction.attr("params").cast<py::list>();
-                    addOperation(qc, Phase, qubits, params);
-                } else if (instructionName == "sx" || instructionName == "csx") {
-                    addOperation(qc, SX, qubits, params);
-                } else if (instructionName == "sxdg") {
-                    addOperation(qc, SXdag, qubits, params);
-                } else if (instructionName == "u2") {
-                    params = instruction.attr("params").cast<py::list>();
-                    addOperation(qc, U2, qubits, params);
-                } else if (instructionName == "u" || instructionName == "u3" || instructionName == "cu3") {
-                    params = instruction.attr("params").cast<py::list>();
-                    addOperation(qc, U3, qubits, params);
-                } else if (instructionName == "swap" || instructionName == "cswap") {
-                    addTwoTargetOperation(qc, SWAP, qubits, params);
-                } else if (instructionName == "iswap") {
-                    addTwoTargetOperation(qc, iSWAP, qubits, params);
-                } else if (instructionName == "dcx") {
-                    addTwoTargetOperation(qc, DCX, qubits, params);
-                } else if (instructionName == "ecr") {
-                    addTwoTargetOperation(qc, ECR, qubits, params);
-                } else if (instructionName == "rxx") {
-                    addTwoTargetOperation(qc, RXX, qubits, params);
-                } else if (instructionName == "ryy") {
-                    addTwoTargetOperation(qc, RYY, qubits, params);
-                } else if (instructionName == "rzx") {
-                    addTwoTargetOperation(qc, RZX, qubits, params);
-                } else if (instructionName == "rzz") {
-                    addTwoTargetOperation(qc, RZZ, qubits, params);
-                } else if (instructionName == "xx_minus_yy") {
-                    addTwoTargetOperation(qc, XXminusYY, qubits, params);
-                } else if (instructionName == "xx_plus_yy") {
-                    addTwoTargetOperation(qc, XXplusYY, qubits, params);
-                } else if (instructionName == "mcx_recursive") {
-                    if (qubits.size() <= 5) {
-                        addOperation(qc, X, qubits, params);
-                    } else {
-                        auto qubitsCopy = qubits.attr("copy")();
-                        qubitsCopy.attr("pop")(); // discard ancillaries
-                        addOperation(qc, X, qubitsCopy, params);
-                    }
-                } else if (instructionName == "mcx_vchain") {
-                    auto              size       = qubits.size();
-                    const std::size_t ncontrols  = (size + 1) / 2;
-                    auto              qubitsCopy = qubits.attr("copy")();
-                    // discard ancillaries
-                    for (std::size_t i = 0; i < ncontrols - 2; ++i) {
-                        qubitsCopy.attr("pop")();
-                    }
-                    addOperation(qc, X, qubitsCopy, params);
-                }
-            } else {
-                std::cerr << "Failed to import instruction " << instructionName << " from Qiskit QasmQobjExperiment" << std::endl;
-            }
-        }
-
-        static void addOperation(QuantumComputation& qc, OpType type, const py::list& qubits, const py::list& params) {
-            std::vector<Control> qargs{};
-            for (const auto qubit: qubits) {
-                auto target = qubit.cast<Qubit>();
-                qargs.emplace_back(Control{target});
-            }
-            auto target = qargs.back().qubit;
-            qargs.pop_back();
-
-            std::vector<fp> parameters{};
-            for (const auto& param: params) {
-                parameters.emplace_back(param.cast<fp>());
-            }
-            const Controls controls(qargs.cbegin(), qargs.cend());
-            qc.emplace_back<StandardOperation>(qc.getNqubits(), controls, target, type, parameters);
-        }
-
-        static void addTwoTargetOperation(QuantumComputation& qc, OpType type, const py::list& qubits, const py::list& params) {
-            std::vector<Control> qargs{};
-            for (const auto qubit: qubits) {
-                auto target = qubit.cast<Qubit>();
-                qargs.emplace_back(Control{target});
-            }
-            auto target1 = qargs.back().qubit;
-            qargs.pop_back();
-            auto target0 = qargs.back().qubit;
-            qargs.pop_back();
-
-            std::vector<fp> parameters{};
-            for (const auto& param: params) {
-                parameters.emplace_back(param.cast<fp>());
-            }
-            const Controls controls(qargs.cbegin(), qargs.cend());
-            qc.emplace_back<StandardOperation>(qc.getNqubits(), controls, target0, target1, type, parameters);
-        }
-    };
-} // namespace qc::qiskit
-#endif //QFR_QASMQOBJEXPERIMENT_HPP
+#include "python/qiskit/QasmQobjExperiment.hpp"
+
+void qc::qiskit::QasmQobjExperiment::import(qc::QuantumComputation& qc,
+                                            const py::object& circ) {
+  qc.reset();
+
+  const py::object pyQasmQobjExperiment =
+      py::module::import("qiskit.qobj").attr("QasmQobjExperiment");
+
+  if (!py::isinstance(circ, pyQasmQobjExperiment)) {
+    throw QFRException(
+        "[import] Python object needs to be a Qiskit QasmQobjExperiment");
+  }
+
+  auto&& header = circ.attr("header");
+  auto&& instructions = circ.attr("instructions");
+
+  auto&& circQregs = header.attr("qreg_sizes");
+  for (const auto qreg : circQregs) {
+    qc.addQubitRegister(qreg.cast<py::list>()[1].cast<std::size_t>(),
+                        qreg.cast<py::list>()[0].cast<std::string>());
+  }
+
+  auto&& circCregs = header.attr("creg_sizes");
+  for (const auto creg : circCregs) {
+    qc.addClassicalRegister(creg.cast<py::list>()[1].cast<std::size_t>(),
+                            creg.cast<py::list>()[0].cast<std::string>());
+  }
+
+  for (const auto instruction : instructions) {
+    emplaceInstruction(qc, instruction.cast<py::object>());
+  }
+  qc.initializeIOMapping();
+}
+
+void qc::qiskit::QasmQobjExperiment::emplaceInstruction(
+    qc::QuantumComputation& qc, const py::object& instruction) {
+  static const auto NATIVELY_SUPPORTED_GATES =
+      std::set<std::string>{"i",          "id",       "iden",
+                            "x",          "y",        "z",
+                            "h",          "s",        "sdg",
+                            "t",          "tdg",      "p",
+                            "u1",         "rx",       "ry",
+                            "rz",         "u2",       "u",
+                            "u3",         "cx",       "cy",
+                            "cz",         "cp",       "cu1",
+                            "ch",         "crx",      "cry",
+                            "crz",        "cu3",      "ccx",
+                            "swap",       "cswap",    "iswap",
+                            "sx",         "sxdg",     "csx",
+                            "mcx",        "mcx_gray", "mcx_recursive",
+                            "mcx_vchain", "mcphase",  "mcrx",
+                            "mcry",       "mcrz",     "dcx",
+                            "ecr",        "rxx",      "ryy",
+                            "rzx",        "rzz",      "xx_minus_yy",
+                            "xx_plus_yy"};
+
+  auto instructionName = instruction.attr("name").cast<std::string>();
+  if (instructionName == "measure") {
+    auto qubit = instruction.attr("qubits").cast<py::list>()[0].cast<Qubit>();
+    auto clbit =
+        instruction.attr("memory").cast<py::list>()[0].cast<std::size_t>();
+    qc.emplace_back<NonUnitaryOperation>(qc.getNqubits(), qubit, clbit);
+  } else if (instructionName == "barrier") {
+    Targets targets{};
+    for (const auto qubit : instruction.attr("qubits")) {
+      auto target = qubit.cast<Qubit>();
+      targets.emplace_back(target);
+    }
+    qc.emplace_back<NonUnitaryOperation>(qc.getNqubits(), targets, Barrier);
+  } else if (instructionName == "reset") {
+    Targets targets{};
+    for (const auto qubit : instruction.attr("qubits")) {
+      auto target = qubit.cast<Qubit>();
+      targets.emplace_back(target);
+    }
+    qc.reset(targets);
+  } else if (NATIVELY_SUPPORTED_GATES.count(instructionName) != 0) {
+    auto&& qubits = instruction.attr("qubits").cast<py::list>();
+    py::list params{};
+    if (py::hasattr(instruction, "params")) {
+      params = instruction.attr("params");
+    }
+    // natively supported operations
+    if (instructionName == "i" || instructionName == "id" ||
+        instructionName == "iden") {
+      addOperation(qc, I, qubits, params);
+    } else if (instructionName == "x" || instructionName == "cx" ||
+               instructionName == "ccx" || instructionName == "mcx_gray" ||
+               instructionName == "mcx") {
+      addOperation(qc, X, qubits, params);
+    } else if (instructionName == "y" || instructionName == "cy") {
+      addOperation(qc, Y, qubits, params);
+    } else if (instructionName == "z" || instructionName == "cz") {
+      addOperation(qc, Z, qubits, params);
+    } else if (instructionName == "h" || instructionName == "ch") {
+      addOperation(qc, H, qubits, params);
+    } else if (instructionName == "s") {
+      addOperation(qc, S, qubits, params);
+    } else if (instructionName == "sdg") {
+      addOperation(qc, Sdag, qubits, params);
+    } else if (instructionName == "t") {
+      addOperation(qc, T, qubits, params);
+    } else if (instructionName == "tdg") {
+      addOperation(qc, Tdag, qubits, params);
+    } else if (instructionName == "rx" || instructionName == "crx" ||
+               instructionName == "mcrx") {
+      params = instruction.attr("params").cast<py::list>();
+      addOperation(qc, RX, qubits, params);
+    } else if (instructionName == "ry" || instructionName == "cry" ||
+               instructionName == "mcry") {
+      params = instruction.attr("params").cast<py::list>();
+      addOperation(qc, RY, qubits, params);
+    } else if (instructionName == "rz" || instructionName == "crz" ||
+               instructionName == "mcrz") {
+      params = instruction.attr("params").cast<py::list>();
+      addOperation(qc, RZ, qubits, params);
+    } else if (instructionName == "p" || instructionName == "u1" ||
+               instructionName == "cp" || instructionName == "cu1" ||
+               instructionName == "mcphase") {
+      params = instruction.attr("params").cast<py::list>();
+      addOperation(qc, Phase, qubits, params);
+    } else if (instructionName == "sx" || instructionName == "csx") {
+      addOperation(qc, SX, qubits, params);
+    } else if (instructionName == "sxdg") {
+      addOperation(qc, SXdag, qubits, params);
+    } else if (instructionName == "u2") {
+      params = instruction.attr("params").cast<py::list>();
+      addOperation(qc, U2, qubits, params);
+    } else if (instructionName == "u" || instructionName == "u3" ||
+               instructionName == "cu3") {
+      params = instruction.attr("params").cast<py::list>();
+      addOperation(qc, U3, qubits, params);
+    } else if (instructionName == "swap" || instructionName == "cswap") {
+      addTwoTargetOperation(qc, SWAP, qubits, params);
+    } else if (instructionName == "iswap") {
+      addTwoTargetOperation(qc, iSWAP, qubits, params);
+    } else if (instructionName == "dcx") {
+      addTwoTargetOperation(qc, DCX, qubits, params);
+    } else if (instructionName == "ecr") {
+      addTwoTargetOperation(qc, ECR, qubits, params);
+    } else if (instructionName == "rxx") {
+      addTwoTargetOperation(qc, RXX, qubits, params);
+    } else if (instructionName == "ryy") {
+      addTwoTargetOperation(qc, RYY, qubits, params);
+    } else if (instructionName == "rzx") {
+      addTwoTargetOperation(qc, RZX, qubits, params);
+    } else if (instructionName == "rzz") {
+      addTwoTargetOperation(qc, RZZ, qubits, params);
+    } else if (instructionName == "xx_minus_yy") {
+      addTwoTargetOperation(qc, XXminusYY, qubits, params);
+    } else if (instructionName == "xx_plus_yy") {
+      addTwoTargetOperation(qc, XXplusYY, qubits, params);
+    } else if (instructionName == "mcx_recursive") {
+      if (qubits.size() <= 5) {
+        addOperation(qc, X, qubits, params);
+      } else {
+        auto qubitsCopy = qubits.attr("copy")();
+        qubitsCopy.attr("pop")(); // discard ancillaries
+        addOperation(qc, X, qubitsCopy, params);
+      }
+    } else if (instructionName == "mcx_vchain") {
+      auto size = qubits.size();
+      const std::size_t ncontrols = (size + 1) / 2;
+      auto qubitsCopy = qubits.attr("copy")();
+      // discard ancillaries
+      for (std::size_t i = 0; i < ncontrols - 2; ++i) {
+        qubitsCopy.attr("pop")();
+      }
+      addOperation(qc, X, qubitsCopy, params);
+    }
+  } else {
+    std::cerr << "Failed to import instruction " << instructionName
+              << " from Qiskit QasmQobjExperiment" << std::endl;
+  }
+}
+
+void qc::qiskit::QasmQobjExperiment::addOperation(qc::QuantumComputation& qc,
+                                                  qc::OpType type,
+                                                  const py::list& qubits,
+                                                  const py::list& params) {
+  std::vector<Control> qargs{};
+  for (const auto qubit : qubits) {
+    auto target = qubit.cast<Qubit>();
+    qargs.emplace_back(Control{target});
+  }
+  auto target = qargs.back().qubit;
+  qargs.pop_back();
+
+  std::vector<fp> parameters{};
+  for (const auto& param : params) {
+    parameters.emplace_back(param.cast<fp>());
+  }
+  const Controls controls(qargs.cbegin(), qargs.cend());
+  qc.emplace_back<StandardOperation>(qc.getNqubits(), controls, target, type,
+                                     parameters);
+}
+
+void qc::qiskit::QasmQobjExperiment::addTwoTargetOperation(
+    qc::QuantumComputation& qc, qc::OpType type, const py::list& qubits,
+    const py::list& params) {
+  std::vector<Control> qargs{};
+  for (const auto qubit : qubits) {
+    auto target = qubit.cast<Qubit>();
+    qargs.emplace_back(Control{target});
+  }
+  auto target1 = qargs.back().qubit;
+  qargs.pop_back();
+  auto target0 = qargs.back().qubit;
+  qargs.pop_back();
+
+  std::vector<fp> parameters{};
+  for (const auto& param : params) {
+    parameters.emplace_back(param.cast<fp>());
+  }
+  const Controls controls(qargs.cbegin(), qargs.cend());
+  qc.emplace_back<StandardOperation>(qc.getNqubits(), controls, target0,
+                                     target1, type, parameters);
+}
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/mqt/qfr/qiskit/QuantumCircuit.hpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/python/qiskit/QuantumCircuit.cpp`

 * *Files 20% similar despite different names*

```diff
@@ -1,432 +1,477 @@
-/*
- * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
- */
-
-#ifndef QFR_QUANTUMCIRCUIT_HPP
-#define QFR_QUANTUMCIRCUIT_HPP
-
-#include "pybind11/pybind11.h"
-
-#include <pybind11/pytypes.h>
-#include <regex>
-#include <type_traits>
-#include <variant>
-
-namespace py = pybind11;
-
-#include "QuantumComputation.hpp"
-
-namespace qc::qiskit {
-    using namespace pybind11::literals;
-
-    class QuantumCircuit {
-    public:
-        static void import(QuantumComputation& qc, const py::object& circ) {
-            qc.reset();
-
-            const py::object quantumCircuit = py::module::import("qiskit").attr("QuantumCircuit");
-
-            if (!py::isinstance(circ, quantumCircuit)) {
-                throw QFRException("[import] Python object needs to be a Qiskit QuantumCircuit");
-            }
-
-            if (!circ.attr("name").is_none()) {
-                qc.setName(circ.attr("name").cast<std::string>());
-            }
-
-            // handle qubit registers
-            const py::object qubit           = py::module::import("qiskit.circuit").attr("Qubit");
-            const py::object ancillaQubit    = py::module::import("qiskit.circuit").attr("AncillaQubit");
-            const py::object ancillaRegister = py::module::import("qiskit.circuit").attr("AncillaRegister");
-            int              qubitIndex      = 0;
-            py::dict         qubitMap{};
-            auto&&           circQregs = circ.attr("qregs");
-            for (const auto qreg: circQregs) {
-                // create corresponding register in quantum computation
-                auto size = qreg.attr("size").cast<std::size_t>();
-                auto name = qreg.attr("name").cast<std::string>();
-                if (py::isinstance(qreg, ancillaRegister)) {
-                    qc.addAncillaryRegister(size, name);
-                    // add ancillas to qubit map
-                    for (std::size_t i = 0; i < size; ++i) {
-                        qubitMap[ancillaQubit(qreg, i)] = qubitIndex;
-                        qubitIndex++;
-                    }
-                } else {
-                    qc.addQubitRegister(size, name);
-                    // add qubits to qubit map
-                    for (std::size_t i = 0; i < size; ++i) {
-                        qubitMap[qubit(qreg, i)] = qubitIndex;
-                        qubitIndex++;
-                    }
-                }
-            }
-
-            // handle classical registers
-            const py::object clbit      = py::module::import("qiskit.circuit").attr("Clbit");
-            int              clbitIndex = 0;
-            py::dict         clbitMap{};
-            auto&&           circCregs = circ.attr("cregs");
-            for (const auto creg: circCregs) {
-                // create corresponding register in quantum computation
-                auto size = creg.attr("size").cast<std::size_t>();
-                auto name = creg.attr("name").cast<std::string>();
-                qc.addClassicalRegister(size, name);
-
-                // add clbits to clbit map
-                for (std::size_t i = 0; i < size; ++i) {
-                    clbitMap[clbit(creg, i)] = clbitIndex;
-                    clbitIndex++;
-                }
-            }
-
-            try {
-                qc.gphase(circ.attr("global_phase").cast<fp>());
-            } catch (const py::cast_error& e) {
-                std::clog << "[import] Warning: Symbolic global phase values are not supported yet. Ignoring global phase.\n";
-            }
-
-            // iterate over instructions
-            auto&& data = circ.attr("data");
-            for (const auto pyinst: data) {
-                auto&& inst        = pyinst.cast<std::tuple<py::object, py::list, py::list>>();
-                auto&& instruction = std::get<0>(inst);
-                auto&& qargs       = std::get<1>(inst);
-                auto&& cargs       = std::get<2>(inst);
-                auto&& params      = instruction.attr("params");
-
-                emplaceOperation(qc, instruction, qargs, cargs, params, qubitMap, clbitMap);
-            }
-
-            // import initial layout in case it is available
-            if (!circ.attr("_layout").is_none()) {
-                importInitialLayout(qc, circ);
-            }
-            qc.initializeIOMapping();
-        }
-
-    protected:
-        static void emplaceOperation(QuantumComputation& qc, const py::object& instruction, const py::list& qargs, const py::list& cargs, const py::list& params, const py::dict& qubitMap, const py::dict& clbitMap) {
-            static const auto NATIVELY_SUPPORTED_GATES = std::set<std::string>{"i", "id", "iden", "x", "y", "z", "h", "s", "sdg", "t", "tdg", "p", "u1", "rx", "ry", "rz", "u2", "u", "u3", "cx", "cy", "cz", "cp", "cu1", "ch", "crx", "cry", "crz", "cu3", "ccx", "swap", "cswap", "iswap", "sx", "sxdg", "csx", "mcx", "mcx_gray", "mcx_recursive", "mcx_vchain", "mcphase", "mcrx", "mcry", "mcrz", "dcx", "ecr", "rxx", "ryy", "rzx", "rzz", "xx_minus_yy", "xx_plus_yy"};
-
-            auto instructionName = instruction.attr("name").cast<std::string>();
-            if (instructionName == "measure") {
-                auto control = qubitMap[qargs[0]].cast<Qubit>();
-                auto target  = clbitMap[cargs[0]].cast<std::size_t>();
-                qc.emplace_back<NonUnitaryOperation>(qc.getNqubits(), control, target);
-            } else if (instructionName == "barrier") {
-                Targets targets{};
-                for (const auto qubit: qargs) {
-                    auto target = qubitMap[qubit].cast<Qubit>();
-                    targets.emplace_back(target);
-                }
-                qc.emplace_back<NonUnitaryOperation>(qc.getNqubits(), targets, Barrier);
-            } else if (instructionName == "reset") {
-                Targets targets{};
-                for (const auto qubit: qargs) {
-                    auto target = qubitMap[qubit].cast<Qubit>();
-                    targets.emplace_back(target);
-                }
-                qc.reset(targets);
-            } else if (NATIVELY_SUPPORTED_GATES.count(instructionName) != 0) {
-                // natively supported operations
-                if (instructionName == "i" || instructionName == "id" || instructionName == "iden") {
-                    addOperation(qc, I, qargs, params, qubitMap);
-                } else if (instructionName == "x" || instructionName == "cx" || instructionName == "ccx" || instructionName == "mcx_gray" || instructionName == "mcx") {
-                    addOperation(qc, X, qargs, params, qubitMap);
-                } else if (instructionName == "y" || instructionName == "cy") {
-                    addOperation(qc, Y, qargs, params, qubitMap);
-                } else if (instructionName == "z" || instructionName == "cz") {
-                    addOperation(qc, Z, qargs, params, qubitMap);
-                } else if (instructionName == "h" || instructionName == "ch") {
-                    addOperation(qc, H, qargs, params, qubitMap);
-                } else if (instructionName == "s") {
-                    addOperation(qc, S, qargs, params, qubitMap);
-                } else if (instructionName == "sdg") {
-                    addOperation(qc, Sdag, qargs, params, qubitMap);
-                } else if (instructionName == "t") {
-                    addOperation(qc, T, qargs, params, qubitMap);
-                } else if (instructionName == "tdg") {
-                    addOperation(qc, Tdag, qargs, params, qubitMap);
-                } else if (instructionName == "rx" || instructionName == "crx" || instructionName == "mcrx") {
-                    addOperation(qc, RX, qargs, params, qubitMap);
-                } else if (instructionName == "ry" || instructionName == "cry" || instructionName == "mcry") {
-                    addOperation(qc, RY, qargs, params, qubitMap);
-                } else if (instructionName == "rz" || instructionName == "crz" || instructionName == "mcrz") {
-                    addOperation(qc, RZ, qargs, params, qubitMap);
-                } else if (instructionName == "p" || instructionName == "u1" || instructionName == "cp" || instructionName == "cu1" || instructionName == "mcphase") {
-                    addOperation(qc, Phase, qargs, params, qubitMap);
-                } else if (instructionName == "sx" || instructionName == "csx") {
-                    addOperation(qc, SX, qargs, params, qubitMap);
-                } else if (instructionName == "sxdg") {
-                    addOperation(qc, SXdag, qargs, params, qubitMap);
-                } else if (instructionName == "u2") {
-                    addOperation(qc, U2, qargs, params, qubitMap);
-                } else if (instructionName == "u" || instructionName == "u3" || instructionName == "cu3") {
-                    addOperation(qc, U3, qargs, params, qubitMap);
-                } else if (instructionName == "swap" || instructionName == "cswap") {
-                    addTwoTargetOperation(qc, SWAP, qargs, params, qubitMap);
-                } else if (instructionName == "iswap") {
-                    addTwoTargetOperation(qc, iSWAP, qargs, params, qubitMap);
-                } else if (instructionName == "dcx") {
-                    addTwoTargetOperation(qc, DCX, qargs, params, qubitMap);
-                } else if (instructionName == "ecr") {
-                    addTwoTargetOperation(qc, ECR, qargs, params, qubitMap);
-                } else if (instructionName == "rxx") {
-                    addTwoTargetOperation(qc, RXX, qargs, params, qubitMap);
-                } else if (instructionName == "ryy") {
-                    addTwoTargetOperation(qc, RYY, qargs, params, qubitMap);
-                } else if (instructionName == "rzx") {
-                    addTwoTargetOperation(qc, RZX, qargs, params, qubitMap);
-                } else if (instructionName == "rzz") {
-                    addTwoTargetOperation(qc, RZZ, qargs, params, qubitMap);
-                } else if (instructionName == "xx_minus_yy") {
-                    addTwoTargetOperation(qc, XXminusYY, qargs, params, qubitMap);
-                } else if (instructionName == "xx_plus_yy") {
-                    addTwoTargetOperation(qc, XXplusYY, qargs, params, qubitMap);
-                } else if (instructionName == "mcx_recursive") {
-                    if (qargs.size() <= 5) {
-                        addOperation(qc, X, qargs, params, qubitMap);
-                    } else {
-                        auto qargsCopy = qargs.attr("copy")();
-                        qargsCopy.attr("pop")(); // discard ancillaries
-                        addOperation(qc, X, qargsCopy, params, qubitMap);
-                    }
-                } else if (instructionName == "mcx_vchain") {
-                    auto              size      = qargs.size();
-                    const std::size_t ncontrols = (size + 1) / 2;
-                    auto              qargsCopy = qargs.attr("copy")();
-                    // discard ancillaries
-                    for (std::size_t i = 0; i < ncontrols - 2; ++i) {
-                        qargsCopy.attr("pop")();
-                    }
-                    addOperation(qc, X, qargsCopy, params, qubitMap);
-                }
-            } else {
-                try {
-                    importDefinition(qc, instruction.attr("definition"), qargs, cargs, qubitMap, clbitMap);
-                } catch (py::error_already_set& e) {
-                    std::cerr << "Failed to import instruction " << instructionName << " from Qiskit QuantumCircuit" << std::endl;
-                    std::cerr << e.what() << std::endl;
-                }
-            }
-        }
-
-        static SymbolOrNumber parseSymbolicExpr(const py::object& pyExpr) {
-            static const std::regex SUMMANDS("[+|-]?[^+-]+");
-            static const std::regex PRODUCTS("[\\*/]?[^\\*/]+");
-
-            auto exprStr = pyExpr.attr("__str__")().cast<std::string>();
-            exprStr.erase(std::remove(exprStr.begin(), exprStr.end(), ' '),
-                          exprStr.end()); // strip whitespace
-
-            auto       sumIt  = std::sregex_iterator(exprStr.begin(), exprStr.end(), SUMMANDS);
-            const auto sumEnd = std::sregex_iterator();
-
-            qc::Symbolic sym;
-            bool         isConst = true;
-
-            while (sumIt != sumEnd) {
-                auto      match    = *sumIt;
-                auto      matchStr = match.str();
-                const int sign     = matchStr[0] == '-' ? -1 : 1;
-                if (matchStr[0] == '+' || matchStr[0] == '-') {
-                    matchStr.erase(0, 1);
-                }
-
-                auto prodIt  = std::sregex_iterator(matchStr.begin(), matchStr.end(), PRODUCTS);
-                auto prodEnd = std::sregex_iterator();
-
-                fp          coeff = 1.0;
-                std::string var;
-                while (prodIt != prodEnd) {
-                    auto prodMatch = *prodIt;
-                    auto prodStr   = prodMatch.str();
-
-                    const bool isDiv = prodStr[0] == '/';
-                    if (prodStr[0] == '*' || prodStr[0] == '/') {
-                        prodStr.erase(0, 1);
-                    }
-
-                    std::istringstream iss(prodStr);
-                    fp                 f{};
-                    iss >> f;
-
-                    if (iss.eof() && !iss.fail()) {
-                        coeff *= isDiv ? 1.0 / f : f;
-                    } else {
-                        var = prodStr;
-                    }
-
-                    ++prodIt;
-                }
-                if (var.empty()) {
-                    sym += coeff;
-                } else {
-                    isConst = false;
-                    sym += sym::Term(sign * coeff, sym::Variable{var});
-                }
-                ++sumIt;
-            }
-
-            if (isConst) {
-                return {sym.getConst()};
-            }
-            return {sym};
-        }
-
-        static SymbolOrNumber parseParam(const py::object& param) {
-            try {
-                return param.cast<fp>();
-            } catch (py::cast_error& e) {
-                return parseSymbolicExpr(param);
-            }
-        }
-
-        static void addOperation(QuantumComputation& qc, OpType type, const py::list& qargs, const py::list& params, const py::dict& qubitMap) {
-            std::vector<Control> qubits{};
-            for (const auto qubit: qargs) {
-                auto target = qubitMap[qubit].cast<Qubit>();
-                qubits.emplace_back(Control{target});
-            }
-            auto target = qubits.back().qubit;
-            qubits.pop_back();
-            std::vector<qc::SymbolOrNumber> parameters{};
-            for (const auto& param: params) {
-                parameters.emplace_back(parseParam(py::reinterpret_borrow<py::object>(param)));
-            }
-            const Controls controls(qubits.cbegin(), qubits.cend());
-            if (std::all_of(parameters.cbegin(), parameters.cend(), [](const auto& p) { return std::holds_alternative<fp>(p); })) {
-                std::vector<fp> fpParams{};
-                std::transform(parameters.cbegin(), parameters.cend(), std::back_inserter(fpParams), [](const auto& p) { return std::get<fp>(p); });
-                qc.emplace_back<StandardOperation>(qc.getNqubits(), controls, target, type, fpParams);
-            } else {
-                qc.emplace_back<SymbolicOperation>(qc.getNqubits(), controls, target, type, parameters);
-                for (const auto& p: parameters) {
-                    qc.addVariables(p);
-                }
-            }
-        }
-
-        static void addTwoTargetOperation(QuantumComputation& qc, OpType type, const py::list& qargs, const py::list& params, const py::dict& qubitMap) {
-            std::vector<Control> qubits{};
-            for (const auto qubit: qargs) {
-                auto target = qubitMap[qubit].cast<Qubit>();
-                qubits.emplace_back(Control{target});
-            }
-            auto target1 = qubits.back().qubit;
-            qubits.pop_back();
-            auto target0 = qubits.back().qubit;
-            qubits.pop_back();
-            std::vector<qc::SymbolOrNumber> parameters{};
-            for (const auto& param: params) {
-                parameters.emplace_back(parseParam(py::reinterpret_borrow<py::object>(param)));
-            }
-            const Controls controls(qubits.cbegin(), qubits.cend());
-            if (std::all_of(parameters.cbegin(), parameters.cend(), [](const auto& p) { return std::holds_alternative<fp>(p); })) {
-                std::vector<fp> fpParams{};
-                std::transform(parameters.cbegin(), parameters.cend(), std::back_inserter(fpParams), [](const auto& p) { return std::get<fp>(p); });
-                qc.emplace_back<StandardOperation>(qc.getNqubits(), controls, target0, target1, type, fpParams);
-            } else {
-                qc.emplace_back<SymbolicOperation>(qc.getNqubits(), controls, target0, target1, type, parameters);
-                for (const auto& p: parameters) {
-                    qc.addVariables(p);
-                }
-            }
-        }
-
-        static void importDefinition(QuantumComputation& qc, const py::object& circ, const py::list& qargs, const py::list& cargs, const py::dict& qubitMap, const py::dict& clbitMap) {
-            py::dict   qargMap{};
-            py::list&& defQubits = circ.attr("qubits");
-            for (size_t i = 0; i < qargs.size(); ++i) {
-                qargMap[defQubits[i]] = qargs[i];
-            }
-
-            py::dict   cargMap{};
-            py::list&& defClbits = circ.attr("clbits");
-            for (size_t i = 0; i < cargs.size(); ++i) {
-                cargMap[defClbits[i]] = cargs[i];
-            }
-
-            auto&& data = circ.attr("data");
-            for (const auto pyinst: data) {
-                auto&& inst        = pyinst.cast<std::tuple<py::object, py::list, py::list>>();
-                auto&& instruction = std::get<0>(inst);
-
-                const py::list& instQargs = std::get<1>(inst);
-                py::list        mappedQargs{};
-                for (auto&& instQarg: instQargs) {
-                    mappedQargs.append(qargMap[instQarg]);
-                }
-
-                const py::list& instCargs = std::get<2>(inst);
-                py::list        mappedCargs{};
-                for (auto&& instCarg: instCargs) {
-                    mappedCargs.append(cargMap[instCarg]);
-                }
-
-                auto&& instParams = instruction.attr("params");
-
-                emplaceOperation(qc, instruction, mappedQargs, mappedCargs, instParams, qubitMap, clbitMap);
-            }
-        }
-
-        static void importInitialLayout(QuantumComputation& qc, const py::object& circ) {
-            const py::object qubit = py::module::import("qiskit.circuit").attr("Qubit");
-
-            // get layout
-            auto layout = circ.attr("_layout");
-
-            // qiskit-terra 0.22.0 changed the `_layout` attribute to a `TranspileLayout` dataclass object
-            // that contains the initial layout as a `Layout` object in the `initial_layout` attribute.
-            if (py::hasattr(layout, "initial_layout")) {
-                layout = layout.attr("initial_layout");
-            }
-
-            // create map between registers used in the layout and logical qubit indices
-            // NOTE: this only works correctly if the registers were originally declared in alphabetical order!
-            const auto  registers         = layout.attr("get_registers")().cast<py::set>();
-            std::size_t logicalQubitIndex = 0U;
-            py::dict    logicalQubitIndices{};
-
-            // the ancilla register
-            decltype(registers.get_type()) ancillaRegister = py::none();
-
-            for (const auto qreg: registers) {
-                // skip ancillary register since it is handled as the very last qubit register
-                if (const auto qregName = qreg.attr("name").cast<std::string>(); qregName == "ancilla") {
-                    ancillaRegister = qreg;
-                    continue;
-                }
-
-                const auto size = qreg.attr("size").cast<std::size_t>();
-                for (std::size_t i = 0U; i < size; ++i) {
-                    logicalQubitIndices[qubit(qreg, i)] = logicalQubitIndex;
-                    ++logicalQubitIndex;
-                }
-            }
-
-            // handle ancillary register, if there is one
-            if (!ancillaRegister.is_none()) {
-                const auto size = ancillaRegister.attr("size").cast<std::size_t>();
-                for (std::size_t i = 0U; i < size; ++i) {
-                    logicalQubitIndices[qubit(ancillaRegister, i)] = logicalQubitIndex;
-                    qc.setLogicalQubitAncillary(static_cast<Qubit>(logicalQubitIndex));
-                    ++logicalQubitIndex;
-                }
-            }
-
-            // get a map of physical to logical qubits
-            const auto physicalQubits = layout.attr("get_physical_bits")().cast<py::dict>();
-
-            // create initial layout
-            for (const auto& [physicalQubit, logicalQubit]: physicalQubits) {
-                if (logicalQubitIndices.contains(logicalQubit)) {
-                    qc.initialLayout[physicalQubit.cast<Qubit>()] = logicalQubitIndices[logicalQubit].cast<Qubit>();
-                }
-            }
-        }
-    };
-} // namespace qc::qiskit
-#endif //QFR_QUANTUMCIRCUIT_HPP
+#include "python/qiskit/QuantumCircuit.hpp"
+
+void qc::qiskit::QuantumCircuit::import(qc::QuantumComputation& qc,
+                                        const py::object& circ) {
+  qc.reset();
+
+  const py::object quantumCircuit =
+      py::module::import("qiskit").attr("QuantumCircuit");
+
+  if (!py::isinstance(circ, quantumCircuit)) {
+    throw QFRException(
+        "[import] Python object needs to be a Qiskit QuantumCircuit");
+  }
+
+  if (!circ.attr("name").is_none()) {
+    qc.setName(circ.attr("name").cast<std::string>());
+  }
+
+  // handle qubit registers
+  const py::object qubit = py::module::import("qiskit.circuit").attr("Qubit");
+  const py::object ancillaQubit =
+      py::module::import("qiskit.circuit").attr("AncillaQubit");
+  const py::object ancillaRegister =
+      py::module::import("qiskit.circuit").attr("AncillaRegister");
+  int qubitIndex = 0;
+  const py::dict qubitMap{};
+  auto&& circQregs = circ.attr("qregs");
+  for (const auto qreg : circQregs) {
+    // create corresponding register in quantum computation
+    auto size = qreg.attr("size").cast<std::size_t>();
+    auto name = qreg.attr("name").cast<std::string>();
+    if (py::isinstance(qreg, ancillaRegister)) {
+      qc.addAncillaryRegister(size, name);
+      // add ancillas to qubit map
+      for (std::size_t i = 0; i < size; ++i) {
+        qubitMap[ancillaQubit(qreg, i)] = qubitIndex;
+        qubitIndex++;
+      }
+    } else {
+      qc.addQubitRegister(size, name);
+      // add qubits to qubit map
+      for (std::size_t i = 0; i < size; ++i) {
+        qubitMap[qubit(qreg, i)] = qubitIndex;
+        qubitIndex++;
+      }
+    }
+  }
+
+  // handle classical registers
+  const py::object clbit = py::module::import("qiskit.circuit").attr("Clbit");
+  int clbitIndex = 0;
+  const py::dict clbitMap{};
+  auto&& circCregs = circ.attr("cregs");
+  for (const auto creg : circCregs) {
+    // create corresponding register in quantum computation
+    auto size = creg.attr("size").cast<std::size_t>();
+    auto name = creg.attr("name").cast<std::string>();
+    qc.addClassicalRegister(size, name);
+
+    // add clbits to clbit map
+    for (std::size_t i = 0; i < size; ++i) {
+      clbitMap[clbit(creg, i)] = clbitIndex;
+      clbitIndex++;
+    }
+  }
+
+  try {
+    qc.gphase(circ.attr("global_phase").cast<fp>());
+  } catch (const py::cast_error& e) {
+    std::clog << "[import] Warning: Symbolic global phase values are not "
+                 "supported yet. Ignoring global phase.\n";
+  }
+
+  // iterate over instructions
+  auto&& data = circ.attr("data");
+  for (const auto pyinst : data) {
+    auto&& inst = pyinst.cast<std::tuple<py::object, py::list, py::list>>();
+    auto&& instruction = std::get<0>(inst);
+    auto&& qargs = std::get<1>(inst);
+    auto&& cargs = std::get<2>(inst);
+    auto&& params = instruction.attr("params");
+
+    emplaceOperation(qc, instruction, qargs, cargs, params, qubitMap, clbitMap);
+  }
+
+  // import initial layout in case it is available
+  if (!circ.attr("_layout").is_none()) {
+    importInitialLayout(qc, circ);
+  }
+  qc.initializeIOMapping();
+}
+
+void qc::qiskit::QuantumCircuit::emplaceOperation(
+    qc::QuantumComputation& qc, const py::object& instruction,
+    const py::list& qargs, const py::list& cargs, const py::list& params,
+    const py::dict& qubitMap, const py::dict& clbitMap) {
+  static const auto NATIVELY_SUPPORTED_GATES =
+      std::set<std::string>{"i",          "id",       "iden",
+                            "x",          "y",        "z",
+                            "h",          "s",        "sdg",
+                            "t",          "tdg",      "p",
+                            "u1",         "rx",       "ry",
+                            "rz",         "u2",       "u",
+                            "u3",         "cx",       "cy",
+                            "cz",         "cp",       "cu1",
+                            "ch",         "crx",      "cry",
+                            "crz",        "cu3",      "ccx",
+                            "swap",       "cswap",    "iswap",
+                            "sx",         "sxdg",     "csx",
+                            "mcx",        "mcx_gray", "mcx_recursive",
+                            "mcx_vchain", "mcphase",  "mcrx",
+                            "mcry",       "mcrz",     "dcx",
+                            "ecr",        "rxx",      "ryy",
+                            "rzx",        "rzz",      "xx_minus_yy",
+                            "xx_plus_yy"};
+
+  auto instructionName = instruction.attr("name").cast<std::string>();
+  if (instructionName == "measure") {
+    auto control = qubitMap[qargs[0]].cast<Qubit>();
+    auto target = clbitMap[cargs[0]].cast<std::size_t>();
+    qc.emplace_back<NonUnitaryOperation>(qc.getNqubits(), control, target);
+  } else if (instructionName == "barrier") {
+    Targets targets{};
+    for (const auto qubit : qargs) {
+      auto target = qubitMap[qubit].cast<Qubit>();
+      targets.emplace_back(target);
+    }
+    qc.emplace_back<NonUnitaryOperation>(qc.getNqubits(), targets, Barrier);
+  } else if (instructionName == "reset") {
+    Targets targets{};
+    for (const auto qubit : qargs) {
+      auto target = qubitMap[qubit].cast<Qubit>();
+      targets.emplace_back(target);
+    }
+    qc.reset(targets);
+  } else if (NATIVELY_SUPPORTED_GATES.count(instructionName) != 0) {
+    // natively supported operations
+    if (instructionName == "i" || instructionName == "id" ||
+        instructionName == "iden") {
+      addOperation(qc, I, qargs, params, qubitMap);
+    } else if (instructionName == "x" || instructionName == "cx" ||
+               instructionName == "ccx" || instructionName == "mcx_gray" ||
+               instructionName == "mcx") {
+      addOperation(qc, X, qargs, params, qubitMap);
+    } else if (instructionName == "y" || instructionName == "cy") {
+      addOperation(qc, Y, qargs, params, qubitMap);
+    } else if (instructionName == "z" || instructionName == "cz") {
+      addOperation(qc, Z, qargs, params, qubitMap);
+    } else if (instructionName == "h" || instructionName == "ch") {
+      addOperation(qc, H, qargs, params, qubitMap);
+    } else if (instructionName == "s") {
+      addOperation(qc, S, qargs, params, qubitMap);
+    } else if (instructionName == "sdg") {
+      addOperation(qc, Sdag, qargs, params, qubitMap);
+    } else if (instructionName == "t") {
+      addOperation(qc, T, qargs, params, qubitMap);
+    } else if (instructionName == "tdg") {
+      addOperation(qc, Tdag, qargs, params, qubitMap);
+    } else if (instructionName == "rx" || instructionName == "crx" ||
+               instructionName == "mcrx") {
+      addOperation(qc, RX, qargs, params, qubitMap);
+    } else if (instructionName == "ry" || instructionName == "cry" ||
+               instructionName == "mcry") {
+      addOperation(qc, RY, qargs, params, qubitMap);
+    } else if (instructionName == "rz" || instructionName == "crz" ||
+               instructionName == "mcrz") {
+      addOperation(qc, RZ, qargs, params, qubitMap);
+    } else if (instructionName == "p" || instructionName == "u1" ||
+               instructionName == "cp" || instructionName == "cu1" ||
+               instructionName == "mcphase") {
+      addOperation(qc, Phase, qargs, params, qubitMap);
+    } else if (instructionName == "sx" || instructionName == "csx") {
+      addOperation(qc, SX, qargs, params, qubitMap);
+    } else if (instructionName == "sxdg") {
+      addOperation(qc, SXdag, qargs, params, qubitMap);
+    } else if (instructionName == "u2") {
+      addOperation(qc, U2, qargs, params, qubitMap);
+    } else if (instructionName == "u" || instructionName == "u3" ||
+               instructionName == "cu3") {
+      addOperation(qc, U3, qargs, params, qubitMap);
+    } else if (instructionName == "swap" || instructionName == "cswap") {
+      addTwoTargetOperation(qc, SWAP, qargs, params, qubitMap);
+    } else if (instructionName == "iswap") {
+      addTwoTargetOperation(qc, iSWAP, qargs, params, qubitMap);
+    } else if (instructionName == "dcx") {
+      addTwoTargetOperation(qc, DCX, qargs, params, qubitMap);
+    } else if (instructionName == "ecr") {
+      addTwoTargetOperation(qc, ECR, qargs, params, qubitMap);
+    } else if (instructionName == "rxx") {
+      addTwoTargetOperation(qc, RXX, qargs, params, qubitMap);
+    } else if (instructionName == "ryy") {
+      addTwoTargetOperation(qc, RYY, qargs, params, qubitMap);
+    } else if (instructionName == "rzx") {
+      addTwoTargetOperation(qc, RZX, qargs, params, qubitMap);
+    } else if (instructionName == "rzz") {
+      addTwoTargetOperation(qc, RZZ, qargs, params, qubitMap);
+    } else if (instructionName == "xx_minus_yy") {
+      addTwoTargetOperation(qc, XXminusYY, qargs, params, qubitMap);
+    } else if (instructionName == "xx_plus_yy") {
+      addTwoTargetOperation(qc, XXplusYY, qargs, params, qubitMap);
+    } else if (instructionName == "mcx_recursive") {
+      if (qargs.size() <= 5) {
+        addOperation(qc, X, qargs, params, qubitMap);
+      } else {
+        auto qargsCopy = qargs.attr("copy")();
+        qargsCopy.attr("pop")(); // discard ancillaries
+        addOperation(qc, X, qargsCopy, params, qubitMap);
+      }
+    } else if (instructionName == "mcx_vchain") {
+      auto size = qargs.size();
+      const std::size_t ncontrols = (size + 1) / 2;
+      auto qargsCopy = qargs.attr("copy")();
+      // discard ancillaries
+      for (std::size_t i = 0; i < ncontrols - 2; ++i) {
+        qargsCopy.attr("pop")();
+      }
+      addOperation(qc, X, qargsCopy, params, qubitMap);
+    }
+  } else {
+    try {
+      importDefinition(qc, instruction.attr("definition"), qargs, cargs,
+                       qubitMap, clbitMap);
+    } catch (py::error_already_set& e) {
+      std::cerr << "Failed to import instruction " << instructionName
+                << " from Qiskit QuantumCircuit" << std::endl;
+      std::cerr << e.what() << std::endl;
+    }
+  }
+}
+
+qc::SymbolOrNumber
+qc::qiskit::QuantumCircuit::parseSymbolicExpr(const py::object& pyExpr) {
+  static const std::regex SUMMANDS("[+|-]?[^+-]+");
+  static const std::regex PRODUCTS("[\\*/]?[^\\*/]+");
+
+  auto exprStr = pyExpr.attr("__str__")().cast<std::string>();
+  exprStr.erase(std::remove(exprStr.begin(), exprStr.end(), ' '),
+                exprStr.end()); // strip whitespace
+
+  auto sumIt = std::sregex_iterator(exprStr.begin(), exprStr.end(), SUMMANDS);
+  const auto sumEnd = std::sregex_iterator();
+
+  qc::Symbolic sym;
+  bool isConst = true;
+
+  while (sumIt != sumEnd) {
+    auto match = *sumIt;
+    auto matchStr = match.str();
+    const int sign = matchStr[0] == '-' ? -1 : 1;
+    if (matchStr[0] == '+' || matchStr[0] == '-') {
+      matchStr.erase(0, 1);
+    }
+
+    auto prodIt =
+        std::sregex_iterator(matchStr.begin(), matchStr.end(), PRODUCTS);
+    auto prodEnd = std::sregex_iterator();
+
+    fp coeff = 1.0;
+    std::string var;
+    while (prodIt != prodEnd) {
+      auto prodMatch = *prodIt;
+      auto prodStr = prodMatch.str();
+
+      const bool isDiv = prodStr[0] == '/';
+      if (prodStr[0] == '*' || prodStr[0] == '/') {
+        prodStr.erase(0, 1);
+      }
+
+      std::istringstream iss(prodStr);
+      fp f{};
+      iss >> f;
+
+      if (iss.eof() && !iss.fail()) {
+        coeff *= isDiv ? 1.0 / f : f;
+      } else {
+        var = prodStr;
+      }
+
+      ++prodIt;
+    }
+    if (var.empty()) {
+      sym += coeff;
+    } else {
+      isConst = false;
+      sym += sym::Term(sign * coeff, sym::Variable{var});
+    }
+    ++sumIt;
+  }
+
+  if (isConst) {
+    return {sym.getConst()};
+  }
+  return {sym};
+}
+
+qc::SymbolOrNumber
+qc::qiskit::QuantumCircuit::parseParam(const py::object& param) {
+  try {
+    return param.cast<fp>();
+  } catch (py::cast_error& e) {
+    return parseSymbolicExpr(param);
+  }
+}
+
+void qc::qiskit::QuantumCircuit::addOperation(qc::QuantumComputation& qc,
+                                              qc::OpType type,
+                                              const py::list& qargs,
+                                              const py::list& params,
+                                              const py::dict& qubitMap) {
+  std::vector<Control> qubits{};
+  for (const auto qubit : qargs) {
+    auto target = qubitMap[qubit].cast<Qubit>();
+    qubits.emplace_back(Control{target});
+  }
+  auto target = qubits.back().qubit;
+  qubits.pop_back();
+  std::vector<qc::SymbolOrNumber> parameters{};
+  for (const auto& param : params) {
+    parameters.emplace_back(
+        parseParam(py::reinterpret_borrow<py::object>(param)));
+  }
+  const Controls controls(qubits.cbegin(), qubits.cend());
+  if (std::all_of(parameters.cbegin(), parameters.cend(), [](const auto& p) {
+        return std::holds_alternative<fp>(p);
+      })) {
+    std::vector<fp> fpParams{};
+    std::transform(parameters.cbegin(), parameters.cend(),
+                   std::back_inserter(fpParams),
+                   [](const auto& p) { return std::get<fp>(p); });
+    qc.emplace_back<StandardOperation>(qc.getNqubits(), controls, target, type,
+                                       fpParams);
+  } else {
+    qc.emplace_back<SymbolicOperation>(qc.getNqubits(), controls, target, type,
+                                       parameters);
+    for (const auto& p : parameters) {
+      qc.addVariables(p);
+    }
+  }
+}
+
+void qc::qiskit::QuantumCircuit::addTwoTargetOperation(
+    qc::QuantumComputation& qc, qc::OpType type, const py::list& qargs,
+    const py::list& params, const py::dict& qubitMap) {
+  std::vector<Control> qubits{};
+  for (const auto qubit : qargs) {
+    auto target = qubitMap[qubit].cast<Qubit>();
+    qubits.emplace_back(Control{target});
+  }
+  auto target1 = qubits.back().qubit;
+  qubits.pop_back();
+  auto target0 = qubits.back().qubit;
+  qubits.pop_back();
+  std::vector<qc::SymbolOrNumber> parameters{};
+  for (const auto& param : params) {
+    parameters.emplace_back(
+        parseParam(py::reinterpret_borrow<py::object>(param)));
+  }
+  const Controls controls(qubits.cbegin(), qubits.cend());
+  if (std::all_of(parameters.cbegin(), parameters.cend(), [](const auto& p) {
+        return std::holds_alternative<fp>(p);
+      })) {
+    std::vector<fp> fpParams{};
+    std::transform(parameters.cbegin(), parameters.cend(),
+                   std::back_inserter(fpParams),
+                   [](const auto& p) { return std::get<fp>(p); });
+    qc.emplace_back<StandardOperation>(qc.getNqubits(), controls, target0,
+                                       target1, type, fpParams);
+  } else {
+    qc.emplace_back<SymbolicOperation>(qc.getNqubits(), controls, target0,
+                                       target1, type, parameters);
+    for (const auto& p : parameters) {
+      qc.addVariables(p);
+    }
+  }
+}
+
+void qc::qiskit::QuantumCircuit::importDefinition(
+    qc::QuantumComputation& qc, const py::object& circ, const py::list& qargs,
+    const py::list& cargs, const py::dict& qubitMap, const py::dict& clbitMap) {
+  const py::dict qargMap{};
+  py::list&& defQubits = circ.attr("qubits");
+  for (size_t i = 0; i < qargs.size(); ++i) {
+    qargMap[defQubits[i]] = qargs[i];
+  }
+
+  const py::dict cargMap{};
+  py::list&& defClbits = circ.attr("clbits");
+  for (size_t i = 0; i < cargs.size(); ++i) {
+    cargMap[defClbits[i]] = cargs[i];
+  }
+
+  auto&& data = circ.attr("data");
+  for (const auto pyinst : data) {
+    auto&& inst = pyinst.cast<std::tuple<py::object, py::list, py::list>>();
+    auto&& instruction = std::get<0>(inst);
+
+    const py::list& instQargs = std::get<1>(inst);
+    py::list mappedQargs{};
+    for (auto&& instQarg : instQargs) {
+      mappedQargs.append(qargMap[instQarg]);
+    }
+
+    const py::list& instCargs = std::get<2>(inst);
+    py::list mappedCargs{};
+    for (auto&& instCarg : instCargs) {
+      mappedCargs.append(cargMap[instCarg]);
+    }
+
+    auto&& instParams = instruction.attr("params");
+
+    emplaceOperation(qc, instruction, mappedQargs, mappedCargs, instParams,
+                     qubitMap, clbitMap);
+  }
+}
+
+void qc::qiskit::QuantumCircuit::importInitialLayout(qc::QuantumComputation& qc,
+                                                     const py::object& circ) {
+  const py::object qubit = py::module::import("qiskit.circuit").attr("Qubit");
+
+  // get layout
+  auto layout = circ.attr("_layout");
+
+  // qiskit-terra 0.22.0 changed the `_layout` attribute to a
+  // `TranspileLayout` dataclass object that contains the initial layout as a
+  // `Layout` object in the `initial_layout` attribute.
+  if (py::hasattr(layout, "initial_layout")) {
+    layout = layout.attr("initial_layout");
+  }
+
+  // create map between registers used in the layout and logical qubit indices
+  // NOTE: this only works correctly if the registers were originally declared
+  // in alphabetical order!
+  const auto registers = layout.attr("get_registers")().cast<py::set>();
+  std::size_t logicalQubitIndex = 0U;
+  const py::dict logicalQubitIndices{};
+
+  // the ancilla register
+  decltype(registers.get_type()) ancillaRegister = py::none();
+
+  for (const auto qreg : registers) {
+    // skip ancillary register since it is handled as the very last qubit
+    // register
+    if (const auto qregName = qreg.attr("name").cast<std::string>();
+        qregName == "ancilla") {
+      ancillaRegister = qreg;
+      continue;
+    }
+
+    const auto size = qreg.attr("size").cast<std::size_t>();
+    for (std::size_t i = 0U; i < size; ++i) {
+      logicalQubitIndices[qubit(qreg, i)] = logicalQubitIndex;
+      ++logicalQubitIndex;
+    }
+  }
+
+  // handle ancillary register, if there is one
+  if (!ancillaRegister.is_none()) {
+    const auto size = ancillaRegister.attr("size").cast<std::size_t>();
+    for (std::size_t i = 0U; i < size; ++i) {
+      logicalQubitIndices[qubit(ancillaRegister, i)] = logicalQubitIndex;
+      qc.setLogicalQubitAncillary(static_cast<Qubit>(logicalQubitIndex));
+      ++logicalQubitIndex;
+    }
+  }
+
+  // get a map of physical to logical qubits
+  const auto physicalQubits =
+      layout.attr("get_physical_bits")().cast<py::dict>();
+
+  // create initial layout
+  for (const auto& [physicalQubit, logicalQubit] : physicalQubits) {
+    if (logicalQubitIndices.contains(logicalQubit)) {
+      qc.initialLayout[physicalQubit.cast<Qubit>()] =
+          logicalQubitIndices[logicalQubit].cast<Qubit>();
+    }
+  }
+}
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/src/CircuitOptimizer.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/CircuitOptimizer.cpp`

 * *Files 20% similar despite different names*

```diff
@@ -1,1258 +1,1355 @@
-/*
- * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
- */
-
 #include "CircuitOptimizer.hpp"
 
 #include <cassert>
 
 namespace qc {
-    void CircuitOptimizer::removeIdentities(QuantumComputation& qc) {
-        // delete the identities from circuit
-        auto it = qc.ops.begin();
-        while (it != qc.ops.end()) {
-            if ((*it)->getType() == I || (*it)->getType() == Barrier) {
-                it = qc.ops.erase(it);
-            } else if ((*it)->isCompoundOperation()) {
-                auto* compOp = dynamic_cast<qc::CompoundOperation*>((*it).get());
-                auto  cit    = compOp->cbegin();
-                while (cit != compOp->cend()) {
-                    const auto* cop = cit->get();
-                    if (cop->getType() == qc::I || cop->getType() == Barrier) {
-                        cit = compOp->erase(cit);
-                    } else {
-                        ++cit;
-                    }
-                }
-                if (compOp->empty()) {
-                    it = qc.ops.erase(it);
-                } else {
-                    if (compOp->size() == 1) {
-                        // CompoundOperation has degraded to single Operation
-                        (*it) = std::move(*(compOp->begin()));
-                    }
-                    ++it;
-                }
-            } else {
-                ++it;
-            }
-        }
-    }
-
-    void CircuitOptimizer::swapReconstruction(QuantumComputation& qc) {
-        Qubit highestPhysicalQubit = 0;
-        for (const auto& q: qc.initialLayout) {
-            if (q.first > highestPhysicalQubit) {
-                highestPhysicalQubit = q.first;
-            }
-        }
-
-        auto dag = DAG(highestPhysicalQubit + 1);
-
-        for (auto& it: qc.ops) {
-            if (!it->isStandardOperation()) {
-                addNonStandardOperationToDag(dag, &it);
-                continue;
-            }
-
-            // Operation is not a CNOT
-            if (it->getType() != X || it->getNcontrols() != 1 || it->getControls().begin()->type != Control::Type::Pos) {
-                addToDag(dag, &it);
-                continue;
-            }
-
-            const Qubit control = it->getControls().begin()->qubit;
-            const Qubit target  = it->getTargets().at(0);
-
-            // first operation
-            if (dag.at(control).empty() || dag.at(target).empty()) {
-                addToDag(dag, &it);
-                continue;
-            }
-
-            auto* opC = dag.at(control).back();
-            auto* opT = dag.at(target).back();
-
-            // previous operation is not a CNOT
-            if ((*opC)->getType() != qc::X || (*opC)->getNcontrols() != 1 || (*opC)->getControls().begin()->type != Control::Type::Pos ||
-                (*opT)->getType() != qc::X || (*opT)->getNcontrols() != 1 || (*opT)->getControls().begin()->type != Control::Type::Pos) {
-                addToDag(dag, &it);
-                continue;
-            }
-
-            const auto opCcontrol = (*opC)->getControls().begin()->qubit;
-            const auto opCtarget  = (*opC)->getTargets().at(0);
-            const auto opTcontrol = (*opT)->getControls().begin()->qubit;
-            const auto opTtarget  = (*opT)->getTargets().at(0);
-
-            // operation at control and target qubit are not the same
-            if (opCcontrol != opTcontrol || opCtarget != opTtarget) {
-                addToDag(dag, &it);
-                continue;
-            }
-
-            if (control == opCcontrol && target == opCtarget) {
-                // elimination
-                dag.at(control).pop_back();
-                dag.at(target).pop_back();
-                (*opC)->setGate(I);
-                (*opC)->setControls({});
-                it->setGate(I);
-                it->setControls({});
-            } else if (control == opCtarget && target == opCcontrol) {
-                dag.at(control).pop_back();
-                dag.at(target).pop_back();
-
-                // replace with SWAP + CNOT
-                (*opC)->setGate(SWAP);
-                if (target > control) {
-                    (*opC)->setTargets({control, target});
-                } else {
-                    (*opC)->setTargets({target, control});
-                }
-                (*opC)->setControls({});
-                addToDag(dag, opC);
-
-                it->setTargets({control});
-                it->setControls({Control{target}});
-                addToDag(dag, &it);
-            } else {
-                addToDag(dag, &it);
-            }
-        }
-
-        removeIdentities(qc);
-    }
-
-    DAG CircuitOptimizer::constructDAG(QuantumComputation& qc) {
-        Qubit highestPhysicalQubit = 0;
-        for (const auto& q: qc.initialLayout) {
-            if (q.first > highestPhysicalQubit) {
-                highestPhysicalQubit = q.first;
-            }
-        }
-
-        auto dag = DAG(highestPhysicalQubit + 1);
-
-        for (auto& it: qc.ops) {
-            if (!it->isStandardOperation()) {
-                addNonStandardOperationToDag(dag, &it);
-            } else {
-                addToDag(dag, &it);
-            }
-        }
-        return dag;
-    }
-
-    void CircuitOptimizer::addToDag(DAG& dag, std::unique_ptr<Operation>* op) {
-        for (const auto& control: (*op)->getControls()) {
-            dag.at(control.qubit).push_back(op);
-        }
-        for (const auto& target: (*op)->getTargets()) {
-            dag.at(target).push_back(op);
-        }
-    }
-
-    void CircuitOptimizer::addNonStandardOperationToDag(DAG& dag, std::unique_ptr<Operation>* op) {
-        const auto& gate = *op;
-        // compound operations are added "as-is"
-        if (gate->isCompoundOperation()) {
-            for (std::size_t i = 0U; i < gate->getNqubits(); ++i) {
-                if (gate->actsOn(static_cast<Qubit>(i))) {
-                    dag.at(i).push_back(op);
-                }
-            }
-        } else if (gate->isNonUnitaryOperation()) {
-            // barriers are not added to a circuit DAG
-            if (gate->getType() == Barrier) {
-                return;
-            }
-
-            for (const auto& b: gate->getTargets()) {
-                dag.at(b).push_back(op);
-            }
-        } else if (gate->isClassicControlledOperation()) {
-            auto* cop = dynamic_cast<ClassicControlledOperation*>(gate.get())->getOperation();
-            for (const auto& control: cop->getControls()) {
-                dag.at(control.qubit).push_back(op);
-            }
-            for (const auto& target: cop->getTargets()) {
-                dag.at(target).push_back(op);
-            }
+void CircuitOptimizer::removeIdentities(QuantumComputation& qc) {
+  // delete the identities from circuit
+  auto it = qc.ops.begin();
+  while (it != qc.ops.end()) {
+    if ((*it)->getType() == I || (*it)->getType() == Barrier) {
+      it = qc.ops.erase(it);
+    } else if ((*it)->isCompoundOperation()) {
+      auto* compOp = dynamic_cast<qc::CompoundOperation*>((*it).get());
+      auto cit = compOp->cbegin();
+      while (cit != compOp->cend()) {
+        const auto* cop = cit->get();
+        if (cop->getType() == qc::I || cop->getType() == Barrier) {
+          cit = compOp->erase(cit);
         } else {
-            throw QFRException("Unexpected operation encountered");
+          ++cit;
         }
-    }
-
-    void CircuitOptimizer::singleQubitGateFusion(QuantumComputation& qc) {
-        static const std::map<qc::OpType, qc::OpType> INVERSE_MAP = {
-                {qc::I, qc::I},
-                {qc::X, qc::X},
-                {qc::Y, qc::Y},
-                {qc::Z, qc::Z},
-                {qc::H, qc::H},
-                {qc::S, qc::Sdag},
-                {qc::Sdag, qc::S},
-                {qc::T, qc::Tdag},
-                {qc::Tdag, qc::T},
-                {qc::SX, qc::SXdag},
-                {qc::SXdag, qc::SX}};
-
-        Qubit highestPhysicalQubit = 0;
-        for (const auto& q: qc.initialLayout) {
-            if (q.first > highestPhysicalQubit) {
-                highestPhysicalQubit = q.first;
-            }
-        }
-
-        auto dag = DAG(highestPhysicalQubit + 1);
-
-        for (auto& it: qc.ops) {
-            if (!it->isStandardOperation()) {
-                addNonStandardOperationToDag(dag, &it);
-                continue;
-            }
-
-            // not a single qubit operation TODO: multiple targets could also be considered here
-            if (!it->getControls().empty() || it->getTargets().size() > 1) {
-                addToDag(dag, &it);
-                continue;
-            }
-
-            const auto target = it->getTargets().at(0);
-
-            // first operation
-            if (dag.at(target).empty()) {
-                addToDag(dag, &it);
-                continue;
-            }
-
-            auto  dagQubit = dag.at(target);
-            auto* op       = dagQubit.back();
-
-            // no single qubit op to fuse with operation
-            if (!(*op)->isCompoundOperation() && (!(*op)->getControls().empty() || (*op)->getTargets().size() > 1)) {
-                addToDag(dag, &it);
-                continue;
-            }
-
-            // compound operation
-            if ((*op)->isCompoundOperation()) {
-                auto* compop = dynamic_cast<CompoundOperation*>(op->get());
-
-                // check if compound operation contains non-single-qubit gates
-                std::size_t involvedQubits = 0;
-                for (std::size_t q = 0; q < dag.size(); ++q) {
-                    if (compop->actsOn(static_cast<Qubit>(q))) {
-                        ++involvedQubits;
-                    }
-                }
-                if (involvedQubits > 1) {
-                    addToDag(dag, &it);
-                    continue;
-                }
-
-                // check if inverse
-                auto lastop    = (--(compop->end()));
-                auto inverseIt = INVERSE_MAP.find((*lastop)->getType());
-                // check if current operation is the inverse of the previous operation
-                if (inverseIt != INVERSE_MAP.end() && it->getType() == inverseIt->second) {
-                    compop->pop_back();
-                    it->setGate(qc::I);
-                } else {
-                    compop->emplace_back<StandardOperation>(
-                            it->getNqubits(),
-                            it->getTargets().at(0),
-                            it->getType(),
-                            it->getParameter());
-                    it->setGate(I);
-                }
-
-                continue;
-            }
-
-            // single qubit op
-
-            // check if current operation is the inverse of the previous operation
-            auto inverseIt = INVERSE_MAP.find((*op)->getType());
-            if (inverseIt != INVERSE_MAP.end() && it->getType() == inverseIt->second) {
-                (*op)->setGate(qc::I);
-                it->setGate(qc::I);
-            } else {
-                auto compop = std::make_unique<CompoundOperation>(it->getNqubits());
-                compop->emplace_back<StandardOperation>(
-                        (*op)->getNqubits(),
-                        (*op)->getTargets().at(0),
-                        (*op)->getType(),
-                        (*op)->getParameter());
-                compop->emplace_back<StandardOperation>(
-                        it->getNqubits(),
-                        it->getTargets().at(0),
-                        it->getType(),
-                        it->getParameter());
-                it->setGate(I);
-                (*op) = std::move(compop);
-                dag.at(target).push_back(op);
-            }
-        }
-
-        removeIdentities(qc);
-    }
-
-    bool CircuitOptimizer::removeDiagonalGate(DAG& dag, DAGReverseIterators& dagIterators, Qubit idx, DAGReverseIterator& it, qc::Operation* op) {
-        // not a diagonal gate
-        if (std::find(DIAGONAL_GATES.begin(), DIAGONAL_GATES.end(), op->getType()) == DIAGONAL_GATES.end()) {
-            it = dag.at(idx).rend();
-            return false;
-        }
-
-        if (op->getNcontrols() != 0) {
-            // need to check all controls and targets
-            bool onlyDiagonalGates = true;
-            for (const auto& control: op->getControls()) {
-                auto controlQubit = control.qubit;
-                if (controlQubit == idx) {
-                    continue;
-                }
-                if (control.type == Control::Type::Neg) {
-                    dagIterators.at(controlQubit) = dag.at(controlQubit).rend();
-                    onlyDiagonalGates             = false;
-                    break;
-                }
-                if (dagIterators.at(controlQubit) == dag.at(controlQubit).rend()) {
-                    onlyDiagonalGates = false;
-                    break;
-                }
-                // recursive call at control with this operation as goal
-                removeDiagonalGatesBeforeMeasureRecursive(dag, dagIterators, controlQubit, it);
-                // check if iteration of control qubit was successful
-                if (*dagIterators.at(controlQubit) != *it) {
-                    onlyDiagonalGates = false;
-                    break;
-                }
-            }
-            for (const auto& target: op->getTargets()) {
-                if (target == idx) {
-                    continue;
-                }
-                if (dagIterators.at(target) == dag.at(target).rend()) {
-                    onlyDiagonalGates = false;
-                    break;
-                }
-                // recursive call at target with this operation as goal
-                removeDiagonalGatesBeforeMeasureRecursive(dag, dagIterators, target, it);
-                // check if iteration of target qubit was successful
-                if (*dagIterators.at(target) != *it) {
-                    onlyDiagonalGates = false;
-                    break;
-                }
-            }
-            if (!onlyDiagonalGates) {
-                // end qubit
-                dagIterators.at(idx) = dag.at(idx).rend();
-            } else {
-                // set operation to identity so that it can be collected by the removeIdentities pass
-                op->setGate(qc::I);
-            }
-            return onlyDiagonalGates;
-        }
-        // set operation to identity so that it can be collected by the removeIdentities pass
-        op->setGate(qc::I);
-        return true;
-    }
-
-    void CircuitOptimizer::removeDiagonalGatesBeforeMeasureRecursive(DAG& dag, DAGReverseIterators& dagIterators, Qubit idx, const DAGReverseIterator& until) {
-        // qubit is finished -> consider next qubit
-        if (dagIterators.at(idx) == dag.at(idx).rend()) {
-            if (idx < static_cast<Qubit>(dag.size() - 1)) {
-                removeDiagonalGatesBeforeMeasureRecursive(dag, dagIterators, idx + 1, dag.at(idx + 1).rend());
-            }
-            return;
-        }
-        // check if desired operation was reached
-        if (until != dag.at(idx).rend()) {
-            if (*dagIterators.at(idx) == *until) {
-                return;
-            }
-        }
-
-        auto& it = dagIterators.at(idx);
-        while (it != dag.at(idx).rend()) {
-            // check if desired operation was reached
-            if (until != dag.at(idx).rend()) {
-                if (*dagIterators.at(idx) == *until) {
-                    break;
-                }
-            }
-            auto* op = (*it)->get();
-            if (op->getType() == Barrier || op->getType() == Snapshot || op->getType() == ShowProbabilities) {
-                ++it;
-            } else if (op->isStandardOperation()) {
-                // try removing gate and upon success increase all corresponding iterators
-                auto onlyDiagonalGates = removeDiagonalGate(dag, dagIterators, idx, it, op);
-                if (onlyDiagonalGates) {
-                    for (const auto& control: op->getControls()) {
-                        ++(dagIterators.at(control.qubit));
-                    }
-                    for (const auto& target: op->getTargets()) {
-                        ++(dagIterators.at(target));
-                    }
-                }
-
-            } else if (op->isCompoundOperation()) {
-                // iterate over all gates of compound operation and upon success increase all corresponding iterators
-                auto* compOp            = dynamic_cast<qc::CompoundOperation*>(op);
-                bool  onlyDiagonalGates = true;
-                auto  cit               = compOp->rbegin();
-                while (cit != compOp->rend()) {
-                    auto* cop         = (*cit).get();
-                    onlyDiagonalGates = removeDiagonalGate(dag, dagIterators, idx, it, cop);
-                    if (!onlyDiagonalGates) {
-                        break;
-                    }
-                    ++cit;
-                }
-                if (onlyDiagonalGates) {
-                    for (size_t q = 0; q < dag.size(); ++q) {
-                        if (compOp->actsOn(static_cast<Qubit>(q))) {
-                            ++(dagIterators.at(q));
-                        }
-                    }
-                }
-            } else if (op->isClassicControlledOperation()) {
-                // consider the operation that is classically controlled and proceed as above
-                auto*      cop               = dynamic_cast<ClassicControlledOperation*>(op)->getOperation();
-                const bool onlyDiagonalGates = removeDiagonalGate(dag, dagIterators, idx, it, cop);
-                if (onlyDiagonalGates) {
-                    for (const auto& control: cop->getControls()) {
-                        ++(dagIterators.at(control.qubit));
-                    }
-                    for (const auto& target: cop->getTargets()) {
-                        ++(dagIterators.at(target));
-                    }
-                }
-            } else if (op->isNonUnitaryOperation()) {
-                // non-unitary operation is not diagonal
-                it = dag.at(idx).rend();
-            } else {
-                throw QFRException("Unexpected operation encountered");
-            }
-        }
-
-        // qubit is finished -> consider next qubit
-        if (dagIterators.at(idx) == dag.at(idx).rend() && idx < static_cast<Qubit>(dag.size() - 1)) {
-            removeDiagonalGatesBeforeMeasureRecursive(dag, dagIterators, idx + 1, dag.at(idx + 1).rend());
-        }
-    }
-
-    void CircuitOptimizer::removeDiagonalGatesBeforeMeasure(QuantumComputation& qc) {
-        auto dag = constructDAG(qc);
-
-        // initialize iterators
-        DAGReverseIterators dagIterators{dag.size()};
+      }
+      if (compOp->empty()) {
+        it = qc.ops.erase(it);
+      } else {
+        if (compOp->size() == 1) {
+          // CompoundOperation has degraded to single Operation
+          (*it) = std::move(*(compOp->begin()));
+        }
+        ++it;
+      }
+    } else {
+      ++it;
+    }
+  }
+}
+
+void CircuitOptimizer::swapReconstruction(QuantumComputation& qc) {
+  Qubit highestPhysicalQubit = 0;
+  for (const auto& q : qc.initialLayout) {
+    if (q.first > highestPhysicalQubit) {
+      highestPhysicalQubit = q.first;
+    }
+  }
+
+  auto dag = DAG(highestPhysicalQubit + 1);
+
+  for (auto& it : qc.ops) {
+    if (!it->isStandardOperation()) {
+      addNonStandardOperationToDag(dag, &it);
+      continue;
+    }
+
+    // Operation is not a CNOT
+    if (it->getType() != X || it->getNcontrols() != 1 ||
+        it->getControls().begin()->type != Control::Type::Pos) {
+      addToDag(dag, &it);
+      continue;
+    }
+
+    const Qubit control = it->getControls().begin()->qubit;
+    const Qubit target = it->getTargets().at(0);
+
+    // first operation
+    if (dag.at(control).empty() || dag.at(target).empty()) {
+      addToDag(dag, &it);
+      continue;
+    }
+
+    auto* opC = dag.at(control).back();
+    auto* opT = dag.at(target).back();
+
+    // previous operation is not a CNOT
+    if ((*opC)->getType() != qc::X || (*opC)->getNcontrols() != 1 ||
+        (*opC)->getControls().begin()->type != Control::Type::Pos ||
+        (*opT)->getType() != qc::X || (*opT)->getNcontrols() != 1 ||
+        (*opT)->getControls().begin()->type != Control::Type::Pos) {
+      addToDag(dag, &it);
+      continue;
+    }
+
+    const auto opCcontrol = (*opC)->getControls().begin()->qubit;
+    const auto opCtarget = (*opC)->getTargets().at(0);
+    const auto opTcontrol = (*opT)->getControls().begin()->qubit;
+    const auto opTtarget = (*opT)->getTargets().at(0);
+
+    // operation at control and target qubit are not the same
+    if (opCcontrol != opTcontrol || opCtarget != opTtarget) {
+      addToDag(dag, &it);
+      continue;
+    }
+
+    if (control == opCcontrol && target == opCtarget) {
+      // elimination
+      dag.at(control).pop_back();
+      dag.at(target).pop_back();
+      (*opC)->setGate(I);
+      (*opC)->setControls({});
+      it->setGate(I);
+      it->setControls({});
+    } else if (control == opCtarget && target == opCcontrol) {
+      dag.at(control).pop_back();
+      dag.at(target).pop_back();
+
+      // replace with SWAP + CNOT
+      (*opC)->setGate(SWAP);
+      if (target > control) {
+        (*opC)->setTargets({control, target});
+      } else {
+        (*opC)->setTargets({target, control});
+      }
+      (*opC)->setControls({});
+      addToDag(dag, opC);
+
+      it->setTargets({control});
+      it->setControls({Control{target}});
+      addToDag(dag, &it);
+    } else {
+      addToDag(dag, &it);
+    }
+  }
+
+  removeIdentities(qc);
+}
+
+DAG CircuitOptimizer::constructDAG(QuantumComputation& qc) {
+  Qubit highestPhysicalQubit = 0;
+  for (const auto& q : qc.initialLayout) {
+    if (q.first > highestPhysicalQubit) {
+      highestPhysicalQubit = q.first;
+    }
+  }
+
+  auto dag = DAG(highestPhysicalQubit + 1);
+
+  for (auto& it : qc.ops) {
+    if (!it->isStandardOperation()) {
+      addNonStandardOperationToDag(dag, &it);
+    } else {
+      addToDag(dag, &it);
+    }
+  }
+  return dag;
+}
+
+void CircuitOptimizer::addToDag(DAG& dag, std::unique_ptr<Operation>* op) {
+  for (const auto& control : (*op)->getControls()) {
+    dag.at(control.qubit).push_back(op);
+  }
+  for (const auto& target : (*op)->getTargets()) {
+    dag.at(target).push_back(op);
+  }
+}
+
+void CircuitOptimizer::addNonStandardOperationToDag(
+    DAG& dag, std::unique_ptr<Operation>* op) {
+  const auto& gate = *op;
+  // compound operations are added "as-is"
+  if (gate->isCompoundOperation()) {
+    for (std::size_t i = 0U; i < gate->getNqubits(); ++i) {
+      if (gate->actsOn(static_cast<Qubit>(i))) {
+        dag.at(i).push_back(op);
+      }
+    }
+  } else if (gate->isNonUnitaryOperation()) {
+    // barriers are not added to a circuit DAG
+    if (gate->getType() == Barrier) {
+      return;
+    }
+
+    for (const auto& b : gate->getTargets()) {
+      dag.at(b).push_back(op);
+    }
+  } else if (gate->isClassicControlledOperation()) {
+    auto* cop =
+        dynamic_cast<ClassicControlledOperation*>(gate.get())->getOperation();
+    for (const auto& control : cop->getControls()) {
+      dag.at(control.qubit).push_back(op);
+    }
+    for (const auto& target : cop->getTargets()) {
+      dag.at(target).push_back(op);
+    }
+  } else {
+    throw QFRException("Unexpected operation encountered");
+  }
+}
+
+void CircuitOptimizer::singleQubitGateFusion(QuantumComputation& qc) {
+  static const std::map<qc::OpType, qc::OpType> INVERSE_MAP = {
+      {qc::I, qc::I},      {qc::X, qc::X},     {qc::Y, qc::Y},
+      {qc::Z, qc::Z},      {qc::H, qc::H},     {qc::S, qc::Sdag},
+      {qc::Sdag, qc::S},   {qc::T, qc::Tdag},  {qc::Tdag, qc::T},
+      {qc::SX, qc::SXdag}, {qc::SXdag, qc::SX}};
+
+  Qubit highestPhysicalQubit = 0;
+  for (const auto& q : qc.initialLayout) {
+    if (q.first > highestPhysicalQubit) {
+      highestPhysicalQubit = q.first;
+    }
+  }
+
+  auto dag = DAG(highestPhysicalQubit + 1);
+
+  for (auto& it : qc.ops) {
+    if (!it->isStandardOperation()) {
+      addNonStandardOperationToDag(dag, &it);
+      continue;
+    }
+
+    // not a single qubit operation TODO: multiple targets could also be
+    // considered here
+    if (!it->getControls().empty() || it->getTargets().size() > 1) {
+      addToDag(dag, &it);
+      continue;
+    }
+
+    const auto target = it->getTargets().at(0);
+
+    // first operation
+    if (dag.at(target).empty()) {
+      addToDag(dag, &it);
+      continue;
+    }
+
+    auto dagQubit = dag.at(target);
+    auto* op = dagQubit.back();
+
+    // no single qubit op to fuse with operation
+    if (!(*op)->isCompoundOperation() &&
+        (!(*op)->getControls().empty() || (*op)->getTargets().size() > 1)) {
+      addToDag(dag, &it);
+      continue;
+    }
+
+    // compound operation
+    if ((*op)->isCompoundOperation()) {
+      auto* compop = dynamic_cast<CompoundOperation*>(op->get());
+
+      // check if compound operation contains non-single-qubit gates
+      std::size_t involvedQubits = 0;
+      for (std::size_t q = 0; q < dag.size(); ++q) {
+        if (compop->actsOn(static_cast<Qubit>(q))) {
+          ++involvedQubits;
+        }
+      }
+      if (involvedQubits > 1) {
+        addToDag(dag, &it);
+        continue;
+      }
+
+      // check if inverse
+      auto lastop = (--(compop->end()));
+      auto inverseIt = INVERSE_MAP.find((*lastop)->getType());
+      // check if current operation is the inverse of the previous operation
+      if (inverseIt != INVERSE_MAP.end() &&
+          it->getType() == inverseIt->second) {
+        compop->pop_back();
+        it->setGate(qc::I);
+      } else {
+        compop->emplace_back<StandardOperation>(
+            it->getNqubits(), it->getTargets().at(0), it->getType(),
+            it->getParameter());
+        it->setGate(I);
+      }
+
+      continue;
+    }
+
+    // single qubit op
+
+    // check if current operation is the inverse of the previous operation
+    auto inverseIt = INVERSE_MAP.find((*op)->getType());
+    if (inverseIt != INVERSE_MAP.end() && it->getType() == inverseIt->second) {
+      (*op)->setGate(qc::I);
+      it->setGate(qc::I);
+    } else {
+      auto compop = std::make_unique<CompoundOperation>(it->getNqubits());
+      compop->emplace_back<StandardOperation>(
+          (*op)->getNqubits(), (*op)->getTargets().at(0), (*op)->getType(),
+          (*op)->getParameter());
+      compop->emplace_back<StandardOperation>(
+          it->getNqubits(), it->getTargets().at(0), it->getType(),
+          it->getParameter());
+      it->setGate(I);
+      (*op) = std::move(compop);
+      dag.at(target).push_back(op);
+    }
+  }
+
+  removeIdentities(qc);
+}
+
+bool CircuitOptimizer::removeDiagonalGate(DAG& dag,
+                                          DAGReverseIterators& dagIterators,
+                                          Qubit idx, DAGReverseIterator& it,
+                                          qc::Operation* op) {
+  // not a diagonal gate
+  if (std::find(DIAGONAL_GATES.begin(), DIAGONAL_GATES.end(), op->getType()) ==
+      DIAGONAL_GATES.end()) {
+    it = dag.at(idx).rend();
+    return false;
+  }
+
+  if (op->getNcontrols() != 0) {
+    // need to check all controls and targets
+    bool onlyDiagonalGates = true;
+    for (const auto& control : op->getControls()) {
+      auto controlQubit = control.qubit;
+      if (controlQubit == idx) {
+        continue;
+      }
+      if (control.type == Control::Type::Neg) {
+        dagIterators.at(controlQubit) = dag.at(controlQubit).rend();
+        onlyDiagonalGates = false;
+        break;
+      }
+      if (dagIterators.at(controlQubit) == dag.at(controlQubit).rend()) {
+        onlyDiagonalGates = false;
+        break;
+      }
+      // recursive call at control with this operation as goal
+      removeDiagonalGatesBeforeMeasureRecursive(dag, dagIterators, controlQubit,
+                                                it);
+      // check if iteration of control qubit was successful
+      if (*dagIterators.at(controlQubit) != *it) {
+        onlyDiagonalGates = false;
+        break;
+      }
+    }
+    for (const auto& target : op->getTargets()) {
+      if (target == idx) {
+        continue;
+      }
+      if (dagIterators.at(target) == dag.at(target).rend()) {
+        onlyDiagonalGates = false;
+        break;
+      }
+      // recursive call at target with this operation as goal
+      removeDiagonalGatesBeforeMeasureRecursive(dag, dagIterators, target, it);
+      // check if iteration of target qubit was successful
+      if (*dagIterators.at(target) != *it) {
+        onlyDiagonalGates = false;
+        break;
+      }
+    }
+    if (!onlyDiagonalGates) {
+      // end qubit
+      dagIterators.at(idx) = dag.at(idx).rend();
+    } else {
+      // set operation to identity so that it can be collected by the
+      // removeIdentities pass
+      op->setGate(qc::I);
+    }
+    return onlyDiagonalGates;
+  }
+  // set operation to identity so that it can be collected by the
+  // removeIdentities pass
+  op->setGate(qc::I);
+  return true;
+}
+
+void CircuitOptimizer::removeDiagonalGatesBeforeMeasureRecursive(
+    DAG& dag, DAGReverseIterators& dagIterators, Qubit idx,
+    const DAGReverseIterator& until) {
+  // qubit is finished -> consider next qubit
+  if (dagIterators.at(idx) == dag.at(idx).rend()) {
+    if (idx < static_cast<Qubit>(dag.size() - 1)) {
+      removeDiagonalGatesBeforeMeasureRecursive(dag, dagIterators, idx + 1,
+                                                dag.at(idx + 1).rend());
+    }
+    return;
+  }
+  // check if desired operation was reached
+  if (until != dag.at(idx).rend()) {
+    if (*dagIterators.at(idx) == *until) {
+      return;
+    }
+  }
+
+  auto& it = dagIterators.at(idx);
+  while (it != dag.at(idx).rend()) {
+    // check if desired operation was reached
+    if (until != dag.at(idx).rend()) {
+      if (*dagIterators.at(idx) == *until) {
+        break;
+      }
+    }
+    auto* op = (*it)->get();
+    if (op->getType() == Barrier || op->getType() == Snapshot ||
+        op->getType() == ShowProbabilities) {
+      ++it;
+    } else if (op->isStandardOperation()) {
+      // try removing gate and upon success increase all corresponding iterators
+      auto onlyDiagonalGates =
+          removeDiagonalGate(dag, dagIterators, idx, it, op);
+      if (onlyDiagonalGates) {
+        for (const auto& control : op->getControls()) {
+          ++(dagIterators.at(control.qubit));
+        }
+        for (const auto& target : op->getTargets()) {
+          ++(dagIterators.at(target));
+        }
+      }
+
+    } else if (op->isCompoundOperation()) {
+      // iterate over all gates of compound operation and upon success increase
+      // all corresponding iterators
+      auto* compOp = dynamic_cast<qc::CompoundOperation*>(op);
+      bool onlyDiagonalGates = true;
+      auto cit = compOp->rbegin();
+      while (cit != compOp->rend()) {
+        auto* cop = (*cit).get();
+        onlyDiagonalGates = removeDiagonalGate(dag, dagIterators, idx, it, cop);
+        if (!onlyDiagonalGates) {
+          break;
+        }
+        ++cit;
+      }
+      if (onlyDiagonalGates) {
         for (size_t q = 0; q < dag.size(); ++q) {
-            if (dag.at(q).empty() || dag.at(q).back()->get()->getType() != qc::Measure) {
-                // qubit is not measured and thus does not have to be considered
-                dagIterators.at(q) = dag.at(q).rend();
-            } else {
-                // point to operation before measurement
-                dagIterators.at(q) = ++(dag.at(q).rbegin());
-            }
-        }
-        // iterate over DAG in depth-first fashion
-        removeDiagonalGatesBeforeMeasureRecursive(dag, dagIterators, 0, dag.at(0).rend());
-
-        // remove resulting identities from circuit
-        removeIdentities(qc);
-    }
-
-    bool CircuitOptimizer::removeFinalMeasurement(DAG& dag, DAGReverseIterators& dagIterators, Qubit idx, DAGReverseIterator& it, qc::Operation* op) {
-        if (op->getNtargets() != 0) {
-            // need to check all targets
-            bool onlyMeasurments = true;
-            for (const auto& target: op->getTargets()) {
-                if (target == idx) {
-                    continue;
-                }
-                if (dagIterators.at(target) == dag.at(target).rend()) {
-                    onlyMeasurments = false;
-                    break;
-                }
-                // recursive call at target with this operation as goal
-                removeFinalMeasurementsRecursive(dag, dagIterators, target, it);
-                // check if iteration of target qubit was successful
-                if (dagIterators.at(target) == dag.at(target).rend() || *dagIterators.at(target) != *it) {
-                    onlyMeasurments = false;
-                    break;
-                }
-            }
-            if (!onlyMeasurments) {
-                // end qubit
-                dagIterators.at(idx) = dag.at(idx).rend();
-            } else {
-                // set operation to identity so that it can be collected by the removeIdentities pass
-                op->setGate(qc::I);
-            }
-            return onlyMeasurments;
-        }
-        return false;
-    }
-
-    void CircuitOptimizer::removeFinalMeasurementsRecursive(DAG& dag, DAGReverseIterators& dagIterators, Qubit idx, const DAGReverseIterator& until) {
-        if (dagIterators.at(idx) == dag.at(idx).rend()) { //we reached the end
-            if (idx < static_cast<Qubit>(dag.size() - 1)) {
-                removeFinalMeasurementsRecursive(dag, dagIterators, idx + 1, dag.at(idx + 1).rend());
-            }
-            return;
-        }
-        // check if desired operation was reached
-        if (until != dag.at(idx).rend()) {
-            if (*dagIterators.at(idx) == *until) {
-                return;
-            }
-        }
-        auto& it = dagIterators.at(idx);
-        while (it != dag.at(idx).rend()) {
-            if (until != dag.at(idx).rend()) {
-                if (*dagIterators.at(idx) == *until) {
-                    break;
-                }
-            }
-            auto* op = (*it)->get();
-            if (op->getType() == Measure) {
-                const bool onlyMeasurment = removeFinalMeasurement(dag, dagIterators, idx, it, op);
-                if (onlyMeasurment) {
-                    for (const auto& target: op->getTargets()) {
-                        if (dagIterators.at(target) == dag.at(target).rend()) {
-                            break;
-                        }
-                        ++(dagIterators.at(target));
-                    }
-                }
-            } else if (op->getType() == Barrier || op->getType() == Snapshot || op->getType() == ShowProbabilities) {
-                for (const auto& target: op->getTargets()) {
-                    if (dagIterators.at(target) == dag.at(target).rend()) {
-                        break;
-                    }
-                    ++(dagIterators.at(target));
-                }
-            } else if (op->isCompoundOperation() && op->isNonUnitaryOperation()) {
-                // iterate over all gates of compound operation and upon success increase all corresponding iterators
-                auto* compOp          = dynamic_cast<qc::CompoundOperation*>(op);
-                bool  onlyMeasurement = true;
-                auto  cit             = compOp->rbegin();
-                while (cit != compOp->rend()) {
-                    auto* cop = (*cit).get();
-                    if (cop->getNtargets() > 0 && cop->getTargets()[0] != idx) {
-                        ++cit;
-                        continue;
-                    }
-                    onlyMeasurement = removeFinalMeasurement(dag, dagIterators, idx, it, cop);
-                    if (!onlyMeasurement) {
-                        break;
-                    }
-                    ++cit;
-                }
-                if (onlyMeasurement) {
-                    ++(dagIterators.at(idx));
-                }
-            } else {
-                // not a measurement, we are done
-                dagIterators.at(idx) = dag.at(idx).rend();
-                break;
-            }
-        }
-        if (dagIterators.at(idx) == dag.at(idx).rend() && idx < static_cast<Qubit>(dag.size() - 1)) {
-            removeFinalMeasurementsRecursive(dag, dagIterators, idx + 1, dag.at(idx + 1).rend());
-        }
-    }
-
-    void CircuitOptimizer::removeFinalMeasurements(QuantumComputation& qc) {
-        auto                dag = constructDAG(qc);
-        DAGReverseIterators dagIterators{dag.size()};
-        for (size_t q = 0; q < dag.size(); ++q) {
-            dagIterators.at(q) = (dag.at(q).rbegin());
-        }
-
-        removeFinalMeasurementsRecursive(dag, dagIterators, 0, dag.at(0).rend());
-
-        removeIdentities(qc);
-    }
-
-    void CircuitOptimizer::decomposeSWAP(QuantumComputation& qc, bool isDirectedArchitecture) {
-        //decompose SWAPS in three cnot and optionally in four H
-        auto it = qc.ops.begin();
-        while (it != qc.ops.end()) {
-            if ((*it)->isStandardOperation()) {
-                if ((*it)->getType() == qc::SWAP) {
-                    const auto targets = (*it)->getTargets();
-                    const auto nqubits = (*it)->getNqubits();
-                    it                 = qc.ops.erase(it);
-                    it                 = qc.ops.insert(it, std::make_unique<StandardOperation>(nqubits, Control{targets[0]}, targets[1], qc::X));
-                    if (isDirectedArchitecture) {
-                        it = qc.ops.insert(it, std::make_unique<StandardOperation>(nqubits, targets[0], qc::H));
-                        it = qc.ops.insert(it, std::make_unique<StandardOperation>(nqubits, targets[1], qc::H));
-                        it = qc.ops.insert(it, std::make_unique<StandardOperation>(nqubits, Control{targets[0]}, targets[1], qc::X));
-                        it = qc.ops.insert(it, std::make_unique<StandardOperation>(nqubits, targets[0], qc::H));
-                        it = qc.ops.insert(it, std::make_unique<StandardOperation>(nqubits, targets[1], qc::H));
-                    } else {
-                        it = qc.ops.insert(it, std::make_unique<StandardOperation>(nqubits, Control{targets[1]}, targets[0], qc::X));
-                    }
-                    it = qc.ops.insert(it, std::make_unique<StandardOperation>(nqubits, Control{targets[0]}, targets[1], qc::X));
-                } else {
-                    ++it;
-                }
-            } else if ((*it)->isCompoundOperation()) {
-                auto* compOp = dynamic_cast<qc::CompoundOperation*>((*it).get());
-                auto  cit    = compOp->begin();
-                while (cit != compOp->end()) {
-                    if ((*cit)->isStandardOperation() && (*cit)->getType() == qc::SWAP) {
-                        const auto targets = (*cit)->getTargets();
-                        const auto nqubits = compOp->getNqubits();
-                        cit                = compOp->erase(cit);
-                        cit                = compOp->insert<StandardOperation>(cit, nqubits, Control{targets[0]}, targets[1], qc::X);
-                        if (isDirectedArchitecture) {
-                            cit = compOp->insert<StandardOperation>(cit, nqubits, targets[0], qc::H);
-                            cit = compOp->insert<StandardOperation>(cit, nqubits, targets[1], qc::H);
-                            cit = compOp->insert<StandardOperation>(cit, nqubits, Control{targets[0]}, targets[1], qc::X);
-                            cit = compOp->insert<StandardOperation>(cit, nqubits, targets[0], qc::H);
-                            cit = compOp->insert<StandardOperation>(cit, nqubits, targets[1], qc::H);
-                        } else {
-                            cit = compOp->insert<StandardOperation>(cit, nqubits, Control{targets[1]}, targets[0], qc::X);
-                        }
-                        cit = compOp->insert<StandardOperation>(cit, nqubits, Control{targets[0]}, targets[1], qc::X);
-                    } else {
-                        ++cit;
-                    }
-                }
-                ++it;
-            } else {
-                ++it;
-            }
-        }
-    }
-
-    void CircuitOptimizer::decomposeTeleport([[maybe_unused]] QuantumComputation& qc) {
-    }
-
-    void CircuitOptimizer::eliminateResets(QuantumComputation& qc) {
-        //                        
-        // q_0:  H M|0> H M       q_0:  H M
-        //              -->        
-        // c: 2/       q_1:  H M
-        //            0            1                      
-        //                                  c: 2/
-        //                                             0          1
-        auto replacementMap = std::map<Qubit, Qubit>();
-        auto it             = qc.ops.begin();
-        while (it != qc.ops.end()) {
-            if ((*it)->getType() == qc::Reset) {
-                for (const auto& target: (*it)->getTargets()) {
-                    auto indexAddQubit = static_cast<Qubit>(qc.getNqubits());
-                    qc.addQubit(indexAddQubit, indexAddQubit, indexAddQubit);
-                    auto oldReset = replacementMap.find(target);
-                    if (oldReset != replacementMap.end()) {
-                        oldReset->second = indexAddQubit;
-                    } else {
-                        replacementMap.try_emplace(target, indexAddQubit);
-                    }
-                }
-                it = qc.erase(it);
-            } else if (!replacementMap.empty()) {
-                if ((*it)->isCompoundOperation()) {
-                    auto* compOp   = dynamic_cast<qc::CompoundOperation*>((*it).get());
-                    auto  compOpIt = compOp->begin();
-                    while (compOpIt != compOp->end()) {
-                        if ((*compOpIt)->getType() == qc::Reset) {
-                            for (const auto& compTarget: (*compOpIt)->getTargets()) {
-                                auto indexAddQubit = static_cast<Qubit>(qc.getNqubits());
-                                qc.addQubit(indexAddQubit, indexAddQubit, indexAddQubit);
-                                auto oldReset = replacementMap.find(compTarget);
-                                if (oldReset != replacementMap.end()) {
-                                    oldReset->second = indexAddQubit;
-                                } else {
-                                    replacementMap.try_emplace(compTarget, indexAddQubit);
-                                }
-                            }
-                            compOpIt = compOp->erase(compOpIt);
-                        } else {
-                            if ((*compOpIt)->isStandardOperation() || (*compOpIt)->isClassicControlledOperation()) {
-                                auto& targets  = (*compOpIt)->getTargets();
-                                auto& controls = (*compOpIt)->getControls();
-                                changeTargets(targets, replacementMap);
-                                changeControls(controls, replacementMap);
-                            } else if ((*compOpIt)->isNonUnitaryOperation()) {
-                                auto& targets = (*compOpIt)->getTargets();
-                                changeTargets(targets, replacementMap);
-                            }
-                            compOpIt++;
-                        }
-                    }
-                }
-                if ((*it)->isStandardOperation() || (*it)->isClassicControlledOperation()) {
-                    auto& targets  = (*it)->getTargets();
-                    auto& controls = (*it)->getControls();
-                    changeTargets(targets, replacementMap);
-                    changeControls(controls, replacementMap);
-                } else if ((*it)->isNonUnitaryOperation()) {
-                    auto& targets = (*it)->getTargets();
-                    changeTargets(targets, replacementMap);
-                }
-                it++;
-            } else {
-                it++;
-            }
-        }
-        // if anything has been modified the number of qubits of each gate has to be adjusted
-        if (!replacementMap.empty()) {
-            for (auto& op: qc.ops) {
-                op->setNqubits(qc.getNqubits());
-            }
-        }
-    }
-
-    void CircuitOptimizer::changeTargets(Targets& targets, const std::map<Qubit, Qubit>& replacementMap) {
-        for (auto& target: targets) {
-            auto newTargetIt = replacementMap.find(target);
-            if (newTargetIt != replacementMap.end()) {
-                target = newTargetIt->second;
-            }
-        }
-    }
-
-    void CircuitOptimizer::changeControls(Controls& controls, const std::map<Qubit, Qubit>& replacementMap) {
-        if (controls.empty() || replacementMap.empty()) {
-            return;
-        }
-
-        // iterate over the replacement map and see if any control matches
-        for (const auto& [from, to]: replacementMap) {
-            auto controlIt = controls.find(from);
-            if (controlIt != controls.end()) {
-                const auto controlType = controlIt->type;
-                controls.erase(controlIt);
-                controls.insert(Control{to, controlType});
-            }
-        }
-    }
-
-    void CircuitOptimizer::deferMeasurements(QuantumComputation& qc) {
-        //                                    
-        // q_0:  H M             q_0:  H M
-        //                          
-        // q_1:  X      -->     q_1:  X 
-        //                                       
-        //                          c: 2/
-        // c: 2/ = 1                              0
-        //            0 
-        std::unordered_map<Qubit, std::size_t> qubitsToAddMeasurements{};
-        auto                                   it = qc.begin();
-        while (it != qc.end()) {
-            if ((*it)->getType() == qc::Measure) {
-                auto*      measurement = dynamic_cast<qc::NonUnitaryOperation*>(it->get());
-                const auto targets     = measurement->getTargets();
-                const auto classics    = measurement->getClassics();
-
-                if (targets.size() != 1 && classics.size() != 1) {
-                    throw QFRException("Deferring measurements with more than 1 target is not yet supported. Try decomposing your measurements.");
-                }
-
-                // if this is the last operation, nothing has to be done
-                if (*it == qc.ops.back()) {
-                    break;
-                }
-
-                // remember q-> c for adding measurements later
-                qubitsToAddMeasurements[targets[0]] = classics[0];
-
-                // remove the measurement from the vector of operations
-                it = qc.erase(it);
-
-                // starting from the next operation after the measurement (if there is any)
-                auto opIt                  = it;
-                auto currentInsertionPoint = it;
-
-                // iterate over all subsequent operations
-                while (opIt != qc.end()) {
-                    const auto* operation = opIt->get();
-                    if (operation->isUnitary() || operation->getType() == qc::Barrier) {
-                        // if an operation does not act on the measured qubit, the insert location for potential operations has to be updated
-                        if (!operation->actsOn(targets.at(0))) {
-                            ++currentInsertionPoint;
-                        }
-                        ++opIt;
-                        continue;
-                    }
-
-                    if (operation->getType() == qc::Reset) {
-                        throw QFRException("Reset encountered in deferMeasurements routine. Please use the eliminateResets method before deferring measurements.");
-                    }
-
-                    if (operation->getType() == qc::Measure) {
-                        const auto* measurement2 = dynamic_cast<qc::NonUnitaryOperation*>((*opIt).get());
-                        const auto& targets2     = measurement2->getTargets();
-                        const auto& classics2    = measurement2->getClassics();
-
-                        // if this is the same measurement a breakpoint has been reached
-                        if (targets == targets2 && classics == classics2) {
-                            break;
-                        }
-
-                        ++currentInsertionPoint;
-                        ++opIt;
-                        continue;
-                    }
-
-                    if (operation->isClassicControlledOperation()) {
-                        auto*       classicOp       = dynamic_cast<qc::ClassicControlledOperation*>((*opIt).get());
-                        const auto& controlRegister = classicOp->getControlRegister();
-                        const auto& expectedValue   = classicOp->getExpectedValue();
-
-                        if (controlRegister.second != 1 && expectedValue <= 1) {
-                            throw QFRException("Classic-controlled operations targeted at more than one bit are currently not supported. Try decomposing the operation into individual contributions.");
-                        }
-
-                        // if this is not the classical bit that is measured, continue
-                        if (controlRegister.first == static_cast<Qubit>(classics.at(0))) {
-                            // get the underlying operation
-                            const auto* standardOp = dynamic_cast<qc::StandardOperation*>(classicOp->getOperation());
-
-                            // get all the necessary information for reconstructing the operation
-                            const auto nqubits = standardOp->getNqubits();
-                            const auto type    = standardOp->getType();
-
-                            const auto targs = standardOp->getTargets();
-                            for (const auto& target: targs) {
-                                if (target == targets[0]) {
-                                    throw qc::QFRException("Implicit reset operation in circuit detected. Measuring a qubit and then targeting the same qubit with a classic-controlled operation is not allowed at the moment.");
-                                }
-                            }
-
-                            // determine the appropriate control to add
-                            auto controls     = standardOp->getControls();
-                            auto controlQubit = targets.at(0);
-                            auto controlType  = (expectedValue == 1) ? Control::Type::Pos : Control::Type::Neg;
-                            controls.emplace(Control{controlQubit, controlType});
-
-                            const auto parameters = standardOp->getParameter();
-
-                            // remove the classic-controlled operation
-                            opIt = qc.erase(opIt);
-
-                            // insert the new operation (invalidated all pointer onwards)
-                            currentInsertionPoint = qc.insert(currentInsertionPoint,
-                                                              std::make_unique<qc::StandardOperation>(nqubits,
-                                                                                                      controls,
-                                                                                                      targs,
-                                                                                                      type,
-                                                                                                      parameters));
-
-                            // advance just after the currently inserted operation
-                            ++currentInsertionPoint;
-                            // the inner loop also has to restart from here due to the invalidation of the iterators
-                            opIt = currentInsertionPoint;
-                        } else {
-                            if (!operation->actsOn(targets[0])) {
-                                ++currentInsertionPoint;
-                            }
-                            ++opIt;
-                            continue;
-                        }
-                    }
-                }
-            }
-            ++it;
-        }
-        for (const auto& [qubit, clbit]: qubitsToAddMeasurements) {
-            qc.measure(qubit, clbit);
-        }
-    }
-
-    bool CircuitOptimizer::isDynamicCircuit(QuantumComputation& qc) {
-        Qubit highestPhysicalQubit = 0;
-        for (const auto& q: qc.initialLayout) {
-            if (q.first > highestPhysicalQubit) {
-                highestPhysicalQubit = q.first;
-            }
-        }
-
-        auto dag = DAG(highestPhysicalQubit + 1);
-
-        bool hasMeasurements = false;
-
-        for (auto& it: qc.ops) {
-            if (!it->isStandardOperation()) {
-                if (it->isNonUnitaryOperation()) {
-                    // whenever a reset operation is encountered the circuit has to be dynamic
-                    if (it->getType() == Reset) {
-                        return true;
-                    }
-
-                    // record whether the circuit contains measurements
-                    if (it->getType() == Measure) {
-                        hasMeasurements = true;
-                    }
-
-                    for (const auto& b: it->getTargets()) {
-                        dag.at(b).push_back(&it);
-                    }
-                } else if (it->isClassicControlledOperation()) {
-                    // whenever a classic-controlled operation is encountered the circuit has to be dynamic
-                    return true;
-                } else if (it->isCompoundOperation()) {
-                    auto* compOp = dynamic_cast<CompoundOperation*>(it.get());
-                    for (auto& op: *compOp) {
-                        if (op->getType() == Reset || op->isClassicControlledOperation()) {
-                            return true;
-                        }
-
-                        if (op->getType() == Measure) {
-                            hasMeasurements = true;
-                        }
-
-                        if (op->isNonUnitaryOperation()) {
-                            for (const auto& b: op->getTargets()) {
-                                dag.at(b).push_back(&op);
-                            }
-                        } else {
-                            addToDag(dag, &op);
-                        }
-                    }
-                }
-            } else {
-                addToDag(dag, &it);
-            }
-        }
-
-        if (!hasMeasurements) {
-            return false;
-        }
-
-        for (const auto& qubitDAG: dag) {
-            bool operation   = false;
-            bool measurement = false;
-            for (auto it = qubitDAG.rbegin(); it != qubitDAG.rend(); ++it) {
-                auto* op = *it;
-                // once a measurement is encountered the iteration for this qubit can stop
-                if (op->get()->getType() == qc::Measure) {
-                    measurement = true;
-                    break;
-                }
-
-                if (op->get()->isStandardOperation() || op->get()->isClassicControlledOperation() || op->get()->isCompoundOperation() || op->get()->getType() == Reset) {
-                    operation = true;
-                }
-            }
-            // there was a measurement and then a non-trivial operation, so the circuit is dynamic
-            if (measurement && operation) {
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    /// this method can be used to reorder the operations of a given quantum computation in order to get a canonical ordering
-    /// it uses iterative breadth-first search starting from the topmost qubit
-    void CircuitOptimizer::reorderOperations(QuantumComputation& qc) {
-        auto dag = constructDAG(qc);
-
-        // initialize iterators
-        DAGIterators dagIterators{dag.size()};
-        for (size_t q = 0; q < dag.size(); ++q) {
-            if (dag.at(q).empty()) {
-                // qubit is isdle
-                dagIterators.at(q) = dag.at(q).end();
-            } else {
-                // point to first operation
-                dagIterators.at(q) = dag.at(q).begin();
-            }
-        }
-
-        std::vector<std::unique_ptr<qc::Operation>> ops{};
-
-        // iterate over DAG in depth-first fashion starting from the top-most qubit
-        const auto msq  = dag.size() - 1;
-        bool       done = false;
-        while (!done) {
-            // assume that everything is done
-            done = true;
-
-            // iterate over qubits in reverse order
-            for (auto q = static_cast<std::make_signed_t<Qubit>>(msq); q >= 0; --q) {
-                // nothing to be done for this qubit
-                if (dagIterators.at(static_cast<std::size_t>(q)) == dag.at(static_cast<std::size_t>(q)).end()) {
-                    continue;
-                }
-                done = false;
-
-                // get the current operation on the qubit
-                auto& it = dagIterators.at(static_cast<std::size_t>(q));
-                auto& op = **it;
-
-                // warning for classically controlled operations
-                if (op->getType() == ClassicControlled) {
-                    std::cerr << "Caution! Reordering operations might not work if the circuit contains classically controlled operations" << std::endl;
-                }
-
-                if (op->getType() == Barrier || op->getType() == Snapshot || op->getType() == ShowProbabilities) {
-                    ++it;
-                    continue;
-                }
-
-                // check whether the gate can be scheduled, i.e. whether all qubits it acts on are at this operation
-                bool              executable = true;
-                std::vector<bool> actsOn(dag.size());
-                actsOn[static_cast<std::size_t>(q)] = true;
-                for (std::size_t i = 0; i < dag.size(); ++i) {
-                    // actually check in reverse order
-                    const auto qb = static_cast<std::make_signed_t<Qubit>>(dag.size() - 1 - i);
-                    if (qb != q && op->actsOn(static_cast<Qubit>(qb))) {
-                        actsOn[static_cast<std::size_t>(qb)] = true;
-
-                        assert(dagIterators.at(static_cast<std::size_t>(qb)) != dag.at(static_cast<std::size_t>(qb)).end());
-                        // check whether operation is executable for the currently considered qubit
-                        if (*dagIterators.at(static_cast<std::size_t>(qb)) != *it) {
-                            executable = false;
-                            break;
-                        }
-                    }
-                }
-
-                // continue, if this gate is not yet executable
-                if (!executable) {
-                    continue;
-                }
-
-                // gate is executable, move it to the new vector
-                ops.emplace_back(std::move(op));
-
-                // now increase all corresponding iterators
-                for (std::size_t i = 0; i < dag.size(); ++i) {
-                    if (actsOn[i]) {
-                        ++(dagIterators.at(i));
-                    }
-                }
-            }
-        }
-
-        // clear all the operations from the quantum circuit
-        qc.ops.clear();
-        // move all operations from the newly created vector to the original one
-        std::move(ops.begin(), ops.end(), std::back_inserter(qc.ops));
-    }
-
-    void CircuitOptimizer::printDAG(const DAG& dag) {
-        for (const auto& qubitDag: dag) {
-            std::cout << " - ";
-            for (const auto& op: qubitDag) {
-                std::cout << std::hex << (*op).get() << std::dec << "(" << toString((*op)->getType()) << ") - ";
-            }
-            std::cout << std::endl;
+          if (compOp->actsOn(static_cast<Qubit>(q))) {
+            ++(dagIterators.at(q));
+          }
+        }
+      }
+    } else if (op->isClassicControlledOperation()) {
+      // consider the operation that is classically controlled and proceed as
+      // above
+      auto* cop = dynamic_cast<ClassicControlledOperation*>(op)->getOperation();
+      const bool onlyDiagonalGates =
+          removeDiagonalGate(dag, dagIterators, idx, it, cop);
+      if (onlyDiagonalGates) {
+        for (const auto& control : cop->getControls()) {
+          ++(dagIterators.at(control.qubit));
+        }
+        for (const auto& target : cop->getTargets()) {
+          ++(dagIterators.at(target));
+        }
+      }
+    } else if (op->isNonUnitaryOperation()) {
+      // non-unitary operation is not diagonal
+      it = dag.at(idx).rend();
+    } else {
+      throw QFRException("Unexpected operation encountered");
+    }
+  }
+
+  // qubit is finished -> consider next qubit
+  if (dagIterators.at(idx) == dag.at(idx).rend() &&
+      idx < static_cast<Qubit>(dag.size() - 1)) {
+    removeDiagonalGatesBeforeMeasureRecursive(dag, dagIterators, idx + 1,
+                                              dag.at(idx + 1).rend());
+  }
+}
+
+void CircuitOptimizer::removeDiagonalGatesBeforeMeasure(
+    QuantumComputation& qc) {
+  auto dag = constructDAG(qc);
+
+  // initialize iterators
+  DAGReverseIterators dagIterators{dag.size()};
+  for (size_t q = 0; q < dag.size(); ++q) {
+    if (dag.at(q).empty() ||
+        dag.at(q).back()->get()->getType() != qc::Measure) {
+      // qubit is not measured and thus does not have to be considered
+      dagIterators.at(q) = dag.at(q).rend();
+    } else {
+      // point to operation before measurement
+      dagIterators.at(q) = ++(dag.at(q).rbegin());
+    }
+  }
+  // iterate over DAG in depth-first fashion
+  removeDiagonalGatesBeforeMeasureRecursive(dag, dagIterators, 0,
+                                            dag.at(0).rend());
+
+  // remove resulting identities from circuit
+  removeIdentities(qc);
+}
+
+bool CircuitOptimizer::removeFinalMeasurement(DAG& dag,
+                                              DAGReverseIterators& dagIterators,
+                                              Qubit idx, DAGReverseIterator& it,
+                                              qc::Operation* op) {
+  if (op->getNtargets() != 0) {
+    // need to check all targets
+    bool onlyMeasurments = true;
+    for (const auto& target : op->getTargets()) {
+      if (target == idx) {
+        continue;
+      }
+      if (dagIterators.at(target) == dag.at(target).rend()) {
+        onlyMeasurments = false;
+        break;
+      }
+      // recursive call at target with this operation as goal
+      removeFinalMeasurementsRecursive(dag, dagIterators, target, it);
+      // check if iteration of target qubit was successful
+      if (dagIterators.at(target) == dag.at(target).rend() ||
+          *dagIterators.at(target) != *it) {
+        onlyMeasurments = false;
+        break;
+      }
+    }
+    if (!onlyMeasurments) {
+      // end qubit
+      dagIterators.at(idx) = dag.at(idx).rend();
+    } else {
+      // set operation to identity so that it can be collected by the
+      // removeIdentities pass
+      op->setGate(qc::I);
+    }
+    return onlyMeasurments;
+  }
+  return false;
+}
+
+void CircuitOptimizer::removeFinalMeasurementsRecursive(
+    DAG& dag, DAGReverseIterators& dagIterators, Qubit idx,
+    const DAGReverseIterator& until) {
+  if (dagIterators.at(idx) == dag.at(idx).rend()) { // we reached the end
+    if (idx < static_cast<Qubit>(dag.size() - 1)) {
+      removeFinalMeasurementsRecursive(dag, dagIterators, idx + 1,
+                                       dag.at(idx + 1).rend());
+    }
+    return;
+  }
+  // check if desired operation was reached
+  if (until != dag.at(idx).rend()) {
+    if (*dagIterators.at(idx) == *until) {
+      return;
+    }
+  }
+  auto& it = dagIterators.at(idx);
+  while (it != dag.at(idx).rend()) {
+    if (until != dag.at(idx).rend()) {
+      if (*dagIterators.at(idx) == *until) {
+        break;
+      }
+    }
+    auto* op = (*it)->get();
+    if (op->getType() == Measure) {
+      const bool onlyMeasurment =
+          removeFinalMeasurement(dag, dagIterators, idx, it, op);
+      if (onlyMeasurment) {
+        for (const auto& target : op->getTargets()) {
+          if (dagIterators.at(target) == dag.at(target).rend()) {
+            break;
+          }
+          ++(dagIterators.at(target));
+        }
+      }
+    } else if (op->getType() == Barrier || op->getType() == Snapshot ||
+               op->getType() == ShowProbabilities) {
+      for (const auto& target : op->getTargets()) {
+        if (dagIterators.at(target) == dag.at(target).rend()) {
+          break;
+        }
+        ++(dagIterators.at(target));
+      }
+    } else if (op->isCompoundOperation() && op->isNonUnitaryOperation()) {
+      // iterate over all gates of compound operation and upon success increase
+      // all corresponding iterators
+      auto* compOp = dynamic_cast<qc::CompoundOperation*>(op);
+      bool onlyMeasurement = true;
+      auto cit = compOp->rbegin();
+      while (cit != compOp->rend()) {
+        auto* cop = (*cit).get();
+        if (cop->getNtargets() > 0 && cop->getTargets()[0] != idx) {
+          ++cit;
+          continue;
+        }
+        onlyMeasurement =
+            removeFinalMeasurement(dag, dagIterators, idx, it, cop);
+        if (!onlyMeasurement) {
+          break;
+        }
+        ++cit;
+      }
+      if (onlyMeasurement) {
+        ++(dagIterators.at(idx));
+      }
+    } else {
+      // not a measurement, we are done
+      dagIterators.at(idx) = dag.at(idx).rend();
+      break;
+    }
+  }
+  if (dagIterators.at(idx) == dag.at(idx).rend() &&
+      idx < static_cast<Qubit>(dag.size() - 1)) {
+    removeFinalMeasurementsRecursive(dag, dagIterators, idx + 1,
+                                     dag.at(idx + 1).rend());
+  }
+}
+
+void CircuitOptimizer::removeFinalMeasurements(QuantumComputation& qc) {
+  auto dag = constructDAG(qc);
+  DAGReverseIterators dagIterators{dag.size()};
+  for (size_t q = 0; q < dag.size(); ++q) {
+    dagIterators.at(q) = (dag.at(q).rbegin());
+  }
+
+  removeFinalMeasurementsRecursive(dag, dagIterators, 0, dag.at(0).rend());
+
+  removeIdentities(qc);
+}
+
+void CircuitOptimizer::decomposeSWAP(QuantumComputation& qc,
+                                     bool isDirectedArchitecture) {
+  // decompose SWAPS in three cnot and optionally in four H
+  auto it = qc.ops.begin();
+  while (it != qc.ops.end()) {
+    if ((*it)->isStandardOperation()) {
+      if ((*it)->getType() == qc::SWAP) {
+        const auto targets = (*it)->getTargets();
+        const auto nqubits = (*it)->getNqubits();
+        it = qc.ops.erase(it);
+        it = qc.ops.insert(
+            it, std::make_unique<StandardOperation>(
+                    nqubits, Control{targets[0]}, targets[1], qc::X));
+        if (isDirectedArchitecture) {
+          it = qc.ops.insert(it, std::make_unique<StandardOperation>(
+                                     nqubits, targets[0], qc::H));
+          it = qc.ops.insert(it, std::make_unique<StandardOperation>(
+                                     nqubits, targets[1], qc::H));
+          it = qc.ops.insert(
+              it, std::make_unique<StandardOperation>(
+                      nqubits, Control{targets[0]}, targets[1], qc::X));
+          it = qc.ops.insert(it, std::make_unique<StandardOperation>(
+                                     nqubits, targets[0], qc::H));
+          it = qc.ops.insert(it, std::make_unique<StandardOperation>(
+                                     nqubits, targets[1], qc::H));
+        } else {
+          it = qc.ops.insert(
+              it, std::make_unique<StandardOperation>(
+                      nqubits, Control{targets[1]}, targets[0], qc::X));
+        }
+        it = qc.ops.insert(
+            it, std::make_unique<StandardOperation>(
+                    nqubits, Control{targets[0]}, targets[1], qc::X));
+      } else {
+        ++it;
+      }
+    } else if ((*it)->isCompoundOperation()) {
+      auto* compOp = dynamic_cast<qc::CompoundOperation*>((*it).get());
+      auto cit = compOp->begin();
+      while (cit != compOp->end()) {
+        if ((*cit)->isStandardOperation() && (*cit)->getType() == qc::SWAP) {
+          const auto targets = (*cit)->getTargets();
+          const auto nqubits = compOp->getNqubits();
+          cit = compOp->erase(cit);
+          cit = compOp->insert<StandardOperation>(
+              cit, nqubits, Control{targets[0]}, targets[1], qc::X);
+          if (isDirectedArchitecture) {
+            cit = compOp->insert<StandardOperation>(cit, nqubits, targets[0],
+                                                    qc::H);
+            cit = compOp->insert<StandardOperation>(cit, nqubits, targets[1],
+                                                    qc::H);
+            cit = compOp->insert<StandardOperation>(
+                cit, nqubits, Control{targets[0]}, targets[1], qc::X);
+            cit = compOp->insert<StandardOperation>(cit, nqubits, targets[0],
+                                                    qc::H);
+            cit = compOp->insert<StandardOperation>(cit, nqubits, targets[1],
+                                                    qc::H);
+          } else {
+            cit = compOp->insert<StandardOperation>(
+                cit, nqubits, Control{targets[1]}, targets[0], qc::X);
+          }
+          cit = compOp->insert<StandardOperation>(
+              cit, nqubits, Control{targets[0]}, targets[1], qc::X);
+        } else {
+          ++cit;
         }
-    }
-    void CircuitOptimizer::printDAG(const DAG& dag, const DAGIterators& iterators) {
-        for (std::size_t i = 0; i < dag.size(); ++i) {
-            std::cout << " - ";
-            for (auto it = iterators.at(i); it != dag.at(i).end(); ++it) {
-                std::cout << std::hex << (**it).get() << std::dec << "(" << toString((**it)->getType()) << ") - ";
-            }
-            std::cout << std::endl;
+      }
+      ++it;
+    } else {
+      ++it;
+    }
+  }
+}
+
+void CircuitOptimizer::decomposeTeleport(
+    [[maybe_unused]] QuantumComputation& qc) {}
+
+void CircuitOptimizer::eliminateResets(QuantumComputation& qc) {
+  //                        
+  // q_0:  H M|0> H M       q_0:  H M
+  //              -->        
+  // c: 2/       q_1:  H M
+  //            0            1                      
+  //                                  c: 2/
+  //                                             0          1
+  auto replacementMap = std::map<Qubit, Qubit>();
+  auto it = qc.ops.begin();
+  while (it != qc.ops.end()) {
+    if ((*it)->getType() == qc::Reset) {
+      for (const auto& target : (*it)->getTargets()) {
+        auto indexAddQubit = static_cast<Qubit>(qc.getNqubits());
+        qc.addQubit(indexAddQubit, indexAddQubit, indexAddQubit);
+        auto oldReset = replacementMap.find(target);
+        if (oldReset != replacementMap.end()) {
+          oldReset->second = indexAddQubit;
+        } else {
+          replacementMap.try_emplace(target, indexAddQubit);
         }
-    }
-
-    void CircuitOptimizer::flattenOperations(QuantumComputation& qc) {
-        auto it = qc.begin();
-        while (it != qc.end()) {
-            if ((*it)->isCompoundOperation()) {
-                it = flattenCompoundOperation(qc.ops, it);
-            } else {
-                ++it;
-            }
+      }
+      it = qc.erase(it);
+    } else if (!replacementMap.empty()) {
+      if ((*it)->isCompoundOperation()) {
+        auto* compOp = dynamic_cast<qc::CompoundOperation*>((*it).get());
+        auto compOpIt = compOp->begin();
+        while (compOpIt != compOp->end()) {
+          if ((*compOpIt)->getType() == qc::Reset) {
+            for (const auto& compTarget : (*compOpIt)->getTargets()) {
+              auto indexAddQubit = static_cast<Qubit>(qc.getNqubits());
+              qc.addQubit(indexAddQubit, indexAddQubit, indexAddQubit);
+              auto oldReset = replacementMap.find(compTarget);
+              if (oldReset != replacementMap.end()) {
+                oldReset->second = indexAddQubit;
+              } else {
+                replacementMap.try_emplace(compTarget, indexAddQubit);
+              }
+            }
+            compOpIt = compOp->erase(compOpIt);
+          } else {
+            if ((*compOpIt)->isStandardOperation() ||
+                (*compOpIt)->isClassicControlledOperation()) {
+              auto& targets = (*compOpIt)->getTargets();
+              auto& controls = (*compOpIt)->getControls();
+              changeTargets(targets, replacementMap);
+              changeControls(controls, replacementMap);
+            } else if ((*compOpIt)->isNonUnitaryOperation()) {
+              auto& targets = (*compOpIt)->getTargets();
+              changeTargets(targets, replacementMap);
+            }
+            compOpIt++;
+          }
+        }
+      }
+      if ((*it)->isStandardOperation() ||
+          (*it)->isClassicControlledOperation()) {
+        auto& targets = (*it)->getTargets();
+        auto& controls = (*it)->getControls();
+        changeTargets(targets, replacementMap);
+        changeControls(controls, replacementMap);
+      } else if ((*it)->isNonUnitaryOperation()) {
+        auto& targets = (*it)->getTargets();
+        changeTargets(targets, replacementMap);
+      }
+      it++;
+    } else {
+      it++;
+    }
+  }
+  // if anything has been modified the number of qubits of each gate has to be
+  // adjusted
+  if (!replacementMap.empty()) {
+    for (auto& op : qc.ops) {
+      op->setNqubits(qc.getNqubits());
+    }
+  }
+}
+
+void CircuitOptimizer::changeTargets(
+    Targets& targets, const std::map<Qubit, Qubit>& replacementMap) {
+  for (auto& target : targets) {
+    auto newTargetIt = replacementMap.find(target);
+    if (newTargetIt != replacementMap.end()) {
+      target = newTargetIt->second;
+    }
+  }
+}
+
+void CircuitOptimizer::changeControls(
+    Controls& controls, const std::map<Qubit, Qubit>& replacementMap) {
+  if (controls.empty() || replacementMap.empty()) {
+    return;
+  }
+
+  // iterate over the replacement map and see if any control matches
+  for (const auto& [from, to] : replacementMap) {
+    auto controlIt = controls.find(from);
+    if (controlIt != controls.end()) {
+      const auto controlType = controlIt->type;
+      controls.erase(controlIt);
+      controls.insert(Control{to, controlType});
+    }
+  }
+}
+
+void CircuitOptimizer::deferMeasurements(QuantumComputation& qc) {
+  //                                    
+  // q_0:  H M             q_0:  H M
+  //                          
+  // q_1:  X      -->     q_1:  X 
+  //                                       
+  //                          c: 2/
+  // c: 2/ = 1                              0
+  //            0 
+  std::unordered_map<Qubit, std::size_t> qubitsToAddMeasurements{};
+  auto it = qc.begin();
+  while (it != qc.end()) {
+    if ((*it)->getType() == qc::Measure) {
+      auto* measurement = dynamic_cast<qc::NonUnitaryOperation*>(it->get());
+      const auto targets = measurement->getTargets();
+      const auto classics = measurement->getClassics();
+
+      if (targets.size() != 1 && classics.size() != 1) {
+        throw QFRException(
+            "Deferring measurements with more than 1 target is not yet "
+            "supported. Try decomposing your measurements.");
+      }
+
+      // if this is the last operation, nothing has to be done
+      if (*it == qc.ops.back()) {
+        break;
+      }
+
+      // remember q-> c for adding measurements later
+      qubitsToAddMeasurements[targets[0]] = classics[0];
+
+      // remove the measurement from the vector of operations
+      it = qc.erase(it);
+
+      // starting from the next operation after the measurement (if there is
+      // any)
+      auto opIt = it;
+      auto currentInsertionPoint = it;
+
+      // iterate over all subsequent operations
+      while (opIt != qc.end()) {
+        const auto* operation = opIt->get();
+        if (operation->isUnitary() || operation->getType() == qc::Barrier) {
+          // if an operation does not act on the measured qubit, the insert
+          // location for potential operations has to be updated
+          if (!operation->actsOn(targets.at(0))) {
+            ++currentInsertionPoint;
+          }
+          ++opIt;
+          continue;
+        }
+
+        if (operation->getType() == qc::Reset) {
+          throw QFRException(
+              "Reset encountered in deferMeasurements routine. Please use the "
+              "eliminateResets method before deferring measurements.");
+        }
+
+        if (operation->getType() == qc::Measure) {
+          const auto* measurement2 =
+              dynamic_cast<qc::NonUnitaryOperation*>((*opIt).get());
+          const auto& targets2 = measurement2->getTargets();
+          const auto& classics2 = measurement2->getClassics();
+
+          // if this is the same measurement a breakpoint has been reached
+          if (targets == targets2 && classics == classics2) {
+            break;
+          }
+
+          ++currentInsertionPoint;
+          ++opIt;
+          continue;
+        }
+
+        if (operation->isClassicControlledOperation()) {
+          auto* classicOp =
+              dynamic_cast<qc::ClassicControlledOperation*>((*opIt).get());
+          const auto& controlRegister = classicOp->getControlRegister();
+          const auto& expectedValue = classicOp->getExpectedValue();
+
+          if (controlRegister.second != 1 && expectedValue <= 1) {
+            throw QFRException(
+                "Classic-controlled operations targeted at more than one bit "
+                "are currently not supported. Try decomposing the operation "
+                "into individual contributions.");
+          }
+
+          // if this is not the classical bit that is measured, continue
+          if (controlRegister.first == static_cast<Qubit>(classics.at(0))) {
+            // get the underlying operation
+            const auto* standardOp =
+                dynamic_cast<qc::StandardOperation*>(classicOp->getOperation());
+
+            // get all the necessary information for reconstructing the
+            // operation
+            const auto nqubits = standardOp->getNqubits();
+            const auto type = standardOp->getType();
+
+            const auto targs = standardOp->getTargets();
+            for (const auto& target : targs) {
+              if (target == targets[0]) {
+                throw qc::QFRException(
+                    "Implicit reset operation in circuit detected. Measuring a "
+                    "qubit and then targeting the same qubit with a "
+                    "classic-controlled operation is not allowed at the "
+                    "moment.");
+              }
+            }
+
+            // determine the appropriate control to add
+            auto controls = standardOp->getControls();
+            auto controlQubit = targets.at(0);
+            auto controlType =
+                (expectedValue == 1) ? Control::Type::Pos : Control::Type::Neg;
+            controls.emplace(Control{controlQubit, controlType});
+
+            const auto parameters = standardOp->getParameter();
+
+            // remove the classic-controlled operation
+            opIt = qc.erase(opIt);
+
+            // insert the new operation (invalidated all pointer onwards)
+            currentInsertionPoint =
+                qc.insert(currentInsertionPoint,
+                          std::make_unique<qc::StandardOperation>(
+                              nqubits, controls, targs, type, parameters));
+
+            // advance just after the currently inserted operation
+            ++currentInsertionPoint;
+            // the inner loop also has to restart from here due to the
+            // invalidation of the iterators
+            opIt = currentInsertionPoint;
+          } else {
+            if (!operation->actsOn(targets[0])) {
+              ++currentInsertionPoint;
+            }
+            ++opIt;
+            continue;
+          }
+        }
+      }
+    }
+    ++it;
+  }
+  for (const auto& [qubit, clbit] : qubitsToAddMeasurements) {
+    qc.measure(qubit, clbit);
+  }
+}
+
+bool CircuitOptimizer::isDynamicCircuit(QuantumComputation& qc) {
+  Qubit highestPhysicalQubit = 0;
+  for (const auto& q : qc.initialLayout) {
+    if (q.first > highestPhysicalQubit) {
+      highestPhysicalQubit = q.first;
+    }
+  }
+
+  auto dag = DAG(highestPhysicalQubit + 1);
+
+  bool hasMeasurements = false;
+
+  for (auto& it : qc.ops) {
+    if (!it->isStandardOperation()) {
+      if (it->isNonUnitaryOperation()) {
+        // whenever a reset operation is encountered the circuit has to be
+        // dynamic
+        if (it->getType() == Reset) {
+          return true;
+        }
+
+        // record whether the circuit contains measurements
+        if (it->getType() == Measure) {
+          hasMeasurements = true;
+        }
+
+        for (const auto& b : it->getTargets()) {
+          dag.at(b).push_back(&it);
+        }
+      } else if (it->isClassicControlledOperation()) {
+        // whenever a classic-controlled operation is encountered the circuit
+        // has to be dynamic
+        return true;
+      } else if (it->isCompoundOperation()) {
+        auto* compOp = dynamic_cast<CompoundOperation*>(it.get());
+        for (auto& op : *compOp) {
+          if (op->getType() == Reset || op->isClassicControlledOperation()) {
+            return true;
+          }
+
+          if (op->getType() == Measure) {
+            hasMeasurements = true;
+          }
+
+          if (op->isNonUnitaryOperation()) {
+            for (const auto& b : op->getTargets()) {
+              dag.at(b).push_back(&op);
+            }
+          } else {
+            addToDag(dag, &op);
+          }
+        }
+      }
+    } else {
+      addToDag(dag, &it);
+    }
+  }
+
+  if (!hasMeasurements) {
+    return false;
+  }
+
+  for (const auto& qubitDAG : dag) {
+    bool operation = false;
+    bool measurement = false;
+    for (auto it = qubitDAG.rbegin(); it != qubitDAG.rend(); ++it) {
+      auto* op = *it;
+      // once a measurement is encountered the iteration for this qubit can stop
+      if (op->get()->getType() == qc::Measure) {
+        measurement = true;
+        break;
+      }
+
+      if (op->get()->isStandardOperation() ||
+          op->get()->isClassicControlledOperation() ||
+          op->get()->isCompoundOperation() || op->get()->getType() == Reset) {
+        operation = true;
+      }
+    }
+    // there was a measurement and then a non-trivial operation, so the circuit
+    // is dynamic
+    if (measurement && operation) {
+      return true;
+    }
+  }
+
+  return false;
+}
+
+/// this method can be used to reorder the operations of a given quantum
+/// computation in order to get a canonical ordering it uses iterative
+/// breadth-first search starting from the topmost qubit
+void CircuitOptimizer::reorderOperations(QuantumComputation& qc) {
+  auto dag = constructDAG(qc);
+
+  // initialize iterators
+  DAGIterators dagIterators{dag.size()};
+  for (size_t q = 0; q < dag.size(); ++q) {
+    if (dag.at(q).empty()) {
+      // qubit is isdle
+      dagIterators.at(q) = dag.at(q).end();
+    } else {
+      // point to first operation
+      dagIterators.at(q) = dag.at(q).begin();
+    }
+  }
+
+  std::vector<std::unique_ptr<qc::Operation>> ops{};
+
+  // iterate over DAG in depth-first fashion starting from the top-most qubit
+  const auto msq = dag.size() - 1;
+  bool done = false;
+  while (!done) {
+    // assume that everything is done
+    done = true;
+
+    // iterate over qubits in reverse order
+    for (auto q = static_cast<std::make_signed_t<Qubit>>(msq); q >= 0; --q) {
+      // nothing to be done for this qubit
+      if (dagIterators.at(static_cast<std::size_t>(q)) ==
+          dag.at(static_cast<std::size_t>(q)).end()) {
+        continue;
+      }
+      done = false;
+
+      // get the current operation on the qubit
+      auto& it = dagIterators.at(static_cast<std::size_t>(q));
+      auto& op = **it;
+
+      // warning for classically controlled operations
+      if (op->getType() == ClassicControlled) {
+        std::cerr << "Caution! Reordering operations might not work if the "
+                     "circuit contains classically controlled operations"
+                  << std::endl;
+      }
+
+      if (op->getType() == Barrier || op->getType() == Snapshot ||
+          op->getType() == ShowProbabilities) {
+        ++it;
+        continue;
+      }
+
+      // check whether the gate can be scheduled, i.e. whether all qubits it
+      // acts on are at this operation
+      bool executable = true;
+      std::vector<bool> actsOn(dag.size());
+      actsOn[static_cast<std::size_t>(q)] = true;
+      for (std::size_t i = 0; i < dag.size(); ++i) {
+        // actually check in reverse order
+        const auto qb =
+            static_cast<std::make_signed_t<Qubit>>(dag.size() - 1 - i);
+        if (qb != q && op->actsOn(static_cast<Qubit>(qb))) {
+          actsOn[static_cast<std::size_t>(qb)] = true;
+
+          assert(dagIterators.at(static_cast<std::size_t>(qb)) !=
+                 dag.at(static_cast<std::size_t>(qb)).end());
+          // check whether operation is executable for the currently considered
+          // qubit
+          if (*dagIterators.at(static_cast<std::size_t>(qb)) != *it) {
+            executable = false;
+            break;
+          }
+        }
+      }
+
+      // continue, if this gate is not yet executable
+      if (!executable) {
+        continue;
+      }
+
+      // gate is executable, move it to the new vector
+      ops.emplace_back(std::move(op));
+
+      // now increase all corresponding iterators
+      for (std::size_t i = 0; i < dag.size(); ++i) {
+        if (actsOn[i]) {
+          ++(dagIterators.at(i));
+        }
+      }
+    }
+  }
+
+  // clear all the operations from the quantum circuit
+  qc.ops.clear();
+  // move all operations from the newly created vector to the original one
+  std::move(ops.begin(), ops.end(), std::back_inserter(qc.ops));
+}
+
+void CircuitOptimizer::printDAG(const DAG& dag) {
+  for (const auto& qubitDag : dag) {
+    std::cout << " - ";
+    for (const auto& op : qubitDag) {
+      std::cout << std::hex << (*op).get() << std::dec << "("
+                << toString((*op)->getType()) << ") - ";
+    }
+    std::cout << std::endl;
+  }
+}
+void CircuitOptimizer::printDAG(const DAG& dag, const DAGIterators& iterators) {
+  for (std::size_t i = 0; i < dag.size(); ++i) {
+    std::cout << " - ";
+    for (auto it = iterators.at(i); it != dag.at(i).end(); ++it) {
+      std::cout << std::hex << (**it).get() << std::dec << "("
+                << toString((**it)->getType()) << ") - ";
+    }
+    std::cout << std::endl;
+  }
+}
+
+void CircuitOptimizer::flattenOperations(QuantumComputation& qc) {
+  auto it = qc.begin();
+  while (it != qc.end()) {
+    if ((*it)->isCompoundOperation()) {
+      it = flattenCompoundOperation(qc.ops, it);
+    } else {
+      ++it;
+    }
+  }
+}
+
+CircuitOptimizer::Iterator CircuitOptimizer::flattenCompoundOperation(
+    std::vector<std::unique_ptr<Operation>>& ops,
+    CircuitOptimizer::Iterator it) {
+  assert((*it)->isCompoundOperation());
+  auto& op = dynamic_cast<qc::CompoundOperation&>(**it);
+  auto opIt = op.begin();
+  while (opIt != op.end()) {
+    if ((*opIt)->isCompoundOperation()) {
+      // recursively flatten compound operations
+      opIt = flattenCompoundOperation(op.getOps(), opIt);
+      --opIt;
+    } else {
+      // move the operation from the compound operation in front of the compound
+      // operation in the flattened container. `it` then points to the newly
+      // inserted element
+      it = ops.insert(it, std::move(*opIt));
+      // advance the operation iterator to point past the now moved-from element
+      // in the compound operation
+      ++opIt;
+      // advance the general iterator to again point to the compound operation
+      ++it;
+    }
+  }
+  // whenever all the operations have been processed, `it` points to the
+  // compound operation and `opIt` to `op.end()` the compound operation can now
+  // be deleted safely
+  return ops.erase(it);
+}
+
+void CircuitOptimizer::cancelCNOTs(QuantumComputation& qc) {
+  Qubit highestPhysicalQubit = 0;
+  for (const auto& q : qc.initialLayout) {
+    if (q.first > highestPhysicalQubit) {
+      highestPhysicalQubit = q.first;
+    }
+  }
+
+  auto dag = DAG(highestPhysicalQubit + 1U);
+
+  for (auto& it : qc.ops) {
+    if (!it->isStandardOperation()) {
+      addNonStandardOperationToDag(dag, &it);
+      continue;
+    }
+
+    // check whether the operation is a CNOT or SWAP gate
+    const auto isCNOT = (it->getType() == X && it->getNcontrols() == 1U &&
+                         it->getControls().begin()->type == Control::Type::Pos);
+    const auto isSWAP = (it->getType() == SWAP && it->getNcontrols() == 0U);
+
+    if (!isCNOT && !isSWAP) {
+      addToDag(dag, &it);
+      continue;
+    }
+
+    const Qubit q0 = it->getTargets().at(0);
+    const Qubit q1 =
+        isSWAP ? it->getTargets().at(1) : it->getControls().begin()->qubit;
+
+    // first operation
+    if (dag.at(q0).empty() || dag.at(q1).empty()) {
+      addToDag(dag, &it);
+      continue;
+    }
+
+    auto* op0 = dag.at(q0).back()->get();
+    auto* op1 = dag.at(q1).back()->get();
+
+    // check whether it's the same operation at both qubits
+    if (op0 != op1) {
+      addToDag(dag, &it);
+      continue;
+    }
+
+    // check whether the operation is a CNOT or SWAP gate
+    const auto prevOpIsCNOT =
+        (op0->getType() == X && op0->getNcontrols() == 1U &&
+         op0->getControls().begin()->type == Control::Type::Pos);
+    const auto prevOpIsSWAP =
+        (op0->getType() == SWAP && op0->getNcontrols() == 0U);
+
+    if (!prevOpIsCNOT && !prevOpIsSWAP) {
+      addToDag(dag, &it);
+      continue;
+    }
+
+    const Qubit prevQ0 = op0->getTargets().at(0);
+    const Qubit prevQ1 = prevOpIsSWAP ? op0->getTargets().at(1)
+                                      : op0->getControls().begin()->qubit;
+
+    if (isCNOT && prevOpIsCNOT) {
+      // two identical CNOT gates cancel each other
+      if (q0 == prevQ0 && q1 == prevQ1) {
+        dag.at(q0).pop_back();
+        dag.at(q1).pop_back();
+        op0->setGate(I);
+        op0->setControls({});
+        it->setGate(I);
+        it->setControls({});
+      } else {
+        // two CNOTs with alternating controls and targets
+        // check whether there is a third one which would make this a SWAP gate
+
+        auto prevPrevOp0It = ++(dag.at(q0).rbegin());
+        auto prevPrevOp1It = ++(dag.at(q1).rbegin());
+        // check whether there is another operation
+        if (prevPrevOp0It == dag.at(q0).rend() ||
+            prevPrevOp1It == dag.at(q1).rend()) {
+          addToDag(dag, &it);
+          continue;
+        }
+
+        auto* prevPrevOp0 = (*prevPrevOp0It)->get();
+        auto* prevPrevOp1 = (*prevPrevOp1It)->get();
+
+        if (prevPrevOp0 != prevPrevOp1) {
+          addToDag(dag, &it);
+          continue;
+        }
+
+        // check whether the operation is a CNOT
+        const auto prevPrevOpIsCNOT =
+            (prevPrevOp0->getType() == X && prevPrevOp0->getNcontrols() == 1U &&
+             prevPrevOp0->getControls().begin()->type == Control::Type::Pos);
+
+        if (!prevPrevOpIsCNOT) {
+          addToDag(dag, &it);
+          continue;
+        }
+
+        const Qubit prevPrevQ0 = prevPrevOp0->getTargets().at(0);
+        const Qubit prevPrevQ1 = prevPrevOp0->getControls().begin()->qubit;
+
+        if (q0 == prevPrevQ0 && q1 == prevPrevQ1) {
+          // SWAP gate identified
+          prevPrevOp0->setGate(SWAP);
+          prevPrevOp0->setControls({});
+          if (prevQ0 > prevQ1) {
+            prevPrevOp0->setTargets({prevQ1, prevQ0});
+          } else {
+            prevPrevOp0->setTargets({prevQ0, prevQ1});
+          }
+          op0->setGate(I);
+          op0->setControls({});
+          it->setGate(I);
+          it->setControls({});
+          dag.at(q0).pop_back();
+          dag.at(q1).pop_back();
+        } else {
+          addToDag(dag, &it);
+          continue;
         }
+      }
+      continue;
     }
 
-    CircuitOptimizer::Iterator CircuitOptimizer::flattenCompoundOperation(std::vector<std::unique_ptr<Operation>>& ops, CircuitOptimizer::Iterator it) {
-        assert((*it)->isCompoundOperation());
-        auto& op   = dynamic_cast<qc::CompoundOperation&>(**it);
-        auto  opIt = op.begin();
-        while (opIt != op.end()) {
-            if ((*opIt)->isCompoundOperation()) {
-                // recursively flatten compound operations
-                opIt = flattenCompoundOperation(op.getOps(), opIt);
-                --opIt;
-            } else {
-                // move the operation from the compound operation in front of the compound operation in the flattened container.
-                // `it` then points to the newly inserted element
-                it = ops.insert(it, std::move(*opIt));
-                // advance the operation iterator to point past the now moved-from element in the compound operation
-                ++opIt;
-                // advance the general iterator to again point to the compound operation
-                ++it;
-            }
-        }
-        // whenever all the operations have been processed, `it` points to the compound operation and `opIt` to `op.end()`
-        // the compound operation can now be deleted safely
-        return ops.erase(it);
+    if (isSWAP && prevOpIsSWAP) {
+      // two identical SWAP gates cancel each other
+      if (std::set{q0, q1} == std::set{prevQ0, prevQ1}) {
+        dag.at(q0).pop_back();
+        dag.at(q1).pop_back();
+        op0->setGate(I);
+        op0->setControls({});
+        it->setGate(I);
+        it->setControls({});
+      } else {
+        addToDag(dag, &it);
+      }
+      continue;
+    }
+
+    if (isCNOT && prevOpIsSWAP) {
+      // SWAP followed by a CNOT is equivalent to two CNOTs
+      op0->setGate(X);
+      op0->setControls({Control{q1}});
+      op0->setTargets({q0});
+      it->setControls({Control{q0}});
+      it->setTargets({q1});
+      addToDag(dag, &it);
+      continue;
+    }
+
+    if (isSWAP && prevOpIsCNOT) {
+      // CNOT followed by a SWAP is equivalent to two CNOTs
+      op0->setControls({Control{prevQ0}});
+      op0->setTargets({prevQ1});
+      it->setGate(X);
+      it->setControls({Control{prevQ1}});
+      it->setTargets({prevQ0});
+      addToDag(dag, &it);
+      continue;
     }
+  }
 
-    void CircuitOptimizer::cancelCNOTs(QuantumComputation& qc) {
-        Qubit highestPhysicalQubit = 0;
-        for (const auto& q: qc.initialLayout) {
-            if (q.first > highestPhysicalQubit) {
-                highestPhysicalQubit = q.first;
-            }
-        }
-
-        auto dag = DAG(highestPhysicalQubit + 1U);
-
-        for (auto& it: qc.ops) {
-            if (!it->isStandardOperation()) {
-                addNonStandardOperationToDag(dag, &it);
-                continue;
-            }
-
-            // check whether the operation is a CNOT or SWAP gate
-            const auto isCNOT = (it->getType() == X && it->getNcontrols() == 1U && it->getControls().begin()->type == Control::Type::Pos);
-            const auto isSWAP = (it->getType() == SWAP && it->getNcontrols() == 0U);
-
-            if (!isCNOT && !isSWAP) {
-                addToDag(dag, &it);
-                continue;
-            }
-
-            const Qubit q0 = it->getTargets().at(0);
-            const Qubit q1 = isSWAP ? it->getTargets().at(1) : it->getControls().begin()->qubit;
-
-            // first operation
-            if (dag.at(q0).empty() || dag.at(q1).empty()) {
-                addToDag(dag, &it);
-                continue;
-            }
-
-            auto* op0 = dag.at(q0).back()->get();
-            auto* op1 = dag.at(q1).back()->get();
-
-            // check whether it's the same operation at both qubits
-            if (op0 != op1) {
-                addToDag(dag, &it);
-                continue;
-            }
-
-            // check whether the operation is a CNOT or SWAP gate
-            const auto prevOpIsCNOT = (op0->getType() == X && op0->getNcontrols() == 1U && op0->getControls().begin()->type == Control::Type::Pos);
-            const auto prevOpIsSWAP = (op0->getType() == SWAP && op0->getNcontrols() == 0U);
-
-            if (!prevOpIsCNOT && !prevOpIsSWAP) {
-                addToDag(dag, &it);
-                continue;
-            }
-
-            const Qubit prevQ0 = op0->getTargets().at(0);
-            const Qubit prevQ1 = prevOpIsSWAP ? op0->getTargets().at(1) : op0->getControls().begin()->qubit;
-
-            if (isCNOT && prevOpIsCNOT) {
-                // two identical CNOT gates cancel each other
-                if (q0 == prevQ0 && q1 == prevQ1) {
-                    dag.at(q0).pop_back();
-                    dag.at(q1).pop_back();
-                    op0->setGate(I);
-                    op0->setControls({});
-                    it->setGate(I);
-                    it->setControls({});
-                } else {
-                    // two CNOTs with alternating controls and targets
-                    // check whether there is a third one which would make this a SWAP gate
-
-                    auto prevPrevOp0It = ++(dag.at(q0).rbegin());
-                    auto prevPrevOp1It = ++(dag.at(q1).rbegin());
-                    // check whether there is another operation
-                    if (prevPrevOp0It == dag.at(q0).rend() || prevPrevOp1It == dag.at(q1).rend()) {
-                        addToDag(dag, &it);
-                        continue;
-                    }
-
-                    auto* prevPrevOp0 = (*prevPrevOp0It)->get();
-                    auto* prevPrevOp1 = (*prevPrevOp1It)->get();
-
-                    if (prevPrevOp0 != prevPrevOp1) {
-                        addToDag(dag, &it);
-                        continue;
-                    }
-
-                    // check whether the operation is a CNOT
-                    const auto prevPrevOpIsCNOT = (prevPrevOp0->getType() == X && prevPrevOp0->getNcontrols() == 1U && prevPrevOp0->getControls().begin()->type == Control::Type::Pos);
-
-                    if (!prevPrevOpIsCNOT) {
-                        addToDag(dag, &it);
-                        continue;
-                    }
-
-                    const Qubit prevPrevQ0 = prevPrevOp0->getTargets().at(0);
-                    const Qubit prevPrevQ1 = prevPrevOp0->getControls().begin()->qubit;
-
-                    if (q0 == prevPrevQ0 && q1 == prevPrevQ1) {
-                        // SWAP gate identified
-                        prevPrevOp0->setGate(SWAP);
-                        prevPrevOp0->setControls({});
-                        if (prevQ0 > prevQ1) {
-                            prevPrevOp0->setTargets({prevQ1, prevQ0});
-                        } else {
-                            prevPrevOp0->setTargets({prevQ0, prevQ1});
-                        }
-                        op0->setGate(I);
-                        op0->setControls({});
-                        it->setGate(I);
-                        it->setControls({});
-                        dag.at(q0).pop_back();
-                        dag.at(q1).pop_back();
-                    } else {
-                        addToDag(dag, &it);
-                        continue;
-                    }
-                }
-                continue;
-            }
-
-            if (isSWAP && prevOpIsSWAP) {
-                // two identical SWAP gates cancel each other
-                if (std::set{q0, q1} == std::set{prevQ0, prevQ1}) {
-                    dag.at(q0).pop_back();
-                    dag.at(q1).pop_back();
-                    op0->setGate(I);
-                    op0->setControls({});
-                    it->setGate(I);
-                    it->setControls({});
-                } else {
-                    addToDag(dag, &it);
-                }
-                continue;
-            }
-
-            if (isCNOT && prevOpIsSWAP) {
-                // SWAP followed by a CNOT is equivalent to two CNOTs
-                op0->setGate(X);
-                op0->setControls({Control{q1}});
-                op0->setTargets({q0});
-                it->setControls({Control{q0}});
-                it->setTargets({q1});
-                addToDag(dag, &it);
-                continue;
-            }
-
-            if (isSWAP && prevOpIsCNOT) {
-                // CNOT followed by a SWAP is equivalent to two CNOTs
-                op0->setControls({Control{prevQ0}});
-                op0->setTargets({prevQ1});
-                it->setGate(X);
-                it->setControls({Control{prevQ1}});
-                it->setTargets({prevQ0});
-                addToDag(dag, &it);
-                continue;
-            }
-        }
-
-        removeIdentities(qc);
-    }
+  removeIdentities(qc);
+}
 } // namespace qc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/src/QuantumComputation.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/QuantumComputation.cpp`

 * *Files 12% similar despite different names*

```diff
@@ -1,989 +1,1061 @@
-/*
- * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
- */
-
 #include "QuantumComputation.hpp"
 
 #include <cassert>
 
 namespace qc {
 
-    /***
-     * Public Methods
-     ***/
-    std::size_t QuantumComputation::getNindividualOps() const {
-        std::size_t nops = 0;
-        for (const auto& op: ops) {
-            if (op->isCompoundOperation()) {
-                auto&& comp = dynamic_cast<CompoundOperation*>(op.get());
-                nops += comp->size();
-            } else {
-                ++nops;
-            }
-        }
-
-        return nops;
-    }
-
-    std::size_t QuantumComputation::getNsingleQubitOps() const {
-        std::size_t nops = 0;
-        for (const auto& op: ops) {
-            if (!op->isUnitary()) {
-                continue;
-            }
-
-            if (op->isCompoundOperation()) {
-                const auto* const comp = dynamic_cast<const CompoundOperation*>(op.get());
-                for (const auto& subop: *comp) {
-                    if (subop->isUnitary() && !subop->isControlled() && subop->getNtargets() == 1U) {
-                        ++nops;
-                    }
-                }
-            } else {
-                if (!op->isControlled() && op->getNtargets() == 1U) {
-                    ++nops;
-                }
-            }
-        }
-        return nops;
-    }
-
-    std::size_t QuantumComputation::getDepth() const {
-        if (empty()) {
-            return 0U;
-        }
-
-        std::vector<std::size_t> depths(getNqubits(), 0U);
-        for (const auto& op: ops) {
-            op->addDepthContribution(depths);
-        }
-
-        return *std::max_element(depths.begin(), depths.end());
-    }
-
-    void QuantumComputation::import(const std::string& filename) {
-        const std::size_t dot       = filename.find_last_of('.');
-        std::string       extension = filename.substr(dot + 1);
-        std::transform(extension.begin(), extension.end(), extension.begin(), [](unsigned char ch) { return ::tolower(ch); });
-        if (extension == "real") {
-            import(filename, Format::Real);
-        } else if (extension == "qasm") {
-            import(filename, Format::OpenQASM);
-        } else if (extension == "txt") {
-            import(filename, Format::GRCS);
-        } else if (extension == "tfc") {
-            import(filename, Format::TFC);
-        } else if (extension == "qc") {
-            import(filename, Format::QC);
-        } else {
-            throw QFRException("[import] extension " + extension + " not recognized");
-        }
-    }
-
-    void QuantumComputation::import(const std::string& filename, Format format) {
-        const std::size_t slash = filename.find_last_of('/');
-        const std::size_t dot   = filename.find_last_of('.');
-        name                    = filename.substr(slash + 1, dot - slash - 1);
-
-        auto ifs = std::ifstream(filename);
-        if (ifs.good()) {
-            import(ifs, format);
-        } else {
-            throw QFRException("[import] Error processing input stream: " + name);
-        }
-    }
-
-    void QuantumComputation::import(std::istream&& is, Format format) {
-        // reset circuit before importing
-        reset();
-
-        switch (format) {
-            case Format::Real:
-                importReal(is);
-                break;
-            case Format::OpenQASM:
-                updateMaxControls(2);
-                importOpenQASM(is);
-                break;
-            case Format::GRCS:
-                importGRCS(is);
-                break;
-            case Format::TFC:
-                importTFC(is);
+/***
+ * Public Methods
+ ***/
+std::size_t QuantumComputation::getNindividualOps() const {
+  std::size_t nops = 0;
+  for (const auto& op : ops) {
+    if (op->isCompoundOperation()) {
+      auto&& comp = dynamic_cast<CompoundOperation*>(op.get());
+      nops += comp->size();
+    } else {
+      ++nops;
+    }
+  }
+
+  return nops;
+}
+
+std::size_t QuantumComputation::getNsingleQubitOps() const {
+  std::size_t nops = 0;
+  for (const auto& op : ops) {
+    if (!op->isUnitary()) {
+      continue;
+    }
+
+    if (op->isCompoundOperation()) {
+      const auto* const comp = dynamic_cast<const CompoundOperation*>(op.get());
+      for (const auto& subop : *comp) {
+        if (subop->isUnitary() && !subop->isControlled() &&
+            subop->getNtargets() == 1U) {
+          ++nops;
+        }
+      }
+    } else {
+      if (!op->isControlled() && op->getNtargets() == 1U) {
+        ++nops;
+      }
+    }
+  }
+  return nops;
+}
+
+std::size_t QuantumComputation::getDepth() const {
+  if (empty()) {
+    return 0U;
+  }
+
+  std::vector<std::size_t> depths(getNqubits(), 0U);
+  for (const auto& op : ops) {
+    op->addDepthContribution(depths);
+  }
+
+  return *std::max_element(depths.begin(), depths.end());
+}
+
+void QuantumComputation::import(const std::string& filename) {
+  const std::size_t dot = filename.find_last_of('.');
+  std::string extension = filename.substr(dot + 1);
+  std::transform(extension.begin(), extension.end(), extension.begin(),
+                 [](unsigned char ch) { return ::tolower(ch); });
+  if (extension == "real") {
+    import(filename, Format::Real);
+  } else if (extension == "qasm") {
+    import(filename, Format::OpenQASM);
+  } else if (extension == "txt") {
+    import(filename, Format::GRCS);
+  } else if (extension == "tfc") {
+    import(filename, Format::TFC);
+  } else if (extension == "qc") {
+    import(filename, Format::QC);
+  } else {
+    throw QFRException("[import] extension " + extension + " not recognized");
+  }
+}
+
+void QuantumComputation::import(const std::string& filename, Format format) {
+  const std::size_t slash = filename.find_last_of('/');
+  const std::size_t dot = filename.find_last_of('.');
+  name = filename.substr(slash + 1, dot - slash - 1);
+
+  auto ifs = std::ifstream(filename);
+  if (ifs.good()) {
+    import(ifs, format);
+  } else {
+    throw QFRException("[import] Error processing input stream: " + name);
+  }
+}
+
+void QuantumComputation::import(std::istream&& is, Format format) {
+  // reset circuit before importing
+  reset();
+
+  switch (format) {
+  case Format::Real:
+    importReal(is);
+    break;
+  case Format::OpenQASM:
+    updateMaxControls(2);
+    importOpenQASM(is);
+    break;
+  case Format::GRCS:
+    importGRCS(is);
+    break;
+  case Format::TFC:
+    importTFC(is);
+    break;
+  case Format::QC:
+    importQC(is);
+    break;
+  default:
+    throw QFRException("[import] format not recognized");
+  }
+
+  // initialize the initial layout and output permutation
+  initializeIOMapping();
+}
+
+void QuantumComputation::initializeIOMapping() {
+  // if no initial layout was found during parsing the identity mapping is
+  // assumed
+  if (initialLayout.empty()) {
+    for (Qubit i = 0; i < nqubits; ++i) {
+      initialLayout.emplace(i, i);
+    }
+  }
+
+  // try gathering (additional) output permutation information from
+  // measurements, e.g., a measurement
+  //      `measure q[i] -> c[j];`
+  // implies that the j-th (logical) output is obtained from measuring the i-th
+  // physical qubit.
+  const bool outputPermutationFound = !outputPermutation.empty();
+
+  // track whether the circuit contains measurements at the end of the circuit
+  // if it does, then all qubits that are not measured shall be considered
+  // garbage outputs
+  bool outputPermutationFromMeasurements = false;
+  std::set<Qubit> measuredQubits{};
+
+  for (const auto& opIt : ops) {
+    if (opIt->getType() == qc::Measure) {
+      outputPermutationFromMeasurements = true;
+      auto* op = dynamic_cast<NonUnitaryOperation*>(opIt.get());
+      assert(op->getTargets().size() == op->getClassics().size());
+      auto classicIt = op->getClassics().cbegin();
+      for (const auto& q : op->getTargets()) {
+        const auto qubitidx = q;
+        // only the first measurement of a qubit is used to determine the output
+        // permutation
+        if (measuredQubits.count(qubitidx) != 0) {
+          continue;
+        }
+
+        const auto bitidx = *classicIt;
+        if (outputPermutationFound) {
+          // output permutation was already set before -> permute existing
+          // values
+          const auto current = outputPermutation.at(qubitidx);
+          if (static_cast<std::size_t>(qubitidx) != bitidx &&
+              static_cast<std::size_t>(current) != bitidx) {
+            for (auto& p : outputPermutation) {
+              if (static_cast<std::size_t>(p.second) == bitidx) {
+                p.second = current;
                 break;
-            case Format::QC:
-                importQC(is);
-                break;
-            default:
-                throw QFRException("[import] format not recognized");
-        }
-
-        // initialize the initial layout and output permutation
-        initializeIOMapping();
-    }
-
-    void QuantumComputation::initializeIOMapping() {
-        // if no initial layout was found during parsing the identity mapping is assumed
-        if (initialLayout.empty()) {
-            for (Qubit i = 0; i < nqubits; ++i) {
-                initialLayout.emplace(i, i);
-            }
-        }
-
-        // try gathering (additional) output permutation information from measurements, e.g., a measurement
-        //      `measure q[i] -> c[j];`
-        // implies that the j-th (logical) output is obtained from measuring the i-th physical qubit.
-        const bool outputPermutationFound = !outputPermutation.empty();
-
-        // track whether the circuit contains measurements at the end of the circuit
-        // if it does, then all qubits that are not measured shall be considered garbage outputs
-        bool            outputPermutationFromMeasurements = false;
-        std::set<Qubit> measuredQubits{};
-
-        for (const auto& opIt: ops) {
-            if (opIt->getType() == qc::Measure) {
-                outputPermutationFromMeasurements = true;
-                auto* op                          = dynamic_cast<NonUnitaryOperation*>(opIt.get());
-                assert(op->getTargets().size() == op->getClassics().size());
-                auto classicIt = op->getClassics().cbegin();
-                for (const auto& q: op->getTargets()) {
-                    const auto qubitidx = q;
-                    // only the first measurement of a qubit is used to determine the output permutation
-                    if (measuredQubits.count(qubitidx) != 0) {
-                        continue;
-                    }
-
-                    const auto bitidx = *classicIt;
-                    if (outputPermutationFound) {
-                        // output permutation was already set before -> permute existing values
-                        const auto current = outputPermutation.at(qubitidx);
-                        if (static_cast<std::size_t>(qubitidx) != bitidx && static_cast<std::size_t>(current) != bitidx) {
-                            for (auto& p: outputPermutation) {
-                                if (static_cast<std::size_t>(p.second) == bitidx) {
-                                    p.second = current;
-                                    break;
-                                }
-                            }
-                            outputPermutation.at(qubitidx) = static_cast<Qubit>(bitidx);
-                        }
-                    } else {
-                        // directly set permutation if none was set beforehand
-                        outputPermutation[qubitidx] = static_cast<Qubit>(bitidx);
-                    }
-                    measuredQubits.emplace(qubitidx);
-                    ++classicIt;
-                }
-            }
-        }
-
-        // clear any qubits that were not measured from the output permutation
-        // these will be marked garbage further down below
-        if (outputPermutationFromMeasurements) {
-            auto it = outputPermutation.begin();
-            while (it != outputPermutation.end()) {
-                if (measuredQubits.find(it->first) == measuredQubits.end()) {
-                    it = outputPermutation.erase(it);
-                } else {
-                    ++it;
-                }
-            }
-        }
-
-        const bool buildOutputPermutation = outputPermutation.empty();
-        for (const auto& [physicalIn, logicalIn]: initialLayout) {
-            const bool isIdle = isIdleQubit(physicalIn);
-
-            // if no output permutation was found, build it from the initial layout
-            if (buildOutputPermutation && !isIdle) {
-                outputPermutation.insert({physicalIn, logicalIn});
-            }
-
-            // if the qubit is not an output, mark it as garbage
-            const bool isOutput = std::any_of(outputPermutation.begin(), outputPermutation.end(),
-                                              [&logicalIn = logicalIn](const auto& p) { return p.second == logicalIn; });
-            if (!isOutput) {
-                setLogicalQubitGarbage(logicalIn);
-            }
-
-            // if the qubit is an ancillary and idle, mark it as garbage
-            if (logicalQubitIsAncillary(logicalIn) && isIdle) {
-                setLogicalQubitGarbage(logicalIn);
-            }
-        }
-    }
-
-    void QuantumComputation::addQubitRegister(std::size_t nq, const std::string& regName) {
-        if (qregs.count(regName) != 0) {
-            auto& reg = qregs.at(regName);
-            if (reg.first + reg.second == nqubits + nancillae) {
-                reg.second += nq;
-            } else {
-                throw QFRException("[addQubitRegister] Augmenting existing qubit registers is only supported for the last register in a circuit");
+              }
             }
+            outputPermutation.at(qubitidx) = static_cast<Qubit>(bitidx);
+          }
         } else {
-            qregs.try_emplace(regName, nqubits, nq);
-        }
-        assert(nancillae == 0); // should only reach this point if no ancillae are present
-
-        for (std::size_t i = 0; i < nq; ++i) {
-            auto j = nqubits + i;
-            initialLayout.insert({j, j});
-            outputPermutation.insert({j, j});
-        }
-        nqubits += nq;
-
-        for (auto& op: ops) {
-            op->setNqubits(nqubits + nancillae);
-        }
-
-        ancillary.resize(nqubits + nancillae);
-        garbage.resize(nqubits + nancillae);
-    }
-
-    void QuantumComputation::addClassicalRegister(std::size_t nc, const std::string& regName) {
-        if (cregs.count(regName) != 0) {
-            throw QFRException("[addClassicalRegister] Augmenting existing classical registers is currently not supported");
+          // directly set permutation if none was set beforehand
+          outputPermutation[qubitidx] = static_cast<Qubit>(bitidx);
         }
-        if (nc == 0) {
-            throw QFRException("[addClassicalRegister] New register size must be larger than 0");
-        }
-
-        cregs.try_emplace(regName, nclassics, nc);
-        nclassics += nc;
-    }
-
-    void QuantumComputation::addAncillaryRegister(std::size_t nq, const std::string& regName) {
-        const auto totalqubits = nqubits + nancillae;
-        if (ancregs.count(regName) != 0) {
-            auto& reg = ancregs.at(regName);
-            if (reg.first + reg.second == totalqubits) {
-                reg.second += nq;
-            } else {
-                throw QFRException("[addAncillaryRegister] Augmenting existing ancillary registers is only supported for the last register in a circuit");
-            }
-        } else {
-            ancregs.try_emplace(regName, totalqubits, nq);
-        }
-
-        ancillary.resize(totalqubits + nq);
-        garbage.resize(totalqubits + nq);
-        for (std::size_t i = 0; i < nq; ++i) {
-            auto j = static_cast<Qubit>(totalqubits + i);
-            initialLayout.insert({j, j});
-            outputPermutation.insert({j, j});
-            ancillary[j] = true;
-        }
-        nancillae += nq;
-
-        for (auto& op: ops) {
-            op->setNqubits(nqubits + nancillae);
-        }
-    }
-
-    // removes the i-th logical qubit and returns the index j it was assigned to in the initial layout
-    // i.e., initialLayout[j] = i
-    std::pair<Qubit, std::optional<Qubit>> QuantumComputation::removeQubit(const Qubit logicalQubitIndex) {
-        // Find index of the physical qubit i is assigned to
-        Qubit physicalQubitIndex = 0;
-        for (const auto& [physical, logical]: initialLayout) {
-            if (logical == logicalQubitIndex) {
-                physicalQubitIndex = physical;
-            }
-        }
-
-        // get register and register-index of the corresponding qubit
-        auto reg = getQubitRegisterAndIndex(physicalQubitIndex);
-
-        if (physicalQubitIsAncillary(physicalQubitIndex)) {
-            // first index
-            if (reg.second == 0) {
-                // last remaining qubit of register
-                if (ancregs[reg.first].second == 1) {
-                    // delete register
-                    ancregs.erase(reg.first);
-                }
-                // first qubit of register
-                else {
-                    ancregs[reg.first].first++;
-                    ancregs[reg.first].second--;
-                }
-                // last index
-            } else if (reg.second == ancregs[reg.first].second - 1) {
-                // reduce count of register
-                ancregs[reg.first].second--;
-            } else {
-                auto ancreg    = ancregs.at(reg.first);
-                auto lowPart   = reg.first + "_l";
-                auto lowIndex  = ancreg.first;
-                auto lowCount  = reg.second;
-                auto highPart  = reg.first + "_h";
-                auto highIndex = ancreg.first + reg.second + 1;
-                auto highCount = ancreg.second - reg.second - 1;
-
-                ancregs.erase(reg.first);
-                ancregs.try_emplace(lowPart, lowIndex, lowCount);
-                ancregs.try_emplace(highPart, highIndex, highCount);
-            }
-            // reduce ancilla count
-            nancillae--;
-        } else {
-            if (reg.second == 0) {
-                // last remaining qubit of register
-                if (qregs[reg.first].second == 1) {
-                    // delete register
-                    qregs.erase(reg.first);
-                }
-                // first qubit of register
-                else {
-                    qregs[reg.first].first++;
-                    qregs[reg.first].second--;
-                }
-                // last index
-            } else if (reg.second == qregs[reg.first].second - 1) {
-                // reduce count of register
-                qregs[reg.first].second--;
-            } else {
-                auto qreg      = qregs.at(reg.first);
-                auto lowPart   = reg.first + "_l";
-                auto lowIndex  = qreg.first;
-                auto lowCount  = reg.second;
-                auto highPart  = reg.first + "_h";
-                auto highIndex = qreg.first + reg.second + 1;
-                auto highCount = qreg.second - reg.second - 1;
-
-                qregs.erase(reg.first);
-                qregs.try_emplace(lowPart, lowIndex, lowCount);
-                qregs.try_emplace(highPart, highIndex, highCount);
-            }
-            // reduce qubit count
-            nqubits--;
-        }
-
-        // adjust initial layout permutation
-        initialLayout.erase(physicalQubitIndex);
-
-        // remove potential output permutation entry
-        std::optional<Qubit> outputQubitIndex{};
-        if (const auto it = outputPermutation.find(physicalQubitIndex); it != outputPermutation.end()) {
-            outputQubitIndex = it->second;
-            // erasing entry
-            outputPermutation.erase(physicalQubitIndex);
-        }
-
-        // update all operations
-        const auto totalQubits = nqubits + nancillae;
-        for (auto& op: ops) {
-            op->setNqubits(totalQubits);
-        }
-
-        // update ancillary and garbage tracking
-        for (std::size_t i = logicalQubitIndex; i < totalQubits; ++i) {
-            ancillary[i] = ancillary[i + 1];
-            garbage[i]   = garbage[i + 1];
-        }
-        // unset last entry
-        ancillary[totalQubits] = false;
-        garbage[totalQubits]   = false;
-
-        return {physicalQubitIndex, outputQubitIndex};
-    }
-
-    // adds j-th physical qubit as ancilla to the end of reg or creates the register if necessary
-    void QuantumComputation::addAncillaryQubit(Qubit physicalQubitIndex, std::optional<Qubit> outputQubitIndex) {
-        if (initialLayout.count(physicalQubitIndex) > 0 || outputPermutation.count(physicalQubitIndex) > 0) {
-            throw QFRException("[addAncillaryQubit] Attempting to insert physical qubit that is already assigned");
-        }
-
-        bool fusionPossible = false;
-        for (auto& ancreg: ancregs) {
-            auto& ancStartIndex = ancreg.second.first;
-            auto& ancCount      = ancreg.second.second;
-            // 1st case: can append to start of existing register
-            if (ancStartIndex == physicalQubitIndex + 1) {
-                ancStartIndex--;
-                ancCount++;
-                fusionPossible = true;
-                break;
-            }
-            // 2nd case: can append to end of existing register
-            if (ancStartIndex + ancCount == physicalQubitIndex) {
-                ancCount++;
-                fusionPossible = true;
-                break;
-            }
-        }
-
-        if (ancregs.empty()) {
-            ancregs.try_emplace("anc", physicalQubitIndex, 1);
-        } else if (!fusionPossible) {
-            auto newRegName = "anc_" + std::to_string(physicalQubitIndex);
-            ancregs.try_emplace(newRegName, physicalQubitIndex, 1);
-        }
-
-        // index of logical qubit
-        auto logicalQubitIndex = nqubits + nancillae;
-
-        // resize ancillary and garbage tracking vectors
-        ancillary.resize(logicalQubitIndex + 1U);
-        garbage.resize(logicalQubitIndex + 1U);
-
-        // increase ancillae count and mark as ancillary
-        nancillae++;
-        ancillary[logicalQubitIndex] = true;
-
-        // adjust initial layout
-        initialLayout.insert({physicalQubitIndex, logicalQubitIndex});
-
-        // adjust output permutation
-        if (outputQubitIndex.has_value()) {
-            outputPermutation.insert({physicalQubitIndex, *outputQubitIndex});
-        } else {
-            // if a qubit is not relevant for the output, it is considered garbage
-            garbage[logicalQubitIndex] = true;
-        }
-
-        // update all operations
-        for (auto& op: ops) {
-            op->setNqubits(nqubits + nancillae);
-        }
-    }
-
-    void QuantumComputation::addQubit(const Qubit logicalQubitIndex, const Qubit physicalQubitIndex, const std::optional<Qubit> outputQubitIndex) {
-        if (initialLayout.count(physicalQubitIndex) > 0 || outputPermutation.count(physicalQubitIndex) > 0) {
-            throw QFRException("[addQubit] Attempting to insert physical qubit that is already assigned");
-        }
-
-        if (logicalQubitIndex > nqubits) {
-            throw QFRException("[addQubit] There are currently only " + std::to_string(nqubits) +
-                               " qubits in the circuit. Adding " + std::to_string(logicalQubitIndex) +
-                               " is therefore not possible at the moment.");
-            // TODO: this does not necessarily have to lead to an error. A new qubit register could be created and all ancillaries shifted
-        }
-
-        // check if qubit fits in existing register
-        bool fusionPossible = false;
-        for (auto& qreg: qregs) {
-            auto& qStartIndex = qreg.second.first;
-            auto& qCount      = qreg.second.second;
-            // 1st case: can append to start of existing register
-            if (qStartIndex == physicalQubitIndex + 1) {
-                qStartIndex--;
-                qCount++;
-                fusionPossible = true;
-                break;
-            }
-            // 2nd case: can append to end of existing register
-            if (qStartIndex + qCount == physicalQubitIndex) {
-                if (physicalQubitIndex == nqubits) {
-                    // need to shift ancillaries
-                    for (auto& ancreg: ancregs) {
-                        ancreg.second.first++;
-                    }
-                }
-                qCount++;
-                fusionPossible = true;
-                break;
-            }
-        }
-
-        consolidateRegister(qregs);
-
-        if (qregs.empty()) {
-            qregs.try_emplace("q", physicalQubitIndex, 1);
-        } else if (!fusionPossible) {
-            auto newRegName = "q_" + std::to_string(physicalQubitIndex);
-            qregs.try_emplace(newRegName, physicalQubitIndex, 1);
-        }
-
-        // increase qubit count
-        nqubits++;
-        // adjust initial layout
-        initialLayout.insert({physicalQubitIndex, logicalQubitIndex});
-        if (outputQubitIndex.has_value()) {
-            // adjust output permutation
-            outputPermutation.insert({physicalQubitIndex, *outputQubitIndex});
-        }
-        // update all operations
-        for (auto& op: ops) {
-            op->setNqubits(nqubits + nancillae);
-        }
-
-        // update ancillary and garbage tracking
-        for (auto i = nqubits + nancillae - 1; i > logicalQubitIndex; --i) {
-            ancillary[i] = ancillary[i - 1];
-            garbage[i]   = garbage[i - 1];
-        }
-        // unset new entry
-        ancillary[logicalQubitIndex] = false;
-        garbage[logicalQubitIndex]   = false;
-    }
-
-    std::ostream& QuantumComputation::print(std::ostream& os) const {
-        const auto width = ops.empty() ? 1 : static_cast<int>(std::log10(ops.size()) + 1.);
-        if (!ops.empty()) {
-            os << std::setw(width) << "i"
-               << ": \t\t\t";
-        } else {
-            os << "i: \t\t\t";
-        }
-        for (const auto& [physical, logical]: initialLayout) {
-            if (ancillary[logical]) {
-                os << "\033[31m" << logical << "\t\033[0m";
-            } else {
-                os << logical << "\t";
-            }
-        }
-        os << std::endl;
-        size_t i = 0U;
-        for (const auto& op: ops) {
-            os << std::setw(width) << ++i << ": \t";
-            op->print(os, initialLayout);
-            os << std::endl;
-        }
-        if (!ops.empty()) {
-            os << std::setw(width) << "o"
-               << ": \t\t\t";
-        } else {
-            os << "o: \t\t\t";
-        }
-        for (const auto& physicalQubit: initialLayout) {
-            auto it = outputPermutation.find(physicalQubit.first);
-            if (it == outputPermutation.end()) {
-                if (garbage[physicalQubit.second]) {
-                    os << "\033[31m|\t\033[0m";
-                } else {
-                    os << "|\t";
-                }
-            } else {
-                os << it->second << "\t";
-            }
-        }
-        os << std::endl;
-        return os;
-    }
-
-    void QuantumComputation::printBin(std::size_t n, std::stringstream& ss) {
-        if (n > 1) {
-            printBin(n / 2, ss);
-        }
-        ss << n % 2;
-    }
-
-    std::ostream& QuantumComputation::printStatistics(std::ostream& os) const {
-        os << "QC Statistics:\n";
-        os << "\tn: " << static_cast<std::size_t>(nqubits) << std::endl;
-        os << "\tanc: " << static_cast<std::size_t>(nancillae) << std::endl;
-        os << "\tm: " << ops.size() << std::endl;
-        os << "--------------" << std::endl;
-        return os;
-    }
-
-    void QuantumComputation::dump(const std::string& filename) {
-        const std::size_t dot       = filename.find_last_of('.');
-        std::string       extension = filename.substr(dot + 1);
-        std::transform(extension.begin(), extension.end(), extension.begin(), [](unsigned char c) { return ::tolower(c); });
-        if (extension == "real") {
-            dump(filename, Format::Real);
-        } else if (extension == "qasm") {
-            dump(filename, Format::OpenQASM);
-        } else if (extension == "qc") {
-            dump(filename, Format::QC);
-        } else if (extension == "tfc") {
-            dump(filename, Format::TFC);
-        } else if (extension == "tensor") {
-            dump(filename, Format::Tensor);
-        } else {
-            throw QFRException("[dump] Extension " + extension + " not recognized/supported for dumping.");
-        }
-    }
-
-    void QuantumComputation::dumpOpenQASM(std::ostream& of) {
-        // Add missing physical qubits
-        if (!qregs.empty()) {
-            for (Qubit physicalQubit = 0; physicalQubit < initialLayout.rbegin()->first; ++physicalQubit) {
-                if (initialLayout.count(physicalQubit) == 0) {
-                    const auto logicalQubit = getHighestLogicalQubitIndex() + 1;
-                    addQubit(logicalQubit, physicalQubit, std::nullopt);
-                }
-            }
-        }
-
-        // dump initial layout and output permutation
-        Permutation inverseInitialLayout{};
-        for (const auto& q: initialLayout) {
-            inverseInitialLayout.insert({q.second, q.first});
-        }
-        of << "// i";
-        for (const auto& q: inverseInitialLayout) {
-            of << " " << static_cast<std::size_t>(q.second);
-        }
-        of << std::endl;
-
-        Permutation inverseOutputPermutation{};
-        for (const auto& q: outputPermutation) {
-            inverseOutputPermutation.insert({q.second, q.first});
-        }
-        of << "// o";
-        for (const auto& q: inverseOutputPermutation) {
-            of << " " << q.second;
-        }
-        of << std::endl;
-
-        of << "OPENQASM 2.0;" << std::endl;
-        of << "include \"qelib1.inc\";" << std::endl;
-        if (std::any_of(std::begin(ops), std::end(ops), [](const auto& op) { return op->getType() == OpType::Teleportation; })) {
-            of << "opaque teleport src, anc, tgt;" << std::endl;
-        }
-        if (!qregs.empty()) {
-            printSortedRegisters(qregs, "qreg", of);
-        } else if (nqubits > 0) {
-            of << "qreg q[" << nqubits << "];" << std::endl;
-        }
-        if (!cregs.empty()) {
-            printSortedRegisters(cregs, "creg", of);
-        } else if (nclassics > 0) {
-            of << "creg c[" << nclassics << "];" << std::endl;
-        }
-        if (!ancregs.empty()) {
-            printSortedRegisters(ancregs, "qreg", of);
-        } else if (nancillae > 0) {
-            of << "qreg anc[" << nancillae << "];" << std::endl;
-        }
-
-        RegisterNames qregnames{};
-        RegisterNames cregnames{};
-        RegisterNames ancregnames{};
-        createRegisterArray(qregs, qregnames, nqubits, "q");
-        createRegisterArray(cregs, cregnames, nclassics, "c");
-        createRegisterArray(ancregs, ancregnames, nancillae, "anc");
-
-        for (const auto& ancregname: ancregnames) {
-            qregnames.push_back(ancregname);
-        }
-
-        for (const auto& op: ops) {
-            op->dumpOpenQASM(of, qregnames, cregnames);
-        }
-    }
-
-    void QuantumComputation::dump(const std::string& filename, Format format) {
-        assert(std::count(filename.begin(), filename.end(), '.') == 1);
-        auto of = std::ofstream(filename);
-        if (!of.good()) {
-            throw QFRException("[dump] Error opening file: " + filename);
-        }
-        dump(of, format);
-    }
-
-    void QuantumComputation::dump(std::ostream&& of, Format format) {
-        switch (format) {
-            case Format::OpenQASM:
-                dumpOpenQASM(of);
-                break;
-            case Format::Real:
-                std::cerr << "Dumping in real format currently not supported\n";
-                break;
-            case Format::GRCS:
-                std::cerr << "Dumping in GRCS format currently not supported\n";
-                break;
-            case Format::TFC:
-                std::cerr << "Dumping in TFC format currently not supported\n";
-                break;
-            case Format::QC:
-                std::cerr << "Dumping in QC format currently not supported\n";
-                break;
-            default:
-                throw QFRException("[dump] Format not recognized/supported for dumping.");
-        }
-    }
-
-    bool QuantumComputation::isIdleQubit(const Qubit physicalQubit) const {
-        return !std::any_of(ops.cbegin(), ops.cend(), [&physicalQubit](const auto& op) { return op->actsOn(physicalQubit); });
-    }
-
-    void QuantumComputation::stripIdleQubits(bool force, bool reduceIOpermutations) {
-        auto layoutCopy = initialLayout;
-        for (auto physicalQubitIt = layoutCopy.rbegin(); physicalQubitIt != layoutCopy.rend(); ++physicalQubitIt) {
-            auto physicalQubitIndex = physicalQubitIt->first;
-            if (isIdleQubit(physicalQubitIndex)) {
-                if (auto it = outputPermutation.find(physicalQubitIndex); it != outputPermutation.end() && !force) {
-                    continue;
-                }
-
-                auto logicalQubitIndex = initialLayout.at(physicalQubitIndex);
-                // check whether the logical qubit is used in the output permutation
-                bool usedInOutputPermutation = false;
-                for (const auto& [physical, logical]: outputPermutation) {
-                    if (logical == logicalQubitIndex) {
-                        usedInOutputPermutation = true;
-                        break;
-                    }
-                }
-                if (usedInOutputPermutation && !force) {
-                    // cannot strip a logical qubit that is used in the output permutation
-                    continue;
-                }
-
-                removeQubit(logicalQubitIndex);
-
-                if (reduceIOpermutations && (logicalQubitIndex < nqubits + nancillae)) {
-                    for (auto& [physical, logical]: initialLayout) {
-                        if (logical > logicalQubitIndex) {
-                            --logical;
-                        }
-                    }
-
-                    for (auto& [physical, logical]: outputPermutation) {
-                        if (logical > logicalQubitIndex) {
-                            --logical;
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    std::string QuantumComputation::getQubitRegister(const Qubit physicalQubitIndex) const {
-        for (const auto& reg: qregs) {
-            auto startIdx = reg.second.first;
-            auto count    = reg.second.second;
-            if (physicalQubitIndex < startIdx) {
-                continue;
-            }
-            if (physicalQubitIndex >= startIdx + count) {
-                continue;
-            }
-            return reg.first;
-        }
-        for (const auto& reg: ancregs) {
-            auto startIdx = reg.second.first;
-            auto count    = reg.second.second;
-            if (physicalQubitIndex < startIdx) {
-                continue;
-            }
-            if (physicalQubitIndex >= startIdx + count) {
-                continue;
-            }
-            return reg.first;
-        }
-
-        throw QFRException("[getQubitRegister] Qubit index " + std::to_string(physicalQubitIndex) + " not found in any register");
-    }
-
-    std::pair<std::string, Qubit> QuantumComputation::getQubitRegisterAndIndex(const Qubit physicalQubitIndex) const {
-        const std::string regName = getQubitRegister(physicalQubitIndex);
-        Qubit             index   = 0;
-        auto              it      = qregs.find(regName);
-        if (it != qregs.end()) {
-            index = physicalQubitIndex - it->second.first;
-        } else {
-            auto itAnc = ancregs.find(regName);
-            if (itAnc != ancregs.end()) {
-                index = physicalQubitIndex - itAnc->second.first;
-            }
-            // no else branch needed here, since error would have already shown in getQubitRegister(physicalQubitIndex)
-        }
-        return {regName, index};
-    }
-
-    std::string QuantumComputation::getClassicalRegister(const Bit classicalIndex) const {
-        for (const auto& reg: cregs) {
-            auto startIdx = reg.second.first;
-            auto count    = reg.second.second;
-            if (classicalIndex < startIdx) {
-                continue;
-            }
-            if (classicalIndex >= startIdx + count) {
-                continue;
-            }
-            return reg.first;
-        }
-
-        throw QFRException("[getClassicalRegister] Classical index " + std::to_string(classicalIndex) + " not found in any register");
-    }
-
-    std::pair<std::string, Bit> QuantumComputation::getClassicalRegisterAndIndex(const Bit classicalIndex) const {
-        const std::string regName = getClassicalRegister(classicalIndex);
-        std::size_t       index   = 0;
-        auto              it      = cregs.find(regName);
-        if (it != cregs.end()) {
-            index = classicalIndex - it->second.first;
-        } // else branch not needed since getClassicalRegister already covers this case
-        return {regName, index};
-    }
-
-    Qubit QuantumComputation::getIndexFromQubitRegister(const std::pair<std::string, Qubit>& qubit) const {
-        // no range check is performed here!
-        return qregs.at(qubit.first).first + qubit.second;
-    }
-    Bit QuantumComputation::getIndexFromClassicalRegister(const std::pair<std::string, std::size_t>& clbit) const {
-        // no range check is performed here!
-        return cregs.at(clbit.first).first + clbit.second;
-    }
-
-    std::ostream& QuantumComputation::printPermutation(const Permutation& permutation, std::ostream& os) {
-        for (const auto& [physical, logical]: permutation) {
-            os << "\t" << physical << ": " << logical << std::endl;
-        }
-        return os;
-    }
-
-    std::ostream& QuantumComputation::printRegisters(std::ostream& os) const {
-        os << "qregs:";
-        for (const auto& qreg: qregs) {
-            os << " {" << qreg.first << ", {" << qreg.second.first << ", " << qreg.second.second << "}}";
-        }
-        os << std::endl;
-        if (!ancregs.empty()) {
-            os << "ancregs:";
-            for (const auto& ancreg: ancregs) {
-                os << " {" << ancreg.first << ", {" << ancreg.second.first << ", " << ancreg.second.second << "}}";
-            }
-            os << std::endl;
-        }
-        os << "cregs:";
-        for (const auto& creg: cregs) {
-            os << " {" << creg.first << ", {" << creg.second.first << ", " << creg.second.second << "}}";
-        }
-        os << std::endl;
-        return os;
-    }
-
-    Qubit QuantumComputation::getHighestLogicalQubitIndex(const Permutation& permutation) {
-        Qubit maxIndex = 0;
-        for (const auto& [physical, logical]: permutation) {
-            maxIndex = std::max(maxIndex, logical);
-        }
-        return maxIndex;
-    }
-
-    bool QuantumComputation::physicalQubitIsAncillary(const Qubit physicalQubitIndex) const {
-        return std::any_of(ancregs.cbegin(), ancregs.cend(), [&physicalQubitIndex](const auto& ancreg) { return ancreg.second.first <= physicalQubitIndex && physicalQubitIndex < ancreg.second.first + ancreg.second.second; });
-    }
-
-    void QuantumComputation::setLogicalQubitGarbage(const Qubit logicalQubitIndex) {
-        garbage[logicalQubitIndex] = true;
-        // setting a logical qubit garbage also means removing it from the output permutation if it was present before
-        for (auto it = outputPermutation.begin(); it != outputPermutation.end(); ++it) {
-            if (it->second == logicalQubitIndex) {
-                outputPermutation.erase(it);
-                break;
-            }
-        }
-    }
-
-    [[nodiscard]] std::pair<bool, std::optional<Qubit>> QuantumComputation::containsLogicalQubit(const Qubit logicalQubitIndex) const {
-        if (const auto it = std::find_if(
-                    initialLayout.cbegin(),
-                    initialLayout.cend(),
-                    [&logicalQubitIndex](const auto& mapping) {
-                        return mapping.second == logicalQubitIndex;
+        measuredQubits.emplace(qubitidx);
+        ++classicIt;
+      }
+    }
+  }
+
+  // clear any qubits that were not measured from the output permutation
+  // these will be marked garbage further down below
+  if (outputPermutationFromMeasurements) {
+    auto it = outputPermutation.begin();
+    while (it != outputPermutation.end()) {
+      if (measuredQubits.find(it->first) == measuredQubits.end()) {
+        it = outputPermutation.erase(it);
+      } else {
+        ++it;
+      }
+    }
+  }
+
+  const bool buildOutputPermutation = outputPermutation.empty();
+  for (const auto& [physicalIn, logicalIn] : initialLayout) {
+    const bool isIdle = isIdleQubit(physicalIn);
+
+    // if no output permutation was found, build it from the initial layout
+    if (buildOutputPermutation && !isIdle) {
+      outputPermutation.insert({physicalIn, logicalIn});
+    }
+
+    // if the qubit is not an output, mark it as garbage
+    const bool isOutput =
+        std::any_of(outputPermutation.begin(), outputPermutation.end(),
+                    [&logicalIn = logicalIn](const auto& p) {
+                      return p.second == logicalIn;
                     });
-            it != initialLayout.cend()) {
-            return {true, it->first};
-        }
-        return {false, std::nullopt};
-    }
-
-    bool QuantumComputation::isLastOperationOnQubit(const const_iterator& opIt, const const_iterator& end) const {
-        if (opIt == end) {
-            return true;
-        }
-
-        // determine which qubits the gate acts on
-        std::vector<bool> actson(nqubits + nancillae);
-        for (std::size_t i = 0; i < actson.size(); ++i) {
-            if ((*opIt)->actsOn(static_cast<Qubit>(i))) {
-                actson[i] = true;
-            }
-        }
-
-        // iterate over remaining gates and check if any act on qubits overlapping with the target gate
-        auto atEnd = opIt;
-        std::advance(atEnd, 1);
-        while (atEnd != end) {
-            for (std::size_t i = 0; i < actson.size(); ++i) {
-                if (actson[i] && (*atEnd)->actsOn(static_cast<Qubit>(i))) {
-                    return false;
-                }
-            }
-            ++atEnd;
-        }
-        return true;
-    }
-
-    void QuantumComputation::unifyQuantumRegisters(const std::string& regName) {
-        ancregs.clear();
-        qregs.clear();
-        qregs[regName] = {0, getNqubits()};
-        nancillae      = 0;
-    }
-
-    void QuantumComputation::appendMeasurementsAccordingToOutputPermutation(const std::string& registerName) {
-        // ensure that the circuit contains enough classical registers
-        if (cregs.empty()) {
-            // in case there are no registers, create a new one
-            addClassicalRegister(outputPermutation.size(), registerName);
-        } else if (nclassics < outputPermutation.size()) {
-            if (cregs.find(registerName) == cregs.end()) {
-                // in case there are registers but not enough, add a new one
-                addClassicalRegister(outputPermutation.size() - nclassics, registerName);
-            } else {
-                // in case the register already exists, augment it
-                nclassics += outputPermutation.size() - nclassics;
-                cregs[registerName].second = outputPermutation.size();
-            }
-        }
-        auto targets = std::vector<qc::Qubit>{};
-        for (std::size_t q = 0; q < getNqubits(); ++q) {
-            targets.emplace_back(q);
-        }
-        barrier(targets);
-        // append measurements according to output permutation
-        for (const auto& [qubit, clbit]: outputPermutation) {
-            measure(qubit, clbit);
-        }
+    if (!isOutput) {
+      setLogicalQubitGarbage(logicalIn);
     }
 
-    void QuantumComputation::checkQubitRange(const Qubit qubit) const {
-        if (const auto it = initialLayout.find(qubit); it == initialLayout.end() || it->second >= getNqubits()) {
-            throw QFRException("Qubit index out of range: " + std::to_string(qubit));
-        }
-    }
-    void QuantumComputation::checkQubitRange(const Qubit qubit, const Controls& controls) const {
-        checkQubitRange(qubit);
-        for (const auto& [ctrl, _]: controls) {
-            checkQubitRange(ctrl);
-        }
-    }
-
-    void QuantumComputation::checkQubitRange(const Qubit qubit0, const Qubit qubit1, const Controls& controls) const {
-        checkQubitRange(qubit0, controls);
-        checkQubitRange(qubit1);
-    }
-
-    void QuantumComputation::checkQubitRange(const std::vector<Qubit>& qubits) const {
-        for (const auto& qubit: qubits) {
-            checkQubitRange(qubit);
-        }
-    }
-
-    void QuantumComputation::addVariable(const SymbolOrNumber& expr) {
-        if (std::holds_alternative<Symbolic>(expr)) {
-            const auto& sym = std::get<Symbolic>(expr);
-            for (const auto& term: sym) {
-                occuringVariables.insert(term.getVar());
-            }
-        }
-    }
-
-    // Instantiates this computation
-    void QuantumComputation::instantiate(const VariableAssignment& assignment) {
-        for (auto& op: ops) {
-            if (auto* symOp = dynamic_cast<SymbolicOperation*>(op.get())) {
-                symOp->instantiate(assignment);
-            }
-        }
+    // if the qubit is an ancillary and idle, mark it as garbage
+    if (logicalQubitIsAncillary(logicalIn) && isIdle) {
+      setLogicalQubitGarbage(logicalIn);
+    }
+  }
+}
+
+void QuantumComputation::addQubitRegister(std::size_t nq,
+                                          const std::string& regName) {
+  if (qregs.count(regName) != 0) {
+    auto& reg = qregs.at(regName);
+    if (reg.first + reg.second == nqubits + nancillae) {
+      reg.second += nq;
+    } else {
+      throw QFRException(
+          "[addQubitRegister] Augmenting existing qubit registers is only "
+          "supported for the last register in a circuit");
+    }
+  } else {
+    qregs.try_emplace(regName, nqubits, nq);
+  }
+  assert(nancillae ==
+         0); // should only reach this point if no ancillae are present
+
+  for (std::size_t i = 0; i < nq; ++i) {
+    auto j = nqubits + i;
+    initialLayout.insert({j, j});
+    outputPermutation.insert({j, j});
+  }
+  nqubits += nq;
+
+  for (auto& op : ops) {
+    op->setNqubits(nqubits + nancillae);
+  }
+
+  ancillary.resize(nqubits + nancillae);
+  garbage.resize(nqubits + nancillae);
+}
+
+void QuantumComputation::addClassicalRegister(std::size_t nc,
+                                              const std::string& regName) {
+  if (cregs.count(regName) != 0) {
+    throw QFRException("[addClassicalRegister] Augmenting existing classical "
+                       "registers is currently not supported");
+  }
+  if (nc == 0) {
+    throw QFRException(
+        "[addClassicalRegister] New register size must be larger than 0");
+  }
+
+  cregs.try_emplace(regName, nclassics, nc);
+  nclassics += nc;
+}
+
+void QuantumComputation::addAncillaryRegister(std::size_t nq,
+                                              const std::string& regName) {
+  const auto totalqubits = nqubits + nancillae;
+  if (ancregs.count(regName) != 0) {
+    auto& reg = ancregs.at(regName);
+    if (reg.first + reg.second == totalqubits) {
+      reg.second += nq;
+    } else {
+      throw QFRException(
+          "[addAncillaryRegister] Augmenting existing ancillary registers is "
+          "only supported for the last register in a circuit");
+    }
+  } else {
+    ancregs.try_emplace(regName, totalqubits, nq);
+  }
+
+  ancillary.resize(totalqubits + nq);
+  garbage.resize(totalqubits + nq);
+  for (std::size_t i = 0; i < nq; ++i) {
+    auto j = static_cast<Qubit>(totalqubits + i);
+    initialLayout.insert({j, j});
+    outputPermutation.insert({j, j});
+    ancillary[j] = true;
+  }
+  nancillae += nq;
+
+  for (auto& op : ops) {
+    op->setNqubits(nqubits + nancillae);
+  }
+}
+
+// removes the i-th logical qubit and returns the index j it was assigned to in
+// the initial layout i.e., initialLayout[j] = i
+std::pair<Qubit, std::optional<Qubit>>
+QuantumComputation::removeQubit(const Qubit logicalQubitIndex) {
+  // Find index of the physical qubit i is assigned to
+  Qubit physicalQubitIndex = 0;
+  for (const auto& [physical, logical] : initialLayout) {
+    if (logical == logicalQubitIndex) {
+      physicalQubitIndex = physical;
+    }
+  }
+
+  // get register and register-index of the corresponding qubit
+  auto reg = getQubitRegisterAndIndex(physicalQubitIndex);
+
+  if (physicalQubitIsAncillary(physicalQubitIndex)) {
+    // first index
+    if (reg.second == 0) {
+      // last remaining qubit of register
+      if (ancregs[reg.first].second == 1) {
+        // delete register
+        ancregs.erase(reg.first);
+      }
+      // first qubit of register
+      else {
+        ancregs[reg.first].first++;
+        ancregs[reg.first].second--;
+      }
+      // last index
+    } else if (reg.second == ancregs[reg.first].second - 1) {
+      // reduce count of register
+      ancregs[reg.first].second--;
+    } else {
+      auto ancreg = ancregs.at(reg.first);
+      auto lowPart = reg.first + "_l";
+      auto lowIndex = ancreg.first;
+      auto lowCount = reg.second;
+      auto highPart = reg.first + "_h";
+      auto highIndex = ancreg.first + reg.second + 1;
+      auto highCount = ancreg.second - reg.second - 1;
+
+      ancregs.erase(reg.first);
+      ancregs.try_emplace(lowPart, lowIndex, lowCount);
+      ancregs.try_emplace(highPart, highIndex, highCount);
+    }
+    // reduce ancilla count
+    nancillae--;
+  } else {
+    if (reg.second == 0) {
+      // last remaining qubit of register
+      if (qregs[reg.first].second == 1) {
+        // delete register
+        qregs.erase(reg.first);
+      }
+      // first qubit of register
+      else {
+        qregs[reg.first].first++;
+        qregs[reg.first].second--;
+      }
+      // last index
+    } else if (reg.second == qregs[reg.first].second - 1) {
+      // reduce count of register
+      qregs[reg.first].second--;
+    } else {
+      auto qreg = qregs.at(reg.first);
+      auto lowPart = reg.first + "_l";
+      auto lowIndex = qreg.first;
+      auto lowCount = reg.second;
+      auto highPart = reg.first + "_h";
+      auto highIndex = qreg.first + reg.second + 1;
+      auto highCount = qreg.second - reg.second - 1;
+
+      qregs.erase(reg.first);
+      qregs.try_emplace(lowPart, lowIndex, lowCount);
+      qregs.try_emplace(highPart, highIndex, highCount);
+    }
+    // reduce qubit count
+    nqubits--;
+  }
+
+  // adjust initial layout permutation
+  initialLayout.erase(physicalQubitIndex);
+
+  // remove potential output permutation entry
+  std::optional<Qubit> outputQubitIndex{};
+  if (const auto it = outputPermutation.find(physicalQubitIndex);
+      it != outputPermutation.end()) {
+    outputQubitIndex = it->second;
+    // erasing entry
+    outputPermutation.erase(physicalQubitIndex);
+  }
+
+  // update all operations
+  const auto totalQubits = nqubits + nancillae;
+  for (auto& op : ops) {
+    op->setNqubits(totalQubits);
+  }
+
+  // update ancillary and garbage tracking
+  for (std::size_t i = logicalQubitIndex; i < totalQubits; ++i) {
+    ancillary[i] = ancillary[i + 1];
+    garbage[i] = garbage[i + 1];
+  }
+  // unset last entry
+  ancillary[totalQubits] = false;
+  garbage[totalQubits] = false;
+
+  return {physicalQubitIndex, outputQubitIndex};
+}
+
+// adds j-th physical qubit as ancilla to the end of reg or creates the register
+// if necessary
+void QuantumComputation::addAncillaryQubit(
+    Qubit physicalQubitIndex, std::optional<Qubit> outputQubitIndex) {
+  if (initialLayout.count(physicalQubitIndex) > 0 ||
+      outputPermutation.count(physicalQubitIndex) > 0) {
+    throw QFRException("[addAncillaryQubit] Attempting to insert physical "
+                       "qubit that is already assigned");
+  }
+
+  bool fusionPossible = false;
+  for (auto& ancreg : ancregs) {
+    auto& ancStartIndex = ancreg.second.first;
+    auto& ancCount = ancreg.second.second;
+    // 1st case: can append to start of existing register
+    if (ancStartIndex == physicalQubitIndex + 1) {
+      ancStartIndex--;
+      ancCount++;
+      fusionPossible = true;
+      break;
+    }
+    // 2nd case: can append to end of existing register
+    if (ancStartIndex + ancCount == physicalQubitIndex) {
+      ancCount++;
+      fusionPossible = true;
+      break;
+    }
+  }
+
+  if (ancregs.empty()) {
+    ancregs.try_emplace("anc", physicalQubitIndex, 1);
+  } else if (!fusionPossible) {
+    auto newRegName = "anc_" + std::to_string(physicalQubitIndex);
+    ancregs.try_emplace(newRegName, physicalQubitIndex, 1);
+  }
+
+  // index of logical qubit
+  auto logicalQubitIndex = nqubits + nancillae;
+
+  // resize ancillary and garbage tracking vectors
+  ancillary.resize(logicalQubitIndex + 1U);
+  garbage.resize(logicalQubitIndex + 1U);
+
+  // increase ancillae count and mark as ancillary
+  nancillae++;
+  ancillary[logicalQubitIndex] = true;
+
+  // adjust initial layout
+  initialLayout.insert({physicalQubitIndex, logicalQubitIndex});
+
+  // adjust output permutation
+  if (outputQubitIndex.has_value()) {
+    outputPermutation.insert({physicalQubitIndex, *outputQubitIndex});
+  } else {
+    // if a qubit is not relevant for the output, it is considered garbage
+    garbage[logicalQubitIndex] = true;
+  }
+
+  // update all operations
+  for (auto& op : ops) {
+    op->setNqubits(nqubits + nancillae);
+  }
+}
+
+void QuantumComputation::addQubit(const Qubit logicalQubitIndex,
+                                  const Qubit physicalQubitIndex,
+                                  const std::optional<Qubit> outputQubitIndex) {
+  if (initialLayout.count(physicalQubitIndex) > 0 ||
+      outputPermutation.count(physicalQubitIndex) > 0) {
+    throw QFRException("[addQubit] Attempting to insert physical qubit that is "
+                       "already assigned");
+  }
+
+  if (logicalQubitIndex > nqubits) {
+    throw QFRException(
+        "[addQubit] There are currently only " + std::to_string(nqubits) +
+        " qubits in the circuit. Adding " + std::to_string(logicalQubitIndex) +
+        " is therefore not possible at the moment.");
+    // TODO: this does not necessarily have to lead to an error. A new qubit
+    // register could be created and all ancillaries shifted
+  }
+
+  // check if qubit fits in existing register
+  bool fusionPossible = false;
+  for (auto& qreg : qregs) {
+    auto& qStartIndex = qreg.second.first;
+    auto& qCount = qreg.second.second;
+    // 1st case: can append to start of existing register
+    if (qStartIndex == physicalQubitIndex + 1) {
+      qStartIndex--;
+      qCount++;
+      fusionPossible = true;
+      break;
+    }
+    // 2nd case: can append to end of existing register
+    if (qStartIndex + qCount == physicalQubitIndex) {
+      if (physicalQubitIndex == nqubits) {
+        // need to shift ancillaries
+        for (auto& ancreg : ancregs) {
+          ancreg.second.first++;
+        }
+      }
+      qCount++;
+      fusionPossible = true;
+      break;
+    }
+  }
+
+  consolidateRegister(qregs);
+
+  if (qregs.empty()) {
+    qregs.try_emplace("q", physicalQubitIndex, 1);
+  } else if (!fusionPossible) {
+    auto newRegName = "q_" + std::to_string(physicalQubitIndex);
+    qregs.try_emplace(newRegName, physicalQubitIndex, 1);
+  }
+
+  // increase qubit count
+  nqubits++;
+  // adjust initial layout
+  initialLayout.insert({physicalQubitIndex, logicalQubitIndex});
+  if (outputQubitIndex.has_value()) {
+    // adjust output permutation
+    outputPermutation.insert({physicalQubitIndex, *outputQubitIndex});
+  }
+  // update all operations
+  for (auto& op : ops) {
+    op->setNqubits(nqubits + nancillae);
+  }
+
+  // update ancillary and garbage tracking
+  for (auto i = nqubits + nancillae - 1; i > logicalQubitIndex; --i) {
+    ancillary[i] = ancillary[i - 1];
+    garbage[i] = garbage[i - 1];
+  }
+  // unset new entry
+  ancillary[logicalQubitIndex] = false;
+  garbage[logicalQubitIndex] = false;
+}
+
+std::ostream& QuantumComputation::print(std::ostream& os) const {
+  const auto width =
+      ops.empty() ? 1 : static_cast<int>(std::log10(ops.size()) + 1.);
+  if (!ops.empty()) {
+    os << std::setw(width) << "i"
+       << ": \t\t\t";
+  } else {
+    os << "i: \t\t\t";
+  }
+  for (const auto& [physical, logical] : initialLayout) {
+    if (ancillary[logical]) {
+      os << "\033[31m" << logical << "\t\033[0m";
+    } else {
+      os << logical << "\t";
+    }
+  }
+  os << std::endl;
+  size_t i = 0U;
+  for (const auto& op : ops) {
+    os << std::setw(width) << ++i << ": \t";
+    op->print(os, initialLayout);
+    os << std::endl;
+  }
+  if (!ops.empty()) {
+    os << std::setw(width) << "o"
+       << ": \t\t\t";
+  } else {
+    os << "o: \t\t\t";
+  }
+  for (const auto& physicalQubit : initialLayout) {
+    auto it = outputPermutation.find(physicalQubit.first);
+    if (it == outputPermutation.end()) {
+      if (garbage[physicalQubit.second]) {
+        os << "\033[31m|\t\033[0m";
+      } else {
+        os << "|\t";
+      }
+    } else {
+      os << it->second << "\t";
+    }
+  }
+  os << std::endl;
+  return os;
+}
+
+void QuantumComputation::printBin(std::size_t n, std::stringstream& ss) {
+  if (n > 1) {
+    printBin(n / 2, ss);
+  }
+  ss << n % 2;
+}
+
+std::ostream& QuantumComputation::printStatistics(std::ostream& os) const {
+  os << "QC Statistics:\n";
+  os << "\tn: " << static_cast<std::size_t>(nqubits) << std::endl;
+  os << "\tanc: " << static_cast<std::size_t>(nancillae) << std::endl;
+  os << "\tm: " << ops.size() << std::endl;
+  os << "--------------" << std::endl;
+  return os;
+}
+
+void QuantumComputation::dump(const std::string& filename) {
+  const std::size_t dot = filename.find_last_of('.');
+  std::string extension = filename.substr(dot + 1);
+  std::transform(extension.begin(), extension.end(), extension.begin(),
+                 [](unsigned char c) { return ::tolower(c); });
+  if (extension == "real") {
+    dump(filename, Format::Real);
+  } else if (extension == "qasm") {
+    dump(filename, Format::OpenQASM);
+  } else if (extension == "qc") {
+    dump(filename, Format::QC);
+  } else if (extension == "tfc") {
+    dump(filename, Format::TFC);
+  } else if (extension == "tensor") {
+    dump(filename, Format::Tensor);
+  } else {
+    throw QFRException("[dump] Extension " + extension +
+                       " not recognized/supported for dumping.");
+  }
+}
+
+void QuantumComputation::dumpOpenQASM(std::ostream& of) {
+  // Add missing physical qubits
+  if (!qregs.empty()) {
+    for (Qubit physicalQubit = 0; physicalQubit < initialLayout.rbegin()->first;
+         ++physicalQubit) {
+      if (initialLayout.count(physicalQubit) == 0) {
+        const auto logicalQubit = getHighestLogicalQubitIndex() + 1;
+        addQubit(logicalQubit, physicalQubit, std::nullopt);
+      }
+    }
+  }
+
+  // dump initial layout and output permutation
+  Permutation inverseInitialLayout{};
+  for (const auto& q : initialLayout) {
+    inverseInitialLayout.insert({q.second, q.first});
+  }
+  of << "// i";
+  for (const auto& q : inverseInitialLayout) {
+    of << " " << static_cast<std::size_t>(q.second);
+  }
+  of << std::endl;
+
+  Permutation inverseOutputPermutation{};
+  for (const auto& q : outputPermutation) {
+    inverseOutputPermutation.insert({q.second, q.first});
+  }
+  of << "// o";
+  for (const auto& q : inverseOutputPermutation) {
+    of << " " << q.second;
+  }
+  of << std::endl;
+
+  of << "OPENQASM 2.0;" << std::endl;
+  of << "include \"qelib1.inc\";" << std::endl;
+  if (std::any_of(std::begin(ops), std::end(ops), [](const auto& op) {
+        return op->getType() == OpType::Teleportation;
+      })) {
+    of << "opaque teleport src, anc, tgt;" << std::endl;
+  }
+  if (!qregs.empty()) {
+    printSortedRegisters(qregs, "qreg", of);
+  } else if (nqubits > 0) {
+    of << "qreg q[" << nqubits << "];" << std::endl;
+  }
+  if (!cregs.empty()) {
+    printSortedRegisters(cregs, "creg", of);
+  } else if (nclassics > 0) {
+    of << "creg c[" << nclassics << "];" << std::endl;
+  }
+  if (!ancregs.empty()) {
+    printSortedRegisters(ancregs, "qreg", of);
+  } else if (nancillae > 0) {
+    of << "qreg anc[" << nancillae << "];" << std::endl;
+  }
+
+  RegisterNames qregnames{};
+  RegisterNames cregnames{};
+  RegisterNames ancregnames{};
+  createRegisterArray(qregs, qregnames, nqubits, "q");
+  createRegisterArray(cregs, cregnames, nclassics, "c");
+  createRegisterArray(ancregs, ancregnames, nancillae, "anc");
+
+  for (const auto& ancregname : ancregnames) {
+    qregnames.push_back(ancregname);
+  }
+
+  for (const auto& op : ops) {
+    op->dumpOpenQASM(of, qregnames, cregnames);
+  }
+}
+
+void QuantumComputation::dump(const std::string& filename, Format format) {
+  assert(std::count(filename.begin(), filename.end(), '.') == 1);
+  auto of = std::ofstream(filename);
+  if (!of.good()) {
+    throw QFRException("[dump] Error opening file: " + filename);
+  }
+  dump(of, format);
+}
+
+void QuantumComputation::dump(std::ostream&& of, Format format) {
+  switch (format) {
+  case Format::OpenQASM:
+    dumpOpenQASM(of);
+    break;
+  case Format::Real:
+    std::cerr << "Dumping in real format currently not supported\n";
+    break;
+  case Format::GRCS:
+    std::cerr << "Dumping in GRCS format currently not supported\n";
+    break;
+  case Format::TFC:
+    std::cerr << "Dumping in TFC format currently not supported\n";
+    break;
+  case Format::QC:
+    std::cerr << "Dumping in QC format currently not supported\n";
+    break;
+  default:
+    throw QFRException("[dump] Format not recognized/supported for dumping.");
+  }
+}
+
+bool QuantumComputation::isIdleQubit(const Qubit physicalQubit) const {
+  return !std::any_of(
+      ops.cbegin(), ops.cend(),
+      [&physicalQubit](const auto& op) { return op->actsOn(physicalQubit); });
+}
+
+void QuantumComputation::stripIdleQubits(bool force,
+                                         bool reduceIOpermutations) {
+  auto layoutCopy = initialLayout;
+  for (auto physicalQubitIt = layoutCopy.rbegin();
+       physicalQubitIt != layoutCopy.rend(); ++physicalQubitIt) {
+    auto physicalQubitIndex = physicalQubitIt->first;
+    if (isIdleQubit(physicalQubitIndex)) {
+      if (auto it = outputPermutation.find(physicalQubitIndex);
+          it != outputPermutation.end() && !force) {
+        continue;
+      }
+
+      auto logicalQubitIndex = initialLayout.at(physicalQubitIndex);
+      // check whether the logical qubit is used in the output permutation
+      bool usedInOutputPermutation = false;
+      for (const auto& [physical, logical] : outputPermutation) {
+        if (logical == logicalQubitIndex) {
+          usedInOutputPermutation = true;
+          break;
+        }
+      }
+      if (usedInOutputPermutation && !force) {
+        // cannot strip a logical qubit that is used in the output permutation
+        continue;
+      }
+
+      removeQubit(logicalQubitIndex);
+
+      if (reduceIOpermutations && (logicalQubitIndex < nqubits + nancillae)) {
+        for (auto& [physical, logical] : initialLayout) {
+          if (logical > logicalQubitIndex) {
+            --logical;
+          }
+        }
+
+        for (auto& [physical, logical] : outputPermutation) {
+          if (logical > logicalQubitIndex) {
+            --logical;
+          }
+        }
+      }
+    }
+  }
+}
+
+std::string
+QuantumComputation::getQubitRegister(const Qubit physicalQubitIndex) const {
+  for (const auto& reg : qregs) {
+    auto startIdx = reg.second.first;
+    auto count = reg.second.second;
+    if (physicalQubitIndex < startIdx) {
+      continue;
+    }
+    if (physicalQubitIndex >= startIdx + count) {
+      continue;
+    }
+    return reg.first;
+  }
+  for (const auto& reg : ancregs) {
+    auto startIdx = reg.second.first;
+    auto count = reg.second.second;
+    if (physicalQubitIndex < startIdx) {
+      continue;
+    }
+    if (physicalQubitIndex >= startIdx + count) {
+      continue;
+    }
+    return reg.first;
+  }
+
+  throw QFRException("[getQubitRegister] Qubit index " +
+                     std::to_string(physicalQubitIndex) +
+                     " not found in any register");
+}
+
+std::pair<std::string, Qubit> QuantumComputation::getQubitRegisterAndIndex(
+    const Qubit physicalQubitIndex) const {
+  const std::string regName = getQubitRegister(physicalQubitIndex);
+  Qubit index = 0;
+  auto it = qregs.find(regName);
+  if (it != qregs.end()) {
+    index = physicalQubitIndex - it->second.first;
+  } else {
+    auto itAnc = ancregs.find(regName);
+    if (itAnc != ancregs.end()) {
+      index = physicalQubitIndex - itAnc->second.first;
+    }
+    // no else branch needed here, since error would have already shown in
+    // getQubitRegister(physicalQubitIndex)
+  }
+  return {regName, index};
+}
+
+std::string
+QuantumComputation::getClassicalRegister(const Bit classicalIndex) const {
+  for (const auto& reg : cregs) {
+    auto startIdx = reg.second.first;
+    auto count = reg.second.second;
+    if (classicalIndex < startIdx) {
+      continue;
+    }
+    if (classicalIndex >= startIdx + count) {
+      continue;
+    }
+    return reg.first;
+  }
+
+  throw QFRException("[getClassicalRegister] Classical index " +
+                     std::to_string(classicalIndex) +
+                     " not found in any register");
+}
+
+std::pair<std::string, Bit> QuantumComputation::getClassicalRegisterAndIndex(
+    const Bit classicalIndex) const {
+  const std::string regName = getClassicalRegister(classicalIndex);
+  std::size_t index = 0;
+  auto it = cregs.find(regName);
+  if (it != cregs.end()) {
+    index = classicalIndex - it->second.first;
+  } // else branch not needed since getClassicalRegister already covers this
+    // case
+  return {regName, index};
+}
+
+Qubit QuantumComputation::getIndexFromQubitRegister(
+    const std::pair<std::string, Qubit>& qubit) const {
+  // no range check is performed here!
+  return qregs.at(qubit.first).first + qubit.second;
+}
+Bit QuantumComputation::getIndexFromClassicalRegister(
+    const std::pair<std::string, std::size_t>& clbit) const {
+  // no range check is performed here!
+  return cregs.at(clbit.first).first + clbit.second;
+}
+
+std::ostream&
+QuantumComputation::printPermutation(const Permutation& permutation,
+                                     std::ostream& os) {
+  for (const auto& [physical, logical] : permutation) {
+    os << "\t" << physical << ": " << logical << std::endl;
+  }
+  return os;
+}
+
+std::ostream& QuantumComputation::printRegisters(std::ostream& os) const {
+  os << "qregs:";
+  for (const auto& qreg : qregs) {
+    os << " {" << qreg.first << ", {" << qreg.second.first << ", "
+       << qreg.second.second << "}}";
+  }
+  os << std::endl;
+  if (!ancregs.empty()) {
+    os << "ancregs:";
+    for (const auto& ancreg : ancregs) {
+      os << " {" << ancreg.first << ", {" << ancreg.second.first << ", "
+         << ancreg.second.second << "}}";
+    }
+    os << std::endl;
+  }
+  os << "cregs:";
+  for (const auto& creg : cregs) {
+    os << " {" << creg.first << ", {" << creg.second.first << ", "
+       << creg.second.second << "}}";
+  }
+  os << std::endl;
+  return os;
+}
+
+Qubit QuantumComputation::getHighestLogicalQubitIndex(
+    const Permutation& permutation) {
+  Qubit maxIndex = 0;
+  for (const auto& [physical, logical] : permutation) {
+    maxIndex = std::max(maxIndex, logical);
+  }
+  return maxIndex;
+}
+
+bool QuantumComputation::physicalQubitIsAncillary(
+    const Qubit physicalQubitIndex) const {
+  return std::any_of(ancregs.cbegin(), ancregs.cend(),
+                     [&physicalQubitIndex](const auto& ancreg) {
+                       return ancreg.second.first <= physicalQubitIndex &&
+                              physicalQubitIndex <
+                                  ancreg.second.first + ancreg.second.second;
+                     });
+}
+
+void QuantumComputation::setLogicalQubitGarbage(const Qubit logicalQubitIndex) {
+  garbage[logicalQubitIndex] = true;
+  // setting a logical qubit garbage also means removing it from the output
+  // permutation if it was present before
+  for (auto it = outputPermutation.begin(); it != outputPermutation.end();
+       ++it) {
+    if (it->second == logicalQubitIndex) {
+      outputPermutation.erase(it);
+      break;
+    }
+  }
+}
+
+[[nodiscard]] std::pair<bool, std::optional<Qubit>>
+QuantumComputation::containsLogicalQubit(const Qubit logicalQubitIndex) const {
+  if (const auto it = std::find_if(initialLayout.cbegin(), initialLayout.cend(),
+                                   [&logicalQubitIndex](const auto& mapping) {
+                                     return mapping.second == logicalQubitIndex;
+                                   });
+      it != initialLayout.cend()) {
+    return {true, it->first};
+  }
+  return {false, std::nullopt};
+}
+
+bool QuantumComputation::isLastOperationOnQubit(
+    const const_iterator& opIt, const const_iterator& end) const {
+  if (opIt == end) {
+    return true;
+  }
+
+  // determine which qubits the gate acts on
+  std::vector<bool> actson(nqubits + nancillae);
+  for (std::size_t i = 0; i < actson.size(); ++i) {
+    if ((*opIt)->actsOn(static_cast<Qubit>(i))) {
+      actson[i] = true;
+    }
+  }
+
+  // iterate over remaining gates and check if any act on qubits overlapping
+  // with the target gate
+  auto atEnd = opIt;
+  std::advance(atEnd, 1);
+  while (atEnd != end) {
+    for (std::size_t i = 0; i < actson.size(); ++i) {
+      if (actson[i] && (*atEnd)->actsOn(static_cast<Qubit>(i))) {
+        return false;
+      }
+    }
+    ++atEnd;
+  }
+  return true;
+}
+
+void QuantumComputation::unifyQuantumRegisters(const std::string& regName) {
+  ancregs.clear();
+  qregs.clear();
+  qregs[regName] = {0, getNqubits()};
+  nancillae = 0;
+}
+
+void QuantumComputation::appendMeasurementsAccordingToOutputPermutation(
+    const std::string& registerName) {
+  // ensure that the circuit contains enough classical registers
+  if (cregs.empty()) {
+    // in case there are no registers, create a new one
+    addClassicalRegister(outputPermutation.size(), registerName);
+  } else if (nclassics < outputPermutation.size()) {
+    if (cregs.find(registerName) == cregs.end()) {
+      // in case there are registers but not enough, add a new one
+      addClassicalRegister(outputPermutation.size() - nclassics, registerName);
+    } else {
+      // in case the register already exists, augment it
+      nclassics += outputPermutation.size() - nclassics;
+      cregs[registerName].second = outputPermutation.size();
+    }
+  }
+  auto targets = std::vector<qc::Qubit>{};
+  for (std::size_t q = 0; q < getNqubits(); ++q) {
+    targets.emplace_back(q);
+  }
+  barrier(targets);
+  // append measurements according to output permutation
+  for (const auto& [qubit, clbit] : outputPermutation) {
+    measure(qubit, clbit);
+  }
+}
+
+void QuantumComputation::checkQubitRange(const Qubit qubit) const {
+  if (const auto it = initialLayout.find(qubit);
+      it == initialLayout.end() || it->second >= getNqubits()) {
+    throw QFRException("Qubit index out of range: " + std::to_string(qubit));
+  }
+}
+void QuantumComputation::checkQubitRange(const Qubit qubit,
+                                         const Controls& controls) const {
+  checkQubitRange(qubit);
+  for (const auto& [ctrl, _] : controls) {
+    checkQubitRange(ctrl);
+  }
+}
+
+void QuantumComputation::checkQubitRange(const Qubit qubit0, const Qubit qubit1,
+                                         const Controls& controls) const {
+  checkQubitRange(qubit0, controls);
+  checkQubitRange(qubit1);
+}
+
+void QuantumComputation::checkQubitRange(
+    const std::vector<Qubit>& qubits) const {
+  for (const auto& qubit : qubits) {
+    checkQubitRange(qubit);
+  }
+}
+
+void QuantumComputation::addVariable(const SymbolOrNumber& expr) {
+  if (std::holds_alternative<Symbolic>(expr)) {
+    const auto& sym = std::get<Symbolic>(expr);
+    for (const auto& term : sym) {
+      occuringVariables.insert(term.getVar());
+    }
+  }
+}
+
+// Instantiates this computation
+void QuantumComputation::instantiate(const VariableAssignment& assignment) {
+  for (auto& op : ops) {
+    if (auto* symOp = dynamic_cast<SymbolicOperation*>(op.get())) {
+      symOp->instantiate(assignment);
     }
+  }
+}
 } // namespace qc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/src/algorithms/BernsteinVazirani.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/algorithms/BernsteinVazirani.cpp`

 * *Files 16% similar despite different names*

```diff
@@ -1,115 +1,112 @@
-/*
- * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
- */
-
 #include "algorithms/BernsteinVazirani.hpp"
 
 namespace qc {
-    BernsteinVazirani::BernsteinVazirani(const BitString& hiddenString, const bool dyn):
-        s(hiddenString), dynamic(dyn) {
-        std::size_t msb = 0;
-        for (std::size_t i = 0; i < s.size(); ++i) {
-            if (s.test(i)) {
-                msb = i;
-            }
-        }
-        bitwidth = msb + 1;
-        createCircuit();
-    }
-
-    BernsteinVazirani::BernsteinVazirani(const std::size_t nq, const bool dyn):
-        bitwidth(nq), dynamic(dyn) {
-        auto distribution = std::bernoulli_distribution();
-        for (std::size_t i = 0; i < nq; ++i) {
-            if (distribution(mt)) {
-                s.set(i);
-            }
-        }
-        createCircuit();
-    }
-
-    BernsteinVazirani::BernsteinVazirani(const BitString& hiddenString, const std::size_t nq, const bool dyn):
-        s(hiddenString), bitwidth(nq), dynamic(dyn) {
-        createCircuit();
-    }
-
-    std::ostream& BernsteinVazirani::printStatistics(std::ostream& os) const {
-        os << "BernsteinVazirani (" << bitwidth << ") Statistics:\n";
-        os << "\tn: " << bitwidth + 1 << std::endl;
-        os << "\tm: " << getNindividualOps() << std::endl;
-        os << "\ts: " << expected << std::endl;
-        os << "\tdynamic: " << dynamic << std::endl;
-        os << "--------------" << std::endl;
-        return os;
-    }
-
-    void BernsteinVazirani::createCircuit() {
-        name = "bv_" + s.to_string();
-
-        expected = s.to_string();
-        std::reverse(expected.begin(), expected.end());
-        while (expected.length() > bitwidth) {
-            expected.pop_back();
-        }
-        std::reverse(expected.begin(), expected.end());
-
-        addQubitRegister(1, "flag");
-
-        if (dynamic) {
-            addQubitRegister(1, "q");
-        } else {
-            addQubitRegister(bitwidth, "q");
-        }
-
-        addClassicalRegister(bitwidth, "c");
-
-        // prepare flag qubit
-        x(0);
-
-        if (dynamic) {
-            for (std::size_t i = 0; i < bitwidth; ++i) {
-                // initial Hadamard
-                h(1);
-
-                // apply controlled-Z gate according to secret bitstring
-                if (s.test(i)) {
-                    z(0, 1_pc);
-                }
-
-                // final Hadamard
-                h(1);
-
-                // measure result
-                measure(1, i);
-
-                // reset qubit if not finished
-                if (i < bitwidth - 1) {
-                    reset(1);
-                }
-            }
-        } else {
-            // initial Hadamard transformation
-            for (std::size_t i = 1; i <= bitwidth; ++i) {
-                h(static_cast<Qubit>(i));
-            }
-
-            // apply controlled-Z gates according to secret bitstring
-            for (std::size_t i = 1; i <= bitwidth; ++i) {
-                if (s.test(i - 1)) {
-                    z(0, qc::Control{static_cast<Qubit>(i)});
-                }
-            }
-
-            // final Hadamard transformation
-            for (std::size_t i = 1; i <= bitwidth; ++i) {
-                h(static_cast<Qubit>(i));
-            }
-
-            // measure results
-            for (std::size_t i = 1; i <= bitwidth; i++) {
-                measure(static_cast<Qubit>(i), i - 1);
-            }
-        }
+BernsteinVazirani::BernsteinVazirani(const BitString& hiddenString,
+                                     const bool dyn)
+    : s(hiddenString), dynamic(dyn) {
+  std::size_t msb = 0;
+  for (std::size_t i = 0; i < s.size(); ++i) {
+    if (s.test(i)) {
+      msb = i;
+    }
+  }
+  bitwidth = msb + 1;
+  createCircuit();
+}
+
+BernsteinVazirani::BernsteinVazirani(const std::size_t nq, const bool dyn)
+    : bitwidth(nq), dynamic(dyn) {
+  auto distribution = std::bernoulli_distribution();
+  for (std::size_t i = 0; i < nq; ++i) {
+    if (distribution(mt)) {
+      s.set(i);
+    }
+  }
+  createCircuit();
+}
+
+BernsteinVazirani::BernsteinVazirani(const BitString& hiddenString,
+                                     const std::size_t nq, const bool dyn)
+    : s(hiddenString), bitwidth(nq), dynamic(dyn) {
+  createCircuit();
+}
+
+std::ostream& BernsteinVazirani::printStatistics(std::ostream& os) const {
+  os << "BernsteinVazirani (" << bitwidth << ") Statistics:\n";
+  os << "\tn: " << bitwidth + 1 << std::endl;
+  os << "\tm: " << getNindividualOps() << std::endl;
+  os << "\ts: " << expected << std::endl;
+  os << "\tdynamic: " << dynamic << std::endl;
+  os << "--------------" << std::endl;
+  return os;
+}
+
+void BernsteinVazirani::createCircuit() {
+  name = "bv_" + s.to_string();
+
+  expected = s.to_string();
+  std::reverse(expected.begin(), expected.end());
+  while (expected.length() > bitwidth) {
+    expected.pop_back();
+  }
+  std::reverse(expected.begin(), expected.end());
+
+  addQubitRegister(1, "flag");
+
+  if (dynamic) {
+    addQubitRegister(1, "q");
+  } else {
+    addQubitRegister(bitwidth, "q");
+  }
+
+  addClassicalRegister(bitwidth, "c");
+
+  // prepare flag qubit
+  x(0);
+
+  if (dynamic) {
+    for (std::size_t i = 0; i < bitwidth; ++i) {
+      // initial Hadamard
+      h(1);
+
+      // apply controlled-Z gate according to secret bitstring
+      if (s.test(i)) {
+        z(0, 1_pc);
+      }
+
+      // final Hadamard
+      h(1);
+
+      // measure result
+      measure(1, i);
+
+      // reset qubit if not finished
+      if (i < bitwidth - 1) {
+        reset(1);
+      }
+    }
+  } else {
+    // initial Hadamard transformation
+    for (std::size_t i = 1; i <= bitwidth; ++i) {
+      h(static_cast<Qubit>(i));
+    }
+
+    // apply controlled-Z gates according to secret bitstring
+    for (std::size_t i = 1; i <= bitwidth; ++i) {
+      if (s.test(i - 1)) {
+        z(0, qc::Control{static_cast<Qubit>(i)});
+      }
+    }
+
+    // final Hadamard transformation
+    for (std::size_t i = 1; i <= bitwidth; ++i) {
+      h(static_cast<Qubit>(i));
+    }
+
+    // measure results
+    for (std::size_t i = 1; i <= bitwidth; i++) {
+      measure(static_cast<Qubit>(i), i - 1);
     }
+  }
+}
 } // namespace qc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/src/algorithms/GoogleRandomCircuitSampling.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/algorithms/GoogleRandomCircuitSampling.cpp`

 * *Files 20% similar despite different names*

```diff
@@ -1,141 +1,150 @@
-/*
- * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
- */
-
 #include "algorithms/GoogleRandomCircuitSampling.hpp"
 
 #include <utility>
 
 namespace qc {
-    GoogleRandomCircuitSampling::GoogleRandomCircuitSampling(const std::string& filename) {
-        importGRCS(filename);
-    }
-
-    GoogleRandomCircuitSampling::GoogleRandomCircuitSampling(std::string prefix, const std::uint16_t device, const std::uint16_t depth, const std::uint16_t instance):
-        layout(Bristlecone), pathPrefix(std::move(prefix)) {
-        std::stringstream ss;
-        ss << pathPrefix;
-        ss << "bristlecone/cz_v2/bris_";
-        ss << device;
-        ss << "/bris_";
-        ss << device;
-        ss << "_";
-        ss << depth;
-        ss << "_";
-        ss << instance;
-        ss << ".txt";
-
-        importGRCS(ss.str());
-    }
-
-    GoogleRandomCircuitSampling::GoogleRandomCircuitSampling(std::string prefix, const std::uint16_t x, const std::uint16_t y, const std::uint16_t depth, const std::uint16_t instance):
-        pathPrefix(std::move(prefix)) {
-        std::stringstream ss;
-        ss << pathPrefix;
-        ss << "rectangular/cz_v2/";
-        ss << x;
-        ss << "x";
-        ss << y;
-        ss << "/inst_";
-        ss << x;
-        ss << "x";
-        ss << y;
-        ss << "_";
-        ss << depth;
-        ss << "_";
-        ss << instance;
-        ss << ".txt";
-        importGRCS(ss.str());
-    }
-
-    void GoogleRandomCircuitSampling::importGRCS(const std::string& filename) {
-        auto ifs = std::ifstream(filename);
-        if (!ifs.good()) {
-            std::cerr << "Error opening/reading from file: " << filename << std::endl;
-            exit(3);
-        }
-        const std::size_t slash     = filename.find_last_of('/');
-        const std::size_t dot       = filename.find_last_of('.');
-        std::string       benchmark = filename.substr(slash + 1, dot - slash - 1);
-        name                        = benchmark;
-        layout                      = (benchmark[0] == 'b') ? Bristlecone : Rectangular;
-        std::size_t nq{};
-        ifs >> nq;
-
-        addQubitRegister(nq);
-        addClassicalRegister(nq);
-
-        std::string line;
-        std::string identifier;
-        std::size_t control = 0;
-        std::size_t target  = 0;
-        std::size_t cycle   = 0;
-        while (std::getline(ifs, line)) {
-            if (line.empty()) {
-                continue;
-            }
-            std::stringstream ss(line);
-            ss >> cycle;
-            if (cycles.size() <= cycle) {
-                cycles.emplace_back();
-            }
-
-            ss >> identifier;
-            if (identifier == "cz") {
-                ss >> control;
-                ss >> target;
-                cycles[cycle].emplace_back(std::make_unique<StandardOperation>(nqubits, Control{static_cast<Qubit>(control)}, target, Z));
-            } else if (identifier == "is") {
-                ss >> control;
-                ss >> target;
-                cycles[cycle].emplace_back(std::make_unique<StandardOperation>(nqubits, qc::Controls{}, control, target, iSWAP));
-            } else {
-                ss >> target;
-                if (identifier == "h") {
-                    cycles[cycle].emplace_back(std::make_unique<StandardOperation>(nqubits, target, H));
-                } else if (identifier == "t") {
-                    cycles[cycle].emplace_back(std::make_unique<StandardOperation>(nqubits, target, T));
-                } else if (identifier == "x_1_2") {
-                    cycles[cycle].emplace_back(std::make_unique<StandardOperation>(nqubits, target, RX, std::vector{PI_2}));
-                } else if (identifier == "y_1_2") {
-                    cycles[cycle].emplace_back(std::make_unique<StandardOperation>(nqubits, target, RY, std::vector{PI_2}));
-                } else {
-                    throw QFRException("Unknown gate '" + identifier);
-                }
-            }
-        }
-    }
-
-    std::size_t GoogleRandomCircuitSampling::getNops() const {
-        std::size_t nops = 0;
-        for (const auto& cycle: cycles) {
-            nops += cycle.size();
-        }
-        return nops;
-    }
-
-    std::ostream& GoogleRandomCircuitSampling::print(std::ostream& os) const {
-        std::size_t i = 0;
-        std::size_t j = 0;
-        for (const auto& cycle: cycles) {
-            os << "Cycle " << i++ << ":\n";
-            for (const auto& op: cycle) {
-                os << std::setw(static_cast<int>(std::log10(getNops()) + 1.)) << ++j << ": ";
-                op->print(os, initialLayout);
-                os << std::endl;
-            }
-        }
-        return os;
-    }
-
-    std::ostream& GoogleRandomCircuitSampling::printStatistics(std::ostream& os) const {
-        os << "GoogleRandomCircuitSampling Statistics:\n";
-        os << "\tLayout: " << ((layout == Rectangular) ? "Rectangular" : "Bristlecone") << std::endl;
-        os << "\tn: " << static_cast<std::size_t>(nqubits) << std::endl;
-        os << "\tm: " << getNops() << std::endl;
-        os << "\tc: 1 + " << cycles.size() - 2 << " + 1" << std::endl;
-        os << "--------------" << std::endl;
-        return os;
-    }
+GoogleRandomCircuitSampling::GoogleRandomCircuitSampling(
+    const std::string& filename) {
+  importGRCS(filename);
+}
+
+GoogleRandomCircuitSampling::GoogleRandomCircuitSampling(
+    std::string prefix, const std::uint16_t device, const std::uint16_t depth,
+    const std::uint16_t instance)
+    : layout(Bristlecone), pathPrefix(std::move(prefix)) {
+  std::stringstream ss;
+  ss << pathPrefix;
+  ss << "bristlecone/cz_v2/bris_";
+  ss << device;
+  ss << "/bris_";
+  ss << device;
+  ss << "_";
+  ss << depth;
+  ss << "_";
+  ss << instance;
+  ss << ".txt";
+
+  importGRCS(ss.str());
+}
+
+GoogleRandomCircuitSampling::GoogleRandomCircuitSampling(
+    std::string prefix, const std::uint16_t x, const std::uint16_t y,
+    const std::uint16_t depth, const std::uint16_t instance)
+    : pathPrefix(std::move(prefix)) {
+  std::stringstream ss;
+  ss << pathPrefix;
+  ss << "rectangular/cz_v2/";
+  ss << x;
+  ss << "x";
+  ss << y;
+  ss << "/inst_";
+  ss << x;
+  ss << "x";
+  ss << y;
+  ss << "_";
+  ss << depth;
+  ss << "_";
+  ss << instance;
+  ss << ".txt";
+  importGRCS(ss.str());
+}
+
+void GoogleRandomCircuitSampling::importGRCS(const std::string& filename) {
+  auto ifs = std::ifstream(filename);
+  if (!ifs.good()) {
+    std::cerr << "Error opening/reading from file: " << filename << std::endl;
+    exit(3);
+  }
+  const std::size_t slash = filename.find_last_of('/');
+  const std::size_t dot = filename.find_last_of('.');
+  std::string benchmark = filename.substr(slash + 1, dot - slash - 1);
+  name = benchmark;
+  layout = (benchmark[0] == 'b') ? Bristlecone : Rectangular;
+  std::size_t nq{};
+  ifs >> nq;
+
+  addQubitRegister(nq);
+  addClassicalRegister(nq);
+
+  std::string line;
+  std::string identifier;
+  std::size_t control = 0;
+  std::size_t target = 0;
+  std::size_t cycle = 0;
+  while (std::getline(ifs, line)) {
+    if (line.empty()) {
+      continue;
+    }
+    std::stringstream ss(line);
+    ss >> cycle;
+    if (cycles.size() <= cycle) {
+      cycles.emplace_back();
+    }
+
+    ss >> identifier;
+    if (identifier == "cz") {
+      ss >> control;
+      ss >> target;
+      cycles[cycle].emplace_back(std::make_unique<StandardOperation>(
+          nqubits, Control{static_cast<Qubit>(control)}, target, Z));
+    } else if (identifier == "is") {
+      ss >> control;
+      ss >> target;
+      cycles[cycle].emplace_back(std::make_unique<StandardOperation>(
+          nqubits, qc::Controls{}, control, target, iSWAP));
+    } else {
+      ss >> target;
+      if (identifier == "h") {
+        cycles[cycle].emplace_back(
+            std::make_unique<StandardOperation>(nqubits, target, H));
+      } else if (identifier == "t") {
+        cycles[cycle].emplace_back(
+            std::make_unique<StandardOperation>(nqubits, target, T));
+      } else if (identifier == "x_1_2") {
+        cycles[cycle].emplace_back(std::make_unique<StandardOperation>(
+            nqubits, target, RX, std::vector{PI_2}));
+      } else if (identifier == "y_1_2") {
+        cycles[cycle].emplace_back(std::make_unique<StandardOperation>(
+            nqubits, target, RY, std::vector{PI_2}));
+      } else {
+        throw QFRException("Unknown gate '" + identifier);
+      }
+    }
+  }
+}
+
+std::size_t GoogleRandomCircuitSampling::getNops() const {
+  std::size_t nops = 0;
+  for (const auto& cycle : cycles) {
+    nops += cycle.size();
+  }
+  return nops;
+}
+
+std::ostream& GoogleRandomCircuitSampling::print(std::ostream& os) const {
+  std::size_t i = 0;
+  std::size_t j = 0;
+  for (const auto& cycle : cycles) {
+    os << "Cycle " << i++ << ":\n";
+    for (const auto& op : cycle) {
+      os << std::setw(static_cast<int>(std::log10(getNops()) + 1.)) << ++j
+         << ": ";
+      op->print(os, initialLayout);
+      os << std::endl;
+    }
+  }
+  return os;
+}
+
+std::ostream&
+GoogleRandomCircuitSampling::printStatistics(std::ostream& os) const {
+  os << "GoogleRandomCircuitSampling Statistics:\n";
+  os << "\tLayout: "
+     << ((layout == Rectangular) ? "Rectangular" : "Bristlecone") << std::endl;
+  os << "\tn: " << static_cast<std::size_t>(nqubits) << std::endl;
+  os << "\tm: " << getNops() << std::endl;
+  os << "\tc: 1 + " << cycles.size() - 2 << " + 1" << std::endl;
+  os << "--------------" << std::endl;
+  return os;
+}
 } // namespace qc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/src/algorithms/Grover.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/algorithms/Grover.cpp`

 * *Files 16% similar despite different names*

```diff
@@ -1,115 +1,116 @@
-/*
- * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
- */
-
 #include "algorithms/Grover.hpp"
 
 namespace qc {
-    /***
-     * Private Methods
-     ***/
-    void Grover::setup(QuantumComputation& qc) const {
-        qc.x(static_cast<Qubit>(nDataQubits));
-        for (std::size_t i = 0; i < nDataQubits; ++i) {
-            qc.h(static_cast<Qubit>(i));
-        }
-    }
-
-    void Grover::oracle(QuantumComputation& qc) const {
-        Controls controls{};
-        for (std::size_t i = 0; i < nDataQubits; ++i) {
-            controls.emplace(Control{static_cast<Qubit>(i), targetValue.test(i) ? Control::Type::Pos : Control::Type::Neg});
-        }
-        qc.z(static_cast<Qubit>(nDataQubits), controls);
-    }
-
-    void Grover::diffusion(QuantumComputation& qc) const {
-        for (std::size_t i = 0; i < nDataQubits; ++i) {
-            qc.h(static_cast<Qubit>(i));
-        }
-        for (std::size_t i = 0; i < nDataQubits; ++i) {
-            qc.x(static_cast<Qubit>(i));
-        }
-
-        qc.h(0);
-        Controls controls{};
-        for (Qubit j = 1; j < nDataQubits; ++j) {
-            controls.emplace(Control{j});
-        }
-        qc.x(0, controls);
-        qc.h(0);
-
-        for (auto i = static_cast<std::make_signed_t<Qubit>>(nDataQubits - 1); i >= 0; --i) {
-            qc.x(static_cast<Qubit>(i));
-        }
-        for (auto i = static_cast<std::make_signed_t<Qubit>>(nDataQubits - 1); i >= 0; --i) {
-            qc.h(static_cast<Qubit>(i));
-        }
-    }
-
-    void Grover::fullGrover(QuantumComputation& qc) const {
-        // create initial superposition
-        setup(qc);
-
-        // apply Grover iterations
-        for (std::size_t j = 0; j < iterations; ++j) {
-            oracle(qc);
-            diffusion(qc);
-        }
-
-        // measure the resulting state
-        for (std::size_t i = 0; i < nDataQubits; ++i) {
-            qc.measure(static_cast<Qubit>(i), i);
-        }
-    }
-
-    /***
-     * Public Methods
-     ***/
-    Grover::Grover(std::size_t nq, std::size_t s):
-        seed(s), nDataQubits(nq) {
-        name = "grover_" + std::to_string(nq);
-
-        addQubitRegister(nDataQubits, "q");
-        addQubitRegister(1, "flag");
-        addClassicalRegister(nDataQubits);
-
-        mt.seed(seed);
-
-        std::bernoulli_distribution distribution{};
-        for (std::size_t i = 0; i < nDataQubits; i++) {
-            if (distribution(mt)) {
-                targetValue.set(i);
-            }
-        }
-
-        expected = targetValue.to_string();
-        std::reverse(expected.begin(), expected.end());
-        while (expected.length() > nqubits - 1) {
-            expected.pop_back();
-        }
-        std::reverse(expected.begin(), expected.end());
-
-        if (nDataQubits <= 2) {
-            iterations = 1;
-        } else if (nDataQubits % 2 == 1) {
-            iterations = static_cast<std::size_t>(std::round(PI_4 * std::pow(2., static_cast<double>(nDataQubits + 1) / 2. - 1.) * std::sqrt(2)));
-        } else {
-            iterations = static_cast<std::size_t>(std::round(PI_4 * std::pow(2., static_cast<double>(nDataQubits) / 2.)));
-        }
-
-        fullGrover(*this);
-    }
-
-    std::ostream& Grover::printStatistics(std::ostream& os) const {
-        os << "Grover (" << nqubits - 1 << ") Statistics:\n";
-        os << "\tn: " << nqubits << std::endl;
-        os << "\tm: " << getNindividualOps() << std::endl;
-        os << "\tseed: " << seed << std::endl;
-        os << "\tx: " << expected << std::endl;
-        os << "\ti: " << iterations << std::endl;
-        os << "--------------" << std::endl;
-        return os;
-    }
+/***
+ * Private Methods
+ ***/
+void Grover::setup(QuantumComputation& qc) const {
+  qc.x(static_cast<Qubit>(nDataQubits));
+  for (std::size_t i = 0; i < nDataQubits; ++i) {
+    qc.h(static_cast<Qubit>(i));
+  }
+}
+
+void Grover::oracle(QuantumComputation& qc) const {
+  Controls controls{};
+  for (std::size_t i = 0; i < nDataQubits; ++i) {
+    controls.emplace(Control{static_cast<Qubit>(i), targetValue.test(i)
+                                                        ? Control::Type::Pos
+                                                        : Control::Type::Neg});
+  }
+  qc.z(static_cast<Qubit>(nDataQubits), controls);
+}
+
+void Grover::diffusion(QuantumComputation& qc) const {
+  for (std::size_t i = 0; i < nDataQubits; ++i) {
+    qc.h(static_cast<Qubit>(i));
+  }
+  for (std::size_t i = 0; i < nDataQubits; ++i) {
+    qc.x(static_cast<Qubit>(i));
+  }
+
+  qc.h(0);
+  Controls controls{};
+  for (Qubit j = 1; j < nDataQubits; ++j) {
+    controls.emplace(Control{j});
+  }
+  qc.x(0, controls);
+  qc.h(0);
+
+  for (auto i = static_cast<std::make_signed_t<Qubit>>(nDataQubits - 1); i >= 0;
+       --i) {
+    qc.x(static_cast<Qubit>(i));
+  }
+  for (auto i = static_cast<std::make_signed_t<Qubit>>(nDataQubits - 1); i >= 0;
+       --i) {
+    qc.h(static_cast<Qubit>(i));
+  }
+}
+
+void Grover::fullGrover(QuantumComputation& qc) const {
+  // create initial superposition
+  setup(qc);
+
+  // apply Grover iterations
+  for (std::size_t j = 0; j < iterations; ++j) {
+    oracle(qc);
+    diffusion(qc);
+  }
+
+  // measure the resulting state
+  for (std::size_t i = 0; i < nDataQubits; ++i) {
+    qc.measure(static_cast<Qubit>(i), i);
+  }
+}
+
+/***
+ * Public Methods
+ ***/
+Grover::Grover(std::size_t nq, std::size_t s) : seed(s), nDataQubits(nq) {
+  name = "grover_" + std::to_string(nq);
+
+  addQubitRegister(nDataQubits, "q");
+  addQubitRegister(1, "flag");
+  addClassicalRegister(nDataQubits);
+
+  mt.seed(seed);
+
+  std::bernoulli_distribution distribution{};
+  for (std::size_t i = 0; i < nDataQubits; i++) {
+    if (distribution(mt)) {
+      targetValue.set(i);
+    }
+  }
+
+  expected = targetValue.to_string();
+  std::reverse(expected.begin(), expected.end());
+  while (expected.length() > nqubits - 1) {
+    expected.pop_back();
+  }
+  std::reverse(expected.begin(), expected.end());
+
+  if (nDataQubits <= 2) {
+    iterations = 1;
+  } else if (nDataQubits % 2 == 1) {
+    iterations = static_cast<std::size_t>(std::round(
+        PI_4 * std::pow(2., static_cast<double>(nDataQubits + 1) / 2. - 1.) *
+        std::sqrt(2)));
+  } else {
+    iterations = static_cast<std::size_t>(
+        std::round(PI_4 * std::pow(2., static_cast<double>(nDataQubits) / 2.)));
+  }
+
+  fullGrover(*this);
+}
+
+std::ostream& Grover::printStatistics(std::ostream& os) const {
+  os << "Grover (" << nqubits - 1 << ") Statistics:\n";
+  os << "\tn: " << nqubits << std::endl;
+  os << "\tm: " << getNindividualOps() << std::endl;
+  os << "\tseed: " << seed << std::endl;
+  os << "\tx: " << expected << std::endl;
+  os << "\ti: " << iterations << std::endl;
+  os << "--------------" << std::endl;
+  return os;
+}
 } // namespace qc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/src/algorithms/QFT.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/algorithms/QFT.cpp`

 * *Files 20% similar despite different names*

```diff
@@ -1,99 +1,95 @@
-/*
- * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
- */
-
 #include "algorithms/QFT.hpp"
 
 namespace qc {
-    QFT::QFT(const std::size_t nq, const bool includeMeas, const bool dyn):
-        precision(nq), includeMeasurements(includeMeas), dynamic(dyn) {
-        name = "qft_" + std::to_string(nq);
-        if (precision == 0) {
-            return;
-        }
-
-        if (dynamic) {
-            addQubitRegister(1);
+QFT::QFT(const std::size_t nq, const bool includeMeas, const bool dyn)
+    : precision(nq), includeMeasurements(includeMeas), dynamic(dyn) {
+  name = "qft_" + std::to_string(nq);
+  if (precision == 0) {
+    return;
+  }
+
+  if (dynamic) {
+    addQubitRegister(1);
+  } else {
+    addQubitRegister(precision);
+  }
+  addClassicalRegister(precision);
+  createCircuit();
+}
+
+std::ostream& QFT::printStatistics(std::ostream& os) const {
+  os << "QFT (" << precision << ") Statistics:\n";
+  os << "\tn: " << nqubits << std::endl;
+  os << "\tm: " << getNindividualOps() << std::endl;
+  os << "\tdynamic: " << dynamic << std::endl;
+  os << "--------------" << std::endl;
+  return os;
+}
+void QFT::createCircuit() {
+  if (dynamic) {
+    for (std::size_t i = 0; i < precision; i++) {
+      // apply classically controlled phase rotations
+      for (std::size_t j = 1; j <= i; ++j) {
+        const auto d = static_cast<Qubit>(precision - j);
+        if (j == i) {
+          classicControlled(S, 0, {d, 1U}, 1U);
+        } else if (j == i - 1) {
+          classicControlled(T, 0, {d, 1U}, 1U);
         } else {
-            addQubitRegister(precision);
+          const auto powerOfTwo = std::pow(2., i - j + 1);
+          const auto lambda = PI / powerOfTwo;
+          classicControlled(Phase, 0, {d, 1U}, 1U, std::vector{lambda});
         }
-        addClassicalRegister(precision);
-        createCircuit();
-    }
+      }
+
+      // apply Hadamard
+      h(0);
 
-    std::ostream& QFT::printStatistics(std::ostream& os) const {
-        os << "QFT (" << precision << ") Statistics:\n";
-        os << "\tn: " << nqubits << std::endl;
-        os << "\tm: " << getNindividualOps() << std::endl;
-        os << "\tdynamic: " << dynamic << std::endl;
-        os << "--------------" << std::endl;
-        return os;
+      // measure result
+      measure(0, precision - 1 - i);
+
+      // reset qubit if not finished
+      if (i < precision - 1) {
+        reset(0);
+      }
     }
-    void QFT::createCircuit() {
-        if (dynamic) {
-            for (std::size_t i = 0; i < precision; i++) {
-                // apply classically controlled phase rotations
-                for (std::size_t j = 1; j <= i; ++j) {
-                    const auto d = static_cast<Qubit>(precision - j);
-                    if (j == i) {
-                        classicControlled(S, 0, {d, 1U}, 1U);
-                    } else if (j == i - 1) {
-                        classicControlled(T, 0, {d, 1U}, 1U);
-                    } else {
-                        const auto powerOfTwo = std::pow(2., i - j + 1);
-                        const auto lambda     = PI / powerOfTwo;
-                        classicControlled(Phase, 0, {d, 1U}, 1U, std::vector{lambda});
-                    }
-                }
-
-                // apply Hadamard
-                h(0);
-
-                // measure result
-                measure(0, precision - 1 - i);
-
-                // reset qubit if not finished
-                if (i < precision - 1) {
-                    reset(0);
-                }
-            }
+  } else {
+    // apply quantum Fourier transform
+    for (std::size_t i = 0; i < precision; ++i) {
+      const auto q = static_cast<Qubit>(i);
+
+      // apply controlled rotations
+      for (std::size_t j = i; j > 0; --j) {
+        const auto d = static_cast<Qubit>(q - j);
+        if (j == 1) {
+          s(d, Control{q});
+        } else if (j == 2) {
+          t(d, Control{q});
         } else {
-            // apply quantum Fourier transform
-            for (std::size_t i = 0; i < precision; ++i) {
-                const auto q = static_cast<Qubit>(i);
-
-                // apply controlled rotations
-                for (std::size_t j = i; j > 0; --j) {
-                    const auto d = static_cast<Qubit>(q - j);
-                    if (j == 1) {
-                        s(d, Control{q});
-                    } else if (j == 2) {
-                        t(d, Control{q});
-                    } else {
-                        const auto powerOfTwo = std::pow(2., j);
-                        const auto lambda     = PI / powerOfTwo;
-                        phase(d, Control{q}, lambda);
-                    }
-                }
-
-                // apply Hadamard
-                h(q);
-            }
-
-            if (includeMeasurements) {
-                // measure qubits in reverse order
-                for (std::size_t i = 0; i < precision; ++i) {
-                    measure(static_cast<Qubit>(i), precision - 1 - i);
-                }
-            } else {
-                for (Qubit i = 0; i < static_cast<Qubit>(precision / 2); ++i) {
-                    swap(i, static_cast<Qubit>(precision - 1 - i));
-                }
-                for (std::size_t i = 0; i < precision; ++i) {
-                    outputPermutation[static_cast<Qubit>(i)] = static_cast<Qubit>(precision - 1 - i);
-                }
-            }
+          const auto powerOfTwo = std::pow(2., j);
+          const auto lambda = PI / powerOfTwo;
+          phase(d, Control{q}, lambda);
         }
+      }
+
+      // apply Hadamard
+      h(q);
+    }
+
+    if (includeMeasurements) {
+      // measure qubits in reverse order
+      for (std::size_t i = 0; i < precision; ++i) {
+        measure(static_cast<Qubit>(i), precision - 1 - i);
+      }
+    } else {
+      for (Qubit i = 0; i < static_cast<Qubit>(precision / 2); ++i) {
+        swap(i, static_cast<Qubit>(precision - 1 - i));
+      }
+      for (std::size_t i = 0; i < precision; ++i) {
+        outputPermutation[static_cast<Qubit>(i)] =
+            static_cast<Qubit>(precision - 1 - i);
+      }
     }
+  }
+}
 } // namespace qc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/src/algorithms/QPE.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/algorithms/QPE.cpp`

 * *Files 21% similar despite different names*

```diff
@@ -1,132 +1,134 @@
-/*
- * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
- */
-
 #include "algorithms/QPE.hpp"
 
 namespace qc {
-    QPE::QPE(const std::size_t nq, const bool exact, const bool iter):
-        precision(nq), iterative(iter) {
-        if (exact) {
-            // if an exact solution is wanted, generate a random n-bit number and convert it to an appropriate phase
-            const std::uint64_t max          = 1ULL << nq;
-            auto                distribution = std::uniform_int_distribution<std::uint64_t>(0, max - 1);
-            std::uint64_t       theta        = 0;
-            while (theta == 0) {
-                theta = distribution(mt);
-            }
-            lambda = 0.;
-            for (std::size_t i = 0; i < nq; ++i) {
-                if ((theta & (1ULL << (nq - i - 1))) != 0) {
-                    lambda += 1. / static_cast<double>(1ULL << i);
-                }
-            }
-        } else {
-            // if an inexact solution is wanted, generate a random n+1-bit number (that has its last bit set) and convert it to an appropriate phase
-            const std::uint64_t max          = 1ULL << (nq + 1);
-            auto                distribution = std::uniform_int_distribution<std::uint64_t>(0, max - 1);
-            std::uint64_t       theta        = 0;
-            while (theta == 0 && (theta & 1) == 0) {
-                theta = distribution(mt);
-            }
-            lambda = 0.;
-            for (std::size_t i = 0; i <= nq; ++i) {
-                if ((theta & (1ULL << (nq - i))) != 0) {
-                    lambda += 1. / static_cast<double>(1ULL << i);
-                }
-            }
-        }
-        createCircuit();
+QPE::QPE(const std::size_t nq, const bool exact, const bool iter)
+    : precision(nq), iterative(iter) {
+  if (exact) {
+    // if an exact solution is wanted, generate a random n-bit number and
+    // convert it to an appropriate phase
+    const std::uint64_t max = 1ULL << nq;
+    auto distribution =
+        std::uniform_int_distribution<std::uint64_t>(0, max - 1);
+    std::uint64_t theta = 0;
+    while (theta == 0) {
+      theta = distribution(mt);
     }
-
-    QPE::QPE(const fp l, const std::size_t prec, const bool iter):
-        lambda(l), precision(prec), iterative(iter) {
-        createCircuit();
+    lambda = 0.;
+    for (std::size_t i = 0; i < nq; ++i) {
+      if ((theta & (1ULL << (nq - i - 1))) != 0) {
+        lambda += 1. / static_cast<double>(1ULL << i);
+      }
     }
-
-    std::ostream& QPE::printStatistics(std::ostream& os) const {
-        os << "QPE Statistics:\n";
-        os << "\tn: " << nqubits + 1 << std::endl;
-        os << "\tm: " << getNindividualOps() << std::endl;
-        os << "\tlambda: " << lambda << "" << std::endl;
-        os << "\tprecision: " << precision << std::endl;
-        os << "\titerative: " << iterative << std::endl;
-        os << "--------------" << std::endl;
-        return os;
+  } else {
+    // if an inexact solution is wanted, generate a random n+1-bit number (that
+    // has its last bit set) and convert it to an appropriate phase
+    const std::uint64_t max = 1ULL << (nq + 1);
+    auto distribution =
+        std::uniform_int_distribution<std::uint64_t>(0, max - 1);
+    std::uint64_t theta = 0;
+    while (theta == 0 && (theta & 1) == 0) {
+      theta = distribution(mt);
+    }
+    lambda = 0.;
+    for (std::size_t i = 0; i <= nq; ++i) {
+      if ((theta & (1ULL << (nq - i))) != 0) {
+        lambda += 1. / static_cast<double>(1ULL << i);
+      }
+    }
+  }
+  createCircuit();
+}
+
+QPE::QPE(const fp l, const std::size_t prec, const bool iter)
+    : lambda(l), precision(prec), iterative(iter) {
+  createCircuit();
+}
+
+std::ostream& QPE::printStatistics(std::ostream& os) const {
+  os << "QPE Statistics:\n";
+  os << "\tn: " << nqubits + 1 << std::endl;
+  os << "\tm: " << getNindividualOps() << std::endl;
+  os << "\tlambda: " << lambda << "" << std::endl;
+  os << "\tprecision: " << precision << std::endl;
+  os << "\titerative: " << iterative << std::endl;
+  os << "--------------" << std::endl;
+  return os;
+}
+
+void QPE::createCircuit() {
+  addQubitRegister(1, "psi");
+
+  if (iterative) {
+    addQubitRegister(1, "q");
+  } else {
+    addQubitRegister(precision, "q");
+  }
+
+  addClassicalRegister(precision, "c");
+
+  // prepare eigenvalue
+  x(0);
+
+  if (iterative) {
+    for (std::size_t i = 0; i < precision; i++) {
+      // Hadamard
+      h(1);
+
+      // normalize angle
+      const auto angle = std::remainder(
+          static_cast<double>(1ULL << (precision - 1 - i)) * lambda, 2.0);
+
+      // controlled phase rotation
+      phase(0, 1_pc, angle * PI);
+
+      // hybrid quantum-classical inverse QFT
+      for (std::size_t j = 0; j < i; j++) {
+        auto iQFTLambda = -PI / static_cast<double>(1ULL << (i - j));
+        classicControlled(Phase, 1, {j, 1U}, 1U, {iQFTLambda});
+      }
+      h(1);
+
+      // measure result
+      measure(1, i);
+
+      // reset qubit if not finished
+      if (i < precision - 1) {
+        reset(1);
+      }
+    }
+  } else {
+    // Hadamard Layer
+    for (std::size_t i = 1; i <= precision; i++) {
+      h(static_cast<Qubit>(i));
     }
 
-    void QPE::createCircuit() {
-        addQubitRegister(1, "psi");
-
-        if (iterative) {
-            addQubitRegister(1, "q");
+    for (std::size_t i = 0; i < precision; i++) {
+      // normalize angle
+      const auto angle = std::remainder(
+          static_cast<double>(1ULL << (precision - 1 - i)) * lambda, 2.0);
+
+      // controlled phase rotation
+      phase(0, Control{static_cast<Qubit>(1 + i)}, angle * PI);
+
+      // inverse QFT
+      for (std::size_t j = 1; j < 1 + i; j++) {
+        const auto iQFTLambda = -PI / static_cast<double>(2ULL << (i - j));
+        if (j == i) {
+          sdag(static_cast<Qubit>(1 + i), Control{static_cast<Qubit>(i)});
+        } else if (j == (i - 1)) {
+          tdag(static_cast<Qubit>(1 + i), Control{static_cast<Qubit>(i - 1)});
         } else {
-            addQubitRegister(precision, "q");
+          phase(static_cast<Qubit>(1 + i), Control{static_cast<Qubit>(j)},
+                iQFTLambda);
         }
+      }
+      h(static_cast<Qubit>(1 + i));
+    }
 
-        addClassicalRegister(precision, "c");
-
-        // prepare eigenvalue
-        x(0);
-
-        if (iterative) {
-            for (std::size_t i = 0; i < precision; i++) {
-                // Hadamard
-                h(1);
-
-                // normalize angle
-                const auto angle = std::remainder(static_cast<double>(1ULL << (precision - 1 - i)) * lambda, 2.0);
-
-                // controlled phase rotation
-                phase(0, 1_pc, angle * PI);
-
-                // hybrid quantum-classical inverse QFT
-                for (std::size_t j = 0; j < i; j++) {
-                    auto iQFTLambda = -PI / static_cast<double>(1ULL << (i - j));
-                    classicControlled(Phase, 1, {j, 1U}, 1U, {iQFTLambda});
-                }
-                h(1);
-
-                // measure result
-                measure(1, i);
-
-                // reset qubit if not finished
-                if (i < precision - 1) {
-                    reset(1);
-                }
-            }
-        } else {
-            // Hadamard Layer
-            for (std::size_t i = 1; i <= precision; i++) {
-                h(static_cast<Qubit>(i));
-            }
-
-            for (std::size_t i = 0; i < precision; i++) {
-                // normalize angle
-                const auto angle = std::remainder(static_cast<double>(1ULL << (precision - 1 - i)) * lambda, 2.0);
-
-                // controlled phase rotation
-                phase(0, Control{static_cast<Qubit>(1 + i)}, angle * PI);
-
-                // inverse QFT
-                for (std::size_t j = 1; j < 1 + i; j++) {
-                    const auto iQFTLambda = -PI / static_cast<double>(2ULL << (i - j));
-                    if (j == i) {
-                        sdag(static_cast<Qubit>(1 + i), Control{static_cast<Qubit>(i)});
-                    } else if (j == (i - 1)) {
-                        tdag(static_cast<Qubit>(1 + i), Control{static_cast<Qubit>(i - 1)});
-                    } else {
-                        phase(static_cast<Qubit>(1 + i), Control{static_cast<Qubit>(j)}, iQFTLambda);
-                    }
-                }
-                h(static_cast<Qubit>(1 + i));
-            }
-
-            // measure results
-            for (std::size_t i = 0; i < nqubits - 1; i++) {
-                measure(static_cast<Qubit>(i + 1), i);
-            }
-        }
+    // measure results
+    for (std::size_t i = 0; i < nqubits - 1; i++) {
+      measure(static_cast<Qubit>(i + 1), i);
     }
+  }
+}
 } // namespace qc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/src/algorithms/RandomCliffordCircuit.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/algorithms/RandomCliffordCircuit.cpp`

 * *Files 3% similar despite different names*

```diff
@@ -1,255 +1,264 @@
-/*
- * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
- */
-
 #include "algorithms/RandomCliffordCircuit.hpp"
 
 namespace qc {
 
-    RandomCliffordCircuit::RandomCliffordCircuit(const std::size_t nq, const std::size_t d, const std::size_t s):
-        depth(d), seed(s) {
-        addQubitRegister(nq);
-        addClassicalRegister(nq);
-
-        for (std::size_t i = 0; i < nqubits; ++i) {
-            initialLayout.insert({i, i});
-            outputPermutation.insert({i, i});
+RandomCliffordCircuit::RandomCliffordCircuit(const std::size_t nq,
+                                             const std::size_t d,
+                                             const std::size_t s)
+    : depth(d), seed(s) {
+  addQubitRegister(nq);
+  addClassicalRegister(nq);
+
+  for (std::size_t i = 0; i < nqubits; ++i) {
+    initialLayout.insert({i, i});
+    outputPermutation.insert({i, i});
+  }
+
+  std::mt19937_64 generator;
+  if (seed == 0) {
+    // this is probably overkill but better safe than sorry
+    std::array<std::mt19937_64::result_type, std::mt19937_64::state_size>
+        randomData{};
+    std::random_device rd;
+    std::generate(std::begin(randomData), std::end(randomData), std::ref(rd));
+    std::seed_seq seeds(std::begin(randomData), std::end(randomData));
+    generator.seed(seeds);
+  } else {
+    generator.seed(seed);
+  }
+  std::uniform_int_distribution<std::uint16_t> distribution(0, 11520);
+  cliffordGenerator = [&]() { return distribution(generator); };
+
+  for (std::size_t l = 0; l < depth; ++l) {
+    if (nqubits == 1) {
+      append1QClifford(cliffordGenerator(), 0);
+    } else if (nqubits == 2) {
+      append2QClifford(cliffordGenerator(), 0, 1);
+    } else {
+      if (l % 2 != 0) {
+        for (std::size_t i = 1; i < nqubits - 1; i += 2) {
+          append2QClifford(cliffordGenerator(), static_cast<Qubit>(i),
+                           static_cast<Qubit>(i + 1));
         }
-
-        std::mt19937_64 generator;
-        if (seed == 0) {
-            // this is probably overkill but better safe than sorry
-            std::array<std::mt19937_64::result_type, std::mt19937_64::state_size> randomData{};
-            std::random_device                                                    rd;
-            std::generate(std::begin(randomData), std::end(randomData), std::ref(rd));
-            std::seed_seq seeds(std::begin(randomData), std::end(randomData));
-            generator.seed(seeds);
-        } else {
-            generator.seed(seed);
+      } else {
+        for (std::size_t i = 0; i < nqubits - 1; i += 2) {
+          append2QClifford(cliffordGenerator(), static_cast<Qubit>(i),
+                           static_cast<Qubit>(i + 1));
         }
-        std::uniform_int_distribution<std::uint16_t> distribution(0, 11520);
-        cliffordGenerator = [&]() { return distribution(generator); };
+      }
+    }
+  }
+}
 
-        for (std::size_t l = 0; l < depth; ++l) {
-            if (nqubits == 1) {
-                append1QClifford(cliffordGenerator(), 0);
-            } else if (nqubits == 2) {
-                append2QClifford(cliffordGenerator(), 0, 1);
-            } else {
-                if (l % 2 != 0) {
-                    for (std::size_t i = 1; i < nqubits - 1; i += 2) {
-                        append2QClifford(cliffordGenerator(), static_cast<Qubit>(i), static_cast<Qubit>(i + 1));
-                    }
-                } else {
-                    for (std::size_t i = 0; i < nqubits - 1; i += 2) {
-                        append2QClifford(cliffordGenerator(), static_cast<Qubit>(i), static_cast<Qubit>(i + 1));
-                    }
-                }
-            }
-        }
+std::ostream& RandomCliffordCircuit::printStatistics(std::ostream& os) const {
+  os << "Random Clifford circuit statistics:\n";
+  os << "\tn: " << nqubits << std::endl;
+  os << "\tm: " << getNindividualOps() << std::endl;
+  os << "\tdepth: " << depth << std::endl;
+  os << "\tseed: " << seed << std::endl;
+  os << "--------------" << std::endl;
+  return os;
+}
+
+void RandomCliffordCircuit::append1QClifford(const std::uint16_t idx,
+                                             const Qubit target) {
+  const auto id = static_cast<std::uint8_t>(idx % 24);
+  emplace_back<CompoundOperation>(nqubits);
+  auto* comp = dynamic_cast<CompoundOperation*>(ops.back().get());
+  // Hadamard
+  if ((id / 12 % 2) != 0) {
+    comp->emplace_back<StandardOperation>(nqubits, target, H);
+  }
+
+  // Rotation
+  if (id / 4 % 3 == 1) {
+    comp->emplace_back<StandardOperation>(nqubits, target, H);
+    comp->emplace_back<StandardOperation>(nqubits, target, S);
+  } else if (id / 4 % 3 == 2) {
+    comp->emplace_back<StandardOperation>(nqubits, target, Sdag);
+    comp->emplace_back<StandardOperation>(nqubits, target, H);
+  }
+
+  // Pauli
+  if (id % 4 == 1) {
+    comp->emplace_back<StandardOperation>(nqubits, target, Z);
+  } else if (id % 4 == 2) {
+    comp->emplace_back<StandardOperation>(nqubits, target, X);
+  } else if (id % 4 == 3) {
+    comp->emplace_back<StandardOperation>(nqubits, target, Y);
+  }
+}
+
+void RandomCliffordCircuit::append2QClifford(const std::uint16_t idx,
+                                             const Qubit control,
+                                             const Qubit target) {
+  auto id = static_cast<std::uint16_t>(idx % 11520);
+  const auto pauliIdx = static_cast<std::uint8_t>(id % 16);
+  id /= 16;
+
+  emplace_back<CompoundOperation>(nqubits);
+  auto* comp = dynamic_cast<CompoundOperation*>(ops.back().get());
+  if (id < 36) {
+    // single-qubit Cliffords
+    if ((id / 9 % 2) != 0) {
+      comp->emplace_back<StandardOperation>(nqubits, control, H);
+    }
+    if ((id / 18 % 2) != 0) {
+      comp->emplace_back<StandardOperation>(nqubits, target, H);
     }
 
-    std::ostream& RandomCliffordCircuit::printStatistics(std::ostream& os) const {
-        os << "Random Clifford circuit statistics:\n";
-        os << "\tn: " << nqubits << std::endl;
-        os << "\tm: " << getNindividualOps() << std::endl;
-        os << "\tdepth: " << depth << std::endl;
-        os << "\tseed: " << seed << std::endl;
-        os << "--------------" << std::endl;
-        return os;
-    }
-
-    void RandomCliffordCircuit::append1QClifford(const std::uint16_t idx, const Qubit target) {
-        const auto id = static_cast<std::uint8_t>(idx % 24);
-        emplace_back<CompoundOperation>(nqubits);
-        auto* comp = dynamic_cast<CompoundOperation*>(ops.back().get());
-        // Hadamard
-        if ((id / 12 % 2) != 0) {
-            comp->emplace_back<StandardOperation>(nqubits, target, H);
-        }
+    if (id % 3 == 1) {
+      comp->emplace_back<StandardOperation>(nqubits, control, H);
+      comp->emplace_back<StandardOperation>(nqubits, control, S);
+    } else if (id % 3 == 2) {
+      comp->emplace_back<StandardOperation>(nqubits, control, Sdag);
+      comp->emplace_back<StandardOperation>(nqubits, control, H);
+    }
+    if (id / 3 % 3 == 1) {
+      comp->emplace_back<StandardOperation>(nqubits, target, H);
+      comp->emplace_back<StandardOperation>(nqubits, target, S);
+    } else if (id / 3 % 3 == 2) {
+      comp->emplace_back<StandardOperation>(nqubits, target, Sdag);
+      comp->emplace_back<StandardOperation>(nqubits, target, H);
+    }
+  } else if (id < 360) {
+    // Cliffords with a single CNOT
+    id -= 36;
 
-        // Rotation
-        if (id / 4 % 3 == 1) {
-            comp->emplace_back<StandardOperation>(nqubits, target, H);
-            comp->emplace_back<StandardOperation>(nqubits, target, S);
-        } else if (id / 4 % 3 == 2) {
-            comp->emplace_back<StandardOperation>(nqubits, target, Sdag);
-            comp->emplace_back<StandardOperation>(nqubits, target, H);
-        }
+    if ((id / 81 % 2) != 0) {
+      comp->emplace_back<StandardOperation>(nqubits, control, H);
+    }
+    if ((id / 162 % 2) != 0) {
+      comp->emplace_back<StandardOperation>(nqubits, target, H);
+    }
 
-        // Pauli
-        if (id % 4 == 1) {
-            comp->emplace_back<StandardOperation>(nqubits, target, Z);
-        } else if (id % 4 == 2) {
-            comp->emplace_back<StandardOperation>(nqubits, target, X);
-        } else if (id % 4 == 3) {
-            comp->emplace_back<StandardOperation>(nqubits, target, Y);
-        }
+    if (id % 3 == 1) {
+      comp->emplace_back<StandardOperation>(nqubits, control, H);
+      comp->emplace_back<StandardOperation>(nqubits, control, S);
+    } else if (id % 3 == 2) {
+      comp->emplace_back<StandardOperation>(nqubits, control, Sdag);
+      comp->emplace_back<StandardOperation>(nqubits, control, H);
+    }
+    if (id / 3 % 3 == 1) {
+      comp->emplace_back<StandardOperation>(nqubits, target, H);
+      comp->emplace_back<StandardOperation>(nqubits, target, S);
+    } else if (id / 3 % 3 == 2) {
+      comp->emplace_back<StandardOperation>(nqubits, target, Sdag);
+      comp->emplace_back<StandardOperation>(nqubits, target, H);
     }
 
-    void RandomCliffordCircuit::append2QClifford(const std::uint16_t idx, const Qubit control, const Qubit target) {
-        auto       id       = static_cast<std::uint16_t>(idx % 11520);
-        const auto pauliIdx = static_cast<std::uint8_t>(id % 16);
-        id /= 16;
-
-        emplace_back<CompoundOperation>(nqubits);
-        auto* comp = dynamic_cast<CompoundOperation*>(ops.back().get());
-        if (id < 36) {
-            // single-qubit Cliffords
-            if ((id / 9 % 2) != 0) {
-                comp->emplace_back<StandardOperation>(nqubits, control, H);
-            }
-            if ((id / 18 % 2) != 0) {
-                comp->emplace_back<StandardOperation>(nqubits, target, H);
-            }
-
-            if (id % 3 == 1) {
-                comp->emplace_back<StandardOperation>(nqubits, control, H);
-                comp->emplace_back<StandardOperation>(nqubits, control, S);
-            } else if (id % 3 == 2) {
-                comp->emplace_back<StandardOperation>(nqubits, control, Sdag);
-                comp->emplace_back<StandardOperation>(nqubits, control, H);
-            }
-            if (id / 3 % 3 == 1) {
-                comp->emplace_back<StandardOperation>(nqubits, target, H);
-                comp->emplace_back<StandardOperation>(nqubits, target, S);
-            } else if (id / 3 % 3 == 2) {
-                comp->emplace_back<StandardOperation>(nqubits, target, Sdag);
-                comp->emplace_back<StandardOperation>(nqubits, target, H);
-            }
-        } else if (id < 360) {
-            // Cliffords with a single CNOT
-            id -= 36;
-
-            if ((id / 81 % 2) != 0) {
-                comp->emplace_back<StandardOperation>(nqubits, control, H);
-            }
-            if ((id / 162 % 2) != 0) {
-                comp->emplace_back<StandardOperation>(nqubits, target, H);
-            }
-
-            if (id % 3 == 1) {
-                comp->emplace_back<StandardOperation>(nqubits, control, H);
-                comp->emplace_back<StandardOperation>(nqubits, control, S);
-            } else if (id % 3 == 2) {
-                comp->emplace_back<StandardOperation>(nqubits, control, Sdag);
-                comp->emplace_back<StandardOperation>(nqubits, control, H);
-            }
-            if (id / 3 % 3 == 1) {
-                comp->emplace_back<StandardOperation>(nqubits, target, H);
-                comp->emplace_back<StandardOperation>(nqubits, target, S);
-            } else if (id / 3 % 3 == 2) {
-                comp->emplace_back<StandardOperation>(nqubits, target, Sdag);
-                comp->emplace_back<StandardOperation>(nqubits, target, H);
-            }
-
-            comp->emplace_back<StandardOperation>(nqubits, qc::Control{control}, target, X);
-
-            if (id / 9 % 3 == 1) {
-                comp->emplace_back<StandardOperation>(nqubits, control, H);
-                comp->emplace_back<StandardOperation>(nqubits, control, S);
-            } else if (id / 9 % 3 == 2) {
-                comp->emplace_back<StandardOperation>(nqubits, control, Sdag);
-                comp->emplace_back<StandardOperation>(nqubits, control, H);
-            }
-            if (id / 27 % 3 == 1) {
-                comp->emplace_back<StandardOperation>(nqubits, target, H);
-                comp->emplace_back<StandardOperation>(nqubits, target, S);
-            } else if (id / 27 % 3 == 2) {
-                comp->emplace_back<StandardOperation>(nqubits, target, Sdag);
-                comp->emplace_back<StandardOperation>(nqubits, target, H);
-            }
-        } else if (id < 684) {
-            // Cliffords with two CNOTs
-            id -= 360;
-
-            if ((id / 81 % 2) != 0) {
-                comp->emplace_back<StandardOperation>(nqubits, control, H);
-            }
-            if ((id / 162 % 2) != 0) {
-                comp->emplace_back<StandardOperation>(nqubits, target, H);
-            }
-
-            if (id % 3 == 1) {
-                comp->emplace_back<StandardOperation>(nqubits, control, H);
-                comp->emplace_back<StandardOperation>(nqubits, control, S);
-            } else if (id % 3 == 2) {
-                comp->emplace_back<StandardOperation>(nqubits, control, Sdag);
-                comp->emplace_back<StandardOperation>(nqubits, control, H);
-            }
-            if (id / 3 % 3 == 1) {
-                comp->emplace_back<StandardOperation>(nqubits, target, H);
-                comp->emplace_back<StandardOperation>(nqubits, target, S);
-            } else if (id / 3 % 3 == 2) {
-                comp->emplace_back<StandardOperation>(nqubits, target, Sdag);
-                comp->emplace_back<StandardOperation>(nqubits, target, H);
-            }
-
-            comp->emplace_back<StandardOperation>(nqubits, qc::Control{control}, target, X);
-            comp->emplace_back<StandardOperation>(nqubits, qc::Control{target}, control, X);
-
-            if (id / 9 % 3 == 1) {
-                comp->emplace_back<StandardOperation>(nqubits, control, H);
-                comp->emplace_back<StandardOperation>(nqubits, control, S);
-            } else if (id / 9 % 3 == 2) {
-                comp->emplace_back<StandardOperation>(nqubits, control, Sdag);
-                comp->emplace_back<StandardOperation>(nqubits, control, H);
-            }
-            if (id / 27 % 3 == 1) {
-                comp->emplace_back<StandardOperation>(nqubits, target, H);
-                comp->emplace_back<StandardOperation>(nqubits, target, S);
-            } else if (id / 27 % 3 == 2) {
-                comp->emplace_back<StandardOperation>(nqubits, target, Sdag);
-                comp->emplace_back<StandardOperation>(nqubits, target, H);
-            }
-        } else {
-            // Cliffords with a SWAP
-            id -= 684;
-
-            if ((id / 9 % 2) != 0) {
-                comp->emplace_back<StandardOperation>(nqubits, control, H);
-            }
-            if ((id / 18 % 2) != 0) {
-                comp->emplace_back<StandardOperation>(nqubits, target, H);
-            }
-
-            if (id % 3 == 1) {
-                comp->emplace_back<StandardOperation>(nqubits, control, H);
-                comp->emplace_back<StandardOperation>(nqubits, control, S);
-            } else if (id % 3 == 2) {
-                comp->emplace_back<StandardOperation>(nqubits, control, Sdag);
-                comp->emplace_back<StandardOperation>(nqubits, control, H);
-            }
-            if (id / 3 % 3 == 1) {
-                comp->emplace_back<StandardOperation>(nqubits, target, H);
-                comp->emplace_back<StandardOperation>(nqubits, target, S);
-            } else if (id / 3 % 3 == 2) {
-                comp->emplace_back<StandardOperation>(nqubits, target, Sdag);
-                comp->emplace_back<StandardOperation>(nqubits, target, H);
-            }
-
-            comp->emplace_back<StandardOperation>(nqubits, qc::Control{control}, target, X);
-            comp->emplace_back<StandardOperation>(nqubits, qc::Control{target}, control, X);
-            comp->emplace_back<StandardOperation>(nqubits, qc::Control{control}, target, X);
-        }
+    comp->emplace_back<StandardOperation>(nqubits, qc::Control{control}, target,
+                                          X);
 
-        // random Pauli on control qubit
-        if (pauliIdx % 4 == 1) {
-            comp->emplace_back<StandardOperation>(nqubits, control, Z);
-        } else if (pauliIdx % 4 == 2) {
-            comp->emplace_back<StandardOperation>(nqubits, control, X);
-        } else if (pauliIdx % 4 == 3) {
-            comp->emplace_back<StandardOperation>(nqubits, control, Y);
-        }
+    if (id / 9 % 3 == 1) {
+      comp->emplace_back<StandardOperation>(nqubits, control, H);
+      comp->emplace_back<StandardOperation>(nqubits, control, S);
+    } else if (id / 9 % 3 == 2) {
+      comp->emplace_back<StandardOperation>(nqubits, control, Sdag);
+      comp->emplace_back<StandardOperation>(nqubits, control, H);
+    }
+    if (id / 27 % 3 == 1) {
+      comp->emplace_back<StandardOperation>(nqubits, target, H);
+      comp->emplace_back<StandardOperation>(nqubits, target, S);
+    } else if (id / 27 % 3 == 2) {
+      comp->emplace_back<StandardOperation>(nqubits, target, Sdag);
+      comp->emplace_back<StandardOperation>(nqubits, target, H);
+    }
+  } else if (id < 684) {
+    // Cliffords with two CNOTs
+    id -= 360;
 
-        // random Pauli on target qubit
-        if (pauliIdx / 4 == 1) {
-            comp->emplace_back<StandardOperation>(nqubits, target, Z);
-        } else if (pauliIdx / 4 == 2) {
-            comp->emplace_back<StandardOperation>(nqubits, target, X);
-        } else if (pauliIdx / 4 == 3) {
-            comp->emplace_back<StandardOperation>(nqubits, target, Y);
-        }
+    if ((id / 81 % 2) != 0) {
+      comp->emplace_back<StandardOperation>(nqubits, control, H);
+    }
+    if ((id / 162 % 2) != 0) {
+      comp->emplace_back<StandardOperation>(nqubits, target, H);
+    }
+
+    if (id % 3 == 1) {
+      comp->emplace_back<StandardOperation>(nqubits, control, H);
+      comp->emplace_back<StandardOperation>(nqubits, control, S);
+    } else if (id % 3 == 2) {
+      comp->emplace_back<StandardOperation>(nqubits, control, Sdag);
+      comp->emplace_back<StandardOperation>(nqubits, control, H);
+    }
+    if (id / 3 % 3 == 1) {
+      comp->emplace_back<StandardOperation>(nqubits, target, H);
+      comp->emplace_back<StandardOperation>(nqubits, target, S);
+    } else if (id / 3 % 3 == 2) {
+      comp->emplace_back<StandardOperation>(nqubits, target, Sdag);
+      comp->emplace_back<StandardOperation>(nqubits, target, H);
+    }
+
+    comp->emplace_back<StandardOperation>(nqubits, qc::Control{control}, target,
+                                          X);
+    comp->emplace_back<StandardOperation>(nqubits, qc::Control{target}, control,
+                                          X);
+
+    if (id / 9 % 3 == 1) {
+      comp->emplace_back<StandardOperation>(nqubits, control, H);
+      comp->emplace_back<StandardOperation>(nqubits, control, S);
+    } else if (id / 9 % 3 == 2) {
+      comp->emplace_back<StandardOperation>(nqubits, control, Sdag);
+      comp->emplace_back<StandardOperation>(nqubits, control, H);
     }
+    if (id / 27 % 3 == 1) {
+      comp->emplace_back<StandardOperation>(nqubits, target, H);
+      comp->emplace_back<StandardOperation>(nqubits, target, S);
+    } else if (id / 27 % 3 == 2) {
+      comp->emplace_back<StandardOperation>(nqubits, target, Sdag);
+      comp->emplace_back<StandardOperation>(nqubits, target, H);
+    }
+  } else {
+    // Cliffords with a SWAP
+    id -= 684;
+
+    if ((id / 9 % 2) != 0) {
+      comp->emplace_back<StandardOperation>(nqubits, control, H);
+    }
+    if ((id / 18 % 2) != 0) {
+      comp->emplace_back<StandardOperation>(nqubits, target, H);
+    }
+
+    if (id % 3 == 1) {
+      comp->emplace_back<StandardOperation>(nqubits, control, H);
+      comp->emplace_back<StandardOperation>(nqubits, control, S);
+    } else if (id % 3 == 2) {
+      comp->emplace_back<StandardOperation>(nqubits, control, Sdag);
+      comp->emplace_back<StandardOperation>(nqubits, control, H);
+    }
+    if (id / 3 % 3 == 1) {
+      comp->emplace_back<StandardOperation>(nqubits, target, H);
+      comp->emplace_back<StandardOperation>(nqubits, target, S);
+    } else if (id / 3 % 3 == 2) {
+      comp->emplace_back<StandardOperation>(nqubits, target, Sdag);
+      comp->emplace_back<StandardOperation>(nqubits, target, H);
+    }
+
+    comp->emplace_back<StandardOperation>(nqubits, qc::Control{control}, target,
+                                          X);
+    comp->emplace_back<StandardOperation>(nqubits, qc::Control{target}, control,
+                                          X);
+    comp->emplace_back<StandardOperation>(nqubits, qc::Control{control}, target,
+                                          X);
+  }
+
+  // random Pauli on control qubit
+  if (pauliIdx % 4 == 1) {
+    comp->emplace_back<StandardOperation>(nqubits, control, Z);
+  } else if (pauliIdx % 4 == 2) {
+    comp->emplace_back<StandardOperation>(nqubits, control, X);
+  } else if (pauliIdx % 4 == 3) {
+    comp->emplace_back<StandardOperation>(nqubits, control, Y);
+  }
+
+  // random Pauli on target qubit
+  if (pauliIdx / 4 == 1) {
+    comp->emplace_back<StandardOperation>(nqubits, target, Z);
+  } else if (pauliIdx / 4 == 2) {
+    comp->emplace_back<StandardOperation>(nqubits, target, X);
+  } else if (pauliIdx / 4 == 3) {
+    comp->emplace_back<StandardOperation>(nqubits, target, Y);
+  }
+}
 } // namespace qc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/src/dd/Operations.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/dd/Operations.cpp`

 * *Files 9% similar despite different names*

```diff
@@ -1,139 +1,142 @@
-/*
-* This file is part of MQT QFR library which is released under the MIT license.
-* See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
-*/
-
 #include "dd/Operations.hpp"
 
 namespace dd {
-    template<class Config>
-    void dumpTensor(qc::Operation* op, std::ostream& of, std::vector<std::size_t>& inds, size_t& gateIdx, std::unique_ptr<dd::Package<Config>>& dd) {
-        const auto type = op->getType();
-        if (op->isStandardOperation()) {
-            auto        nqubits  = op->getNqubits();
-            const auto& controls = op->getControls();
-            const auto& targets  = op->getTargets();
-
-            // start of tensor
-            of << "[";
-
-            // save tags including operation type, involved qubits, and gate index
-            of << "[\"" << op->getName() << "\", ";
-
-            // obtain an ordered map of involved qubits and add corresponding tags
-            std::map<qc::Qubit, std::variant<qc::Qubit, qc::Control>> orderedQubits{};
-            for (const auto& control: controls) {
-                orderedQubits.emplace(control.qubit, control);
-                of << "\"Q" << control.qubit << "\", ";
-            }
-            for (const auto& target: targets) {
-                orderedQubits.emplace(target, target);
-                of << "\"Q" << target << "\", ";
-            }
-            of << "\"GATE" << gateIdx << "\"], ";
-            ++gateIdx;
-
-            // generate indices
-            // in order to conform to the DD variable ordering that later provides the tensor data
-            // the ordered map has to be traversed in reverse order in order to correctly determine the indices
-            std::stringstream ssIn{};
-            std::stringstream ssOut{};
-            auto              iter  = orderedQubits.rbegin();
-            auto              qubit = iter->first;
-            auto&             idx   = inds[qubit];
-            ssIn << "\"q" << qubit << "_" << idx << "\"";
-            ++idx;
-            ssOut << "\"q" << qubit << "_" << idx << "\"";
-            ++iter;
-            while (iter != orderedQubits.rend()) {
-                qubit     = iter->first;
-                auto& ind = inds[qubit];
-                ssIn << ", \"q" << qubit << "_" << ind << "\"";
-                ++ind;
-                ssOut << ", \"q" << qubit << "_" << ind << "\"";
-                ++iter;
-            }
-            of << "[" << ssIn.str() << ", " << ssOut.str() << "], ";
-
-            // write tensor dimensions
-            const std::size_t localQubits  = targets.size() + controls.size();
-            const std::size_t globalQubits = nqubits;
-            of << "[";
-            for (std::size_t q = 0U; q < localQubits; ++q) {
-                if (q != 0U) {
-                    of << ", ";
-                }
-                of << 2 << ", " << 2;
-            }
-            of << "], ";
-
-            // obtain a local representation of the underlying operation
-            qc::Qubit    localIdx = 0;
-            qc::Controls localControls{};
-            qc::Targets  localTargets{};
-            for (const auto& [q, var]: orderedQubits) {
-                if (std::holds_alternative<qc::Qubit>(var)) {
-                    localTargets.emplace_back(localIdx);
-                } else {
-                    const auto* control = std::get_if<qc::Control>(&var);
-                    localControls.emplace(qc::Control{localIdx, control->type});
-                }
-                ++localIdx;
-            }
-            // temporarily change nqubits
-            op->setNqubits(localQubits);
-
-            // get DD for local operation
-            auto localOp = op->clone();
-            localOp->setControls(localControls);
-            localOp->setTargets(localTargets);
-            const auto localDD = getDD(localOp.get(), dd);
-
-            // translate local DD to matrix
-            const auto localMatrix = dd->getMatrix(localDD);
-
-            // restore nqubits
-            op->setNqubits(globalQubits);
-
-            // set appropriate precision for dumping numbers
-            const auto precision = of.precision();
-            of.precision(std::numeric_limits<dd::fp>::max_digits10);
-
-            // write tensor data
-            of << "[";
-            for (std::size_t row = 0U; row < localMatrix.size(); ++row) {
-                const auto& r = localMatrix[row];
-                for (std::size_t col = 0U; col < r.size(); ++col) {
-                    if (row != 0U || col != 0U) {
-                        of << ", ";
-                    }
-
-                    const auto& elem = r[col];
-                    of << "[" << elem.real() << ", " << elem.imag() << "]";
-                }
-            }
-            of << "]";
-
-            // restore old precision
-            of.precision(precision);
-
-            // end of tensor
-            of << "]";
-        } else if (auto* compoundOp = dynamic_cast<qc::CompoundOperation*>(op)) {
-            for (const auto& operation: *compoundOp) {
-                if (operation != (*compoundOp->begin())) {
-                    of << ",\n";
-                }
-                dumpTensor(operation.get(), of, inds, gateIdx, dd);
-            }
-        } else if (type == qc::Barrier || type == qc::ShowProbabilities || type == qc::Snapshot) {
-            return;
-        } else if (type == qc::Measure) {
-            std::clog << "Skipping measurement in tensor dump." << std::endl;
-        } else {
-            throw qc::QFRException("Dumping of tensors is currently only supported for StandardOperations.");
+template <class Config>
+void dumpTensor(qc::Operation* op, std::ostream& of,
+                std::vector<std::size_t>& inds, size_t& gateIdx,
+                std::unique_ptr<dd::Package<Config>>& dd) {
+  const auto type = op->getType();
+  if (op->isStandardOperation()) {
+    auto nqubits = op->getNqubits();
+    const auto& controls = op->getControls();
+    const auto& targets = op->getTargets();
+
+    // start of tensor
+    of << "[";
+
+    // save tags including operation type, involved qubits, and gate index
+    of << "[\"" << op->getName() << "\", ";
+
+    // obtain an ordered map of involved qubits and add corresponding tags
+    std::map<qc::Qubit, std::variant<qc::Qubit, qc::Control>> orderedQubits{};
+    for (const auto& control : controls) {
+      orderedQubits.emplace(control.qubit, control);
+      of << "\"Q" << control.qubit << "\", ";
+    }
+    for (const auto& target : targets) {
+      orderedQubits.emplace(target, target);
+      of << "\"Q" << target << "\", ";
+    }
+    of << "\"GATE" << gateIdx << "\"], ";
+    ++gateIdx;
+
+    // generate indices
+    // in order to conform to the DD variable ordering that later provides the
+    // tensor data the ordered map has to be traversed in reverse order in order
+    // to correctly determine the indices
+    std::stringstream ssIn{};
+    std::stringstream ssOut{};
+    auto iter = orderedQubits.rbegin();
+    auto qubit = iter->first;
+    auto& idx = inds[qubit];
+    ssIn << "\"q" << qubit << "_" << idx << "\"";
+    ++idx;
+    ssOut << "\"q" << qubit << "_" << idx << "\"";
+    ++iter;
+    while (iter != orderedQubits.rend()) {
+      qubit = iter->first;
+      auto& ind = inds[qubit];
+      ssIn << ", \"q" << qubit << "_" << ind << "\"";
+      ++ind;
+      ssOut << ", \"q" << qubit << "_" << ind << "\"";
+      ++iter;
+    }
+    of << "[" << ssIn.str() << ", " << ssOut.str() << "], ";
+
+    // write tensor dimensions
+    const std::size_t localQubits = targets.size() + controls.size();
+    const std::size_t globalQubits = nqubits;
+    of << "[";
+    for (std::size_t q = 0U; q < localQubits; ++q) {
+      if (q != 0U) {
+        of << ", ";
+      }
+      of << 2 << ", " << 2;
+    }
+    of << "], ";
+
+    // obtain a local representation of the underlying operation
+    qc::Qubit localIdx = 0;
+    qc::Controls localControls{};
+    qc::Targets localTargets{};
+    for (const auto& [q, var] : orderedQubits) {
+      if (std::holds_alternative<qc::Qubit>(var)) {
+        localTargets.emplace_back(localIdx);
+      } else {
+        const auto* control = std::get_if<qc::Control>(&var);
+        localControls.emplace(qc::Control{localIdx, control->type});
+      }
+      ++localIdx;
+    }
+    // temporarily change nqubits
+    op->setNqubits(localQubits);
+
+    // get DD for local operation
+    auto localOp = op->clone();
+    localOp->setControls(localControls);
+    localOp->setTargets(localTargets);
+    const auto localDD = getDD(localOp.get(), dd);
+
+    // translate local DD to matrix
+    const auto localMatrix = dd->getMatrix(localDD);
+
+    // restore nqubits
+    op->setNqubits(globalQubits);
+
+    // set appropriate precision for dumping numbers
+    const auto precision = of.precision();
+    of.precision(std::numeric_limits<dd::fp>::max_digits10);
+
+    // write tensor data
+    of << "[";
+    for (std::size_t row = 0U; row < localMatrix.size(); ++row) {
+      const auto& r = localMatrix[row];
+      for (std::size_t col = 0U; col < r.size(); ++col) {
+        if (row != 0U || col != 0U) {
+          of << ", ";
         }
+
+        const auto& elem = r[col];
+        of << "[" << elem.real() << ", " << elem.imag() << "]";
+      }
     }
+    of << "]";
+
+    // restore old precision
+    of.precision(precision);
 
-    template void dumpTensor<DDPackageConfig>(qc::Operation* op, std::ostream& of, std::vector<std::size_t>& inds, size_t& gateIdx, std::unique_ptr<dd::Package<DDPackageConfig>>& dd);
+    // end of tensor
+    of << "]";
+  } else if (auto* compoundOp = dynamic_cast<qc::CompoundOperation*>(op)) {
+    for (const auto& operation : *compoundOp) {
+      if (operation != (*compoundOp->begin())) {
+        of << ",\n";
+      }
+      dumpTensor(operation.get(), of, inds, gateIdx, dd);
+    }
+  } else if (type == qc::Barrier || type == qc::ShowProbabilities ||
+             type == qc::Snapshot) {
+    return;
+  } else if (type == qc::Measure) {
+    std::clog << "Skipping measurement in tensor dump." << std::endl;
+  } else {
+    throw qc::QFRException("Dumping of tensors is currently only supported for "
+                           "StandardOperations.");
+  }
+}
+
+template void
+dumpTensor<DDPackageConfig>(qc::Operation* op, std::ostream& of,
+                            std::vector<std::size_t>& inds, size_t& gateIdx,
+                            std::unique_ptr<dd::Package<DDPackageConfig>>& dd);
 } // namespace dd
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/src/dd/Simulation.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/dd/Simulation.cpp`

 * *Files 10% similar despite different names*

```diff
@@ -1,400 +1,468 @@
-/*
-* This file is part of MQT QFR library which is released under the MIT license.
-* See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
-*/
-
 #include "dd/Simulation.hpp"
 
 namespace dd {
-    template<class Config>
-    std::map<std::string, std::size_t> simulate(const QuantumComputation* qc, const VectorDD& in, std::unique_ptr<dd::Package<Config>>& dd, std::size_t shots, std::size_t seed) {
-        bool isDynamicCircuit = false;
-        bool hasMeasurements  = false;
-        bool measurementsLast = true;
-
-        std::mt19937_64 mt{};
-        if (seed != 0U) {
-            mt.seed(seed);
-        } else {
-            // create and properly seed rng
-            std::array<std::mt19937_64::result_type, std::mt19937_64::state_size> randomData{};
-            std::random_device                                                    rd;
-            std::generate(std::begin(randomData), std::end(randomData), [&rd]() { return rd(); });
-            std::seed_seq seeds(std::begin(randomData), std::end(randomData));
-            mt.seed(seeds);
-        }
+template <class Config>
+std::map<std::string, std::size_t>
+simulate(const QuantumComputation* qc, const VectorDD& in,
+         std::unique_ptr<dd::Package<Config>>& dd, std::size_t shots,
+         std::size_t seed) {
+  bool isDynamicCircuit = false;
+  bool hasMeasurements = false;
+  bool measurementsLast = true;
+
+  std::mt19937_64 mt{};
+  if (seed != 0U) {
+    mt.seed(seed);
+  } else {
+    // create and properly seed rng
+    std::array<std::mt19937_64::result_type, std::mt19937_64::state_size>
+        randomData{};
+    std::random_device rd;
+    std::generate(std::begin(randomData), std::end(randomData),
+                  [&rd]() { return rd(); });
+    std::seed_seq seeds(std::begin(randomData), std::end(randomData));
+    mt.seed(seeds);
+  }
+
+  std::map<dd::Qubit, std::size_t> measurementMap{};
+
+  // rudimentary check whether circuit is dynamic
+  for (const auto& op : *qc) {
+    // if it contains any dynamic circuit primitives, it certainly is dynamic
+    if (op->isClassicControlledOperation() || op->getType() == qc::Reset) {
+      isDynamicCircuit = true;
+      break;
+    }
 
-        std::map<dd::Qubit, std::size_t> measurementMap{};
+    // once a measurement is encountered we store the corresponding mapping
+    // (qubit -> bit)
+    if (op->getType() == qc::Measure) {
+      const auto* measure = dynamic_cast<qc::NonUnitaryOperation*>(op.get());
+      hasMeasurements = true;
+
+      const auto& quantum = measure->getTargets();
+      const auto& classic = measure->getClassics();
+
+      for (std::size_t i = 0; i < quantum.size(); ++i) {
+        measurementMap[static_cast<dd::Qubit>(quantum.at(i))] = classic.at(i);
+      }
+    }
 
-        // rudimentary check whether circuit is dynamic
-        for (const auto& op: *qc) {
-            // if it contains any dynamic circuit primitives, it certainly is dynamic
-            if (op->isClassicControlledOperation() || op->getType() == qc::Reset) {
-                isDynamicCircuit = true;
-                break;
-            }
+    // if an operation happens after a measurement, the resulting circuit can
+    // only be simulated in single shots
+    if (hasMeasurements &&
+        (op->isUnitary() || op->isClassicControlledOperation())) {
+      measurementsLast = false;
+    }
+  }
 
-            // once a measurement is encountered we store the corresponding mapping (qubit -> bit)
-            if (op->getType() == qc::Measure) {
-                const auto* measure = dynamic_cast<qc::NonUnitaryOperation*>(op.get());
-                hasMeasurements     = true;
-
-                const auto& quantum = measure->getTargets();
-                const auto& classic = measure->getClassics();
-
-                for (std::size_t i = 0; i < quantum.size(); ++i) {
-                    measurementMap[static_cast<dd::Qubit>(quantum.at(i))] = classic.at(i);
-                }
-            }
+  if (!measurementsLast) {
+    isDynamicCircuit = true;
+  }
+
+  if (!isDynamicCircuit) {
+    // if all gates are unitary (besides measurements at the end), we just
+    // simulate once and measure all qubits repeatedly
+    auto permutation = qc->initialLayout;
+    auto e = in;
+    dd->incRef(e);
+
+    for (const auto& op : *qc) {
+      // simply skip any non-unitary
+      if (!op->isUnitary()) {
+        continue;
+      }
+
+      auto tmp = dd->multiply(getDD(op.get(), dd, permutation), e);
+      dd->incRef(tmp);
+      dd->decRef(e);
+      e = tmp;
 
-            // if an operation happens after a measurement, the resulting circuit can only be simulated in single shots
-            if (hasMeasurements && (op->isUnitary() || op->isClassicControlledOperation())) {
-                measurementsLast = false;
-            }
-        }
+      dd->garbageCollect();
+    }
 
-        if (!measurementsLast) {
-            isDynamicCircuit = true;
-        }
+    // correct permutation if necessary
+    changePermutation(e, permutation, qc->outputPermutation, dd);
+    e = dd->reduceGarbage(e, qc->garbage);
+
+    // measure all qubits
+    std::map<std::string, std::size_t> counts{};
+    for (std::size_t i = 0U; i < shots; ++i) {
+      // measure all returns a string of the form "q(n-1) ... q(0)"
+      auto measurement = dd->measureAll(e, false, mt);
+      counts.operator[](measurement) += 1U;
+    }
+    // reduce reference count of measured state
+    dd->decRef(e);
 
-        if (!isDynamicCircuit) {
-            // if all gates are unitary (besides measurements at the end), we just simulate once and measure all qubits repeatedly
-            auto permutation = qc->initialLayout;
-            auto e           = in;
-            dd->incRef(e);
-
-            for (const auto& op: *qc) {
-                // simply skip any non-unitary
-                if (!op->isUnitary()) {
-                    continue;
-                }
-
-                auto tmp = dd->multiply(getDD(op.get(), dd, permutation), e);
-                dd->incRef(tmp);
-                dd->decRef(e);
-                e = tmp;
+    std::map<std::string, std::size_t> actualCounts{};
+    for (const auto& [bitstring, count] : counts) {
+      std::string measurement(qc->getNcbits(), '0');
+      if (hasMeasurements) {
+        // if the circuit contains measurements, we only want to return the
+        // measured bits
+        for (const auto& [qubit, bit] : measurementMap) {
+          // measurement map specifies that the circuit `qubit` is measured into
+          // a certain `bit`
+          measurement[qc->getNcbits() - 1U - bit] =
+              bitstring[bitstring.size() - 1U -
+                        static_cast<std::size_t>(qubit)];
+        }
+      } else {
+        // otherwise, we consider the output permutation for determining where
+        // to measure the qubits to
+        for (const auto& [qubit, bit] : qc->outputPermutation) {
+          measurement[qc->getNcbits() - 1 - bit] =
+              bitstring[bitstring.size() - 1U -
+                        static_cast<std::size_t>(qubit)];
+        }
+      }
+      actualCounts[measurement] += count;
+    }
+    return actualCounts;
+  }
 
-                dd->garbageCollect();
-            }
+  std::map<std::string, std::size_t> counts{};
 
-            // correct permutation if necessary
-            changePermutation(e, permutation, qc->outputPermutation, dd);
-            e = dd->reduceGarbage(e, qc->garbage);
-
-            // measure all qubits
-            std::map<std::string, std::size_t> counts{};
-            for (std::size_t i = 0U; i < shots; ++i) {
-                // measure all returns a string of the form "q(n-1) ... q(0)"
-                auto measurement = dd->measureAll(e, false, mt);
-                // reverse the order of the bits so that measurements follow big-endian convention
-                counts[measurement]++;
-            }
-            // reduce reference count of measured state
-            dd->decRef(e);
+  for (std::size_t i = 0U; i < shots; i++) {
+    std::map<std::size_t, char> measurements{};
 
-            std::map<std::string, std::size_t> actualCounts{};
-            for (const auto& [bitstring, count]: counts) {
-                std::string measurement(qc->getNcbits(), '0');
-                if (hasMeasurements) {
-                    // if the circuit contains measurements, we only want to return the measured bits
-                    for (const auto& [qubit, bit]: measurementMap) {
-                        // measurement map specifies that the circuit `qubit` is measured into a certain `bit`
-                        measurement[qc->getNcbits() - 1U - bit] = bitstring[bitstring.size() - 1U - static_cast<std::size_t>(qubit)];
-                    }
-                } else {
-                    // otherwise, we consider the output permutation for determining where to measure the qubits to
-                    for (const auto& [qubit, bit]: qc->outputPermutation) {
-                        measurement[qc->getNcbits() - 1 - bit] = bitstring[bitstring.size() - 1U - static_cast<std::size_t>(qubit)];
-                    }
-                }
-                actualCounts[measurement] += count;
-            }
-            return actualCounts;
+    auto permutation = qc->initialLayout;
+    auto e = in;
+    dd->incRef(e);
+
+    for (const auto& op : *qc) {
+      if (op->getType() == Measure) {
+        auto* measure = dynamic_cast<NonUnitaryOperation*>(op.get());
+        const auto& qubits = measure->getTargets();
+        const auto& bits = measure->getClassics();
+        for (std::size_t j = 0U; j < qubits.size(); ++j) {
+          measurements[bits.at(j)] = dd->measureOneCollapsing(
+              e, static_cast<dd::Qubit>(permutation.at(qubits.at(j))), true,
+              mt);
         }
+        continue;
+      }
 
-        std::map<std::string, std::size_t> counts{};
+      if (op->getType() == Reset) {
+        auto* reset = dynamic_cast<NonUnitaryOperation*>(op.get());
+        const auto& qubits = reset->getTargets();
+        for (const auto& qubit : qubits) {
+          auto bit = dd->measureOneCollapsing(
+              e, static_cast<dd::Qubit>(permutation.at(qubit)), true, mt);
+          // apply an X operation whenever the measured result is one
+          if (bit == '1') {
+            const auto x =
+                qc::StandardOperation(qc->getNqubits(), qubit, qc::X);
+            auto tmp = dd->multiply(getDD(&x, dd), e);
+            dd->incRef(tmp);
+            dd->decRef(e);
+            e = tmp;
+            dd->garbageCollect();
+          }
+        }
+        continue;
+      }
 
-        for (std::size_t i = 0U; i < shots; i++) {
-            std::map<std::size_t, char> measurements{};
+      if (op->getType() == ClassicControlled) {
+        auto* classicControlled =
+            dynamic_cast<ClassicControlledOperation*>(op.get());
+        const auto& controlRegister = classicControlled->getControlRegister();
+        const auto& expectedValue = classicControlled->getExpectedValue();
+        auto actualValue = 0ULL;
+        // determine the actual value from measurements
+        for (std::size_t j = 0; j < controlRegister.second; ++j) {
+          if (measurements[controlRegister.first + j] == '1') {
+            actualValue |= 1ULL << j;
+          }
+        }
 
-            auto permutation = qc->initialLayout;
-            auto e           = in;
-            dd->incRef(e);
-
-            for (const auto& op: *qc) {
-                if (op->getType() == Measure) {
-                    auto*       measure = dynamic_cast<NonUnitaryOperation*>(op.get());
-                    const auto& qubits  = measure->getTargets();
-                    const auto& bits    = measure->getClassics();
-                    for (std::size_t j = 0U; j < qubits.size(); ++j) {
-                        measurements[bits.at(j)] = dd->measureOneCollapsing(e, static_cast<dd::Qubit>(permutation.at(qubits.at(j))), true, mt);
-                    }
-                    continue;
-                }
-
-                if (op->getType() == Reset) {
-                    auto*       reset  = dynamic_cast<NonUnitaryOperation*>(op.get());
-                    const auto& qubits = reset->getTargets();
-                    for (const auto& qubit: qubits) {
-                        auto bit = dd->measureOneCollapsing(e, static_cast<dd::Qubit>(permutation.at(qubit)), true, mt);
-                        // apply an X operation whenever the measured result is one
-                        if (bit == '1') {
-                            const auto x   = qc::StandardOperation(qc->getNqubits(), qubit, qc::X);
-                            auto       tmp = dd->multiply(getDD(&x, dd), e);
-                            dd->incRef(tmp);
-                            dd->decRef(e);
-                            e = tmp;
-                            dd->garbageCollect();
-                        }
-                    }
-                    continue;
-                }
-
-                if (op->getType() == ClassicControlled) {
-                    auto*       classicControlled = dynamic_cast<ClassicControlledOperation*>(op.get());
-                    const auto& controlRegister   = classicControlled->getControlRegister();
-                    const auto& expectedValue     = classicControlled->getExpectedValue();
-                    auto        actualValue       = 0ULL;
-                    // determine the actual value from measurements
-                    for (std::size_t j = 0; j < controlRegister.second; ++j) {
-                        if (measurements[controlRegister.first + j] == '1') {
-                            actualValue |= 1ULL << j;
-                        }
-                    }
-
-                    // do not apply an operation if the value is not the expected one
-                    if (actualValue != expectedValue) {
-                        continue;
-                    }
-                }
-
-                auto tmp = dd->multiply(getDD(op.get(), dd, permutation), e);
-                dd->incRef(tmp);
-                dd->decRef(e);
-                e = tmp;
+        // do not apply an operation if the value is not the expected one
+        if (actualValue != expectedValue) {
+          continue;
+        }
+      }
 
-                dd->garbageCollect();
-            }
+      auto tmp = dd->multiply(getDD(op.get(), dd, permutation), e);
+      dd->incRef(tmp);
+      dd->decRef(e);
+      e = tmp;
 
-            // reduce reference count of measured state
-            dd->decRef(e);
+      dd->garbageCollect();
+    }
 
-            std::string shot(qc->getNcbits(), '0');
-            for (const auto& [bit, value]: measurements) {
-                shot[qc->getNcbits() - bit - 1U] = value;
-            }
-            counts[shot]++;
-        }
+    // reduce reference count of measured state
+    dd->decRef(e);
 
-        return counts;
+    std::string shot(qc->getNcbits(), '0');
+    for (const auto& [bit, value] : measurements) {
+      shot[qc->getNcbits() - bit - 1U] = value;
     }
+    counts[shot]++;
+  }
 
-    template<class Config>
-    void extractProbabilityVector(const QuantumComputation* qc, const VectorDD& in, ProbabilityVector& probVector, std::unique_ptr<dd::Package<Config>>& dd) {
-        // ! initial layout, output permutation and garbage qubits are currently not supported here
-        dd->incRef(in);
-        extractProbabilityVectorRecursive(qc, in, qc->begin(), std::map<std::size_t, char>{}, 1., probVector, dd);
-    }
-
-    template<class Config>
-    void extractProbabilityVectorRecursive(const QuantumComputation* qc, const VectorDD& currentState, decltype(qc->begin()) currentIt, std::map<std::size_t, char> measurements, dd::fp commonFactor, ProbabilityVector& probVector, std::unique_ptr<dd::Package<Config>>& dd) {
-        auto state = currentState;
-        for (auto it = currentIt; it != qc->end(); ++it) {
-            const auto& op = (*it);
-
-            // check whether a classic controlled operations can be applied
-            if (op->getType() == ClassicControlled) {
-                auto*       classicControlled = dynamic_cast<ClassicControlledOperation*>(op.get());
-                const auto& controlRegister   = classicControlled->getControlRegister();
-                const auto& expectedValue     = classicControlled->getExpectedValue();
-                qc::Bit     actualValue       = 0U;
-                // determine the actual value from measurements
-                for (std::size_t j = 0; j < controlRegister.second; ++j) {
-                    actualValue |= (measurements[controlRegister.first + j] == '1') ? (static_cast<qc::Bit>(1) << j) : 0U;
-                }
-
-                // do not apply an operation if the value is not the expected one
-                if (actualValue != expectedValue) {
-                    continue;
-                }
-            }
+  return counts;
+}
 
-            if (op->getType() == Reset) {
-                // a reset operation should only happen once a qubit has been measured, i.e., the qubit is in a basis state
-                // thus the probabilities for 0 and 1 need to be determined
-                // if p(1) ~= 1, an X operation has to be applied to the qubit
-                // if p(0) ~= 1, nothing has to be done
-                // if 0 < p(0), p(1) < 1, an error should be raised
-
-                const auto& targets = op->getTargets();
-                if (targets.size() != 1) {
-                    throw qc::QFRException("Resets on multiple qubits are currently not supported. Please split them into multiple single resets.");
-                }
-
-                auto [pzero, pone] = dd->determineMeasurementProbabilities(state, static_cast<dd::Qubit>(targets[0]), true);
-
-                // normalize probabilities
-                const auto norm = pzero + pone;
-                pzero /= norm;
-                pone /= norm;
-
-                if (dd::ComplexTable<>::Entry::approximatelyOne(pone)) {
-                    qc::MatrixDD xGate      = dd->makeGateDD(dd::Xmat, static_cast<dd::QubitCount>(state.p->v + 1), static_cast<dd::Qubit>(targets[0U]));
-                    qc::VectorDD resetState = dd->multiply(xGate, state);
-                    dd->incRef(resetState);
-                    dd->decRef(state);
-                    state = resetState;
-                    continue;
-                }
-
-                if (!dd::ComplexTable<>::Entry::approximatelyOne(pzero)) {
-                    throw qc::QFRException("Reset on non basis state encountered. This is not supported in this method.");
-                }
+template <class Config>
+void extractProbabilityVector(const QuantumComputation* qc, const VectorDD& in,
+                              ProbabilityVector& probVector,
+                              std::unique_ptr<dd::Package<Config>>& dd) {
+  // ! initial layout, output permutation and garbage qubits are currently not
+  // supported here
+  dd->incRef(in);
+  extractProbabilityVectorRecursive(
+      qc, in, qc->begin(), std::map<std::size_t, char>{}, 1., probVector, dd);
+}
+
+template <class Config>
+void extractProbabilityVectorRecursive(
+    const QuantumComputation* qc, const VectorDD& currentState,
+    decltype(qc->begin()) currentIt, std::map<std::size_t, char> measurements,
+    dd::fp commonFactor, ProbabilityVector& probVector,
+    std::unique_ptr<dd::Package<Config>>& dd) {
+  auto state = currentState;
+  for (auto it = currentIt; it != qc->end(); ++it) {
+    const auto& op = (*it);
+
+    // check whether a classic controlled operations can be applied
+    if (op->getType() == ClassicControlled) {
+      auto* classicControlled =
+          dynamic_cast<ClassicControlledOperation*>(op.get());
+      const auto& controlRegister = classicControlled->getControlRegister();
+      const auto& expectedValue = classicControlled->getExpectedValue();
+      qc::Bit actualValue = 0U;
+      // determine the actual value from measurements
+      for (std::size_t j = 0; j < controlRegister.second; ++j) {
+        actualValue |= (measurements[controlRegister.first + j] == '1')
+                           ? (static_cast<qc::Bit>(1) << j)
+                           : 0U;
+      }
+
+      // do not apply an operation if the value is not the expected one
+      if (actualValue != expectedValue) {
+        continue;
+      }
+    }
 
-                continue;
-            }
+    if (op->getType() == Reset) {
+      // a reset operation should only happen once a qubit has been measured,
+      // i.e., the qubit is in a basis state thus the probabilities for 0 and 1
+      // need to be determined if p(1) ~= 1, an X operation has to be applied to
+      // the qubit if p(0) ~= 1, nothing has to be done if 0 < p(0), p(1) < 1,
+      // an error should be raised
+
+      const auto& targets = op->getTargets();
+      if (targets.size() != 1) {
+        throw qc::QFRException(
+            "Resets on multiple qubits are currently not supported. Please "
+            "split them into multiple single resets.");
+      }
+
+      auto [pzero, pone] = dd->determineMeasurementProbabilities(
+          state, static_cast<dd::Qubit>(targets[0]), true);
+
+      // normalize probabilities
+      const auto norm = pzero + pone;
+      pzero /= norm;
+      pone /= norm;
+
+      if (dd::ComplexTable<>::Entry::approximatelyOne(pone)) {
+        const qc::MatrixDD xGate = dd->makeGateDD(
+            dd::Xmat, static_cast<dd::QubitCount>(state.p->v + 1),
+            static_cast<dd::Qubit>(targets[0U]));
+        const qc::VectorDD resetState = dd->multiply(xGate, state);
+        dd->incRef(resetState);
+        dd->decRef(state);
+        state = resetState;
+        continue;
+      }
+
+      if (!dd::ComplexTable<>::Entry::approximatelyOne(pzero)) {
+        throw qc::QFRException("Reset on non basis state encountered. This is "
+                               "not supported in this method.");
+      }
 
-            // measurements form splitting points in this extraction scheme
-            if (op->getType() == Measure) {
-                const auto* measurement = dynamic_cast<qc::NonUnitaryOperation*>(op.get());
-                const auto& targets     = measurement->getTargets();
-                const auto& classics    = measurement->getClassics();
-                if (targets.size() != 1U || classics.size() != 1U) {
-                    throw qc::QFRException("Measurements on multiple qubits are not supported right now. Split your measurements into individual operations.");
-                }
-
-                // determine probabilities for this measurement
-                auto [pzero, pone] = dd->determineMeasurementProbabilities(state, static_cast<dd::Qubit>(targets[0]), true);
-
-                // normalize probabilities
-                const auto norm = pzero + pone;
-                pzero /= norm;
-                pone /= norm;
-
-                // base case -> determine the basis state from the measurement and safe the probability
-                if (measurements.size() == qc->getNcbits() - 1) {
-                    std::size_t idx0 = 0U;
-                    std::size_t idx1 = 0U;
-                    for (std::size_t i = 0U; i < qc->getNcbits(); ++i) {
-                        // if this is the qubit being measured and the result is one
-                        if (i == static_cast<std::size_t>(classics[0U])) {
-                            idx1 |= (1ULL << i);
-                        } else {
-                            // sanity check
-                            auto findIt = measurements.find(i);
-                            if (findIt == measurements.end()) {
-                                throw qc::QFRException("No information on classical bit " + std::to_string(i));
-                            }
-                            // if i-th bit is set increase the index appropriately
-                            if (findIt->second == '1') {
-                                idx0 |= (1ULL << i);
-                                idx1 |= (1ULL << i);
-                            }
-                        }
-                    }
-                    const auto prob0 = commonFactor * pzero;
-                    if (!dd::ComplexTable<>::Entry::approximatelyZero(prob0)) {
-                        probVector[idx0] = prob0;
-                    }
-                    const auto prob1 = commonFactor * pone;
-                    if (!dd::ComplexTable<>::Entry::approximatelyZero(prob1)) {
-                        probVector[idx1] = prob1;
-                    }
-
-                    // probabilities have been written -> this path is done
-                    dd->decRef(state);
-                    return;
-                }
-
-                bool nonZeroP0 = !dd::ComplexTable<>::Entry::approximatelyZero(pzero);
-                bool nonZeroP1 = !dd::ComplexTable<>::Entry::approximatelyZero(pone);
-
-                // in case both outcomes are non-zero the reference count of the state has to be increased once more in order to avoid reference counting errors
-                if (nonZeroP0 && nonZeroP1) {
-                    dd->incRef(state);
-                }
-
-                // recursive case -- outcome 0
-                if (nonZeroP0) {
-                    // save measurement result
-                    measurements[classics[0]] = '0';
-                    // determine accumulated probability
-                    auto probability = commonFactor * pzero;
-                    // determine the next iteration point
-                    auto nextIt = it + 1;
-                    // actually collapse the state
-                    const dd::GateMatrix measurementMatrix{dd::complex_one, dd::complex_zero, dd::complex_zero, dd::complex_zero};
-                    qc::MatrixDD         measurementGate = dd->makeGateDD(measurementMatrix, static_cast<dd::QubitCount>(state.p->v + 1), static_cast<dd::Qubit>(targets[0]));
-                    qc::VectorDD         measuredState   = dd->multiply(measurementGate, state);
-
-                    auto c = dd->cn.getTemporary(1. / std::sqrt(pzero), 0);
-                    dd::ComplexNumbers::mul(c, measuredState.w, c);
-                    measuredState.w = dd->cn.lookup(c);
-                    dd->incRef(measuredState);
-                    dd->decRef(state);
-                    // recursive call from here
-                    extractProbabilityVectorRecursive(qc, measuredState, nextIt, measurements, probability, probVector, dd);
-                }
-
-                // recursive case -- outcome 1
-                if (nonZeroP1) {
-                    // save measurement result
-                    measurements[classics[0]] = '1';
-                    // determine accumulated probability
-                    auto probability = commonFactor * pone;
-                    // determine the next iteration point
-                    auto nextIt = it + 1;
-                    // actually collapse the state
-                    const dd::GateMatrix measurementMatrix{dd::complex_zero, dd::complex_zero, dd::complex_zero, dd::complex_one};
-                    qc::MatrixDD         measurementGate = dd->makeGateDD(measurementMatrix, static_cast<dd::QubitCount>(state.p->v + 1), static_cast<dd::Qubit>(targets[0]));
-                    qc::VectorDD         measuredState   = dd->multiply(measurementGate, state);
-
-                    auto c = dd->cn.getTemporary(1. / std::sqrt(pone), 0);
-                    dd::ComplexNumbers::mul(c, measuredState.w, c);
-                    measuredState.w = dd->cn.lookup(c);
-                    dd->incRef(measuredState);
-                    dd->decRef(state);
-                    // recursive call from here
-                    extractProbabilityVectorRecursive(qc, measuredState, nextIt, measurements, probability, probVector, dd);
-                }
+      continue;
+    }
 
-                // everything is said and done
-                return;
+    // measurements form splitting points in this extraction scheme
+    if (op->getType() == Measure) {
+      const auto* measurement =
+          dynamic_cast<qc::NonUnitaryOperation*>(op.get());
+      const auto& targets = measurement->getTargets();
+      const auto& classics = measurement->getClassics();
+      if (targets.size() != 1U || classics.size() != 1U) {
+        throw qc::QFRException(
+            "Measurements on multiple qubits are not supported right now. "
+            "Split your measurements into individual operations.");
+      }
+
+      // determine probabilities for this measurement
+      auto [pzero, pone] = dd->determineMeasurementProbabilities(
+          state, static_cast<dd::Qubit>(targets[0]), true);
+
+      // normalize probabilities
+      const auto norm = pzero + pone;
+      pzero /= norm;
+      pone /= norm;
+
+      // base case -> determine the basis state from the measurement and safe
+      // the probability
+      if (measurements.size() == qc->getNcbits() - 1) {
+        std::size_t idx0 = 0U;
+        std::size_t idx1 = 0U;
+        for (std::size_t i = 0U; i < qc->getNcbits(); ++i) {
+          // if this is the qubit being measured and the result is one
+          if (i == static_cast<std::size_t>(classics[0U])) {
+            idx1 |= (1ULL << i);
+          } else {
+            // sanity check
+            auto findIt = measurements.find(i);
+            if (findIt == measurements.end()) {
+              throw qc::QFRException("No information on classical bit " +
+                                     std::to_string(i));
+            }
+            // if i-th bit is set increase the index appropriately
+            if (findIt->second == '1') {
+              idx0 |= (1ULL << i);
+              idx1 |= (1ULL << i);
             }
-
-            // any standard operation or classic-controlled operation is applied here
-            auto tmp = dd->multiply(getDD(op.get(), dd), state);
-            dd->incRef(tmp);
-            dd->decRef(state);
-            state = tmp;
-
-            dd->garbageCollect();
+          }
         }
-    }
-
-    template<class Config>
-    VectorDD simulate(GoogleRandomCircuitSampling* qc, const VectorDD& in, std::unique_ptr<dd::Package<Config>>& dd, const std::optional<std::size_t> ncycles) {
-        if (ncycles.has_value() && (*ncycles < qc->cycles.size() - 2U)) {
-            qc->removeCycles(qc->cycles.size() - 2U - *ncycles);
+        const auto prob0 = commonFactor * pzero;
+        if (!dd::ComplexTable<>::Entry::approximatelyZero(prob0)) {
+          probVector[idx0] = prob0;
         }
-
-        Permutation permutation = qc->initialLayout;
-        auto        e           = in;
-        dd->incRef(e);
-        for (const auto& cycle: qc->cycles) {
-            for (const auto& op: cycle) {
-                auto tmp = dd->multiply(getDD(op.get(), dd, permutation), e);
-                dd->incRef(tmp);
-                dd->decRef(e);
-                e = tmp;
-                dd->garbageCollect();
-            }
+        const auto prob1 = commonFactor * pone;
+        if (!dd::ComplexTable<>::Entry::approximatelyZero(prob1)) {
+          probVector[idx1] = prob1;
         }
-        return e;
+
+        // probabilities have been written -> this path is done
+        dd->decRef(state);
+        return;
+      }
+
+      const bool nonZeroP0 =
+          !dd::ComplexTable<>::Entry::approximatelyZero(pzero);
+      const bool nonZeroP1 =
+          !dd::ComplexTable<>::Entry::approximatelyZero(pone);
+
+      // in case both outcomes are non-zero the reference count of the state has
+      // to be increased once more in order to avoid reference counting errors
+      if (nonZeroP0 && nonZeroP1) {
+        dd->incRef(state);
+      }
+
+      // recursive case -- outcome 0
+      if (nonZeroP0) {
+        // save measurement result
+        measurements[classics[0]] = '0';
+        // determine accumulated probability
+        auto probability = commonFactor * pzero;
+        // determine the next iteration point
+        auto nextIt = it + 1;
+        // actually collapse the state
+        const dd::GateMatrix measurementMatrix{
+            dd::complex_one, dd::complex_zero, dd::complex_zero,
+            dd::complex_zero};
+        const qc::MatrixDD measurementGate = dd->makeGateDD(
+            measurementMatrix, static_cast<dd::QubitCount>(state.p->v + 1),
+            static_cast<dd::Qubit>(targets[0]));
+        qc::VectorDD measuredState = dd->multiply(measurementGate, state);
+
+        auto c = dd->cn.getTemporary(1. / std::sqrt(pzero), 0);
+        dd::ComplexNumbers::mul(c, measuredState.w, c);
+        measuredState.w = dd->cn.lookup(c);
+        dd->incRef(measuredState);
+        dd->decRef(state);
+        // recursive call from here
+        extractProbabilityVectorRecursive(qc, measuredState, nextIt,
+                                          measurements, probability, probVector,
+                                          dd);
+      }
+
+      // recursive case -- outcome 1
+      if (nonZeroP1) {
+        // save measurement result
+        measurements[classics[0]] = '1';
+        // determine accumulated probability
+        auto probability = commonFactor * pone;
+        // determine the next iteration point
+        auto nextIt = it + 1;
+        // actually collapse the state
+        const dd::GateMatrix measurementMatrix{
+            dd::complex_zero, dd::complex_zero, dd::complex_zero,
+            dd::complex_one};
+        const qc::MatrixDD measurementGate = dd->makeGateDD(
+            measurementMatrix, static_cast<dd::QubitCount>(state.p->v + 1),
+            static_cast<dd::Qubit>(targets[0]));
+        qc::VectorDD measuredState = dd->multiply(measurementGate, state);
+
+        auto c = dd->cn.getTemporary(1. / std::sqrt(pone), 0);
+        dd::ComplexNumbers::mul(c, measuredState.w, c);
+        measuredState.w = dd->cn.lookup(c);
+        dd->incRef(measuredState);
+        dd->decRef(state);
+        // recursive call from here
+        extractProbabilityVectorRecursive(qc, measuredState, nextIt,
+                                          measurements, probability, probVector,
+                                          dd);
+      }
+
+      // everything is said and done
+      return;
     }
 
-    template std::map<std::string, std::size_t> simulate<DDPackageConfig>(const QuantumComputation* qc, const VectorDD& in, std::unique_ptr<dd::Package<DDPackageConfig>>& dd, std::size_t shots, std::size_t seed);
-    template void                               extractProbabilityVector<DDPackageConfig>(const QuantumComputation* qc, const VectorDD& in, ProbabilityVector& probVector, std::unique_ptr<dd::Package<DDPackageConfig>>& dd);
-    template void                               extractProbabilityVectorRecursive<DDPackageConfig>(const QuantumComputation* qc, const VectorDD& in, decltype(qc->begin()) currentIt, std::map<std::size_t, char> measurements, dd::fp commonFactor, dd::ProbabilityVector& probVector, std::unique_ptr<dd::Package<DDPackageConfig>>& dd);
-    template VectorDD                           simulate<DDPackageConfig>(GoogleRandomCircuitSampling* qc, const VectorDD& in, std::unique_ptr<dd::Package<DDPackageConfig>>& dd, const std::optional<std::size_t> ncycles);
+    // any standard operation or classic-controlled operation is applied here
+    auto tmp = dd->multiply(getDD(op.get(), dd), state);
+    dd->incRef(tmp);
+    dd->decRef(state);
+    state = tmp;
+
+    dd->garbageCollect();
+  }
+}
+
+template <class Config>
+VectorDD simulate(GoogleRandomCircuitSampling* qc, const VectorDD& in,
+                  std::unique_ptr<dd::Package<Config>>& dd,
+                  const std::optional<std::size_t> ncycles) {
+  if (ncycles.has_value() && (*ncycles < qc->cycles.size() - 2U)) {
+    qc->removeCycles(qc->cycles.size() - 2U - *ncycles);
+  }
+
+  Permutation permutation = qc->initialLayout;
+  auto e = in;
+  dd->incRef(e);
+  for (const auto& cycle : qc->cycles) {
+    for (const auto& op : cycle) {
+      auto tmp = dd->multiply(getDD(op.get(), dd, permutation), e);
+      dd->incRef(tmp);
+      dd->decRef(e);
+      e = tmp;
+      dd->garbageCollect();
+    }
+  }
+  return e;
+}
+
+template std::map<std::string, std::size_t>
+simulate<DDPackageConfig>(const QuantumComputation* qc, const VectorDD& in,
+                          std::unique_ptr<dd::Package<DDPackageConfig>>& dd,
+                          std::size_t shots, std::size_t seed);
+template void extractProbabilityVector<DDPackageConfig>(
+    const QuantumComputation* qc, const VectorDD& in,
+    ProbabilityVector& probVector,
+    std::unique_ptr<dd::Package<DDPackageConfig>>& dd);
+template void extractProbabilityVectorRecursive<DDPackageConfig>(
+    const QuantumComputation* qc, const VectorDD& in,
+    decltype(qc->begin()) currentIt, std::map<std::size_t, char> measurements,
+    dd::fp commonFactor, dd::ProbabilityVector& probVector,
+    std::unique_ptr<dd::Package<DDPackageConfig>>& dd);
+template VectorDD
+simulate<DDPackageConfig>(GoogleRandomCircuitSampling* qc, const VectorDD& in,
+                          std::unique_ptr<dd::Package<DDPackageConfig>>& dd,
+                          const std::optional<std::size_t> ncycles);
 } // namespace dd
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/src/ecc/Q18Surface.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/ecc/Q18Surface.cpp`

 * *Files 12% similar despite different names*

```diff
@@ -1,154 +1,160 @@
-/*
-* This file is part of MQT QFR library which is released under the MIT license.
-* See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
-*/
-
 #include "ecc/Q18Surface.hpp"
 namespace ecc {
-    void Q18Surface::measureAndCorrect() {
-        if (isDecoded) {
-            return;
-        }
-        const auto nQubits    = qcOriginal->getNqubits();
-        const auto clAncStart = qcOriginal->getNcbits();
-
-        std::map<std::size_t, std::size_t> xCheckMasks;
-        for (std::size_t j = 0; j < ANCILLA_WIDTH; j++) {
-            xCheckMasks[X_CHECKS.at(j)] = 1 << j;
-        }
-
-        for (Qubit i = 0; i < nQubits; i++) {
-            std::array<Qubit, N_REDUNDANT_QUBITS>       qubits        = {};
-            std::array<qc::Control, N_REDUNDANT_QUBITS> controlQubits = {};
-            for (std::size_t j = 0; j < qubits.size(); j++) {
-                qubits.at(j) = static_cast<Qubit>(i + j * nQubits);
-            }
-            for (std::size_t j = 0; j < controlQubits.size(); j++) {
-                controlQubits.at(j) = qc::Control{qubits.at(j)};
-            }
-
-            if (gatesWritten) {
-                for (Qubit const ai: ANCILLA_INDICES) {
-                    qcMapped->reset(qubits.at(ai));
-                }
-            }
-
-            //initialize ancillas: X-check
-            for (const auto& [targetIndex, ancillaIndices]: qubitCorrectionX) {
-                for (const auto ancilla: ancillaIndices) {
-                    qcMapped->x(qubits.at(ancilla), controlQubits.at(targetIndex));
-                }
-            }
-
-            //map ancillas to classical bit result
-            for (std::size_t j = 0; j < X_CHECKS.size(); j++) {
-                qcMapped->measure(qubits.at(X_CHECKS.at(j)), clAncStart + j);
-            }
-
-            //logic: classical control
-            auto controlRegister = std::make_pair(static_cast<Qubit>(clAncStart), ANCILLA_WIDTH);
-            for (const auto& [targetIndex, ancillaIndices]: qubitCorrectionX) {
-                std::size_t mask = 0;
-                for (std::size_t const ancillaIndex: ancillaIndices) {
-                    mask |= xCheckMasks[ancillaIndex];
-                }
-                qcMapped->classicControlled(qc::X, qubits.at(targetIndex), controlRegister, mask);
-            }
-
-            gatesWritten = true;
-        }
-    }
-
-    void Q18Surface::writeDecoding() {
-        if (isDecoded) {
-            return;
-        }
-        const auto nQubits = qcOriginal->getNqubits();
-        for (Qubit i = 0; i < nQubits; i++) {
-            qcMapped->reset(static_cast<Qubit>(i + X_INFORMATION * nQubits));
-            for (const Qubit qubit: ANCILLA_QUBITS_DECODE) {
-                qcMapped->x(static_cast<Qubit>(i + X_INFORMATION * nQubits), qc::Control{static_cast<Qubit>(i + qubit * nQubits), qc::Control::Type::Pos});
-            }
-            qcMapped->measure(static_cast<Qubit>(i + X_INFORMATION * nQubits), i);
-            qcMapped->reset(i);
-            qcMapped->x(i, qc::Control{static_cast<Qubit>(i + X_INFORMATION * nQubits), qc::Control::Type::Pos});
-        }
-        isDecoded = true;
-    }
-
-    void Q18Surface::mapGate(const qc::Operation& gate) {
-        if (isDecoded && gate.getType() != qc::Measure) {
-            writeEncoding();
-        }
-        const auto nQubits = qcOriginal->getNqubits();
-
-        //no control gate decomposition is supported
-        if (gate.isControlled() && gate.getType() != qc::Measure) {
-            //multi-qubit gates are currently not supported
-            gateNotAvailableError(gate);
-        } else {
-            static constexpr std::array<std::pair<Qubit, Qubit>, 6> SWAP_QUBIT_INDICES = {std::make_pair(1, 29), std::make_pair(3, 17), std::make_pair(6, 34), std::make_pair(8, 22), std::make_pair(13, 27), std::make_pair(18, 32)};
-
-            switch (gate.getType()) {
-                case qc::Barrier:
-                case qc::I:
-                    break;
-                case qc::X:
-                    for (auto i: gate.getTargets()) {
-                        for (auto j: LOGICAL_X) {
-                            qcMapped->x(static_cast<Qubit>(i + j * nQubits));
-                        }
-                    }
-                    break;
-                case qc::H:
-                    //apply H gate to every data qubit
-                    //swap circuit along '/' axis
-                    for (auto i: gate.getTargets()) {
-                        for (const auto j: DATA_QUBITS) {
-                            qcMapped->h(static_cast<Qubit>(i + j * nQubits));
-                        }
-                        for (auto pair: SWAP_QUBIT_INDICES) {
-                            qcMapped->swap(static_cast<Qubit>(i + static_cast<size_t>(pair.first) * nQubits), static_cast<Qubit>(i + static_cast<size_t>(pair.second) * nQubits));
-                        }
-                        //qubits 5, 10, 15, 20, 25, 30 are along axis
-                    }
-                    break;
-                case qc::Y:
-                    //Y = Z X
-                    for (auto i: gate.getTargets()) {
-                        for (auto j: LOGICAL_Z) {
-                            qcMapped->z(static_cast<Qubit>(i + j * nQubits));
-                        }
-                        for (auto j: LOGICAL_X) {
-                            qcMapped->x(static_cast<Qubit>(i + j * nQubits));
-                        }
-                    }
-                    break;
-                case qc::Z:
-                    for (auto i: gate.getTargets()) {
-                        for (auto j: LOGICAL_Z) {
-                            qcMapped->z(static_cast<Qubit>(i + j * nQubits));
-                        }
-                    }
-                    break;
-                case qc::Measure:
-                    if (!isDecoded) {
-                        measureAndCorrect();
-                        writeDecoding();
-                    }
-                    if (const auto* measureGate = dynamic_cast<const qc::NonUnitaryOperation*>(&gate)) {
-                        const auto& classics = measureGate->getClassics();
-                        const auto& targets  = measureGate->getTargets();
-                        for (std::size_t j = 0; j < classics.size(); j++) {
-                            qcMapped->measure(targets.at(j), classics.at(j));
-                        }
-                    } else {
-                        throw std::runtime_error("Dynamic cast to NonUnitaryOperation failed.");
-                    }
-                    break;
-                default:
-                    gateNotAvailableError(gate);
-            }
-        }
+void Q18Surface::measureAndCorrect() {
+  if (isDecoded) {
+    return;
+  }
+  const auto nQubits = qcOriginal->getNqubits();
+  const auto clAncStart = qcOriginal->getNcbits();
+
+  std::map<std::size_t, std::size_t> xCheckMasks;
+  for (std::size_t j = 0; j < ANCILLA_WIDTH; j++) {
+    xCheckMasks[X_CHECKS.at(j)] = 1 << j;
+  }
+
+  for (Qubit i = 0; i < nQubits; i++) {
+    std::array<Qubit, N_REDUNDANT_QUBITS> qubits = {};
+    std::array<qc::Control, N_REDUNDANT_QUBITS> controlQubits = {};
+    for (std::size_t j = 0; j < qubits.size(); j++) {
+      qubits.at(j) = static_cast<Qubit>(i + j * nQubits);
+    }
+    for (std::size_t j = 0; j < controlQubits.size(); j++) {
+      controlQubits.at(j) = qc::Control{qubits.at(j)};
+    }
+
+    if (gatesWritten) {
+      for (Qubit const ai : ANCILLA_INDICES) {
+        qcMapped->reset(qubits.at(ai));
+      }
+    }
+
+    // initialize ancillas: X-check
+    for (const auto& [targetIndex, ancillaIndices] : qubitCorrectionX) {
+      for (const auto ancilla : ancillaIndices) {
+        qcMapped->x(qubits.at(ancilla), controlQubits.at(targetIndex));
+      }
+    }
+
+    // map ancillas to classical bit result
+    for (std::size_t j = 0; j < X_CHECKS.size(); j++) {
+      qcMapped->measure(qubits.at(X_CHECKS.at(j)), clAncStart + j);
+    }
+
+    // logic: classical control
+    auto controlRegister =
+        std::make_pair(static_cast<Qubit>(clAncStart), ANCILLA_WIDTH);
+    for (const auto& [targetIndex, ancillaIndices] : qubitCorrectionX) {
+      std::size_t mask = 0;
+      for (std::size_t const ancillaIndex : ancillaIndices) {
+        mask |= xCheckMasks[ancillaIndex];
+      }
+      qcMapped->classicControlled(qc::X, qubits.at(targetIndex),
+                                  controlRegister, mask);
+    }
+
+    gatesWritten = true;
+  }
+}
+
+void Q18Surface::writeDecoding() {
+  if (isDecoded) {
+    return;
+  }
+  const auto nQubits = qcOriginal->getNqubits();
+  for (Qubit i = 0; i < nQubits; i++) {
+    qcMapped->reset(static_cast<Qubit>(i + X_INFORMATION * nQubits));
+    for (const Qubit qubit : ANCILLA_QUBITS_DECODE) {
+      qcMapped->x(static_cast<Qubit>(i + X_INFORMATION * nQubits),
+                  qc::Control{static_cast<Qubit>(i + qubit * nQubits),
+                              qc::Control::Type::Pos});
+    }
+    qcMapped->measure(static_cast<Qubit>(i + X_INFORMATION * nQubits), i);
+    qcMapped->reset(i);
+    qcMapped->x(i, qc::Control{static_cast<Qubit>(i + X_INFORMATION * nQubits),
+                               qc::Control::Type::Pos});
+  }
+  isDecoded = true;
+}
+
+void Q18Surface::mapGate(const qc::Operation& gate) {
+  if (isDecoded && gate.getType() != qc::Measure) {
+    writeEncoding();
+  }
+  const auto nQubits = qcOriginal->getNqubits();
+
+  // no control gate decomposition is supported
+  if (gate.isControlled() && gate.getType() != qc::Measure) {
+    // multi-qubit gates are currently not supported
+    gateNotAvailableError(gate);
+  } else {
+    static constexpr std::array<std::pair<Qubit, Qubit>, 6> SWAP_QUBIT_INDICES =
+        {std::make_pair(1, 29), std::make_pair(3, 17),  std::make_pair(6, 34),
+         std::make_pair(8, 22), std::make_pair(13, 27), std::make_pair(18, 32)};
+
+    switch (gate.getType()) {
+    case qc::Barrier:
+    case qc::I:
+      break;
+    case qc::X:
+      for (auto i : gate.getTargets()) {
+        for (auto j : LOGICAL_X) {
+          qcMapped->x(static_cast<Qubit>(i + j * nQubits));
+        }
+      }
+      break;
+    case qc::H:
+      // apply H gate to every data qubit
+      // swap circuit along '/' axis
+      for (auto i : gate.getTargets()) {
+        for (const auto j : DATA_QUBITS) {
+          qcMapped->h(static_cast<Qubit>(i + j * nQubits));
+        }
+        for (auto pair : SWAP_QUBIT_INDICES) {
+          qcMapped->swap(
+              static_cast<Qubit>(i + static_cast<size_t>(pair.first) * nQubits),
+              static_cast<Qubit>(i +
+                                 static_cast<size_t>(pair.second) * nQubits));
+        }
+        // qubits 5, 10, 15, 20, 25, 30 are along axis
+      }
+      break;
+    case qc::Y:
+      // Y = Z X
+      for (auto i : gate.getTargets()) {
+        for (auto j : LOGICAL_Z) {
+          qcMapped->z(static_cast<Qubit>(i + j * nQubits));
+        }
+        for (auto j : LOGICAL_X) {
+          qcMapped->x(static_cast<Qubit>(i + j * nQubits));
+        }
+      }
+      break;
+    case qc::Z:
+      for (auto i : gate.getTargets()) {
+        for (auto j : LOGICAL_Z) {
+          qcMapped->z(static_cast<Qubit>(i + j * nQubits));
+        }
+      }
+      break;
+    case qc::Measure:
+      if (!isDecoded) {
+        measureAndCorrect();
+        writeDecoding();
+      }
+      if (const auto* measureGate =
+              dynamic_cast<const qc::NonUnitaryOperation*>(&gate)) {
+        const auto& classics = measureGate->getClassics();
+        const auto& targets = measureGate->getTargets();
+        for (std::size_t j = 0; j < classics.size(); j++) {
+          qcMapped->measure(targets.at(j), classics.at(j));
+        }
+      } else {
+        throw std::runtime_error("Dynamic cast to NonUnitaryOperation failed.");
+      }
+      break;
+    default:
+      gateNotAvailableError(gate);
     }
+  }
+}
 } // namespace ecc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/src/ecc/Q3Shor.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/ecc/Q3Shor.cpp`

 * *Files 11% similar despite different names*

```diff
@@ -1,117 +1,130 @@
-/*
- * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
- */
-
 #include "ecc/Q3Shor.hpp"
 namespace ecc {
-    void Q3Shor::writeEncoding() {
-        if (!isDecoded || !gatesWritten) {
-            gatesWritten = true;
-            return;
-        }
-        isDecoded          = false;
-        const auto nQubits = qcOriginal->getNqubits();
-
-        for (std::size_t i = 0; i < nQubits; i++) {
-            auto ctrl = qc::Control{static_cast<Qubit>(i)};
-            qcMapped->x(static_cast<Qubit>(i + nQubits), ctrl);
-            qcMapped->x(static_cast<Qubit>(i + 2 * nQubits), ctrl);
-        }
-    }
-
-    void Q3Shor::measureAndCorrect() {
-        if (isDecoded || !gatesWritten) {
-            return;
-        }
-        const auto nQubits  = qcOriginal->getNqubits();
-        const auto ancStart = static_cast<Qubit>(nQubits * ecc.nRedundantQubits); //measure start (index of first ancilla qubit)
-        const auto clStart  = static_cast<Qubit>(qcOriginal->getNcbits());
-        for (std::size_t i = 0; i < nQubits; i++) {
-            qcMapped->reset(ancStart);
-            qcMapped->reset(ancStart + 1);
-
-            qcMapped->x(ancStart, qc::Control{static_cast<Qubit>(i)});
-            qcMapped->x(ancStart, qc::Control{static_cast<Qubit>(i + nQubits)});
-            qcMapped->x(ancStart + 1, qc::Control{static_cast<Qubit>(i + nQubits)});
-            qcMapped->x(ancStart + 1, qc::Control{static_cast<Qubit>(i + 2 * nQubits)});
-
-            qcMapped->measure(ancStart, clStart);
-            qcMapped->measure(ancStart + 1, clStart + 1);
-
-            const auto controlRegister = std::make_pair(clStart, static_cast<QubitCount>(2));
-            qcMapped->classicControlled(qc::X, static_cast<Qubit>(i), controlRegister, 1U);
-            qcMapped->classicControlled(qc::X, static_cast<Qubit>(i + 2 * nQubits), controlRegister, 2U);
-            qcMapped->classicControlled(qc::X, static_cast<Qubit>(i + nQubits), controlRegister, 3U);
-        }
+void Q3Shor::writeEncoding() {
+  if (!isDecoded || !gatesWritten) {
+    gatesWritten = true;
+    return;
+  }
+  isDecoded = false;
+  const auto nQubits = qcOriginal->getNqubits();
+
+  for (std::size_t i = 0; i < nQubits; i++) {
+    auto ctrl = qc::Control{static_cast<Qubit>(i)};
+    qcMapped->x(static_cast<Qubit>(i + nQubits), ctrl);
+    qcMapped->x(static_cast<Qubit>(i + 2 * nQubits), ctrl);
+  }
+}
+
+void Q3Shor::measureAndCorrect() {
+  if (isDecoded || !gatesWritten) {
+    return;
+  }
+  const auto nQubits = qcOriginal->getNqubits();
+  const auto ancStart = static_cast<Qubit>(
+      nQubits *
+      ecc.nRedundantQubits); // measure start (index of first ancilla qubit)
+  const auto clStart = static_cast<Qubit>(qcOriginal->getNcbits());
+  for (std::size_t i = 0; i < nQubits; i++) {
+    qcMapped->reset(ancStart);
+    qcMapped->reset(ancStart + 1);
+
+    qcMapped->x(ancStart, qc::Control{static_cast<Qubit>(i)});
+    qcMapped->x(ancStart, qc::Control{static_cast<Qubit>(i + nQubits)});
+    qcMapped->x(ancStart + 1, qc::Control{static_cast<Qubit>(i + nQubits)});
+    qcMapped->x(ancStart + 1, qc::Control{static_cast<Qubit>(i + 2 * nQubits)});
+
+    qcMapped->measure(ancStart, clStart);
+    qcMapped->measure(ancStart + 1, clStart + 1);
+
+    const auto controlRegister =
+        std::make_pair(clStart, static_cast<QubitCount>(2));
+    qcMapped->classicControlled(qc::X, static_cast<Qubit>(i), controlRegister,
+                                1U);
+    qcMapped->classicControlled(qc::X, static_cast<Qubit>(i + 2 * nQubits),
+                                controlRegister, 2U);
+    qcMapped->classicControlled(qc::X, static_cast<Qubit>(i + nQubits),
+                                controlRegister, 3U);
+  }
+}
+
+void Q3Shor::writeDecoding() {
+  if (isDecoded) {
+    return;
+  }
+  const auto nQubits = qcOriginal->getNqubits();
+  for (Qubit i = 0; i < nQubits; i++) {
+    std::array<Qubit, N_REDUNDANT_QUBITS> qubits = {
+        i, static_cast<Qubit>(i + nQubits),
+        static_cast<Qubit>(i + 2 * nQubits)};
+    qcMapped->x(qubits[1], qc::Control{qubits[0]});
+    qcMapped->x(qubits[2], qc::Control{qubits[0]});
+    qcMapped->x(qubits[0], {qc::Control{qubits[1]}, qc::Control{qubits[2]}});
+  }
+  isDecoded = true;
+}
+
+void Q3Shor::mapGate(const qc::Operation& gate) {
+  if (isDecoded && gate.getType() != qc::Measure && gate.getType() != qc::H) {
+    writeEncoding();
+  }
+  const auto nQubits = qcOriginal->getNqubits();
+  switch (gate.getType()) {
+  case qc::I:
+  case qc::Barrier:
+    break;
+  case qc::X:
+  case qc::Y:
+  case qc::Z:
+  case qc::S:
+  case qc::Sdag:
+  case qc::T:
+  case qc::Tdag:
+    for (std::size_t j = 0; j < gate.getNtargets(); j++) {
+      auto i = gate.getTargets()[j];
+      if (gate.getNcontrols() != 0U) {
+        const auto& controls = gate.getControls();
+        qcMapped->emplace_back<qc::StandardOperation>(
+            qcMapped->getNqubits(), controls, i, gate.getType());
+        qc::Controls controls2;
+        qc::Controls controls3;
+        for (const auto& ct : controls) {
+          controls2.insert(
+              qc::Control{static_cast<Qubit>(ct.qubit + nQubits), ct.type});
+          controls3.insert(
+              qc::Control{static_cast<Qubit>(ct.qubit + 2 * nQubits), ct.type});
+        }
+        qcMapped->emplace_back<qc::StandardOperation>(
+            qcMapped->getNqubits(), controls2, i + nQubits, gate.getType());
+        qcMapped->emplace_back<qc::StandardOperation>(
+            qcMapped->getNqubits(), controls3, i + 2 * nQubits, gate.getType());
+      } else {
+        qcMapped->emplace_back<qc::StandardOperation>(qcMapped->getNqubits(), i,
+                                                      gate.getType());
+        qcMapped->emplace_back<qc::StandardOperation>(
+            qcMapped->getNqubits(), i + nQubits, gate.getType());
+        qcMapped->emplace_back<qc::StandardOperation>(
+            qcMapped->getNqubits(), i + 2 * nQubits, gate.getType());
+      }
     }
-
-    void Q3Shor::writeDecoding() {
-        if (isDecoded) {
-            return;
-        }
-        const auto nQubits = qcOriginal->getNqubits();
-        for (Qubit i = 0; i < nQubits; i++) {
-            std::array<Qubit, N_REDUNDANT_QUBITS> qubits = {i, static_cast<Qubit>(i + nQubits), static_cast<Qubit>(i + 2 * nQubits)};
-            qcMapped->x(qubits[1], qc::Control{qubits[0]});
-            qcMapped->x(qubits[2], qc::Control{qubits[0]});
-            qcMapped->x(qubits[0], {qc::Control{qubits[1]}, qc::Control{qubits[2]}});
-        }
-        isDecoded = true;
+    break;
+  case qc::Measure:
+    if (!isDecoded) {
+      measureAndCorrect();
+      writeDecoding();
     }
-
-    void Q3Shor::mapGate(const qc::Operation& gate) {
-        if (isDecoded && gate.getType() != qc::Measure && gate.getType() != qc::H) {
-            writeEncoding();
-        }
-        const auto nQubits = qcOriginal->getNqubits();
-        switch (gate.getType()) {
-            case qc::I:
-            case qc::Barrier:
-                break;
-            case qc::X:
-            case qc::Y:
-            case qc::Z:
-            case qc::S:
-            case qc::Sdag:
-            case qc::T:
-            case qc::Tdag:
-                for (std::size_t j = 0; j < gate.getNtargets(); j++) {
-                    auto i = gate.getTargets()[j];
-                    if (gate.getNcontrols() != 0U) {
-                        const auto& controls = gate.getControls();
-                        qcMapped->emplace_back<qc::StandardOperation>(qcMapped->getNqubits(), controls, i, gate.getType());
-                        qc::Controls controls2;
-                        qc::Controls controls3;
-                        for (const auto& ct: controls) {
-                            controls2.insert(qc::Control{static_cast<Qubit>(ct.qubit + nQubits), ct.type});
-                            controls3.insert(qc::Control{static_cast<Qubit>(ct.qubit + 2 * nQubits), ct.type});
-                        }
-                        qcMapped->emplace_back<qc::StandardOperation>(qcMapped->getNqubits(), controls2, i + nQubits, gate.getType());
-                        qcMapped->emplace_back<qc::StandardOperation>(qcMapped->getNqubits(), controls3, i + 2 * nQubits, gate.getType());
-                    } else {
-                        qcMapped->emplace_back<qc::StandardOperation>(qcMapped->getNqubits(), i, gate.getType());
-                        qcMapped->emplace_back<qc::StandardOperation>(qcMapped->getNqubits(), i + nQubits, gate.getType());
-                        qcMapped->emplace_back<qc::StandardOperation>(qcMapped->getNqubits(), i + 2 * nQubits, gate.getType());
-                    }
-                }
-                break;
-            case qc::Measure:
-                if (!isDecoded) {
-                    measureAndCorrect();
-                    writeDecoding();
-                }
-                if (const auto* measureGate = dynamic_cast<const qc::NonUnitaryOperation*>(&gate)) {
-                    for (std::size_t j = 0; j < measureGate->getNclassics(); j++) {
-                        qcMapped->measure(measureGate->getTargets()[j], measureGate->getClassics()[j]);
-                    }
-                } else {
-                    throw std::runtime_error("Dynamic cast to NonUnitaryOperation failed.");
-                }
-                break;
-            default:
-                gateNotAvailableError(gate);
-                break;
-        }
+    if (const auto* measureGate =
+            dynamic_cast<const qc::NonUnitaryOperation*>(&gate)) {
+      for (std::size_t j = 0; j < measureGate->getNclassics(); j++) {
+        qcMapped->measure(measureGate->getTargets()[j],
+                          measureGate->getClassics()[j]);
+      }
+    } else {
+      throw std::runtime_error("Dynamic cast to NonUnitaryOperation failed.");
     }
+    break;
+  default:
+    gateNotAvailableError(gate);
+    break;
+  }
+}
 } // namespace ecc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/src/ecc/Q5Laflamme.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/ecc/Q5Laflamme.cpp`

 * *Files 10% similar despite different names*

```diff
@@ -1,156 +1,166 @@
-/*
- * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
- */
-
 #include "ecc/Q5Laflamme.hpp"
 namespace ecc {
-    void Q5Laflamme::writeEncoding() {
-        Ecc::writeEncoding();
+void Q5Laflamme::writeEncoding() {
+  Ecc::writeEncoding();
 
-        const auto nQubits         = qcOriginal->getNqubits();
-        const auto ancStart        = static_cast<Qubit>(nQubits * ecc.nRedundantQubits);
-        const auto clEncode        = qcOriginal->getNcbits() + N_CORRECTING_BITS; //encode
-        const auto controlRegister = std::make_pair(static_cast<Qubit>(clEncode), static_cast<QubitCount>(1));
+  const auto nQubits = qcOriginal->getNqubits();
+  const auto ancStart = static_cast<Qubit>(nQubits * ecc.nRedundantQubits);
+  const auto clEncode = qcOriginal->getNcbits() + N_CORRECTING_BITS; // encode
+  const auto controlRegister =
+      std::make_pair(static_cast<Qubit>(clEncode), static_cast<QubitCount>(1));
+
+  for (Qubit i = 0; i < nQubits; i++) {
+    qcMapped->reset(ancStart);
+  }
+
+  for (Qubit i = 0; i < nQubits; i++) {
+    qcMapped->h(ancStart);
+    for (std::size_t j = 0; j < ecc.nRedundantQubits; j++) {
+      qcMapped->z(static_cast<Qubit>(i + j * nQubits), qc::Control{ancStart});
+    }
+    qcMapped->h(ancStart);
+    qcMapped->measure(ancStart, clEncode);
 
-        for (Qubit i = 0; i < nQubits; i++) {
-            qcMapped->reset(ancStart);
-        }
+    for (std::size_t j = 0; j < ecc.nRedundantQubits; j++) {
+      qcMapped->classicControlled(qc::X, static_cast<Qubit>(i + j * nQubits),
+                                  controlRegister);
+    }
+  }
+  gatesWritten = true;
+}
+
+void Q5Laflamme::measureAndCorrect() {
+  if (isDecoded) {
+    return;
+  }
+  const auto nQubits = static_cast<Qubit>(qcOriginal->getNqubits());
+  const auto ancStart = static_cast<Qubit>(nQubits * ecc.nRedundantQubits);
+  const auto clAncStart = static_cast<Qubit>(qcOriginal->getNcbits());
+
+  for (Qubit i = 0; i < nQubits; i++) {
+    std::array<Qubit, N_REDUNDANT_QUBITS> qubits = {};
+    for (std::size_t j = 0; j < qubits.size(); j++) {
+      qubits.at(j) = static_cast<Qubit>(i + j * nQubits);
+    }
 
-        for (Qubit i = 0; i < nQubits; i++) {
-            qcMapped->h(ancStart);
-            for (std::size_t j = 0; j < ecc.nRedundantQubits; j++) {
-                qcMapped->z(static_cast<Qubit>(i + j * nQubits), qc::Control{ancStart});
-            }
-            qcMapped->h(ancStart);
-            qcMapped->measure(ancStart, clEncode);
-
-            for (std::size_t j = 0; j < ecc.nRedundantQubits; j++) {
-                qcMapped->classicControlled(qc::X, static_cast<Qubit>(i + j * nQubits), controlRegister);
-            }
-        }
-        gatesWritten = true;
+    // initialize ancilla qubits
+    std::array<qc::Control, N_CORRECTING_BITS> controls;
+    for (std::size_t j = 0; j < controls.size(); j++) {
+      qcMapped->reset(static_cast<Qubit>(ancStart + j));
+      qcMapped->h(static_cast<Qubit>(ancStart + j));
+      controls.at(j) = qc::Control{static_cast<Qubit>(ancStart + j)};
     }
 
-    void Q5Laflamme::measureAndCorrect() {
-        if (isDecoded) {
-            return;
-        }
-        const auto nQubits    = static_cast<Qubit>(qcOriginal->getNqubits());
-        const auto ancStart   = static_cast<Qubit>(nQubits * ecc.nRedundantQubits);
-        const auto clAncStart = static_cast<Qubit>(qcOriginal->getNcbits());
-
-        for (Qubit i = 0; i < nQubits; i++) {
-            std::array<Qubit, N_REDUNDANT_QUBITS> qubits = {};
-            for (std::size_t j = 0; j < qubits.size(); j++) {
-                qubits.at(j) = static_cast<Qubit>(i + j * nQubits);
-            }
-
-            //initialize ancilla qubits
-            std::array<qc::Control, N_CORRECTING_BITS> controls;
-            for (std::size_t j = 0; j < controls.size(); j++) {
-                qcMapped->reset(static_cast<Qubit>(ancStart + j));
-                qcMapped->h(static_cast<Qubit>(ancStart + j));
-                controls.at(j) = qc::Control{static_cast<Qubit>(ancStart + j)};
-            }
-
-            //performs the controlled operations for ancilla qubits
-            for (std::size_t c = 0; c < STABILIZER_MATRIX.size(); c++) {
-                for (std::size_t q = 0; q < STABILIZER_MATRIX.at(c).size(); q++) {
-                    switch (STABILIZER_MATRIX.at(c).at(q)) {
-                        case qc::X: qcMapped->x(qubits.at(q), controls.at(c)); break;
-                        case qc::Z: qcMapped->z(qubits.at(q), controls.at(c)); break;
-                        default: break;
-                    }
-                }
-            }
-
-            //measure ancilla qubits
-            for (std::size_t j = 0; j < ecc.nCorrectingBits; j++) {
-                qcMapped->h(static_cast<Qubit>(ancStart + j));
-                qcMapped->measure(static_cast<Qubit>(ancStart + j), clAncStart + j);
-            }
-
-            const auto controlRegister = std::make_pair(static_cast<Qubit>(qcOriginal->getNcbits()), N_CORRECTING_BITS);
-
-            //perform corrections
-            for (std::size_t q = 0; q < ecc.nRedundantQubits; q++) {
-                for (auto op: {qc::X, qc::Y, qc::Z}) {
-                    std::size_t value = 0;
-                    for (std::size_t c = 0; c < STABILIZER_MATRIX.size(); c++) {
-                        const auto stabilizerOp = STABILIZER_MATRIX.at(c).at(q);
-                        if (stabilizerOp != qc::I && stabilizerOp != op) {
-                            value |= (1 << c);
-                        }
-                    }
-                    qcMapped->classicControlled(op, qubits.at(q), controlRegister, value);
-                }
-            }
+    // performs the controlled operations for ancilla qubits
+    for (std::size_t c = 0; c < STABILIZER_MATRIX.size(); c++) {
+      for (std::size_t q = 0; q < STABILIZER_MATRIX.at(c).size(); q++) {
+        switch (STABILIZER_MATRIX.at(c).at(q)) {
+        case qc::X:
+          qcMapped->x(qubits.at(q), controls.at(c));
+          break;
+        case qc::Z:
+          qcMapped->z(qubits.at(q), controls.at(c));
+          break;
+        default:
+          break;
         }
+      }
     }
 
-    void Q5Laflamme::writeDecoding() {
-        if (isDecoded) {
-            return;
-        }
-        const QubitCount nQubits    = qcOriginal->getNqubits();
-        const size_t     clAncStart = qcOriginal->getNcbits();
+    // measure ancilla qubits
+    for (std::size_t j = 0; j < ecc.nCorrectingBits; j++) {
+      qcMapped->h(static_cast<Qubit>(ancStart + j));
+      qcMapped->measure(static_cast<Qubit>(ancStart + j), clAncStart + j);
+    }
+
+    const auto controlRegister = std::make_pair(
+        static_cast<Qubit>(qcOriginal->getNcbits()), N_CORRECTING_BITS);
 
-        for (std::size_t i = 0; i < nQubits; i++) {
-            //#|####
-            //0|1111
-            //odd amount of 1's -> x.at(0) = 1
-            //measure from index 1 (not 0) to 4, =qubit 2 to 5
-            for (std::size_t j = 1; j < ecc.nRedundantQubits; j++) {
-                qcMapped->measure(static_cast<Qubit>(i + j * nQubits), clAncStart + j - 1);
-            }
-            const auto controlRegister = std::make_pair(static_cast<Qubit>(clAncStart), N_CORRECTING_BITS);
-            for (Qubit const value: DECODING_CORRECTION_VALUES) {
-                qcMapped->classicControlled(qc::X, static_cast<Qubit>(i), controlRegister, value);
-            }
+    // perform corrections
+    for (std::size_t q = 0; q < ecc.nRedundantQubits; q++) {
+      for (auto op : {qc::X, qc::Y, qc::Z}) {
+        std::size_t value = 0;
+        for (std::size_t c = 0; c < STABILIZER_MATRIX.size(); c++) {
+          const auto stabilizerOp = STABILIZER_MATRIX.at(c).at(q);
+          if (stabilizerOp != qc::I && stabilizerOp != op) {
+            value |= (1 << c);
+          }
         }
-        isDecoded = true;
+        qcMapped->classicControlled(op, qubits.at(q), controlRegister, value);
+      }
     }
+  }
+}
 
-    void Q5Laflamme::mapGate(const qc::Operation& gate) {
-        if (isDecoded && gate.getType() != qc::Measure && gate.getType() != qc::H) {
-            writeEncoding();
-        }
-        const auto nQubits = qcOriginal->getNqubits();
-        switch (gate.getType()) {
-            case qc::I:
-            case qc::Barrier:
-                break;
-            case qc::X:
-            case qc::Y:
-            case qc::Z:
-                for (std::size_t t = 0; t < gate.getNtargets(); t++) {
-                    auto i = gate.getTargets().at(t);
-                    if (gate.getNcontrols() != 0U) {
-                        gateNotAvailableError(gate);
-                    } else {
-                        for (Qubit j = 0; j < N_REDUNDANT_QUBITS; j++) {
-                            qcMapped->emplace_back<qc::StandardOperation>(qcMapped->getNqubits(), static_cast<Qubit>(i + j * nQubits), gate.getType());
-                        }
-                    }
-                }
-                break;
-            case qc::Measure:
-                if (!isDecoded) {
-                    measureAndCorrect();
-                    writeDecoding();
-                }
-                if (const auto* measureGate = dynamic_cast<const qc::NonUnitaryOperation*>(&gate)) {
-                    for (std::size_t j = 0; j < measureGate->getNclassics(); j++) {
-                        qcMapped->measure(static_cast<Qubit>(measureGate->getClassics().at(j)), measureGate->getTargets().at(j));
-                    }
-                } else {
-                    throw std::runtime_error("Dynamic cast to NonUnitaryOperation failed.");
-                }
-
-                break;
-            default:
-                gateNotAvailableError(gate);
+void Q5Laflamme::writeDecoding() {
+  if (isDecoded) {
+    return;
+  }
+  const QubitCount nQubits = qcOriginal->getNqubits();
+  const size_t clAncStart = qcOriginal->getNcbits();
+
+  for (std::size_t i = 0; i < nQubits; i++) {
+    // #|####
+    // 0|1111
+    // odd amount of 1's -> x.at(0) = 1
+    // measure from index 1 (not 0) to 4, =qubit 2 to 5
+    for (std::size_t j = 1; j < ecc.nRedundantQubits; j++) {
+      qcMapped->measure(static_cast<Qubit>(i + j * nQubits),
+                        clAncStart + j - 1);
+    }
+    const auto controlRegister =
+        std::make_pair(static_cast<Qubit>(clAncStart), N_CORRECTING_BITS);
+    for (Qubit const value : DECODING_CORRECTION_VALUES) {
+      qcMapped->classicControlled(qc::X, static_cast<Qubit>(i), controlRegister,
+                                  value);
+    }
+  }
+  isDecoded = true;
+}
+
+void Q5Laflamme::mapGate(const qc::Operation& gate) {
+  if (isDecoded && gate.getType() != qc::Measure && gate.getType() != qc::H) {
+    writeEncoding();
+  }
+  const auto nQubits = qcOriginal->getNqubits();
+  switch (gate.getType()) {
+  case qc::I:
+  case qc::Barrier:
+    break;
+  case qc::X:
+  case qc::Y:
+  case qc::Z:
+    for (std::size_t t = 0; t < gate.getNtargets(); t++) {
+      auto i = gate.getTargets().at(t);
+      if (gate.getNcontrols() != 0U) {
+        gateNotAvailableError(gate);
+      } else {
+        for (Qubit j = 0; j < N_REDUNDANT_QUBITS; j++) {
+          qcMapped->emplace_back<qc::StandardOperation>(
+              qcMapped->getNqubits(), static_cast<Qubit>(i + j * nQubits),
+              gate.getType());
         }
+      }
+    }
+    break;
+  case qc::Measure:
+    if (!isDecoded) {
+      measureAndCorrect();
+      writeDecoding();
     }
+    if (const auto* measureGate =
+            dynamic_cast<const qc::NonUnitaryOperation*>(&gate)) {
+      for (std::size_t j = 0; j < measureGate->getNclassics(); j++) {
+        qcMapped->measure(static_cast<Qubit>(measureGate->getClassics().at(j)),
+                          measureGate->getTargets().at(j));
+      }
+    } else {
+      throw std::runtime_error("Dynamic cast to NonUnitaryOperation failed.");
+    }
+
+    break;
+  default:
+    gateNotAvailableError(gate);
+  }
+}
 } // namespace ecc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/src/ecc/Q7Steane.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/ecc/Q7Steane.cpp`

 * *Files 12% similar despite different names*

```diff
@@ -1,210 +1,236 @@
-/*
-* This file is part of MQT QFR library which is released under the MIT license.
-* See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
-*/
-
 #include "ecc/Q7Steane.hpp"
 namespace ecc {
-    void Q7Steane::writeEncoding() {
-        if (!isDecoded) {
-            return;
-        }
-        isDecoded          = false;
-        const auto nQubits = qcOriginal->getNqubits();
-        //reset data qubits if necessary
-        if (gatesWritten) {
-            for (std::size_t i = 0; i < nQubits; i++) {
-                for (std::size_t j = 1; j < N_REDUNDANT_QUBITS; j++) {
-                    qcMapped->reset(static_cast<Qubit>(i + j * nQubits));
-                }
-            }
-        }
-        measureAndCorrectSingle(true);
-    }
-
-    void Q7Steane::measureAndCorrect() {
-        if (isDecoded) {
-            return;
-        }
-        measureAndCorrectSingle(true);
-        measureAndCorrectSingle(false);
-    }
-
-    void Q7Steane::measureAndCorrectSingle(bool xSyndrome) {
-        const auto nQubits         = qcOriginal->getNqubits();
-        const auto ancStart        = nQubits * ecc.nRedundantQubits;
-        const auto clAncStart      = qcOriginal->getNcbits();
-        const auto controlRegister = std::make_pair(static_cast<Qubit>(clAncStart), N_CORRECTING_BITS);
-
-        for (Qubit i = 0; i < nQubits; i++) {
-            if (gatesWritten) {
-                for (std::size_t j = 0; j < ecc.nCorrectingBits; j++) {
-                    qcMapped->reset(static_cast<Qubit>(ancStart + j));
-                }
-            }
-
-            std::array<qc::Control, 3> controls = {};
-            for (std::size_t j = 0; j < ecc.nCorrectingBits; j++) {
-                qcMapped->h(static_cast<Qubit>(ancStart + j));
-                controls.at(j) = qc::Control{static_cast<Qubit>(ancStart + j)};
-            }
-
-            //K1: UIUIUIU
-            //K2: IUUIIUU
-            //K3: IIIUUUU
-            for (std::size_t c = 0; c < controls.size(); c++) {
-                for (std::size_t q = 0; q < ecc.nRedundantQubits; q++) {
-                    if (((q + 1) & (1 << c)) != 0) {
-                        const auto target = static_cast<Qubit>(i + nQubits * q);
-                        if (xSyndrome) {
-                            qcMapped->x(target, controls.at(c));
-                        } else {
-                            qcMapped->z(target, controls.at(c));
-                        }
-                    }
-                }
-            }
-
-            for (std::size_t j = 0; j < ecc.nCorrectingBits; j++) {
-                qcMapped->h(static_cast<Qubit>(ancStart + j));
-                qcMapped->measure(static_cast<Qubit>(ancStart + j), clAncStart + j);
-            }
-
-            //correct Z_i for i+1 = c0*1+c1*2+c2*4
-            //correct X_i for i+1 = c3*1+c4*2+c5*4
-            const auto opType = xSyndrome ? qc::Z : qc::X;
-            for (std::size_t j = 0; j < N_REDUNDANT_QUBITS; j++) {
-                qcMapped->classicControlled(opType, static_cast<Qubit>(i + j * nQubits), controlRegister, j + 1U);
-            }
-            gatesWritten = true;
-        }
-    }
-
-    void Q7Steane::writeDecoding() {
-        if (isDecoded) {
-            return;
-        }
-        const auto nQubits    = qcOriginal->getNqubits();
-        const auto clAncStart = qcOriginal->getNcbits();
-
-        //use exiting registers qeccX and qeccZ for decoding
-        const auto controlRegister = std::make_pair(static_cast<Qubit>(clAncStart), N_CORRECTING_BITS);
-
-        for (Qubit i = 0; i < nQubits; i++) {
-            //#|###|###
-            //0|111|111
-            //odd amount of 1's -> x.at(0) = 1
-            //measure from index 1 (not 0) to 6, =qubit 2 to 7
-
-            qcMapped->measure(static_cast<Qubit>(i + 1 * nQubits), clAncStart);
-            qcMapped->measure(static_cast<Qubit>(i + 2 * nQubits), clAncStart + 1);
-            qcMapped->measure(static_cast<Qubit>(i + 3 * nQubits), clAncStart + 2);
-            for (auto value: DECODING_CORRECTION_VALUES) {
-                qcMapped->classicControlled(qc::X, i, controlRegister, value);
-            }
-            qcMapped->measure(static_cast<Qubit>(i + 4 * nQubits), clAncStart);
-            qcMapped->measure(static_cast<Qubit>(i + 5 * nQubits), clAncStart + 1);
-            qcMapped->measure(static_cast<Qubit>(i + 6 * nQubits), clAncStart + 2);
-            for (auto value: DECODING_CORRECTION_VALUES) {
-                qcMapped->classicControlled(qc::X, i, controlRegister, value);
-            }
-        }
-        isDecoded = true;
-    }
-
-    void Q7Steane::mapGate(const qc::Operation& gate) {
-        if (isDecoded && gate.getType() != qc::Measure) {
-            writeEncoding();
-        }
-        const QubitCount nQubits = qcOriginal->getNqubits();
-        switch (gate.getType()) {
-            case qc::I:
-            case qc::Barrier:
-                break;
-            case qc::X:
-            case qc::H:
-            case qc::Y:
-            case qc::Z:
-                for (auto i: gate.getTargets()) {
-                    if (gate.getNcontrols() != 0U) {
-                        const auto& ctrls = gate.getControls();
-                        for (std::size_t j = 0; j < N_REDUNDANT_QUBITS; j++) {
-                            qc::Controls ctrls2;
-                            for (const auto& ct: ctrls) {
-                                ctrls2.insert(qc::Control{static_cast<Qubit>(ct.qubit + j * nQubits), ct.type});
-                            }
-                            qcMapped->emplace_back<qc::StandardOperation>(qcMapped->getNqubits(), ctrls2, static_cast<Qubit>(i + j * nQubits), gate.getType());
-                        }
-                    } else {
-                        for (std::size_t j = 0; j < N_REDUNDANT_QUBITS; j++) {
-                            qcMapped->emplace_back<qc::StandardOperation>(qcMapped->getNqubits(), static_cast<Qubit>(i + j * nQubits), gate.getType());
-                        }
-                    }
-                }
-                break;
-                //locigal S = 3 physical S's
-            case qc::S:
-            case qc::Sdag:
-                for (auto i: gate.getTargets()) {
-                    if (gate.getNcontrols() != 0U) {
-                        const auto& ctrls = gate.getControls();
-                        for (std::size_t j = 0; j < N_REDUNDANT_QUBITS; j++) {
-                            qc::Controls ctrls2;
-                            for (const auto& ct: ctrls) {
-                                ctrls2.insert(qc::Control{static_cast<Qubit>(ct.qubit + j * nQubits), ct.type});
-                            }
-                            qcMapped->emplace_back<qc::StandardOperation>(qcMapped->getNqubits(), ctrls2, static_cast<Qubit>(i + j * nQubits), gate.getType());
-                            qcMapped->emplace_back<qc::StandardOperation>(qcMapped->getNqubits(), ctrls2, static_cast<Qubit>(i + j * nQubits), gate.getType());
-                            qcMapped->emplace_back<qc::StandardOperation>(qcMapped->getNqubits(), ctrls2, static_cast<Qubit>(i + j * nQubits), gate.getType());
-                        }
-                    } else {
-                        for (std::size_t j = 0; j < N_REDUNDANT_QUBITS; j++) {
-                            qcMapped->emplace_back<qc::StandardOperation>(qcMapped->getNqubits(), static_cast<Qubit>(i + j * nQubits), gate.getType());
-                            qcMapped->emplace_back<qc::StandardOperation>(qcMapped->getNqubits(), static_cast<Qubit>(i + j * nQubits), gate.getType());
-                            qcMapped->emplace_back<qc::StandardOperation>(qcMapped->getNqubits(), static_cast<Qubit>(i + j * nQubits), gate.getType());
-                        }
-                    }
-                }
-                break;
-            case qc::Measure:
-                if (!isDecoded) {
-                    measureAndCorrect();
-                    writeDecoding();
-                }
-                if (const auto* measureGate = dynamic_cast<const qc::NonUnitaryOperation*>(&gate)) {
-                    for (std::size_t j = 0; j < measureGate->getNclassics(); j++) {
-                        auto classicalRegisterName = qcOriginal->getClassicalRegister(measureGate->getTargets().at(j));
-                        if (!classicalRegisterName.empty()) {
-                            qcMapped->measure(static_cast<Qubit>(measureGate->getClassics().at(j)), {classicalRegisterName, measureGate->getTargets().at(j)});
-                        } else {
-                            qcMapped->measure(static_cast<Qubit>(measureGate->getClassics().at(j)), measureGate->getTargets().at(j));
-                        }
-                    }
-                } else {
-                    throw std::runtime_error("Dynamic cast to NonUnitaryOperation failed.");
-                }
-
-                break;
-            case qc::T:
-            case qc::Tdag:
-                for (auto i: gate.getTargets()) {
-                    if (gate.getControls().empty()) {
-                        qcMapped->x(static_cast<Qubit>(i + 5 * nQubits), qc::Control{static_cast<Qubit>(i + 6 * nQubits)});
-                        qcMapped->x(static_cast<Qubit>(i + 0 * nQubits), qc::Control{static_cast<Qubit>(i + 5 * nQubits)});
-                        if (gate.getType() == qc::T) {
-                            qcMapped->t(static_cast<Qubit>(i + 0 * nQubits));
-                        } else {
-                            qcMapped->tdag(static_cast<Qubit>(i + 0 * nQubits));
-                        }
-                        qcMapped->x(static_cast<Qubit>(i + 0 * nQubits), qc::Control{static_cast<Qubit>(i + 5 * nQubits)});
-                        qcMapped->x(static_cast<Qubit>(i + 5 * nQubits), qc::Control{static_cast<Qubit>(i + 6 * nQubits)});
-                    } else {
-                        gateNotAvailableError(gate);
-                    }
-                }
-                break;
-            default:
-                gateNotAvailableError(gate);
+void Q7Steane::writeEncoding() {
+  if (!isDecoded) {
+    return;
+  }
+  isDecoded = false;
+  const auto nQubits = qcOriginal->getNqubits();
+  // reset data qubits if necessary
+  if (gatesWritten) {
+    for (std::size_t i = 0; i < nQubits; i++) {
+      for (std::size_t j = 1; j < N_REDUNDANT_QUBITS; j++) {
+        qcMapped->reset(static_cast<Qubit>(i + j * nQubits));
+      }
+    }
+  }
+  measureAndCorrectSingle(true);
+}
+
+void Q7Steane::measureAndCorrect() {
+  if (isDecoded) {
+    return;
+  }
+  measureAndCorrectSingle(true);
+  measureAndCorrectSingle(false);
+}
+
+void Q7Steane::measureAndCorrectSingle(bool xSyndrome) {
+  const auto nQubits = qcOriginal->getNqubits();
+  const auto ancStart = nQubits * ecc.nRedundantQubits;
+  const auto clAncStart = qcOriginal->getNcbits();
+  const auto controlRegister =
+      std::make_pair(static_cast<Qubit>(clAncStart), N_CORRECTING_BITS);
+
+  for (Qubit i = 0; i < nQubits; i++) {
+    if (gatesWritten) {
+      for (std::size_t j = 0; j < ecc.nCorrectingBits; j++) {
+        qcMapped->reset(static_cast<Qubit>(ancStart + j));
+      }
+    }
+
+    std::array<qc::Control, 3> controls = {};
+    for (std::size_t j = 0; j < ecc.nCorrectingBits; j++) {
+      qcMapped->h(static_cast<Qubit>(ancStart + j));
+      controls.at(j) = qc::Control{static_cast<Qubit>(ancStart + j)};
+    }
+
+    // K1: UIUIUIU
+    // K2: IUUIIUU
+    // K3: IIIUUUU
+    for (std::size_t c = 0; c < controls.size(); c++) {
+      for (std::size_t q = 0; q < ecc.nRedundantQubits; q++) {
+        if (((q + 1) & (1 << c)) != 0) {
+          const auto target = static_cast<Qubit>(i + nQubits * q);
+          if (xSyndrome) {
+            qcMapped->x(target, controls.at(c));
+          } else {
+            qcMapped->z(target, controls.at(c));
+          }
+        }
+      }
+    }
+
+    for (std::size_t j = 0; j < ecc.nCorrectingBits; j++) {
+      qcMapped->h(static_cast<Qubit>(ancStart + j));
+      qcMapped->measure(static_cast<Qubit>(ancStart + j), clAncStart + j);
+    }
+
+    // correct Z_i for i+1 = c0*1+c1*2+c2*4
+    // correct X_i for i+1 = c3*1+c4*2+c5*4
+    const auto opType = xSyndrome ? qc::Z : qc::X;
+    for (std::size_t j = 0; j < N_REDUNDANT_QUBITS; j++) {
+      qcMapped->classicControlled(opType, static_cast<Qubit>(i + j * nQubits),
+                                  controlRegister, j + 1U);
+    }
+    gatesWritten = true;
+  }
+}
+
+void Q7Steane::writeDecoding() {
+  if (isDecoded) {
+    return;
+  }
+  const auto nQubits = qcOriginal->getNqubits();
+  const auto clAncStart = qcOriginal->getNcbits();
+
+  // use exiting registers qeccX and qeccZ for decoding
+  const auto controlRegister =
+      std::make_pair(static_cast<Qubit>(clAncStart), N_CORRECTING_BITS);
+
+  for (Qubit i = 0; i < nQubits; i++) {
+    // #|###|###
+    // 0|111|111
+    // odd amount of 1's -> x.at(0) = 1
+    // measure from index 1 (not 0) to 6, =qubit 2 to 7
+
+    qcMapped->measure(static_cast<Qubit>(i + 1 * nQubits), clAncStart);
+    qcMapped->measure(static_cast<Qubit>(i + 2 * nQubits), clAncStart + 1);
+    qcMapped->measure(static_cast<Qubit>(i + 3 * nQubits), clAncStart + 2);
+    for (auto value : DECODING_CORRECTION_VALUES) {
+      qcMapped->classicControlled(qc::X, i, controlRegister, value);
+    }
+    qcMapped->measure(static_cast<Qubit>(i + 4 * nQubits), clAncStart);
+    qcMapped->measure(static_cast<Qubit>(i + 5 * nQubits), clAncStart + 1);
+    qcMapped->measure(static_cast<Qubit>(i + 6 * nQubits), clAncStart + 2);
+    for (auto value : DECODING_CORRECTION_VALUES) {
+      qcMapped->classicControlled(qc::X, i, controlRegister, value);
+    }
+  }
+  isDecoded = true;
+}
+
+void Q7Steane::mapGate(const qc::Operation& gate) {
+  if (isDecoded && gate.getType() != qc::Measure) {
+    writeEncoding();
+  }
+  const QubitCount nQubits = qcOriginal->getNqubits();
+  switch (gate.getType()) {
+  case qc::I:
+  case qc::Barrier:
+    break;
+  case qc::X:
+  case qc::H:
+  case qc::Y:
+  case qc::Z:
+    for (auto i : gate.getTargets()) {
+      if (gate.getNcontrols() != 0U) {
+        const auto& ctrls = gate.getControls();
+        for (std::size_t j = 0; j < N_REDUNDANT_QUBITS; j++) {
+          qc::Controls ctrls2;
+          for (const auto& ct : ctrls) {
+            ctrls2.insert(qc::Control{
+                static_cast<Qubit>(ct.qubit + j * nQubits), ct.type});
+          }
+          qcMapped->emplace_back<qc::StandardOperation>(
+              qcMapped->getNqubits(), ctrls2,
+              static_cast<Qubit>(i + j * nQubits), gate.getType());
+        }
+      } else {
+        for (std::size_t j = 0; j < N_REDUNDANT_QUBITS; j++) {
+          qcMapped->emplace_back<qc::StandardOperation>(
+              qcMapped->getNqubits(), static_cast<Qubit>(i + j * nQubits),
+              gate.getType());
+        }
+      }
+    }
+    break;
+    // locigal S = 3 physical S's
+  case qc::S:
+  case qc::Sdag:
+    for (auto i : gate.getTargets()) {
+      if (gate.getNcontrols() != 0U) {
+        const auto& ctrls = gate.getControls();
+        for (std::size_t j = 0; j < N_REDUNDANT_QUBITS; j++) {
+          qc::Controls ctrls2;
+          for (const auto& ct : ctrls) {
+            ctrls2.insert(qc::Control{
+                static_cast<Qubit>(ct.qubit + j * nQubits), ct.type});
+          }
+          qcMapped->emplace_back<qc::StandardOperation>(
+              qcMapped->getNqubits(), ctrls2,
+              static_cast<Qubit>(i + j * nQubits), gate.getType());
+          qcMapped->emplace_back<qc::StandardOperation>(
+              qcMapped->getNqubits(), ctrls2,
+              static_cast<Qubit>(i + j * nQubits), gate.getType());
+          qcMapped->emplace_back<qc::StandardOperation>(
+              qcMapped->getNqubits(), ctrls2,
+              static_cast<Qubit>(i + j * nQubits), gate.getType());
+        }
+      } else {
+        for (std::size_t j = 0; j < N_REDUNDANT_QUBITS; j++) {
+          qcMapped->emplace_back<qc::StandardOperation>(
+              qcMapped->getNqubits(), static_cast<Qubit>(i + j * nQubits),
+              gate.getType());
+          qcMapped->emplace_back<qc::StandardOperation>(
+              qcMapped->getNqubits(), static_cast<Qubit>(i + j * nQubits),
+              gate.getType());
+          qcMapped->emplace_back<qc::StandardOperation>(
+              qcMapped->getNqubits(), static_cast<Qubit>(i + j * nQubits),
+              gate.getType());
         }
+      }
+    }
+    break;
+  case qc::Measure:
+    if (!isDecoded) {
+      measureAndCorrect();
+      writeDecoding();
+    }
+    if (const auto* measureGate =
+            dynamic_cast<const qc::NonUnitaryOperation*>(&gate)) {
+      for (std::size_t j = 0; j < measureGate->getNclassics(); j++) {
+        auto classicalRegisterName =
+            qcOriginal->getClassicalRegister(measureGate->getTargets().at(j));
+        if (!classicalRegisterName.empty()) {
+          qcMapped->measure(
+              static_cast<Qubit>(measureGate->getClassics().at(j)),
+              {classicalRegisterName, measureGate->getTargets().at(j)});
+        } else {
+          qcMapped->measure(
+              static_cast<Qubit>(measureGate->getClassics().at(j)),
+              measureGate->getTargets().at(j));
+        }
+      }
+    } else {
+      throw std::runtime_error("Dynamic cast to NonUnitaryOperation failed.");
+    }
+
+    break;
+  case qc::T:
+  case qc::Tdag:
+    for (auto i : gate.getTargets()) {
+      if (gate.getControls().empty()) {
+        qcMapped->x(static_cast<Qubit>(i + 5 * nQubits),
+                    qc::Control{static_cast<Qubit>(i + 6 * nQubits)});
+        qcMapped->x(static_cast<Qubit>(i + 0 * nQubits),
+                    qc::Control{static_cast<Qubit>(i + 5 * nQubits)});
+        if (gate.getType() == qc::T) {
+          qcMapped->t(static_cast<Qubit>(i + 0 * nQubits));
+        } else {
+          qcMapped->tdag(static_cast<Qubit>(i + 0 * nQubits));
+        }
+        qcMapped->x(static_cast<Qubit>(i + 0 * nQubits),
+                    qc::Control{static_cast<Qubit>(i + 5 * nQubits)});
+        qcMapped->x(static_cast<Qubit>(i + 5 * nQubits),
+                    qc::Control{static_cast<Qubit>(i + 6 * nQubits)});
+      } else {
+        gateNotAvailableError(gate);
+      }
     }
+    break;
+  default:
+    gateNotAvailableError(gate);
+  }
+}
 } // namespace ecc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/src/ecc/Q9Shor.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/ecc/Q9Shor.cpp`

 * *Files 11% similar despite different names*

```diff
@@ -1,186 +1,201 @@
-/*
- * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
- */
-
 #include "ecc/Q9Shor.hpp"
 namespace ecc {
-    void Q9Shor::writeEncoding() {
-        if (!isDecoded) {
-            return;
-        }
-        isDecoded          = false;
-        const auto nQubits = qcOriginal->getNqubits();
-        for (Qubit i = 0; i < nQubits; i++) {
-            std::array<qc::Control, 3> controls = {};
-            for (std::size_t j = 0; j < controls.size(); j++) {
-                controls.at(j) = {static_cast<Qubit>(i + 3 * j * nQubits), qc::Control::Type::Pos};
-                if (j > 0) {
-                    qcMapped->x(static_cast<Qubit>(i + 3 * j * nQubits), controls[0]);
-                }
-            }
-            for (std::size_t j = 0; j < controls.size(); j++) {
-                qcMapped->h(static_cast<Qubit>(i + 3 * j * nQubits));
-                qcMapped->x(static_cast<Qubit>(i + (3 * j + 1) * nQubits), controls.at(j));
-                qcMapped->x(static_cast<Qubit>(i + (3 * j + 2) * nQubits), controls.at(j));
-            }
-        }
-        gatesWritten = true;
+void Q9Shor::writeEncoding() {
+  if (!isDecoded) {
+    return;
+  }
+  isDecoded = false;
+  const auto nQubits = qcOriginal->getNqubits();
+  for (Qubit i = 0; i < nQubits; i++) {
+    std::array<qc::Control, 3> controls = {};
+    for (std::size_t j = 0; j < controls.size(); j++) {
+      controls.at(j) = {static_cast<Qubit>(i + 3 * j * nQubits),
+                        qc::Control::Type::Pos};
+      if (j > 0) {
+        qcMapped->x(static_cast<Qubit>(i + 3 * j * nQubits), controls[0]);
+      }
+    }
+    for (std::size_t j = 0; j < controls.size(); j++) {
+      qcMapped->h(static_cast<Qubit>(i + 3 * j * nQubits));
+      qcMapped->x(static_cast<Qubit>(i + (3 * j + 1) * nQubits),
+                  controls.at(j));
+      qcMapped->x(static_cast<Qubit>(i + (3 * j + 2) * nQubits),
+                  controls.at(j));
+    }
+  }
+  gatesWritten = true;
+}
+
+void Q9Shor::measureAndCorrect() {
+  if (isDecoded) {
+    return;
+  }
+  const auto nQubits = qcOriginal->getNqubits();
+  const auto clStart = qcOriginal->getNcbits();
+  for (Qubit i = 0; i < nQubits; i++) {
+    // syntactic sugar for qubit indices
+    std::array<Qubit, N_REDUNDANT_QUBITS> qubits = {};
+    std::array<Qubit, N_CORRECTING_BITS> ancillaQubits = {};
+    std::array<qc::Control, N_CORRECTING_BITS> ancillaControls = {};
+    std::array<qc::Control, N_CORRECTING_BITS> negativeAncillaControls = {};
+    for (std::size_t j = 0; j < qubits.size(); j++) {
+      qubits.at(j) = static_cast<Qubit>(i + j * nQubits);
+    }
+    for (std::size_t j = 0; j < ancillaQubits.size(); j++) {
+      ancillaQubits.at(j) =
+          static_cast<Qubit>(ecc.nRedundantQubits * nQubits + j);
+      qcMapped->reset(ancillaQubits.at(j));
+    }
+    for (std::size_t j = 0; j < ancillaControls.size(); j++) {
+      ancillaControls.at(j) = qc::Control{ancillaQubits.at(j)};
+    }
+    for (std::size_t j = 0; j < negativeAncillaControls.size(); j++) {
+      negativeAncillaControls.at(j) =
+          qc::Control{ancillaQubits.at(j), qc::Control::Type::Neg};
     }
 
-    void Q9Shor::measureAndCorrect() {
-        if (isDecoded) {
-            return;
-        }
-        const auto nQubits = qcOriginal->getNqubits();
-        const auto clStart = qcOriginal->getNcbits();
-        for (Qubit i = 0; i < nQubits; i++) {
-            //syntactic sugar for qubit indices
-            std::array<Qubit, N_REDUNDANT_QUBITS>      qubits                  = {};
-            std::array<Qubit, N_CORRECTING_BITS>       ancillaQubits           = {};
-            std::array<qc::Control, N_CORRECTING_BITS> ancillaControls         = {};
-            std::array<qc::Control, N_CORRECTING_BITS> negativeAncillaControls = {};
-            for (std::size_t j = 0; j < qubits.size(); j++) {
-                qubits.at(j) = static_cast<Qubit>(i + j * nQubits);
-            }
-            for (std::size_t j = 0; j < ancillaQubits.size(); j++) {
-                ancillaQubits.at(j) = static_cast<Qubit>(ecc.nRedundantQubits * nQubits + j);
-                qcMapped->reset(ancillaQubits.at(j));
-            }
-            for (std::size_t j = 0; j < ancillaControls.size(); j++) {
-                ancillaControls.at(j) = qc::Control{ancillaQubits.at(j)};
-            }
-            for (std::size_t j = 0; j < negativeAncillaControls.size(); j++) {
-                negativeAncillaControls.at(j) = qc::Control{ancillaQubits.at(j), qc::Control::Type::Neg};
-            }
-
-            // PREPARE measurements --------------------------------------------------------
-            for (Qubit const j: ancillaQubits) {
-                qcMapped->h(j);
-            }
-            //x errors = indirectly via controlled z
-            for (std::size_t j = 0; j < 3; j++) {
-                qcMapped->z(qubits.at(3 * j), ancillaControls.at(2 * j));
-                qcMapped->z(qubits.at(3 * j + 1), ancillaControls.at(2 * j));
-                qcMapped->z(qubits.at(3 * j + 1), ancillaControls.at(2 * j + 1));
-                qcMapped->z(qubits.at(3 * j + 2), ancillaControls.at(2 * j + 1));
-            }
-
-            //z errors = indirectly via controlled x/C-NOT
-            for (std::size_t j = 0; j < 6; j++) {
-                qcMapped->x(qubits.at(j), ancillaControls[6]);
-                qcMapped->x(qubits.at(3 + j), ancillaControls[7]);
-            }
-
-            for (Qubit const j: ancillaQubits) {
-                qcMapped->h(j);
-            }
-
-            //MEASURE ancilla qubits
-            for (std::size_t j = 0; j < N_CORRECTING_BITS; j++) {
-                qcMapped->measure(ancillaQubits.at(j), clStart + j);
-            }
-
-            //CORRECT
-            //x, i.e. bit flip errors
-            for (std::size_t j = 0; j < 3; j++) {
-                const auto controlRegister = std::make_pair(static_cast<Qubit>(clStart + 2 * j), 2);
-                qcMapped->classicControlled(qc::X, qubits.at(3 * j), controlRegister, 1U);
-                qcMapped->classicControlled(qc::X, qubits.at(3 * j + 2), controlRegister, 2U);
-                qcMapped->classicControlled(qc::X, qubits.at(3 * j + 1), controlRegister, 3U);
-            }
-
-            //z, i.e. phase flip errors
-            const auto controlRegister = std::make_pair(static_cast<Qubit>(clStart + 6), 2);
-            qcMapped->classicControlled(qc::Z, qubits.at(0), controlRegister, 1U);
-            qcMapped->classicControlled(qc::Z, qubits.at(6), controlRegister, 2U);
-            qcMapped->classicControlled(qc::Z, qubits.at(3), controlRegister, 3U);
-        }
+    // PREPARE measurements
+    // --------------------------------------------------------
+    for (Qubit const j : ancillaQubits) {
+      qcMapped->h(j);
+    }
+    // x errors = indirectly via controlled z
+    for (std::size_t j = 0; j < 3; j++) {
+      qcMapped->z(qubits.at(3 * j), ancillaControls.at(2 * j));
+      qcMapped->z(qubits.at(3 * j + 1), ancillaControls.at(2 * j));
+      qcMapped->z(qubits.at(3 * j + 1), ancillaControls.at(2 * j + 1));
+      qcMapped->z(qubits.at(3 * j + 2), ancillaControls.at(2 * j + 1));
     }
 
-    void Q9Shor::writeDecoding() {
-        if (isDecoded) {
-            return;
-        }
-        const auto nQubits = qcOriginal->getNqubits();
-        for (Qubit i = 0; i < nQubits; i++) {
-            std::array<qc::Control, N_REDUNDANT_QUBITS> ci;
-            for (Qubit j = 0; j < ci.size(); j++) {
-                ci.at(j) = qc::Control{static_cast<Qubit>(i + j * nQubits), qc::Control::Type::Pos};
-            }
-
-            for (std::size_t j = 0; j < 3; j++) {
-                std::array<Qubit, 3> targets = {static_cast<Qubit>(i + 3 * j * nQubits), static_cast<Qubit>(i + (3 * j + 1) * nQubits), static_cast<Qubit>(i + (3 * j + 2) * nQubits)};
-                qcMapped->x(targets.at(1), ci.at(3 * j));
-                qcMapped->x(targets.at(2), ci.at(3 * j));
-                qcMapped->x(targets.at(0), {ci.at(3 * j + 1), ci.at(3 * j + 2)});
-                qcMapped->h(targets.at(0));
-            }
-
-            qcMapped->x(static_cast<Qubit>(i + 3 * nQubits), ci[0]);
-            qcMapped->x(static_cast<Qubit>(i + 6 * nQubits), ci[0]);
-            qcMapped->x(i, {ci.at(3), ci.at(6)});
-        }
-        isDecoded = true;
+    // z errors = indirectly via controlled x/C-NOT
+    for (std::size_t j = 0; j < 6; j++) {
+      qcMapped->x(qubits.at(j), ancillaControls[6]);
+      qcMapped->x(qubits.at(3 + j), ancillaControls[7]);
     }
 
-    void Q9Shor::mapGate(const qc::Operation& gate) {
-        if (isDecoded && gate.getType() != qc::Measure && gate.getType() != qc::H) {
-            writeEncoding();
-        }
-        const auto nQubits = qcOriginal->getNqubits();
-        auto       type    = qc::I;
-        switch (gate.getType()) {
-            case qc::I:
-            case qc::Barrier:
-                break;
-            case qc::X:
-                type = qc::Z;
-                break;
-            case qc::Y:
-                type = qc::Y;
-                break;
-            case qc::Z:
-                type = qc::X;
-                break;
-            case qc::Measure:
-                if (!isDecoded) {
-                    measureAndCorrect();
-                    writeDecoding();
-                }
-                if (const auto* measureGate = dynamic_cast<const qc::NonUnitaryOperation*>(&gate)) {
-                    for (std::size_t j = 0; j < measureGate->getNclassics(); j++) {
-                        qcMapped->measure(measureGate->getTargets().at(j), measureGate->getClassics().at(j));
-                    }
-                } else {
-                    throw std::runtime_error("Dynamic cast to NonUnitaryOperation failed.");
-                }
-                return;
-            default:
-                gateNotAvailableError(gate);
-        }
-        for (std::size_t t = 0; t < gate.getNtargets(); t++) {
-            auto i = gate.getTargets()[t];
+    for (Qubit const j : ancillaQubits) {
+      qcMapped->h(j);
+    }
 
-            if (gate.getNcontrols() != 0U) {
-                //Q9Shor code: put H gate before and after each control point, i.e. "cx 0,1" becomes "h0; cz 0,1; h0"
-                const auto& controls = gate.getControls();
-                for (size_t j = 0; j < N_REDUNDANT_QUBITS; j++) {
-                    qc::Controls controls2;
-                    for (const auto& ct: controls) {
-                        controls2.insert(qc::Control{static_cast<Qubit>(ct.qubit + j * nQubits), ct.type});
-                        qcMapped->h(static_cast<Qubit>(ct.qubit + j * nQubits));
-                    }
-                    qcMapped->emplace_back<qc::StandardOperation>(qcMapped->getNqubits(), controls2, i + j * nQubits, type);
-                    for (const auto& ct: controls) {
-                        qcMapped->h(static_cast<Qubit>(ct.qubit + j * nQubits));
-                    }
-                }
-            } else {
-                for (size_t j = 0; j < N_REDUNDANT_QUBITS; j++) {
-                    qcMapped->emplace_back<qc::StandardOperation>(qcMapped->getNqubits(), i + j * nQubits, type);
-                }
-            }
-        }
+    // MEASURE ancilla qubits
+    for (std::size_t j = 0; j < N_CORRECTING_BITS; j++) {
+      qcMapped->measure(ancillaQubits.at(j), clStart + j);
+    }
+
+    // CORRECT
+    // x, i.e. bit flip errors
+    for (std::size_t j = 0; j < 3; j++) {
+      const auto controlRegister =
+          std::make_pair(static_cast<Qubit>(clStart + 2 * j), 2);
+      qcMapped->classicControlled(qc::X, qubits.at(3 * j), controlRegister, 1U);
+      qcMapped->classicControlled(qc::X, qubits.at(3 * j + 2), controlRegister,
+                                  2U);
+      qcMapped->classicControlled(qc::X, qubits.at(3 * j + 1), controlRegister,
+                                  3U);
+    }
+
+    // z, i.e. phase flip errors
+    const auto controlRegister =
+        std::make_pair(static_cast<Qubit>(clStart + 6), 2);
+    qcMapped->classicControlled(qc::Z, qubits.at(0), controlRegister, 1U);
+    qcMapped->classicControlled(qc::Z, qubits.at(6), controlRegister, 2U);
+    qcMapped->classicControlled(qc::Z, qubits.at(3), controlRegister, 3U);
+  }
+}
+
+void Q9Shor::writeDecoding() {
+  if (isDecoded) {
+    return;
+  }
+  const auto nQubits = qcOriginal->getNqubits();
+  for (Qubit i = 0; i < nQubits; i++) {
+    std::array<qc::Control, N_REDUNDANT_QUBITS> ci;
+    for (Qubit j = 0; j < ci.size(); j++) {
+      ci.at(j) = qc::Control{static_cast<Qubit>(i + j * nQubits),
+                             qc::Control::Type::Pos};
+    }
+
+    for (std::size_t j = 0; j < 3; j++) {
+      std::array<Qubit, 3> targets = {
+          static_cast<Qubit>(i + 3 * j * nQubits),
+          static_cast<Qubit>(i + (3 * j + 1) * nQubits),
+          static_cast<Qubit>(i + (3 * j + 2) * nQubits)};
+      qcMapped->x(targets.at(1), ci.at(3 * j));
+      qcMapped->x(targets.at(2), ci.at(3 * j));
+      qcMapped->x(targets.at(0), {ci.at(3 * j + 1), ci.at(3 * j + 2)});
+      qcMapped->h(targets.at(0));
+    }
+
+    qcMapped->x(static_cast<Qubit>(i + 3 * nQubits), ci[0]);
+    qcMapped->x(static_cast<Qubit>(i + 6 * nQubits), ci[0]);
+    qcMapped->x(i, {ci.at(3), ci.at(6)});
+  }
+  isDecoded = true;
+}
+
+void Q9Shor::mapGate(const qc::Operation& gate) {
+  if (isDecoded && gate.getType() != qc::Measure && gate.getType() != qc::H) {
+    writeEncoding();
+  }
+  const auto nQubits = qcOriginal->getNqubits();
+  auto type = qc::I;
+  switch (gate.getType()) {
+  case qc::I:
+  case qc::Barrier:
+    break;
+  case qc::X:
+    type = qc::Z;
+    break;
+  case qc::Y:
+    type = qc::Y;
+    break;
+  case qc::Z:
+    type = qc::X;
+    break;
+  case qc::Measure:
+    if (!isDecoded) {
+      measureAndCorrect();
+      writeDecoding();
+    }
+    if (const auto* measureGate =
+            dynamic_cast<const qc::NonUnitaryOperation*>(&gate)) {
+      for (std::size_t j = 0; j < measureGate->getNclassics(); j++) {
+        qcMapped->measure(measureGate->getTargets().at(j),
+                          measureGate->getClassics().at(j));
+      }
+    } else {
+      throw std::runtime_error("Dynamic cast to NonUnitaryOperation failed.");
+    }
+    return;
+  default:
+    gateNotAvailableError(gate);
+  }
+  for (std::size_t t = 0; t < gate.getNtargets(); t++) {
+    auto i = gate.getTargets()[t];
+
+    if (gate.getNcontrols() != 0U) {
+      // Q9Shor code: put H gate before and after each control point, i.e. "cx
+      // 0,1" becomes "h0; cz 0,1; h0"
+      const auto& controls = gate.getControls();
+      for (size_t j = 0; j < N_REDUNDANT_QUBITS; j++) {
+        qc::Controls controls2;
+        for (const auto& ct : controls) {
+          controls2.insert(
+              qc::Control{static_cast<Qubit>(ct.qubit + j * nQubits), ct.type});
+          qcMapped->h(static_cast<Qubit>(ct.qubit + j * nQubits));
+        }
+        qcMapped->emplace_back<qc::StandardOperation>(
+            qcMapped->getNqubits(), controls2, i + j * nQubits, type);
+        for (const auto& ct : controls) {
+          qcMapped->h(static_cast<Qubit>(ct.qubit + j * nQubits));
+        }
+      }
+    } else {
+      for (size_t j = 0; j < N_REDUNDANT_QUBITS; j++) {
+        qcMapped->emplace_back<qc::StandardOperation>(qcMapped->getNqubits(),
+                                                      i + j * nQubits, type);
+      }
     }
+  }
+}
 } // namespace ecc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/src/ecc/Q9Surface.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/ecc/Q9Surface.cpp`

 * *Files 18% similar despite different names*

```diff
@@ -1,175 +1,182 @@
-/*
-* This file is part of MQT QFR library which is released under the MIT license.
-* See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
-*/
-
 #include "ecc/Q9Surface.hpp"
 namespace ecc {
-    void Q9Surface::measureAndCorrect() {
-        if (isDecoded) {
-            return;
-        }
-        const auto nQubits    = qcOriginal->getNqubits();
-        const auto ancStart   = qcOriginal->getNqubits() * ecc.nRedundantQubits;
-        const auto clAncStart = qcOriginal->getNcbits();
-        for (std::size_t i = 0; i < nQubits; i++) {
-            std::array<Qubit, N_REDUNDANT_QUBITS>       qubits          = {};
-            std::array<Qubit, N_CORRECTING_BITS>        ancillaQubits   = {};
-            std::array<qc::Control, N_CORRECTING_BITS>  ancillaControls = {};
-            std::array<qc::Control, N_REDUNDANT_QUBITS> controlQubits   = {};
-            for (std::size_t j = 0; j < qubits.size(); j++) {
-                qubits.at(j) = static_cast<Qubit>(i + j * nQubits);
-            }
-            for (std::size_t j = 0; j < ancillaQubits.size(); j++) {
-                ancillaQubits.at(j) = static_cast<Qubit>(ancStart + j);
-            }
-            if (gatesWritten) {
-                for (unsigned int ancillaQubit: ancillaQubits) {
-                    qcMapped->reset(ancillaQubit);
-                }
-            }
-            for (std::size_t j = 0; j < ancillaControls.size(); j++) {
-                ancillaControls.at(j) = qc::Control{ancillaQubits.at(j)};
-            }
-            for (std::size_t j = 0; j < controlQubits.size(); j++) {
-                controlQubits.at(j) = qc::Control{qubits.at(j)};
-            }
-
-            //X-type check (z error) on a0, a2, a5, a7: cx ancillaQubits->qubits
-            //Z-type check (x error) on a1, a3, a4, a6: cz ancillaQubits->qubits = cx qubits->ancillaQubits, no hadamard gate
-            for (auto q: Z_ANCILLA_QUBITS) {
-                qcMapped->h(ancillaQubits.at(q));
-            }
-
-            for (std::size_t q = 0; q < qubitCorrectionZ.size(); q++) {
-                for (auto c: qubitCorrectionZ.at(q)) {
-                    qcMapped->x(qubits.at(q), ancillaControls.at(c));
-                }
-            }
-
-            for (std::size_t q = 0; q < qubitCorrectionX.size(); q++) {
-                for (auto c: qubitCorrectionX.at(q)) {
-                    qcMapped->x(ancillaQubits.at(c), controlQubits.at(q));
-                }
-            }
-
-            for (std::size_t j = 0; j < Z_ANCILLA_QUBITS.size(); j++) {
-                qcMapped->h(ancillaQubits.at(Z_ANCILLA_QUBITS.at(j)));
-                qcMapped->measure(ancillaQubits.at(Z_ANCILLA_QUBITS.at(j)), clAncStart + j);
-                qcMapped->measure(ancillaQubits.at(X_ANCILLA_QUBITS.at(j)), clAncStart + 4 + j);
-            }
-
-            //correction
-            auto controlRegister = std::make_pair(static_cast<Qubit>(clAncStart), ANCILLA_WIDTH);
-            for (std::size_t q = 0; q < qubitCorrectionZ.size(); q++) {
-                if (uncorrectedZQubits.count(static_cast<Qubit>(q)) == 0) {
-                    std::size_t mask = 0;
-                    for (std::size_t c = 0; c < Z_ANCILLA_QUBITS.size(); c++) {
-                        if (qubitCorrectionZ.at(q).count(Z_ANCILLA_QUBITS.at(c)) > 0) {
-                            mask |= (1 << c);
-                        }
-                    }
-                    qcMapped->classicControlled(qc::Z, qubits.at(q), controlRegister, mask);
-                }
-            }
-            controlRegister = std::make_pair(static_cast<Qubit>(clAncStart + ANCILLA_WIDTH), ANCILLA_WIDTH);
-            for (std::size_t q = 0; q < qubitCorrectionX.size(); q++) {
-                if (uncorrectedXQubits.count(static_cast<Qubit>(q)) == 0) {
-                    std::size_t mask = 0;
-                    for (std::size_t c = 0; c < X_ANCILLA_QUBITS.size(); c++) {
-                        if (qubitCorrectionX.at(q).count(X_ANCILLA_QUBITS.at(c)) > 0) {
-                            mask |= (1 << c);
-                        }
-                    }
-                    qcMapped->classicControlled(qc::X, qubits.at(q), controlRegister, mask);
-                }
-            }
+void Q9Surface::measureAndCorrect() {
+  if (isDecoded) {
+    return;
+  }
+  const auto nQubits = qcOriginal->getNqubits();
+  const auto ancStart = qcOriginal->getNqubits() * ecc.nRedundantQubits;
+  const auto clAncStart = qcOriginal->getNcbits();
+  for (std::size_t i = 0; i < nQubits; i++) {
+    std::array<Qubit, N_REDUNDANT_QUBITS> qubits = {};
+    std::array<Qubit, N_CORRECTING_BITS> ancillaQubits = {};
+    std::array<qc::Control, N_CORRECTING_BITS> ancillaControls = {};
+    std::array<qc::Control, N_REDUNDANT_QUBITS> controlQubits = {};
+    for (std::size_t j = 0; j < qubits.size(); j++) {
+      qubits.at(j) = static_cast<Qubit>(i + j * nQubits);
+    }
+    for (std::size_t j = 0; j < ancillaQubits.size(); j++) {
+      ancillaQubits.at(j) = static_cast<Qubit>(ancStart + j);
+    }
+    if (gatesWritten) {
+      for (const auto ancillaQubit : ancillaQubits) {
+        qcMapped->reset(ancillaQubit);
+      }
+    }
+    for (std::size_t j = 0; j < ancillaControls.size(); j++) {
+      ancillaControls.at(j) = qc::Control{ancillaQubits.at(j)};
+    }
+    for (std::size_t j = 0; j < controlQubits.size(); j++) {
+      controlQubits.at(j) = qc::Control{qubits.at(j)};
+    }
 
-            gatesWritten = true;
-        }
+    // X-type check (z error) on a0, a2, a5, a7: cx ancillaQubits->qubits
+    // Z-type check (x error) on a1, a3, a4, a6: cz ancillaQubits->qubits = cx
+    // qubits->ancillaQubits, no hadamard gate
+    for (auto q : Z_ANCILLA_QUBITS) {
+      qcMapped->h(ancillaQubits.at(q));
     }
 
-    void Q9Surface::writeDecoding() {
-        if (isDecoded) {
-            return;
-        }
-        const auto nQubits = qcOriginal->getNqubits();
-        for (std::size_t i = 0; i < nQubits; i++) {
-            //measure 0, 4, 8. state = m0*m4*m8
-            qcMapped->measure(static_cast<Qubit>(i), i);
-            qcMapped->measure(static_cast<Qubit>(i + 4 * nQubits), i);
-            qcMapped->measure(static_cast<Qubit>(i + 8 * nQubits), i);
-            qcMapped->x(static_cast<Qubit>(i), qc::Control{static_cast<Qubit>(i + 4 * nQubits), qc::Control::Type::Pos});
-            qcMapped->x(static_cast<Qubit>(i), qc::Control{static_cast<Qubit>(i + 8 * nQubits), qc::Control::Type::Pos});
-            qcMapped->measure(static_cast<Qubit>(i), i);
-        }
-        isDecoded = true;
+    for (std::size_t q = 0; q < qubitCorrectionZ.size(); q++) {
+      for (auto c : qubitCorrectionZ.at(q)) {
+        qcMapped->x(qubits.at(q), ancillaControls.at(c));
+      }
     }
 
-    void Q9Surface::mapGate(const qc::Operation& gate) {
-        if (isDecoded && gate.getType() != qc::Measure) {
-            writeEncoding();
-        }
-        const auto nQubits = qcOriginal->getNqubits();
+    for (std::size_t q = 0; q < qubitCorrectionX.size(); q++) {
+      for (auto c : qubitCorrectionX.at(q)) {
+        qcMapped->x(ancillaQubits.at(c), controlQubits.at(q));
+      }
+    }
 
-        if ((gate.getNcontrols() != 0U) && gate.getType() != qc::Measure) {
-            gateNotAvailableError(gate);
-        }
+    for (std::size_t j = 0; j < Z_ANCILLA_QUBITS.size(); j++) {
+      qcMapped->h(ancillaQubits.at(Z_ANCILLA_QUBITS.at(j)));
+      qcMapped->measure(ancillaQubits.at(Z_ANCILLA_QUBITS.at(j)),
+                        clAncStart + j);
+      qcMapped->measure(ancillaQubits.at(X_ANCILLA_QUBITS.at(j)),
+                        clAncStart + 4 + j);
+    }
 
-        switch (gate.getType()) {
-            case qc::I:
-            case qc::Barrier:
-                break;
-            case qc::X:
-                for (auto i: gate.getTargets()) {
-                    for (auto j: LOGICAL_X) {
-                        qcMapped->x(static_cast<Qubit>(i + j * nQubits));
-                    }
-                }
-                break;
-            case qc::H:
-                for (auto i: gate.getTargets()) {
-                    for (std::size_t j = 0; j < N_REDUNDANT_QUBITS; j++) {
-                        qcMapped->h(static_cast<Qubit>(i + j * nQubits));
-                    }
-                    for (auto pair: SWAP_INDICES) {
-                        qcMapped->swap(static_cast<Qubit>(i + pair.first * nQubits), static_cast<Qubit>(i + pair.second * nQubits));
-                    }
-                }
-                break;
-            case qc::Y:
-                //Y = Z X
-                for (auto i: gate.getTargets()) {
-                    for (auto j: LOGICAL_Z) {
-                        qcMapped->z(static_cast<Qubit>(i + j * nQubits));
-                    }
-                    for (auto j: LOGICAL_X) {
-                        qcMapped->x(static_cast<Qubit>(i + j * nQubits));
-                    }
-                }
-                break;
-            case qc::Z:
-                for (auto i: gate.getTargets()) {
-                    for (auto j: LOGICAL_Z) {
-                        qcMapped->z(static_cast<Qubit>(i + j * nQubits));
-                    }
-                }
-                break;
-            case qc::Measure:
-                if (!isDecoded) {
-                    measureAndCorrect();
-                    writeDecoding();
-                }
-                if (const auto* measureGate = dynamic_cast<const qc::NonUnitaryOperation*>(&gate)) {
-                    for (std::size_t j = 0; j < measureGate->getNclassics(); j++) {
-                        qcMapped->measure(measureGate->getTargets().at(j), measureGate->getClassics().at(j));
-                    }
-                } else {
-                    throw std::runtime_error("Dynamic cast to NonUnitaryOperation failed.");
-                }
-                break;
-            default:
-                gateNotAvailableError(gate);
+    // correction
+    auto controlRegister =
+        std::make_pair(static_cast<Qubit>(clAncStart), ANCILLA_WIDTH);
+    for (std::size_t q = 0; q < qubitCorrectionZ.size(); q++) {
+      if (uncorrectedZQubits.count(static_cast<Qubit>(q)) == 0) {
+        std::size_t mask = 0;
+        for (std::size_t c = 0; c < Z_ANCILLA_QUBITS.size(); c++) {
+          if (qubitCorrectionZ.at(q).count(Z_ANCILLA_QUBITS.at(c)) > 0) {
+            mask |= (1 << c);
+          }
+        }
+        qcMapped->classicControlled(qc::Z, qubits.at(q), controlRegister, mask);
+      }
+    }
+    controlRegister = std::make_pair(
+        static_cast<Qubit>(clAncStart + ANCILLA_WIDTH), ANCILLA_WIDTH);
+    for (std::size_t q = 0; q < qubitCorrectionX.size(); q++) {
+      if (uncorrectedXQubits.count(static_cast<Qubit>(q)) == 0) {
+        std::size_t mask = 0;
+        for (std::size_t c = 0; c < X_ANCILLA_QUBITS.size(); c++) {
+          if (qubitCorrectionX.at(q).count(X_ANCILLA_QUBITS.at(c)) > 0) {
+            mask |= (1 << c);
+          }
         }
+        qcMapped->classicControlled(qc::X, qubits.at(q), controlRegister, mask);
+      }
+    }
+
+    gatesWritten = true;
+  }
+}
+
+void Q9Surface::writeDecoding() {
+  if (isDecoded) {
+    return;
+  }
+  const auto nQubits = qcOriginal->getNqubits();
+  for (std::size_t i = 0; i < nQubits; i++) {
+    // measure 0, 4, 8. state = m0*m4*m8
+    qcMapped->measure(static_cast<Qubit>(i), i);
+    qcMapped->measure(static_cast<Qubit>(i + 4 * nQubits), i);
+    qcMapped->measure(static_cast<Qubit>(i + 8 * nQubits), i);
+    qcMapped->x(static_cast<Qubit>(i),
+                qc::Control{static_cast<Qubit>(i + 4 * nQubits),
+                            qc::Control::Type::Pos});
+    qcMapped->x(static_cast<Qubit>(i),
+                qc::Control{static_cast<Qubit>(i + 8 * nQubits),
+                            qc::Control::Type::Pos});
+    qcMapped->measure(static_cast<Qubit>(i), i);
+  }
+  isDecoded = true;
+}
+
+void Q9Surface::mapGate(const qc::Operation& gate) {
+  if (isDecoded && gate.getType() != qc::Measure) {
+    writeEncoding();
+  }
+  const auto nQubits = qcOriginal->getNqubits();
+
+  if ((gate.getNcontrols() != 0U) && gate.getType() != qc::Measure) {
+    gateNotAvailableError(gate);
+  }
+
+  switch (gate.getType()) {
+  case qc::I:
+  case qc::Barrier:
+    break;
+  case qc::X:
+    for (auto i : gate.getTargets()) {
+      for (auto j : LOGICAL_X) {
+        qcMapped->x(static_cast<Qubit>(i + j * nQubits));
+      }
+    }
+    break;
+  case qc::H:
+    for (auto i : gate.getTargets()) {
+      for (std::size_t j = 0; j < N_REDUNDANT_QUBITS; j++) {
+        qcMapped->h(static_cast<Qubit>(i + j * nQubits));
+      }
+      for (auto pair : SWAP_INDICES) {
+        qcMapped->swap(static_cast<Qubit>(i + pair.first * nQubits),
+                       static_cast<Qubit>(i + pair.second * nQubits));
+      }
+    }
+    break;
+  case qc::Y:
+    // Y = Z X
+    for (auto i : gate.getTargets()) {
+      for (auto j : LOGICAL_Z) {
+        qcMapped->z(static_cast<Qubit>(i + j * nQubits));
+      }
+      for (auto j : LOGICAL_X) {
+        qcMapped->x(static_cast<Qubit>(i + j * nQubits));
+      }
+    }
+    break;
+  case qc::Z:
+    for (auto i : gate.getTargets()) {
+      for (auto j : LOGICAL_Z) {
+        qcMapped->z(static_cast<Qubit>(i + j * nQubits));
+      }
+    }
+    break;
+  case qc::Measure:
+    if (!isDecoded) {
+      measureAndCorrect();
+      writeDecoding();
+    }
+    if (const auto* measureGate =
+            dynamic_cast<const qc::NonUnitaryOperation*>(&gate)) {
+      for (std::size_t j = 0; j < measureGate->getNclassics(); j++) {
+        qcMapped->measure(measureGate->getTargets().at(j),
+                          measureGate->getClassics().at(j));
+      }
+    } else {
+      throw std::runtime_error("Dynamic cast to NonUnitaryOperation failed.");
     }
+    break;
+  default:
+    gateNotAvailableError(gate);
+  }
+}
 } // namespace ecc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/src/operations/NonUnitaryOperation.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/operations/NonUnitaryOperation.cpp`

 * *Files 14% similar despite different names*

```diff
@@ -1,268 +1,292 @@
 /*
  * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
+ * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for
+ * more information.
  */
 
 #include "operations/NonUnitaryOperation.hpp"
 
 #include <algorithm>
 #include <cassert>
 #include <utility>
 
 namespace qc {
-    // Measurement constructor
-    NonUnitaryOperation::NonUnitaryOperation(const std::size_t nq, std::vector<Qubit> qubitRegister, std::vector<Bit> classicalRegister):
-        qubits(std::move(qubitRegister)), classics(std::move(classicalRegister)) {
-        if (qubits.size() != classics.size()) {
-            throw std::invalid_argument("Sizes of qubit register and classical register do not match.");
-        }
-        // i-th qubit to be measured shall be measured into i-th classical register
-        type    = Measure;
-        nqubits = nq;
-        Operation::setName();
-    }
-    NonUnitaryOperation::NonUnitaryOperation(const std::size_t nq, const Qubit qubit, const Bit cbit) {
-        type    = Measure;
-        nqubits = nq;
-        qubits.emplace_back(qubit);
-        classics.emplace_back(cbit);
-        Operation::setName();
-    }
-
-    // Snapshot constructor
-    NonUnitaryOperation::NonUnitaryOperation(const std::size_t nq, const std::vector<Qubit>& qubitRegister, const std::size_t n):
-        NonUnitaryOperation(nq, qubitRegister, Snapshot) {
-        parameter.emplace_back(static_cast<fp>(n));
-    }
-
-    // General constructor
-    NonUnitaryOperation::NonUnitaryOperation(const std::size_t nq, const std::vector<Qubit>& qubitRegister, OpType op) {
-        type    = op;
-        nqubits = nq;
-        targets = qubitRegister;
-        std::sort(targets.begin(), targets.end());
-        Operation::setName();
-    }
-
-    std::ostream& NonUnitaryOperation::printNonUnitary(std::ostream& os, const std::vector<Qubit>& q, const std::vector<Bit>& c, const Permutation& permutation) const {
-        switch (type) {
-            case Measure:
-                printMeasurement(os, q, c, permutation);
-                break;
-            case Reset:
-            case Barrier:
-            case Snapshot:
-                printResetBarrierOrSnapshot(os, q, permutation);
-                break;
-            case ShowProbabilities:
-                os << name;
-                break;
-            default:
-                std::cerr << "Non-unitary operation with invalid type " << type << " detected. Proceed with caution!" << std::endl;
-                break;
-        }
-        return os;
-    }
-
-    void NonUnitaryOperation::dumpOpenQASM(std::ostream& of, const RegisterNames& qreg, const RegisterNames& creg) const {
-        auto classicsIt = classics.cbegin();
-        switch (type) {
-            case Measure:
-                if (isWholeQubitRegister(qreg, qubits.front(), qubits.back()) &&
-                    isWholeQubitRegister(qreg, classics.front(), classics.back())) {
-                    of << "measure " << qreg[qubits.front()].first << " -> " << creg[classics.front()].first << ";" << std::endl;
-                } else {
-                    for (const auto& c: qubits) {
-                        of << "measure " << qreg[c].second << " -> " << creg[*classicsIt].second << ";" << std::endl;
-                        ++classicsIt;
-                    }
-                }
-                break;
-            case Reset:
-                if (isWholeQubitRegister(qreg, targets.front(), targets.back())) {
-                    of << "reset " << qreg[targets.front()].first << ";" << std::endl;
-                } else {
-                    for (const auto& target: targets) {
-                        of << "reset " << qreg[target].second << ";" << std::endl;
-                    }
-                }
-                break;
-            case Snapshot:
-                if (!targets.empty()) {
-                    of << "snapshot(" << parameter[0] << ") ";
-
-                    for (unsigned int q = 0; q < targets.size(); ++q) {
-                        if (q > 0) {
-                            of << ", ";
-                        }
-                        of << qreg[targets[q]].second;
-                    }
-                    of << ";" << std::endl;
-                }
-                break;
-            case ShowProbabilities:
-                of << "show_probabilities;" << std::endl;
-                break;
-            case Barrier:
-                if (isWholeQubitRegister(qreg, targets.front(), targets.back())) {
-                    of << "barrier " << qreg[targets.front()].first << ";" << std::endl;
-                } else {
-                    for (const auto& target: targets) {
-                        of << "barrier " << qreg[target].second << ";" << std::endl;
-                    }
-                }
-                break;
-            default:
-                std::cerr << "Non-unitary operation with invalid type " << type << " detected. Proceed with caution!" << std::endl;
-                break;
-        }
-    }
-
-    bool NonUnitaryOperation::actsOn(Qubit i) const {
-        if (type == Measure) {
-            return std::any_of(qubits.cbegin(), qubits.cend(), [&i](const auto& q) { return q == i; });
-        }
-        if (type == Reset) {
-            return std::any_of(targets.cbegin(), targets.cend(), [&i](const auto& t) { return t == i; });
-        }
-        // other non-unitary operations (e.g., barrier statements) may be ignored
-        return false;
-    }
-
-    bool NonUnitaryOperation::equals(const Operation& op, const Permutation& perm1, const Permutation& perm2) const {
-        if (const auto* nonunitary = dynamic_cast<const NonUnitaryOperation*>(&op)) {
-            if (getType() != nonunitary->getType()) {
-                return false;
-            }
-
-            if (getType() == Measure) {
-                // check number of qubits to be measured
-                const auto nq1 = qubits.size();
-                const auto nq2 = nonunitary->qubits.size();
-                if (nq1 != nq2) {
-                    return false;
-                }
-
-                // these are just sanity checks and should always be fulfilled
-                assert(qubits.size() == classics.size());
-                assert(nonunitary->qubits.size() == nonunitary->classics.size());
-
-                std::set<std::pair<Qubit, Bit>> measurements1{};
-                auto                            qubitIt1   = qubits.cbegin();
-                auto                            classicIt1 = classics.cbegin();
-                while (qubitIt1 != qubits.cend()) {
-                    if (perm1.empty()) {
-                        measurements1.emplace(*qubitIt1, *classicIt1);
-                    } else {
-                        measurements1.emplace(perm1.at(*qubitIt1), *classicIt1);
-                    }
-                    ++qubitIt1;
-                    ++classicIt1;
-                }
-
-                std::set<std::pair<Qubit, Bit>> measurements2{};
-                auto                            qubitIt2   = nonunitary->qubits.cbegin();
-                auto                            classicIt2 = nonunitary->classics.cbegin();
-                while (qubitIt2 != nonunitary->qubits.cend()) {
-                    if (perm2.empty()) {
-                        measurements2.emplace(*qubitIt2, *classicIt2);
-                    } else {
-                        measurements2.emplace(perm2.at(*qubitIt2), *classicIt2);
-                    }
-                    ++qubitIt2;
-                    ++classicIt2;
-                }
-
-                return measurements1 == measurements2;
-            }
-            return Operation::equals(op, perm1, perm2);
+// Measurement constructor
+NonUnitaryOperation::NonUnitaryOperation(const std::size_t nq,
+                                         std::vector<Qubit> qubitRegister,
+                                         std::vector<Bit> classicalRegister)
+    : qubits(std::move(qubitRegister)), classics(std::move(classicalRegister)) {
+  if (qubits.size() != classics.size()) {
+    throw std::invalid_argument(
+        "Sizes of qubit register and classical register do not match.");
+  }
+  // i-th qubit to be measured shall be measured into i-th classical register
+  type = Measure;
+  nqubits = nq;
+  Operation::setName();
+}
+NonUnitaryOperation::NonUnitaryOperation(const std::size_t nq,
+                                         const Qubit qubit, const Bit cbit) {
+  type = Measure;
+  nqubits = nq;
+  qubits.emplace_back(qubit);
+  classics.emplace_back(cbit);
+  Operation::setName();
+}
+
+// Snapshot constructor
+NonUnitaryOperation::NonUnitaryOperation(
+    const std::size_t nq, const std::vector<Qubit>& qubitRegister,
+    const std::size_t n)
+    : NonUnitaryOperation(nq, qubitRegister, Snapshot) {
+  parameter.emplace_back(static_cast<fp>(n));
+}
+
+// General constructor
+NonUnitaryOperation::NonUnitaryOperation(
+    const std::size_t nq, const std::vector<Qubit>& qubitRegister, OpType op) {
+  type = op;
+  nqubits = nq;
+  targets = qubitRegister;
+  std::sort(targets.begin(), targets.end());
+  Operation::setName();
+}
+
+std::ostream& NonUnitaryOperation::printNonUnitary(
+    std::ostream& os, const std::vector<Qubit>& q, const std::vector<Bit>& c,
+    const Permutation& permutation) const {
+  switch (type) {
+  case Measure:
+    printMeasurement(os, q, c, permutation);
+    break;
+  case Reset:
+  case Barrier:
+  case Snapshot:
+    printResetBarrierOrSnapshot(os, q, permutation);
+    break;
+  case ShowProbabilities:
+    os << name;
+    break;
+  default:
+    std::cerr << "Non-unitary operation with invalid type " << type
+              << " detected. Proceed with caution!" << std::endl;
+    break;
+  }
+  return os;
+}
+
+void NonUnitaryOperation::dumpOpenQASM(std::ostream& of,
+                                       const RegisterNames& qreg,
+                                       const RegisterNames& creg) const {
+  auto classicsIt = classics.cbegin();
+  switch (type) {
+  case Measure:
+    if (isWholeQubitRegister(qreg, qubits.front(), qubits.back()) &&
+        isWholeQubitRegister(qreg, classics.front(), classics.back())) {
+      of << "measure " << qreg[qubits.front()].first << " -> "
+         << creg[classics.front()].first << ";" << std::endl;
+    } else {
+      for (const auto& c : qubits) {
+        of << "measure " << qreg[c].second << " -> " << creg[*classicsIt].second
+           << ";" << std::endl;
+        ++classicsIt;
+      }
+    }
+    break;
+  case Reset:
+    if (isWholeQubitRegister(qreg, targets.front(), targets.back())) {
+      of << "reset " << qreg[targets.front()].first << ";" << std::endl;
+    } else {
+      for (const auto& target : targets) {
+        of << "reset " << qreg[target].second << ";" << std::endl;
+      }
+    }
+    break;
+  case Snapshot:
+    if (!targets.empty()) {
+      of << "snapshot(" << parameter[0] << ") ";
+
+      for (unsigned int q = 0; q < targets.size(); ++q) {
+        if (q > 0) {
+          of << ", ";
         }
+        of << qreg[targets[q]].second;
+      }
+      of << ";" << std::endl;
+    }
+    break;
+  case ShowProbabilities:
+    of << "show_probabilities;" << std::endl;
+    break;
+  case Barrier:
+    if (isWholeQubitRegister(qreg, targets.front(), targets.back())) {
+      of << "barrier " << qreg[targets.front()].first << ";" << std::endl;
+    } else {
+      for (const auto& target : targets) {
+        of << "barrier " << qreg[target].second << ";" << std::endl;
+      }
+    }
+    break;
+  default:
+    std::cerr << "Non-unitary operation with invalid type " << type
+              << " detected. Proceed with caution!" << std::endl;
+    break;
+  }
+}
+
+bool NonUnitaryOperation::actsOn(Qubit i) const {
+  if (type == Measure) {
+    return std::any_of(qubits.cbegin(), qubits.cend(),
+                       [&i](const auto& q) { return q == i; });
+  }
+  if (type == Reset) {
+    return std::any_of(targets.cbegin(), targets.cend(),
+                       [&i](const auto& t) { return t == i; });
+  }
+  // other non-unitary operations (e.g., barrier statements) may be ignored
+  return false;
+}
+
+bool NonUnitaryOperation::equals(const Operation& op, const Permutation& perm1,
+                                 const Permutation& perm2) const {
+  if (const auto* nonunitary = dynamic_cast<const NonUnitaryOperation*>(&op)) {
+    if (getType() != nonunitary->getType()) {
+      return false;
+    }
+
+    if (getType() == Measure) {
+      // check number of qubits to be measured
+      const auto nq1 = qubits.size();
+      const auto nq2 = nonunitary->qubits.size();
+      if (nq1 != nq2) {
         return false;
-    }
+      }
 
-    void NonUnitaryOperation::addDepthContribution(std::vector<std::size_t>& depths) const {
-        if (type == Measure || type == Reset) {
-            Operation::addDepthContribution(depths);
+      // these are just sanity checks and should always be fulfilled
+      assert(qubits.size() == classics.size());
+      assert(nonunitary->qubits.size() == nonunitary->classics.size());
+
+      std::set<std::pair<Qubit, Bit>> measurements1{};
+      auto qubitIt1 = qubits.cbegin();
+      auto classicIt1 = classics.cbegin();
+      while (qubitIt1 != qubits.cend()) {
+        if (perm1.empty()) {
+          measurements1.emplace(*qubitIt1, *classicIt1);
+        } else {
+          measurements1.emplace(perm1.at(*qubitIt1), *classicIt1);
         }
-    }
-
-    void NonUnitaryOperation::printMeasurement(std::ostream& os, const std::vector<Qubit>& q, const std::vector<Bit>& c, const Permutation& permutation) const {
-        auto qubitIt   = q.cbegin();
-        auto classicIt = c.cbegin();
-        os << name << "\t";
-        if (permutation.empty()) {
-            for (std::size_t i = 0; i < nqubits; ++i) {
-                if (qubitIt != q.cend() && *qubitIt == i) {
-                    os << "\033[34m" << *classicIt << "\t"
-                       << "\033[0m";
-                    ++qubitIt;
-                    ++classicIt;
-                } else {
-                    os << "|\t";
-                }
-            }
+        ++qubitIt1;
+        ++classicIt1;
+      }
+
+      std::set<std::pair<Qubit, Bit>> measurements2{};
+      auto qubitIt2 = nonunitary->qubits.cbegin();
+      auto classicIt2 = nonunitary->classics.cbegin();
+      while (qubitIt2 != nonunitary->qubits.cend()) {
+        if (perm2.empty()) {
+          measurements2.emplace(*qubitIt2, *classicIt2);
         } else {
-            for (const auto& [physical, logical]: permutation) {
-                if (qubitIt != q.cend() && *qubitIt == physical) {
-                    os << "\033[34m" << *classicIt << "\t"
-                       << "\033[0m";
-                    ++qubitIt;
-                    ++classicIt;
-                } else {
-                    os << "|\t";
-                }
-            }
+          measurements2.emplace(perm2.at(*qubitIt2), *classicIt2);
         }
-    }
-
-    void NonUnitaryOperation::printResetBarrierOrSnapshot(std::ostream& os, const std::vector<Qubit>& q, const Permutation& permutation) const {
-        auto qubitIt = q.cbegin();
-        os << name << "\t";
-        if (permutation.empty()) {
-            for (std::size_t i = 0; i < nqubits; ++i) {
-                if (qubitIt != q.cend() && *qubitIt == i) {
-                    if (type == Reset) {
-                        os << "\033[31m"
-                           << "r\t"
-                           << "\033[0m";
-                    } else if (type == Barrier) {
-                        os << "\033[32m"
-                           << "b\t"
-                           << "\033[0m";
-                    } else {
-                        os << "\033[33m"
-                           << "s\t"
-                           << "\033[0m";
-                    }
-                    ++qubitIt;
-                } else {
-                    os << "|\t";
-                }
-            }
+        ++qubitIt2;
+        ++classicIt2;
+      }
+
+      return measurements1 == measurements2;
+    }
+    return Operation::equals(op, perm1, perm2);
+  }
+  return false;
+}
+
+void NonUnitaryOperation::addDepthContribution(
+    std::vector<std::size_t>& depths) const {
+  if (type == Measure || type == Reset) {
+    Operation::addDepthContribution(depths);
+  }
+}
+
+void NonUnitaryOperation::printMeasurement(
+    std::ostream& os, const std::vector<Qubit>& q, const std::vector<Bit>& c,
+    const Permutation& permutation) const {
+  auto qubitIt = q.cbegin();
+  auto classicIt = c.cbegin();
+  os << name << "\t";
+  if (permutation.empty()) {
+    for (std::size_t i = 0; i < nqubits; ++i) {
+      if (qubitIt != q.cend() && *qubitIt == i) {
+        os << "\033[34m" << *classicIt << "\t"
+           << "\033[0m";
+        ++qubitIt;
+        ++classicIt;
+      } else {
+        os << "|\t";
+      }
+    }
+  } else {
+    for (const auto& [physical, logical] : permutation) {
+      if (qubitIt != q.cend() && *qubitIt == physical) {
+        os << "\033[34m" << *classicIt << "\t"
+           << "\033[0m";
+        ++qubitIt;
+        ++classicIt;
+      } else {
+        os << "|\t";
+      }
+    }
+  }
+}
+
+void NonUnitaryOperation::printResetBarrierOrSnapshot(
+    std::ostream& os, const std::vector<Qubit>& q,
+    const Permutation& permutation) const {
+  auto qubitIt = q.cbegin();
+  os << name << "\t";
+  if (permutation.empty()) {
+    for (std::size_t i = 0; i < nqubits; ++i) {
+      if (qubitIt != q.cend() && *qubitIt == i) {
+        if (type == Reset) {
+          os << "\033[31m"
+             << "r\t"
+             << "\033[0m";
+        } else if (type == Barrier) {
+          os << "\033[32m"
+             << "b\t"
+             << "\033[0m";
         } else {
-            for (const auto& [physical, logical]: permutation) {
-                if (qubitIt != q.cend() && *qubitIt == physical) {
-                    if (type == Reset) {
-                        os << "\033[31m"
-                           << "r\t"
-                           << "\033[0m";
-                    } else if (type == Barrier) {
-                        os << "\033[32m"
-                           << "b\t"
-                           << "\033[0m";
-                    } else {
-                        os << "\033[33m"
-                           << "s\t"
-                           << "\033[0m";
-                    }
-                    ++qubitIt;
-                } else {
-                    os << "|\t";
-                }
-            }
+          os << "\033[33m"
+             << "s\t"
+             << "\033[0m";
         }
-        if (type == Snapshot) {
-            os << "\tp: (" << q.size() << ") (" << parameter[1] << ")";
+        ++qubitIt;
+      } else {
+        os << "|\t";
+      }
+    }
+  } else {
+    for (const auto& [physical, logical] : permutation) {
+      if (qubitIt != q.cend() && *qubitIt == physical) {
+        if (type == Reset) {
+          os << "\033[31m"
+             << "r\t"
+             << "\033[0m";
+        } else if (type == Barrier) {
+          os << "\033[32m"
+             << "b\t"
+             << "\033[0m";
+        } else {
+          os << "\033[33m"
+             << "s\t"
+             << "\033[0m";
         }
-    }
+        ++qubitIt;
+      } else {
+        os << "|\t";
+      }
+    }
+  }
+  if (type == Snapshot) {
+    os << "\tp: (" << q.size() << ") (" << parameter[1] << ")";
+  }
+}
 } // namespace qc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/src/operations/Operation.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/operations/Operation.cpp`

 * *Files 15% similar despite different names*

```diff
@@ -1,246 +1,244 @@
-/*
- * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
- */
-
 #include "operations/Operation.hpp"
 
 namespace qc {
-    void Operation::setName() {
-        switch (type) {
-            case iSWAP:
-                name = "iSWP";
-                break;
-            case Peres:
-                name = "Pr ";
-                break;
-            case Peresdag:
-                name = "Prdg";
-                break;
-            case RXX:
-                name = "XX  ";
-                break;
-            case RYY:
-                name = "YY  ";
-                break;
-            case RZZ:
-                name = "ZZ  ";
-                break;
-            case RZX:
-                name = "ZX  ";
-                break;
-            case XXminusYY:
-                name = "XY- ";
-                break;
-            case XXplusYY:
-                name = "XY+ ";
-                break;
-            case Reset:
-                name = "Rst ";
-                break;
-            case ClassicControlled:
-                name = "clc_";
-                break;
-            default:
-                name = toString(type);
-                name.resize(4, ' ');
-        }
-    }
-
-    std::ostream& Operation::printParameters(std::ostream& os) const {
-        if (isClassicControlledOperation()) {
-            os << "\tc[" << parameter[0];
-            if (parameter[1] != 1) {
-                os << " ... " << (parameter[0] + parameter[1] - 1);
-            }
-            os << "] == " << parameter[2];
-            return os;
-        }
-
-        bool isZero = true;
-        for (const auto& p: parameter) {
-            if (p != static_cast<fp>(0)) {
-                isZero = false;
-                break;
-            }
-        }
-        if (!isZero) {
-            os << "\tp: (" << parameter[0] << ") ";
-            for (size_t j = 1; j < parameter.size(); ++j) {
-                isZero = true;
-                for (size_t i = j; i < parameter.size(); ++i) {
-                    if (parameter.at(i) != static_cast<fp>(0)) {
-                        isZero = false;
-                        break;
-                    }
-                }
-                if (isZero) {
-                    break;
-                }
-                os << "(" << parameter.at(j) << ") ";
-            }
-        }
-
-        return os;
-    }
-
-    std::ostream& Operation::print(std::ostream& os) const {
-        const auto precBefore = std::cout.precision(20);
-
-        os << std::setw(4) << name << "\t";
-
-        auto controlIt = controls.begin();
-        auto targetIt  = targets.begin();
-        for (std::size_t i = 0; i < nqubits; ++i) {
-            if (targetIt != targets.end() && *targetIt == i) {
-                if (type == ClassicControlled) {
-                    os << "\033[1m\033[35m" << name[2] << name[3];
-                } else {
-                    os << "\033[1m\033[36m" << name[0] << name[1];
-                }
-                os << "\t\033[0m";
-                ++targetIt;
-            } else if (controlIt != controls.end() && controlIt->qubit == i) {
-                if (controlIt->type == Control::Type::Pos) {
-                    os << "\033[32m";
-                } else {
-                    os << "\033[31m";
-                }
-                os << "c\t"
-                   << "\033[0m";
-                ++controlIt;
-            } else {
-                os << "|\t";
-            }
-        }
-
-        printParameters(os);
-
-        std::cout.precision(precBefore);
-
-        return os;
-    }
-
-    std::ostream& Operation::print(std::ostream& os, const Permutation& permutation) const {
-        const auto precBefore = std::cout.precision(20);
-
-        os << std::setw(4) << name << "\t";
-        const auto& actualControls = getControls();
-        const auto& actualTargets  = getTargets();
-        auto        controlIt      = actualControls.cbegin();
-        auto        targetIt       = actualTargets.cbegin();
-        for (const auto& [physical, logical]: permutation) {
-            if (targetIt != actualTargets.cend() && *targetIt == physical) {
-                if (type == ClassicControlled) {
-                    os << "\033[1m\033[35m" << name[2] << name[3];
-                } else {
-                    os << "\033[1m\033[36m" << name[0] << name[1];
-                }
-                os << "\t\033[0m";
-                ++targetIt;
-            } else if (controlIt != actualControls.cend() && controlIt->qubit == physical) {
-                if (controlIt->type == Control::Type::Pos) {
-                    os << "\033[32m";
-                } else {
-                    os << "\033[31m";
-                }
-                os << "c\t"
-                   << "\033[0m";
-                ++controlIt;
-            } else {
-                os << "|\t";
-            }
-        }
-
-        printParameters(os);
-
-        std::cout.precision(precBefore);
-
-        return os;
-    }
-
-    bool Operation::equals(const Operation& op, const Permutation& perm1, const Permutation& perm2) const {
-        // check type
-        if (getType() != op.getType()) {
-            return false;
-        }
-
-        // check number of controls
-        const auto nc1 = getNcontrols();
-        const auto nc2 = op.getNcontrols();
-        if (nc1 != nc2) {
-            return false;
-        }
-
-        // check parameters
-        const auto& param1 = getParameter();
-        const auto& param2 = op.getParameter();
-        if (param1 != param2) {
-            return false;
-        }
-
-        // check controls
-        if (nc1 != 0U) {
-            Controls controls1{};
-            if (perm1.empty()) {
-                controls1 = getControls();
-            } else {
-                for (const auto& control: getControls()) {
-                    controls1.emplace(Control{perm1.at(control.qubit), control.type});
-                }
-            }
-
-            Controls controls2{};
-            if (perm2.empty()) {
-                controls2 = op.getControls();
-            } else {
-                for (const auto& control: op.getControls()) {
-                    controls2.emplace(Control{perm2.at(control.qubit), control.type});
-                }
-            }
-
-            if (controls1 != controls2) {
-                return false;
-            }
-        }
-
-        // check targets
-        std::set<Qubit> targets1{};
-        if (perm1.empty()) {
-            targets1 = {getTargets().begin(), getTargets().end()};
-        } else {
-            for (const auto& target: getTargets()) {
-                targets1.emplace(perm1.at(target));
-            }
-        }
-
-        std::set<Qubit> targets2{};
-        if (perm2.empty()) {
-            targets2 = {op.getTargets().begin(), op.getTargets().end()};
-        } else {
-            for (const auto& target: op.getTargets()) {
-                targets2.emplace(perm2.at(target));
-            }
-        }
-
-        return targets1 == targets2;
-    }
-
-    void Operation::addDepthContribution(std::vector<std::size_t>& depths) const {
-        std::size_t maxDepth = 0;
-        for (const auto& target: getTargets()) {
-            maxDepth = std::max(maxDepth, depths[target]);
-        }
-        for (const auto& control: getControls()) {
-            maxDepth = std::max(maxDepth, depths[control.qubit]);
-        }
-        maxDepth += 1;
-        for (const auto& target: getTargets()) {
-            depths[target] = maxDepth;
-        }
-        for (const auto& control: getControls()) {
-            depths[control.qubit] = maxDepth;
-        }
-    }
+void Operation::setName() {
+  switch (type) {
+  case iSWAP:
+    name = "iSWP";
+    break;
+  case Peres:
+    name = "Pr ";
+    break;
+  case Peresdag:
+    name = "Prdg";
+    break;
+  case RXX:
+    name = "XX  ";
+    break;
+  case RYY:
+    name = "YY  ";
+    break;
+  case RZZ:
+    name = "ZZ  ";
+    break;
+  case RZX:
+    name = "ZX  ";
+    break;
+  case XXminusYY:
+    name = "XY- ";
+    break;
+  case XXplusYY:
+    name = "XY+ ";
+    break;
+  case Reset:
+    name = "Rst ";
+    break;
+  case ClassicControlled:
+    name = "clc_";
+    break;
+  default:
+    name = toString(type);
+    name.resize(4, ' ');
+  }
+}
+
+std::ostream& Operation::printParameters(std::ostream& os) const {
+  if (isClassicControlledOperation()) {
+    os << "\tc[" << parameter[0];
+    if (parameter[1] != 1) {
+      os << " ... " << (parameter[0] + parameter[1] - 1);
+    }
+    os << "] == " << parameter[2];
+    return os;
+  }
+
+  bool isZero = true;
+  for (const auto& p : parameter) {
+    if (p != static_cast<fp>(0)) {
+      isZero = false;
+      break;
+    }
+  }
+  if (!isZero) {
+    os << "\tp: (" << parameter[0] << ") ";
+    for (size_t j = 1; j < parameter.size(); ++j) {
+      isZero = true;
+      for (size_t i = j; i < parameter.size(); ++i) {
+        if (parameter.at(i) != static_cast<fp>(0)) {
+          isZero = false;
+          break;
+        }
+      }
+      if (isZero) {
+        break;
+      }
+      os << "(" << parameter.at(j) << ") ";
+    }
+  }
+
+  return os;
+}
+
+std::ostream& Operation::print(std::ostream& os) const {
+  const auto precBefore = std::cout.precision(20);
+
+  os << std::setw(4) << name << "\t";
+
+  auto controlIt = controls.begin();
+  auto targetIt = targets.begin();
+  for (std::size_t i = 0; i < nqubits; ++i) {
+    if (targetIt != targets.end() && *targetIt == i) {
+      if (type == ClassicControlled) {
+        os << "\033[1m\033[35m" << name[2] << name[3];
+      } else {
+        os << "\033[1m\033[36m" << name[0] << name[1];
+      }
+      os << "\t\033[0m";
+      ++targetIt;
+    } else if (controlIt != controls.end() && controlIt->qubit == i) {
+      if (controlIt->type == Control::Type::Pos) {
+        os << "\033[32m";
+      } else {
+        os << "\033[31m";
+      }
+      os << "c\t"
+         << "\033[0m";
+      ++controlIt;
+    } else {
+      os << "|\t";
+    }
+  }
+
+  printParameters(os);
+
+  std::cout.precision(precBefore);
+
+  return os;
+}
+
+std::ostream& Operation::print(std::ostream& os,
+                               const Permutation& permutation) const {
+  const auto precBefore = std::cout.precision(20);
+
+  os << std::setw(4) << name << "\t";
+  const auto& actualControls = getControls();
+  const auto& actualTargets = getTargets();
+  auto controlIt = actualControls.cbegin();
+  auto targetIt = actualTargets.cbegin();
+  for (const auto& [physical, logical] : permutation) {
+    if (targetIt != actualTargets.cend() && *targetIt == physical) {
+      if (type == ClassicControlled) {
+        os << "\033[1m\033[35m" << name[2] << name[3];
+      } else {
+        os << "\033[1m\033[36m" << name[0] << name[1];
+      }
+      os << "\t\033[0m";
+      ++targetIt;
+    } else if (controlIt != actualControls.cend() &&
+               controlIt->qubit == physical) {
+      if (controlIt->type == Control::Type::Pos) {
+        os << "\033[32m";
+      } else {
+        os << "\033[31m";
+      }
+      os << "c\t"
+         << "\033[0m";
+      ++controlIt;
+    } else {
+      os << "|\t";
+    }
+  }
+
+  printParameters(os);
+
+  std::cout.precision(precBefore);
+
+  return os;
+}
+
+bool Operation::equals(const Operation& op, const Permutation& perm1,
+                       const Permutation& perm2) const {
+  // check type
+  if (getType() != op.getType()) {
+    return false;
+  }
+
+  // check number of controls
+  const auto nc1 = getNcontrols();
+  const auto nc2 = op.getNcontrols();
+  if (nc1 != nc2) {
+    return false;
+  }
+
+  // check parameters
+  const auto& param1 = getParameter();
+  const auto& param2 = op.getParameter();
+  if (param1 != param2) {
+    return false;
+  }
+
+  // check controls
+  if (nc1 != 0U) {
+    Controls controls1{};
+    if (perm1.empty()) {
+      controls1 = getControls();
+    } else {
+      for (const auto& control : getControls()) {
+        controls1.emplace(Control{perm1.at(control.qubit), control.type});
+      }
+    }
+
+    Controls controls2{};
+    if (perm2.empty()) {
+      controls2 = op.getControls();
+    } else {
+      for (const auto& control : op.getControls()) {
+        controls2.emplace(Control{perm2.at(control.qubit), control.type});
+      }
+    }
+
+    if (controls1 != controls2) {
+      return false;
+    }
+  }
+
+  // check targets
+  std::set<Qubit> targets1{};
+  if (perm1.empty()) {
+    targets1 = {getTargets().begin(), getTargets().end()};
+  } else {
+    for (const auto& target : getTargets()) {
+      targets1.emplace(perm1.at(target));
+    }
+  }
+
+  std::set<Qubit> targets2{};
+  if (perm2.empty()) {
+    targets2 = {op.getTargets().begin(), op.getTargets().end()};
+  } else {
+    for (const auto& target : op.getTargets()) {
+      targets2.emplace(perm2.at(target));
+    }
+  }
+
+  return targets1 == targets2;
+}
+
+void Operation::addDepthContribution(std::vector<std::size_t>& depths) const {
+  std::size_t maxDepth = 0;
+  for (const auto& target : getTargets()) {
+    maxDepth = std::max(maxDepth, depths[target]);
+  }
+  for (const auto& control : getControls()) {
+    maxDepth = std::max(maxDepth, depths[control.qubit]);
+  }
+  maxDepth += 1;
+  for (const auto& target : getTargets()) {
+    depths[target] = maxDepth;
+  }
+  for (const auto& control : getControls()) {
+    depths[control.qubit] = maxDepth;
+  }
+}
 
 } // namespace qc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/src/operations/StandardOperation.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/operations/StandardOperation.cpp`

 * *Files 21% similar despite different names*

```diff
@@ -1,437 +1,462 @@
-/*
- * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
- */
-
 #include "operations/StandardOperation.hpp"
 
 #include <cassert>
 #include <sstream>
 #include <variant>
 
 namespace qc {
-    /***
-     * Protected Methods
-     ***/
-    OpType StandardOperation::parseU3(fp& theta, fp& phi, fp& lambda) {
-        if (std::abs(theta) < PARAMETER_TOLERANCE && std::abs(phi) < PARAMETER_TOLERANCE) {
-            parameter = {lambda};
-            return parseU1(parameter[0]);
-        }
-
-        if (std::abs(theta - PI_2) < PARAMETER_TOLERANCE) {
-            parameter = {phi, lambda};
-            return parseU2(parameter[0], parameter[1]);
-        }
-
-        if (std::abs(lambda) < PARAMETER_TOLERANCE) {
-            lambda = 0.L;
-            if (std::abs(phi) < PARAMETER_TOLERANCE) {
-                checkInteger(theta);
-                checkFractionPi(theta);
-                parameter = {theta};
-                return RY;
-            }
-        }
-
-        if (std::abs(lambda - PI_2) < PARAMETER_TOLERANCE) {
-            lambda = PI_2;
-            if (std::abs(phi + PI_2) < PARAMETER_TOLERANCE) {
-                checkInteger(theta);
-                checkFractionPi(theta);
-                parameter = {theta};
-                return RX;
-            }
-
-            if (std::abs(phi - PI_2) < PARAMETER_TOLERANCE) {
-                phi = PI_2;
-                if (std::abs(theta - PI) < PARAMETER_TOLERANCE) {
-                    parameter.clear();
-                    return Y;
-                }
-            }
-        }
-
-        if (std::abs(lambda + PI_2) < PARAMETER_TOLERANCE) {
-            lambda = -PI_2;
-            if (std::abs(phi - PI_2) < PARAMETER_TOLERANCE) {
-                phi       = PI_2;
-                parameter = {-theta};
-                return RX;
-            }
-        }
-
-        if (std::abs(lambda - PI) < PARAMETER_TOLERANCE) {
-            lambda = PI;
-            if (std::abs(phi) < PARAMETER_TOLERANCE) {
-                phi = 0.L;
-                if (std::abs(theta - PI) < PARAMETER_TOLERANCE) {
-                    parameter.clear();
-                    return X;
-                }
-            }
-        }
-
-        // parse a real u3 gate
-        checkInteger(lambda);
-        checkFractionPi(lambda);
-        checkInteger(phi);
-        checkFractionPi(phi);
-        checkInteger(theta);
-        checkFractionPi(theta);
-
-        return U3;
-    }
-
-    OpType StandardOperation::parseU2(fp& phi, fp& lambda) {
-        if (std::abs(phi) < PARAMETER_TOLERANCE) {
-            phi = 0.L;
-            if (std::abs(std::abs(lambda) - PI) < PARAMETER_TOLERANCE) {
-                parameter.clear();
-                return H;
-            }
-            if (std::abs(lambda) < PARAMETER_TOLERANCE) {
-                parameter = {PI_2};
-                return RY;
-            }
-        }
-
-        if (std::abs(lambda - PI_2) < PARAMETER_TOLERANCE) {
-            lambda = PI_2;
-            if (std::abs(phi + PI_2) < PARAMETER_TOLERANCE) {
-                parameter.clear();
-                return V;
-            }
-        }
-
-        if (std::abs(lambda + PI_2) < PARAMETER_TOLERANCE) {
-            lambda = -PI_2;
-            if (std::abs(phi - PI_2) < PARAMETER_TOLERANCE) {
-                parameter.clear();
-                return Vdag;
-            }
-        }
-
-        checkInteger(lambda);
-        checkFractionPi(lambda);
-        checkInteger(phi);
-        checkFractionPi(phi);
-
-        return U2;
-    }
-
-    OpType StandardOperation::parseU1(fp& lambda) {
-        if (std::abs(lambda) < PARAMETER_TOLERANCE) {
-            parameter.clear();
-            return I;
-        }
-        const bool sign = std::signbit(lambda);
-
-        if (std::abs(std::abs(lambda) - PI) < PARAMETER_TOLERANCE) {
-            parameter.clear();
-            return Z;
-        }
-
-        if (std::abs(std::abs(lambda) - PI_2) < PARAMETER_TOLERANCE) {
-            parameter.clear();
-            return sign ? Sdag : S;
-        }
-
-        if (std::abs(std::abs(lambda) - PI_4) < PARAMETER_TOLERANCE) {
-            parameter.clear();
-            return sign ? Tdag : T;
-        }
-
-        checkInteger(lambda);
-        checkFractionPi(lambda);
-
-        return Phase;
-    }
-
-    void StandardOperation::checkUgate() {
-        if (parameter.empty()) {
-            return;
-        }
-        if (type == Phase) {
-            assert(parameter.size() == 1);
-            type = parseU1(parameter.at(0));
-        } else if (type == U2) {
-            assert(parameter.size() == 2);
-            type = parseU2(parameter.at(0), parameter.at(1));
-        } else if (type == U3) {
-            assert(parameter.size() == 3);
-            type = parseU3(parameter.at(0), parameter.at(1), parameter.at(2));
-        }
-    }
-
-    void StandardOperation::setup(const std::size_t nq, const Qubit startingQubit) {
-        nqubits    = nq;
-        startQubit = startingQubit;
-        checkUgate();
-        setName();
-    }
-
-    /***
-     * Constructors
-     ***/
-    StandardOperation::StandardOperation(const std::size_t nq, const Qubit target, const OpType g, std::vector<fp> params, const Qubit startingQubit) {
-        type      = g;
-        parameter = std::move(params);
-        setup(nq, startingQubit);
-        targets.emplace_back(target);
-    }
-
-    StandardOperation::StandardOperation(const std::size_t nq, const Targets& targ, const OpType g, std::vector<fp> params, const Qubit startingQubit) {
-        type      = g;
-        parameter = std::move(params);
-        setup(nq, startingQubit);
-        targets = targ;
-    }
-
-    StandardOperation::StandardOperation(const std::size_t nq, const Control control, const Qubit target, const OpType g, const std::vector<fp>& params, const Qubit startingQubit):
-        StandardOperation(nq, target, g, params, startingQubit) {
-        controls.insert(control);
-    }
-
-    StandardOperation::StandardOperation(const std::size_t nq, const Control control, const Targets& targ, const OpType g, const std::vector<fp>& params, const Qubit startingQubit):
-        StandardOperation(nq, targ, g, params, startingQubit) {
-        controls.insert(control);
-    }
-
-    StandardOperation::StandardOperation(const std::size_t nq, const Controls& c, const Qubit target, const OpType g, const std::vector<fp>& params, const Qubit startingQubit):
-        StandardOperation(nq, target, g, params, startingQubit) {
-        controls = c;
-    }
-
-    StandardOperation::StandardOperation(const std::size_t nq, const Controls& c, const Targets& targ, const OpType g, const std::vector<fp>& params, const Qubit startingQubit):
-        StandardOperation(nq, targ, g, params, startingQubit) {
-        controls = c;
-    }
-
-    // MCT Constructor
-    StandardOperation::StandardOperation(const std::size_t nq, const Controls& c, const Qubit target, const Qubit startingQubit):
-        StandardOperation(nq, c, target, X, {}, startingQubit) {
-    }
-
-    // MCF (cSWAP), Peres, parameterized two target Constructor
-    StandardOperation::StandardOperation(const std::size_t nq, const Controls& c, const Qubit target0, const Qubit target1, const OpType g, const std::vector<fp>& params, const Qubit startingQubit):
-        StandardOperation(nq, c, {target0, target1}, g, params, startingQubit) {
-    }
-
-    /***
-     * Public Methods
-    ***/
-    void StandardOperation::dumpOpenQASM(std::ostream& of, const RegisterNames& qreg, [[maybe_unused]] const RegisterNames& creg) const {
-        std::ostringstream op;
-        op << std::setprecision(std::numeric_limits<fp>::digits10);
-        if ((controls.size() > 1 && type != X) || controls.size() > 2) {
-            std::cout << "[WARNING] Multiple controlled gates are not natively supported by OpenQASM. "
-                      << "However, this library can parse .qasm files with multiple controlled gates (e.g., cccx) correctly. "
-                      << "Thus, while not valid vanilla OpenQASM, the dumped file will work with this library. " << std::endl;
-        }
-
-        // safe the numbers of controls as a prefix to the operation name
-        op << std::string(controls.size(), 'c');
-
-        switch (type) {
-            case GPhase:
-                op << "gphase(" << parameter.at(0) << ")";
-                break;
-            case I:
-                op << "id";
-                break;
-            case H:
-                op << "h";
-                break;
-            case X:
-                op << "x";
-                break;
-            case Y:
-                op << "y";
-                break;
-            case Z:
-                op << "z";
-                break;
-            case S:
-                if (!controls.empty()) {
-                    op << "p(pi/2)";
-                } else {
-                    op << "s";
-                }
-                break;
-            case Sdag:
-                if (!controls.empty()) {
-                    op << "p(-pi/2)";
-                } else {
-                    op << "sdg";
-                }
-                break;
-            case T:
-                if (!controls.empty()) {
-                    op << "p(pi/4)";
-                } else {
-                    op << "t";
-                }
-                break;
-            case Tdag:
-                if (!controls.empty()) {
-                    op << "p(-pi/4)";
-                } else {
-                    op << "tdg";
-                }
-                break;
-            case V:
-                op << "u3(pi/2,-pi/2,pi/2)";
-                break;
-            case Vdag:
-                op << "u3(pi/2,pi/2,-pi/2)";
-                break;
-            case U3:
-                op << "u3(" << parameter[0] << "," << parameter[1] << "," << parameter[2] << ")";
-                break;
-            case U2:
-                op << "u3(pi/2," << parameter[0] << "," << parameter[1] << ")";
-                break;
-            case Phase:
-                op << "p(" << parameter[0] << ")";
-                break;
-            case SX:
-                op << "sx";
-                break;
-            case SXdag:
-                op << "sxdg";
-                break;
-            case RX:
-                op << "rx(" << parameter[0] << ")";
-                break;
-            case RY:
-                op << "ry(" << parameter[0] << ")";
-                break;
-            case RZ:
-                op << "rz(" << parameter[0] << ")";
-                break;
-            case DCX:
-                op << "dcx";
-                break;
-            case ECR:
-                op << "ecr";
-                break;
-            case RXX:
-                op << "rxx(" << parameter[0] << ")";
-                break;
-            case RYY:
-                op << "ryy(" << parameter[0] << ")";
-                break;
-            case RZZ:
-                op << "rzz(" << parameter[0] << ")";
-                break;
-            case RZX:
-                op << "rzx(" << parameter[0] << ")";
-                break;
-            case XXminusYY:
-                op << "xx_minus_yy(" << parameter[0] << "," << parameter[1] << ")";
-                break;
-            case XXplusYY:
-                op << "xx_plus_yy(" << parameter[0] << "," << parameter[1] << ")";
-                break;
-            case SWAP:
-                op << "swap";
-                break;
-            case iSWAP:
-                op << "iswap";
-                break;
-            case Peres:
-                of << op.str() << "cx";
-                for (const auto& c: controls) {
-                    of << " " << qreg[c.qubit].second << ",";
-                }
-                of << " " << qreg[targets[1]].second << ", " << qreg[targets[0]].second << ";\n";
-
-                of << op.str() << "x";
-                for (const auto& c: controls) {
-                    of << " " << qreg[c.qubit].second << ",";
-                }
-                of << " " << qreg[targets[1]].second << ";\n";
-                return;
-            case Peresdag:
-                of << op.str() << "x";
-                for (const auto& c: controls) {
-                    of << " " << qreg[c.qubit].second << ",";
-                }
-                of << " " << qreg[targets[1]].second << ";\n";
-
-                of << op.str() << "cx";
-                for (const auto& c: controls) {
-                    of << " " << qreg[c.qubit].second << ",";
-                }
-                of << " " << qreg[targets[1]].second << ", " << qreg[targets[0]].second << ";\n";
-                return;
-            case Teleportation:
-                dumpOpenQASMTeleportation(of, qreg);
-                return;
-            default:
-                std::cerr << "gate type (index) " << static_cast<int>(type) << " could not be converted to OpenQASM" << std::endl;
-        }
-
-        // apply X operations to negate the respective controls
-        for (const auto& c: controls) {
-            if (c.type == Control::Type::Neg) {
-                of << "x " << qreg[c.qubit].second << ";\n";
-            }
-        }
-        // apply the operation
-        of << op.str();
-        // add controls and targets of the operation
-        for (const auto& c: controls) {
-            of << " " << qreg[c.qubit].second << ",";
-        }
-        if (!targets.empty()) {
-            for (const auto& t: targets) {
-                of << " " << qreg[t].second << ",";
-            }
-            of.seekp(-1, std::ios_base::cur);
-        }
-        of << ";\n";
-        // apply X operations to negate the respective controls again
-        for (const auto& c: controls) {
-            if (c.type == Control::Type::Neg) {
-                of << "x " << qreg[c.qubit].second << ";\n";
-            }
-        }
-    }
-
-    void StandardOperation::dumpOpenQASMTeleportation(std::ostream& of, const RegisterNames& qreg) const {
-        if (!controls.empty() || targets.size() != 3) {
-            std::cerr << "controls = ";
-            for (const auto& c: controls) {
-                std::cerr << qreg.at(c.qubit).second << " ";
-            }
-            std::cerr << "\ntargets = ";
-            for (const auto& t: targets) {
-                std::cerr << qreg.at(t).second << " ";
-            }
-            std::cerr << "\n";
-
-            throw QFRException("Teleportation needs three targets");
-        }
-        /*
-                                                        
-                        | q_0:  H M |0 or |1
-                                           
-                        |0 a_0:  H  X M |0 or |1
-                                                 
-                        |0 a_1:  X  X  Z  |
-                                                             
-                                                                     
-                      bitflip: 1/ = 1 
-                                                            0      
-                    phaseflip: 1/ = 1 
-                                                               0           
-                */
-        of << "// teleport q_0, a_0, a_1; q_0 --> a_1  via a_0\n";
-        of << "teleport "
-           << qreg[targets[0]].second << ", "
-           << qreg[targets[1]].second << ", "
-           << qreg[targets[2]].second << ";\n";
-    }
+/***
+ * Protected Methods
+ ***/
+OpType StandardOperation::parseU3(fp& theta, fp& phi, fp& lambda) {
+  if (std::abs(theta) < PARAMETER_TOLERANCE &&
+      std::abs(phi) < PARAMETER_TOLERANCE) {
+    parameter = {lambda};
+    return parseU1(parameter[0]);
+  }
+
+  if (std::abs(theta - PI_2) < PARAMETER_TOLERANCE) {
+    parameter = {phi, lambda};
+    return parseU2(parameter[0], parameter[1]);
+  }
+
+  if (std::abs(lambda) < PARAMETER_TOLERANCE) {
+    lambda = 0.L;
+    if (std::abs(phi) < PARAMETER_TOLERANCE) {
+      checkInteger(theta);
+      checkFractionPi(theta);
+      parameter = {theta};
+      return RY;
+    }
+  }
+
+  if (std::abs(lambda - PI_2) < PARAMETER_TOLERANCE) {
+    lambda = PI_2;
+    if (std::abs(phi + PI_2) < PARAMETER_TOLERANCE) {
+      checkInteger(theta);
+      checkFractionPi(theta);
+      parameter = {theta};
+      return RX;
+    }
+
+    if (std::abs(phi - PI_2) < PARAMETER_TOLERANCE) {
+      phi = PI_2;
+      if (std::abs(theta - PI) < PARAMETER_TOLERANCE) {
+        parameter.clear();
+        return Y;
+      }
+    }
+  }
+
+  if (std::abs(lambda + PI_2) < PARAMETER_TOLERANCE) {
+    lambda = -PI_2;
+    if (std::abs(phi - PI_2) < PARAMETER_TOLERANCE) {
+      phi = PI_2;
+      parameter = {-theta};
+      return RX;
+    }
+  }
+
+  if (std::abs(lambda - PI) < PARAMETER_TOLERANCE) {
+    lambda = PI;
+    if (std::abs(phi) < PARAMETER_TOLERANCE) {
+      phi = 0.L;
+      if (std::abs(theta - PI) < PARAMETER_TOLERANCE) {
+        parameter.clear();
+        return X;
+      }
+    }
+  }
+
+  // parse a real u3 gate
+  checkInteger(lambda);
+  checkFractionPi(lambda);
+  checkInteger(phi);
+  checkFractionPi(phi);
+  checkInteger(theta);
+  checkFractionPi(theta);
+
+  return U3;
+}
+
+OpType StandardOperation::parseU2(fp& phi, fp& lambda) {
+  if (std::abs(phi) < PARAMETER_TOLERANCE) {
+    phi = 0.L;
+    if (std::abs(std::abs(lambda) - PI) < PARAMETER_TOLERANCE) {
+      parameter.clear();
+      return H;
+    }
+    if (std::abs(lambda) < PARAMETER_TOLERANCE) {
+      parameter = {PI_2};
+      return RY;
+    }
+  }
+
+  if (std::abs(lambda - PI_2) < PARAMETER_TOLERANCE) {
+    lambda = PI_2;
+    if (std::abs(phi + PI_2) < PARAMETER_TOLERANCE) {
+      parameter.clear();
+      return V;
+    }
+  }
+
+  if (std::abs(lambda + PI_2) < PARAMETER_TOLERANCE) {
+    lambda = -PI_2;
+    if (std::abs(phi - PI_2) < PARAMETER_TOLERANCE) {
+      parameter.clear();
+      return Vdag;
+    }
+  }
+
+  checkInteger(lambda);
+  checkFractionPi(lambda);
+  checkInteger(phi);
+  checkFractionPi(phi);
+
+  return U2;
+}
+
+OpType StandardOperation::parseU1(fp& lambda) {
+  if (std::abs(lambda) < PARAMETER_TOLERANCE) {
+    parameter.clear();
+    return I;
+  }
+  const bool sign = std::signbit(lambda);
+
+  if (std::abs(std::abs(lambda) - PI) < PARAMETER_TOLERANCE) {
+    parameter.clear();
+    return Z;
+  }
+
+  if (std::abs(std::abs(lambda) - PI_2) < PARAMETER_TOLERANCE) {
+    parameter.clear();
+    return sign ? Sdag : S;
+  }
+
+  if (std::abs(std::abs(lambda) - PI_4) < PARAMETER_TOLERANCE) {
+    parameter.clear();
+    return sign ? Tdag : T;
+  }
+
+  checkInteger(lambda);
+  checkFractionPi(lambda);
+
+  return Phase;
+}
+
+void StandardOperation::checkUgate() {
+  if (parameter.empty()) {
+    return;
+  }
+  if (type == Phase) {
+    assert(parameter.size() == 1);
+    type = parseU1(parameter.at(0));
+  } else if (type == U2) {
+    assert(parameter.size() == 2);
+    type = parseU2(parameter.at(0), parameter.at(1));
+  } else if (type == U3) {
+    assert(parameter.size() == 3);
+    type = parseU3(parameter.at(0), parameter.at(1), parameter.at(2));
+  }
+}
+
+void StandardOperation::setup(const std::size_t nq, const Qubit startingQubit) {
+  nqubits = nq;
+  startQubit = startingQubit;
+  checkUgate();
+  setName();
+}
+
+/***
+ * Constructors
+ ***/
+StandardOperation::StandardOperation(const std::size_t nq, const Qubit target,
+                                     const OpType g, std::vector<fp> params,
+                                     const Qubit startingQubit) {
+  type = g;
+  parameter = std::move(params);
+  setup(nq, startingQubit);
+  targets.emplace_back(target);
+}
+
+StandardOperation::StandardOperation(const std::size_t nq, const Targets& targ,
+                                     const OpType g, std::vector<fp> params,
+                                     const Qubit startingQubit) {
+  type = g;
+  parameter = std::move(params);
+  setup(nq, startingQubit);
+  targets = targ;
+}
+
+StandardOperation::StandardOperation(const std::size_t nq,
+                                     const Control control, const Qubit target,
+                                     const OpType g,
+                                     const std::vector<fp>& params,
+                                     const Qubit startingQubit)
+    : StandardOperation(nq, target, g, params, startingQubit) {
+  controls.insert(control);
+}
+
+StandardOperation::StandardOperation(const std::size_t nq,
+                                     const Control control, const Targets& targ,
+                                     const OpType g,
+                                     const std::vector<fp>& params,
+                                     const Qubit startingQubit)
+    : StandardOperation(nq, targ, g, params, startingQubit) {
+  controls.insert(control);
+}
+
+StandardOperation::StandardOperation(const std::size_t nq, const Controls& c,
+                                     const Qubit target, const OpType g,
+                                     const std::vector<fp>& params,
+                                     const Qubit startingQubit)
+    : StandardOperation(nq, target, g, params, startingQubit) {
+  controls = c;
+}
+
+StandardOperation::StandardOperation(const std::size_t nq, const Controls& c,
+                                     const Targets& targ, const OpType g,
+                                     const std::vector<fp>& params,
+                                     const Qubit startingQubit)
+    : StandardOperation(nq, targ, g, params, startingQubit) {
+  controls = c;
+}
+
+// MCT Constructor
+StandardOperation::StandardOperation(const std::size_t nq, const Controls& c,
+                                     const Qubit target,
+                                     const Qubit startingQubit)
+    : StandardOperation(nq, c, target, X, {}, startingQubit) {}
+
+// MCF (cSWAP), Peres, parameterized two target Constructor
+StandardOperation::StandardOperation(const std::size_t nq, const Controls& c,
+                                     const Qubit target0, const Qubit target1,
+                                     const OpType g,
+                                     const std::vector<fp>& params,
+                                     const Qubit startingQubit)
+    : StandardOperation(nq, c, {target0, target1}, g, params, startingQubit) {}
+
+/***
+ * Public Methods
+ ***/
+void StandardOperation::dumpOpenQASM(
+    std::ostream& of, const RegisterNames& qreg,
+    [[maybe_unused]] const RegisterNames& creg) const {
+  std::ostringstream op;
+  op << std::setprecision(std::numeric_limits<fp>::digits10);
+  if ((controls.size() > 1 && type != X) || controls.size() > 2) {
+    std::cout << "[WARNING] Multiple controlled gates are not natively "
+                 "supported by OpenQASM. "
+              << "However, this library can parse .qasm files with multiple "
+                 "controlled gates (e.g., cccx) correctly. "
+              << "Thus, while not valid vanilla OpenQASM, the dumped file will "
+                 "work with this library. "
+              << std::endl;
+  }
+
+  // safe the numbers of controls as a prefix to the operation name
+  op << std::string(controls.size(), 'c');
+
+  switch (type) {
+  case GPhase:
+    op << "gphase(" << parameter.at(0) << ")";
+    break;
+  case I:
+    op << "id";
+    break;
+  case H:
+    op << "h";
+    break;
+  case X:
+    op << "x";
+    break;
+  case Y:
+    op << "y";
+    break;
+  case Z:
+    op << "z";
+    break;
+  case S:
+    if (!controls.empty()) {
+      op << "p(pi/2)";
+    } else {
+      op << "s";
+    }
+    break;
+  case Sdag:
+    if (!controls.empty()) {
+      op << "p(-pi/2)";
+    } else {
+      op << "sdg";
+    }
+    break;
+  case T:
+    if (!controls.empty()) {
+      op << "p(pi/4)";
+    } else {
+      op << "t";
+    }
+    break;
+  case Tdag:
+    if (!controls.empty()) {
+      op << "p(-pi/4)";
+    } else {
+      op << "tdg";
+    }
+    break;
+  case V:
+    op << "u3(pi/2,-pi/2,pi/2)";
+    break;
+  case Vdag:
+    op << "u3(pi/2,pi/2,-pi/2)";
+    break;
+  case U3:
+    op << "u3(" << parameter[0] << "," << parameter[1] << "," << parameter[2]
+       << ")";
+    break;
+  case U2:
+    op << "u3(pi/2," << parameter[0] << "," << parameter[1] << ")";
+    break;
+  case Phase:
+    op << "p(" << parameter[0] << ")";
+    break;
+  case SX:
+    op << "sx";
+    break;
+  case SXdag:
+    op << "sxdg";
+    break;
+  case RX:
+    op << "rx(" << parameter[0] << ")";
+    break;
+  case RY:
+    op << "ry(" << parameter[0] << ")";
+    break;
+  case RZ:
+    op << "rz(" << parameter[0] << ")";
+    break;
+  case DCX:
+    op << "dcx";
+    break;
+  case ECR:
+    op << "ecr";
+    break;
+  case RXX:
+    op << "rxx(" << parameter[0] << ")";
+    break;
+  case RYY:
+    op << "ryy(" << parameter[0] << ")";
+    break;
+  case RZZ:
+    op << "rzz(" << parameter[0] << ")";
+    break;
+  case RZX:
+    op << "rzx(" << parameter[0] << ")";
+    break;
+  case XXminusYY:
+    op << "xx_minus_yy(" << parameter[0] << "," << parameter[1] << ")";
+    break;
+  case XXplusYY:
+    op << "xx_plus_yy(" << parameter[0] << "," << parameter[1] << ")";
+    break;
+  case SWAP:
+    op << "swap";
+    break;
+  case iSWAP:
+    op << "iswap";
+    break;
+  case Peres:
+    of << op.str() << "cx";
+    for (const auto& c : controls) {
+      of << " " << qreg[c.qubit].second << ",";
+    }
+    of << " " << qreg[targets[1]].second << ", " << qreg[targets[0]].second
+       << ";\n";
+
+    of << op.str() << "x";
+    for (const auto& c : controls) {
+      of << " " << qreg[c.qubit].second << ",";
+    }
+    of << " " << qreg[targets[1]].second << ";\n";
+    return;
+  case Peresdag:
+    of << op.str() << "x";
+    for (const auto& c : controls) {
+      of << " " << qreg[c.qubit].second << ",";
+    }
+    of << " " << qreg[targets[1]].second << ";\n";
+
+    of << op.str() << "cx";
+    for (const auto& c : controls) {
+      of << " " << qreg[c.qubit].second << ",";
+    }
+    of << " " << qreg[targets[1]].second << ", " << qreg[targets[0]].second
+       << ";\n";
+    return;
+  case Teleportation:
+    dumpOpenQASMTeleportation(of, qreg);
+    return;
+  default:
+    std::cerr << "gate type (index) " << static_cast<int>(type)
+              << " could not be converted to OpenQASM" << std::endl;
+  }
+
+  // apply X operations to negate the respective controls
+  for (const auto& c : controls) {
+    if (c.type == Control::Type::Neg) {
+      of << "x " << qreg[c.qubit].second << ";\n";
+    }
+  }
+  // apply the operation
+  of << op.str();
+  // add controls and targets of the operation
+  for (const auto& c : controls) {
+    of << " " << qreg[c.qubit].second << ",";
+  }
+  if (!targets.empty()) {
+    for (const auto& t : targets) {
+      of << " " << qreg[t].second << ",";
+    }
+    of.seekp(-1, std::ios_base::cur);
+  }
+  of << ";\n";
+  // apply X operations to negate the respective controls again
+  for (const auto& c : controls) {
+    if (c.type == Control::Type::Neg) {
+      of << "x " << qreg[c.qubit].second << ";\n";
+    }
+  }
+}
+
+void StandardOperation::dumpOpenQASMTeleportation(
+    std::ostream& of, const RegisterNames& qreg) const {
+  if (!controls.empty() || targets.size() != 3) {
+    std::cerr << "controls = ";
+    for (const auto& c : controls) {
+      std::cerr << qreg.at(c.qubit).second << " ";
+    }
+    std::cerr << "\ntargets = ";
+    for (const auto& t : targets) {
+      std::cerr << qreg.at(t).second << " ";
+    }
+    std::cerr << "\n";
+
+    throw QFRException("Teleportation needs three targets");
+  }
+  /*
+                                                  
+                  | q_0:  H M |0
+     or |1            |0 a_0:  H  X
+     M |0 or |1           
+           |0 a_1:  X  X  Z
+      |                                  
+                bitflip: 1/ = 1 
+                                                      0      
+              phaseflip: 1/ = 1 
+                                                         0           
+          */
+  of << "// teleport q_0, a_0, a_1; q_0 --> a_1  via a_0\n";
+  of << "teleport " << qreg[targets[0]].second << ", "
+     << qreg[targets[1]].second << ", " << qreg[targets[2]].second << ";\n";
+}
 } // namespace qc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/src/operations/SymbolicOperation.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/operations/SymbolicOperation.cpp`

 * *Files 20% similar despite different names*

```diff
@@ -3,281 +3,333 @@
 #include "Definitions.hpp"
 #include "operations/StandardOperation.hpp"
 
 #include <variant>
 
 namespace qc {
 
-    void SymbolicOperation::storeSymbolOrNumber(const SymbolOrNumber& param, const std::size_t i) {
-        if (std::holds_alternative<fp>(param)) {
-            parameter.at(i) = std::get<fp>(param);
-        } else {
-            symbolicParameter.at(i) = std::get<Symbolic>(param);
-        }
-    }
-
-    OpType SymbolicOperation::parseU3([[maybe_unused]] const Symbolic& theta, fp& phi, fp& lambda) {
-        if (std::abs(lambda) < PARAMETER_TOLERANCE) {
-            lambda = 0.L;
-            if (std::abs(phi) < PARAMETER_TOLERANCE) {
-                phi = 0.L;
-            }
-        }
-
-        if (std::abs(lambda - PI_2) < PARAMETER_TOLERANCE) {
-            lambda = PI_2;
-            if (std::abs(phi - PI_2) < PARAMETER_TOLERANCE) {
-                phi = PI_2;
-            }
-        }
-
-        if (std::abs(lambda - PI) < PARAMETER_TOLERANCE) {
-            lambda = PI;
-            if (std::abs(phi) < PARAMETER_TOLERANCE) {
-                phi = 0.L;
-            }
-        }
-
-        // parse a real u3 gate
-        checkInteger(lambda);
-        checkFractionPi(lambda);
-        checkInteger(phi);
-        checkFractionPi(phi);
-
-        return U3;
-    }
-    OpType SymbolicOperation::parseU3(fp& theta, const Symbolic& phi,
-                                      fp& lambda) {
-        if (std::abs(theta - PI_2) < PARAMETER_TOLERANCE) {
-            theta = PI_2;
-            return parseU2(phi, lambda);
-        }
-
-        if (std::abs(lambda) < PARAMETER_TOLERANCE) {
-            lambda = 0.L;
-        }
-
-        if (std::abs(lambda - PI_2) < PARAMETER_TOLERANCE) {
-            lambda = PI_2;
-        }
-
-        if (std::abs(lambda - PI) < PARAMETER_TOLERANCE) {
-            lambda = PI;
-        }
-
-        // parse a real u3 gate
-        checkInteger(lambda);
-        checkFractionPi(lambda);
-        checkInteger(theta);
-        checkFractionPi(theta);
-
-        return U3;
-    }
-    OpType SymbolicOperation::parseU3(fp& theta, fp& phi,
-                                      [[maybe_unused]] const Symbolic& lambda) {
-        if (std::abs(theta) < PARAMETER_TOLERANCE &&
-            std::abs(phi) < PARAMETER_TOLERANCE) {
-            phi   = 0.L;
-            theta = 0.L;
-            return SymbolicOperation::parseU1(lambda);
-        }
-
-        if (std::abs(theta - PI_2) < PARAMETER_TOLERANCE) {
-            theta = PI_2;
-            return parseU2(phi, lambda);
-        }
-        // parse a real u3 gate
-        checkInteger(phi);
-        checkFractionPi(phi);
-        checkInteger(theta);
-        checkFractionPi(theta);
-
-        return U3;
-    }
-    OpType SymbolicOperation::parseU3([[maybe_unused]] const Symbolic& theta,
-                                      [[maybe_unused]] const Symbolic& phi, fp& lambda) {
-        // parse a real u3 gate
-        checkInteger(lambda);
-        checkFractionPi(lambda);
-
-        return U3;
-    }
-    OpType SymbolicOperation::parseU3([[maybe_unused]] const Symbolic& theta, fp& phi,
-                                      [[maybe_unused]] const Symbolic& lambda) {
-        // parse a real u3 gate
-        checkInteger(phi);
-        checkFractionPi(phi);
-
-        return U3;
-    }
-    OpType SymbolicOperation::parseU3(fp& theta, const Symbolic& phi, const Symbolic& lambda) {
-        if (std::abs(theta - PI_2) < PARAMETER_TOLERANCE) {
-            theta = PI_2;
-            return parseU2(phi, lambda);
-        }
-
-        // parse a real u3 gate
-
-        checkInteger(theta);
-        checkFractionPi(theta);
-
-        return U3;
-    }
-
-    OpType SymbolicOperation::parseU2([[maybe_unused]] const Symbolic& phi, [[maybe_unused]] const Symbolic& lambda) {
-        return U2;
-    }
-
-    OpType SymbolicOperation::parseU2([[maybe_unused]] const Symbolic& phi, fp& lambda) {
-        checkInteger(lambda);
-        checkFractionPi(lambda);
-
-        return U2;
-    }
-    OpType SymbolicOperation::parseU2(fp& phi, [[maybe_unused]] const Symbolic& lambda) {
-        checkInteger(phi);
-        checkFractionPi(phi);
-
-        return U2;
-    }
-
-    OpType SymbolicOperation::parseU1([[maybe_unused]] const Symbolic& lambda) {
-        return Phase;
-    }
-
-    void SymbolicOperation::checkSymbolicUgate() {
-        if (type == Phase) {
-            if (!isSymbolicParameter(0)) {
-                type = StandardOperation::parseU1(parameter[0]);
-            }
-        } else if (type == U2) {
-            if (!isSymbolicParameter(0) && !isSymbolicParameter(1)) {
-                type = StandardOperation::parseU2(parameter[0], parameter[1]);
-            } else if (isSymbolicParameter(0)) {
-                type = parseU2(symbolicParameter[0].value(), parameter[1]);
-            } else if (isSymbolicParameter(1)) {
-                type = parseU2(parameter[0], symbolicParameter[1].value());
-            }
-        } else if (type == U3) {
-            if (!isSymbolicParameter(0) && !isSymbolicParameter(1) && !isSymbolicParameter(2)) {
-                type = StandardOperation::parseU3(parameter[0], parameter[1], parameter[2]);
-            } else if (!isSymbolicParameter(0) && !isSymbolicParameter(1)) {
-                type = parseU3(parameter[0], parameter[1], symbolicParameter[2].value());
-            } else if (!isSymbolicParameter(0) && !isSymbolicParameter(2)) {
-                type = parseU3(parameter[0], symbolicParameter[1].value(), parameter[2]);
-            } else if (!isSymbolicParameter(1) && !isSymbolicParameter(2)) {
-                type = parseU3(symbolicParameter[0].value(), parameter[1], parameter[2]);
-            } else if (!isSymbolicParameter(0)) {
-                type = parseU3(parameter[0], symbolicParameter[1].value(), symbolicParameter[2].value());
-            } else if (!isSymbolicParameter(1)) {
-                type = parseU3(symbolicParameter[0].value(), parameter[1], symbolicParameter[2].value());
-            } else if (!isSymbolicParameter(2)) {
-                type = parseU3(symbolicParameter[0].value(), symbolicParameter[1].value(), parameter[2]);
-            }
-        }
-    }
-
-    void SymbolicOperation::setup(const std::size_t nq, const std::vector<SymbolOrNumber>& params, const Qubit startingQubit) {
-        nqubits              = nq;
-        const auto numParams = params.size();
-        parameter.resize(numParams);
-        symbolicParameter.resize(numParams);
-        for (std::size_t i = 0; i < numParams; ++i) {
-            storeSymbolOrNumber(params[i], i);
-        }
-        startQubit = startingQubit;
-        checkSymbolicUgate();
-        setName();
-    }
-
-    [[nodiscard]] fp SymbolicOperation::getInstantiation(const SymbolOrNumber& symOrNum, const VariableAssignment& assignment) {
-        return std::visit(Overload{
-                                  [&](const fp num) { return num; },
-                                  [&](const Symbolic& sym) { return sym.evaluate(assignment); }},
-                          symOrNum);
-    }
-
-    SymbolicOperation::SymbolicOperation(const std::size_t nq, const Qubit target, const OpType g, const std::vector<SymbolOrNumber>& params, const Qubit startingQubit) {
-        type = g;
-        setup(nq, params, startingQubit);
-        targets.emplace_back(target);
-    }
-
-    SymbolicOperation::SymbolicOperation(const std::size_t nq, const Targets& targ, const OpType g, const std::vector<SymbolOrNumber>& params, const Qubit startingQubit) {
-        type = g;
-        setup(nq, params, startingQubit);
-        targets = targ;
-    }
-
-    SymbolicOperation::SymbolicOperation(const std::size_t nq, const Control control, const Qubit target, const OpType g, const std::vector<SymbolOrNumber>& params, const Qubit startingQubit):
-        SymbolicOperation(nq, target, g, params, startingQubit) {
-        controls.insert(control);
-    }
-
-    SymbolicOperation::SymbolicOperation(const std::size_t nq, const Control control, const Targets& targ, const OpType g, const std::vector<SymbolOrNumber>& params, const Qubit startingQubit):
-        SymbolicOperation(nq, targ, g, params, startingQubit) {
-        controls.insert(control);
-    }
-
-    SymbolicOperation::SymbolicOperation(const std::size_t nq, const Controls& c, const Qubit target, const OpType g, const std::vector<SymbolOrNumber>& params, const Qubit startingQubit):
-        SymbolicOperation(nq, target, g, params, startingQubit) {
-        controls = c;
-    }
-
-    SymbolicOperation::SymbolicOperation(const std::size_t nq, const Controls& c, const Targets& targ, const OpType g, const std::vector<SymbolOrNumber>& params, const Qubit startingQubit):
-        SymbolicOperation(nq, targ, g, params, startingQubit) {
-        controls = c;
-    }
-
-    // MCF (cSWAP), Peres, parameterized two target Constructor
-    SymbolicOperation::SymbolicOperation(const std::size_t nq, const Controls& c, const Qubit target0, const Qubit target1, const OpType g, const std::vector<SymbolOrNumber>& params, const Qubit startingQubit):
-        SymbolicOperation(nq, c, {target0, target1}, g, params, startingQubit) {
-    }
-
-    bool SymbolicOperation::equals(const Operation& op, const Permutation& perm1, const Permutation& perm2) const {
-        if (!op.isSymbolicOperation() && !isStandardOperation()) {
-            return false;
-        }
-        if (isStandardOperation() && qc::StandardOperation::equals(op, perm1, perm2)) {
-            return true;
-        }
-
-        if (!op.isSymbolicOperation()) {
-            return false;
-        }
-        const auto& symOp = dynamic_cast<const SymbolicOperation&>(op);
-        for (std::size_t i = 0; i < symbolicParameter.size(); ++i) {
-            if (symbolicParameter.at(i).has_value() != symOp.symbolicParameter.at(i).has_value()) {
-                return false;
-            }
-
-            if (symbolicParameter.at(i).has_value()) {
-                return symbolicParameter.at(i).value() == symOp.symbolicParameter.at(i).value();
-            }
-        }
-        return true;
-    }
-
-    [[noreturn]] void SymbolicOperation::dumpOpenQASM([[maybe_unused]] std::ostream& of, [[maybe_unused]] const RegisterNames& qreg, [[maybe_unused]] const RegisterNames& creg) const {
-        throw QFRException("OpenQasm2.0 doesn't support parametrized gates!");
-    }
-
-    StandardOperation SymbolicOperation::getInstantiatedOperation(const VariableAssignment& assignment) const {
-        std::vector<fp> parameters;
-        const auto      size = symbolicParameter.size();
-        parameters.reserve(size);
-        for (std::size_t i = 0; i < size; ++i) {
-            parameters.emplace_back(getInstantiation(getParameter(i), assignment));
-        }
-        return {nqubits, targets, type, parameters, startQubit};
-    }
-
-    // Instantiates this Operation
-    // Afterwards casting to StandardOperation can be done if assignment is total
-    void SymbolicOperation::instantiate(const VariableAssignment& assignment) {
-        for (std::size_t i = 0; i < symbolicParameter.size(); ++i) {
-            parameter.at(i) = getInstantiation(getParameter(i), assignment);
-            symbolicParameter.at(i).reset();
-        }
-        checkUgate();
-    }
+void SymbolicOperation::storeSymbolOrNumber(const SymbolOrNumber& param,
+                                            const std::size_t i) {
+  if (std::holds_alternative<fp>(param)) {
+    parameter.at(i) = std::get<fp>(param);
+  } else {
+    symbolicParameter.at(i) = std::get<Symbolic>(param);
+  }
+}
+
+OpType SymbolicOperation::parseU3([[maybe_unused]] const Symbolic& theta,
+                                  fp& phi, fp& lambda) {
+  if (std::abs(lambda) < PARAMETER_TOLERANCE) {
+    lambda = 0.L;
+    if (std::abs(phi) < PARAMETER_TOLERANCE) {
+      phi = 0.L;
+    }
+  }
+
+  if (std::abs(lambda - PI_2) < PARAMETER_TOLERANCE) {
+    lambda = PI_2;
+    if (std::abs(phi - PI_2) < PARAMETER_TOLERANCE) {
+      phi = PI_2;
+    }
+  }
+
+  if (std::abs(lambda - PI) < PARAMETER_TOLERANCE) {
+    lambda = PI;
+    if (std::abs(phi) < PARAMETER_TOLERANCE) {
+      phi = 0.L;
+    }
+  }
+
+  // parse a real u3 gate
+  checkInteger(lambda);
+  checkFractionPi(lambda);
+  checkInteger(phi);
+  checkFractionPi(phi);
+
+  return U3;
+}
+OpType SymbolicOperation::parseU3(fp& theta, const Symbolic& phi, fp& lambda) {
+  if (std::abs(theta - PI_2) < PARAMETER_TOLERANCE) {
+    theta = PI_2;
+    return parseU2(phi, lambda);
+  }
+
+  if (std::abs(lambda) < PARAMETER_TOLERANCE) {
+    lambda = 0.L;
+  }
+
+  if (std::abs(lambda - PI_2) < PARAMETER_TOLERANCE) {
+    lambda = PI_2;
+  }
+
+  if (std::abs(lambda - PI) < PARAMETER_TOLERANCE) {
+    lambda = PI;
+  }
+
+  // parse a real u3 gate
+  checkInteger(lambda);
+  checkFractionPi(lambda);
+  checkInteger(theta);
+  checkFractionPi(theta);
+
+  return U3;
+}
+OpType SymbolicOperation::parseU3(fp& theta, fp& phi,
+                                  [[maybe_unused]] const Symbolic& lambda) {
+  if (std::abs(theta) < PARAMETER_TOLERANCE &&
+      std::abs(phi) < PARAMETER_TOLERANCE) {
+    phi = 0.L;
+    theta = 0.L;
+    return SymbolicOperation::parseU1(lambda);
+  }
+
+  if (std::abs(theta - PI_2) < PARAMETER_TOLERANCE) {
+    theta = PI_2;
+    return parseU2(phi, lambda);
+  }
+  // parse a real u3 gate
+  checkInteger(phi);
+  checkFractionPi(phi);
+  checkInteger(theta);
+  checkFractionPi(theta);
+
+  return U3;
+}
+OpType SymbolicOperation::parseU3([[maybe_unused]] const Symbolic& theta,
+                                  [[maybe_unused]] const Symbolic& phi,
+                                  fp& lambda) {
+  // parse a real u3 gate
+  checkInteger(lambda);
+  checkFractionPi(lambda);
+
+  return U3;
+}
+OpType SymbolicOperation::parseU3([[maybe_unused]] const Symbolic& theta,
+                                  fp& phi,
+                                  [[maybe_unused]] const Symbolic& lambda) {
+  // parse a real u3 gate
+  checkInteger(phi);
+  checkFractionPi(phi);
+
+  return U3;
+}
+OpType SymbolicOperation::parseU3(fp& theta, const Symbolic& phi,
+                                  const Symbolic& lambda) {
+  if (std::abs(theta - PI_2) < PARAMETER_TOLERANCE) {
+    theta = PI_2;
+    return parseU2(phi, lambda);
+  }
+
+  // parse a real u3 gate
+
+  checkInteger(theta);
+  checkFractionPi(theta);
+
+  return U3;
+}
+
+OpType SymbolicOperation::parseU2([[maybe_unused]] const Symbolic& phi,
+                                  [[maybe_unused]] const Symbolic& lambda) {
+  return U2;
+}
+
+OpType SymbolicOperation::parseU2([[maybe_unused]] const Symbolic& phi,
+                                  fp& lambda) {
+  checkInteger(lambda);
+  checkFractionPi(lambda);
+
+  return U2;
+}
+OpType SymbolicOperation::parseU2(fp& phi,
+                                  [[maybe_unused]] const Symbolic& lambda) {
+  checkInteger(phi);
+  checkFractionPi(phi);
+
+  return U2;
+}
+
+OpType SymbolicOperation::parseU1([[maybe_unused]] const Symbolic& lambda) {
+  return Phase;
+}
+
+void SymbolicOperation::checkSymbolicUgate() {
+  // NOLINTBEGIN(bugprone-unchecked-optional-access) - we check for this
+  if (type == Phase) {
+    if (!isSymbolicParameter(0)) {
+      type = StandardOperation::parseU1(parameter[0]);
+    }
+  } else if (type == U2) {
+    if (!isSymbolicParameter(0) && !isSymbolicParameter(1)) {
+      type = StandardOperation::parseU2(parameter[0], parameter[1]);
+    } else if (isSymbolicParameter(0)) {
+      type = parseU2(symbolicParameter[0].value(), parameter[1]);
+    } else if (isSymbolicParameter(1)) {
+      type = parseU2(parameter[0], symbolicParameter[1].value());
+    }
+  } else if (type == U3) {
+    if (!isSymbolicParameter(0) && !isSymbolicParameter(1) &&
+        !isSymbolicParameter(2)) {
+      type =
+          StandardOperation::parseU3(parameter[0], parameter[1], parameter[2]);
+    } else if (!isSymbolicParameter(0) && !isSymbolicParameter(1)) {
+      type = parseU3(parameter[0], parameter[1], symbolicParameter[2].value());
+    } else if (!isSymbolicParameter(0) && !isSymbolicParameter(2)) {
+      type = parseU3(parameter[0], symbolicParameter[1].value(), parameter[2]);
+    } else if (!isSymbolicParameter(1) && !isSymbolicParameter(2)) {
+      type = parseU3(symbolicParameter[0].value(), parameter[1], parameter[2]);
+    } else if (!isSymbolicParameter(0)) {
+      type = parseU3(parameter[0], symbolicParameter[1].value(),
+                     symbolicParameter[2].value());
+    } else if (!isSymbolicParameter(1)) {
+      type = parseU3(symbolicParameter[0].value(), parameter[1],
+                     symbolicParameter[2].value());
+    } else if (!isSymbolicParameter(2)) {
+      type = parseU3(symbolicParameter[0].value(), symbolicParameter[1].value(),
+                     parameter[2]);
+    }
+  }
+  // NOLINTEND(bugprone-unchecked-optional-access)
+}
+
+void SymbolicOperation::setup(const std::size_t nq,
+                              const std::vector<SymbolOrNumber>& params,
+                              const Qubit startingQubit) {
+  nqubits = nq;
+  const auto numParams = params.size();
+  parameter.resize(numParams);
+  symbolicParameter.resize(numParams);
+  for (std::size_t i = 0; i < numParams; ++i) {
+    storeSymbolOrNumber(params[i], i);
+  }
+  startQubit = startingQubit;
+  checkSymbolicUgate();
+  setName();
+}
+
+[[nodiscard]] fp
+SymbolicOperation::getInstantiation(const SymbolOrNumber& symOrNum,
+                                    const VariableAssignment& assignment) {
+  return std::visit(
+      Overload{[&](const fp num) { return num; },
+               [&](const Symbolic& sym) { return sym.evaluate(assignment); }},
+      symOrNum);
+}
+
+SymbolicOperation::SymbolicOperation(const std::size_t nq, const Qubit target,
+                                     const OpType g,
+                                     const std::vector<SymbolOrNumber>& params,
+                                     const Qubit startingQubit) {
+  type = g;
+  setup(nq, params, startingQubit);
+  targets.emplace_back(target);
+}
+
+SymbolicOperation::SymbolicOperation(const std::size_t nq, const Targets& targ,
+                                     const OpType g,
+                                     const std::vector<SymbolOrNumber>& params,
+                                     const Qubit startingQubit) {
+  type = g;
+  setup(nq, params, startingQubit);
+  targets = targ;
+}
+
+SymbolicOperation::SymbolicOperation(const std::size_t nq,
+                                     const Control control, const Qubit target,
+                                     const OpType g,
+                                     const std::vector<SymbolOrNumber>& params,
+                                     const Qubit startingQubit)
+    : SymbolicOperation(nq, target, g, params, startingQubit) {
+  controls.insert(control);
+}
+
+SymbolicOperation::SymbolicOperation(const std::size_t nq,
+                                     const Control control, const Targets& targ,
+                                     const OpType g,
+                                     const std::vector<SymbolOrNumber>& params,
+                                     const Qubit startingQubit)
+    : SymbolicOperation(nq, targ, g, params, startingQubit) {
+  controls.insert(control);
+}
+
+SymbolicOperation::SymbolicOperation(const std::size_t nq, const Controls& c,
+                                     const Qubit target, const OpType g,
+                                     const std::vector<SymbolOrNumber>& params,
+                                     const Qubit startingQubit)
+    : SymbolicOperation(nq, target, g, params, startingQubit) {
+  controls = c;
+}
+
+SymbolicOperation::SymbolicOperation(const std::size_t nq, const Controls& c,
+                                     const Targets& targ, const OpType g,
+                                     const std::vector<SymbolOrNumber>& params,
+                                     const Qubit startingQubit)
+    : SymbolicOperation(nq, targ, g, params, startingQubit) {
+  controls = c;
+}
+
+// MCF (cSWAP), Peres, parameterized two target Constructor
+SymbolicOperation::SymbolicOperation(const std::size_t nq, const Controls& c,
+                                     const Qubit target0, const Qubit target1,
+                                     const OpType g,
+                                     const std::vector<SymbolOrNumber>& params,
+                                     const Qubit startingQubit)
+    : SymbolicOperation(nq, c, {target0, target1}, g, params, startingQubit) {}
+
+bool SymbolicOperation::equals(const Operation& op, const Permutation& perm1,
+                               const Permutation& perm2) const {
+  if (!op.isSymbolicOperation() && !isStandardOperation()) {
+    return false;
+  }
+  if (isStandardOperation() &&
+      qc::StandardOperation::equals(op, perm1, perm2)) {
+    return true;
+  }
+
+  if (!op.isSymbolicOperation()) {
+    return false;
+  }
+  const auto& symOp = dynamic_cast<const SymbolicOperation&>(op);
+  for (std::size_t i = 0; i < symbolicParameter.size(); ++i) {
+    const auto& symParam = symbolicParameter.at(i);
+    const auto& symOpParam = symOp.symbolicParameter.at(i);
+    const auto symParamIsSymbolic = symParam.has_value();
+    const auto symOpParamIsSymbolic = symOpParam.has_value();
+
+    if (symParamIsSymbolic != symOpParamIsSymbolic) {
+      return false;
+    }
+
+    if (symParamIsSymbolic) {
+      return symParam.value() == symOpParam.value();
+    }
+  }
+  return true;
+}
+
+[[noreturn]] void SymbolicOperation::dumpOpenQASM(
+    [[maybe_unused]] std::ostream& of,
+    [[maybe_unused]] const RegisterNames& qreg,
+    [[maybe_unused]] const RegisterNames& creg) const {
+  throw QFRException("OpenQasm2.0 doesn't support parametrized gates!");
+}
+
+StandardOperation SymbolicOperation::getInstantiatedOperation(
+    const VariableAssignment& assignment) const {
+  std::vector<fp> parameters;
+  const auto size = symbolicParameter.size();
+  parameters.reserve(size);
+  for (std::size_t i = 0; i < size; ++i) {
+    parameters.emplace_back(getInstantiation(getParameter(i), assignment));
+  }
+  return {nqubits, targets, type, parameters, startQubit};
+}
+
+// Instantiates this Operation
+// Afterwards casting to StandardOperation can be done if assignment is total
+void SymbolicOperation::instantiate(const VariableAssignment& assignment) {
+  for (std::size_t i = 0; i < symbolicParameter.size(); ++i) {
+    parameter.at(i) = getInstantiation(getParameter(i), assignment);
+    symbolicParameter.at(i).reset();
+  }
+  checkUgate();
+}
 } // namespace qc
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/src/parsers/GRCSParser.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/parsers/GRCSParser.cpp`

 * *Files 20% similar despite different names*

```diff
@@ -1,49 +1,44 @@
-/*
- * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
- */
-
 #include "QuantumComputation.hpp"
 
 void qc::QuantumComputation::importGRCS(std::istream& is) {
-    std::size_t nq{};
-    is >> nq;
-    addQubitRegister(nq);
-    addClassicalRegister(nq);
+  std::size_t nq{};
+  is >> nq;
+  addQubitRegister(nq);
+  addClassicalRegister(nq);
 
-    std::string line;
-    std::string identifier;
-    Qubit       control = 0;
-    Qubit       target  = 0;
-    std::size_t cycle   = 0;
-    while (std::getline(is, line)) {
-        if (line.empty()) {
-            continue;
-        }
-        std::stringstream ss(line);
-        ss >> cycle;
-        ss >> identifier;
-        if (identifier == "cz") {
-            ss >> control;
-            ss >> target;
-            z(target, qc::Control{control});
-        } else if (identifier == "is") {
-            ss >> control;
-            ss >> target;
-            iswap(control, target);
-        } else {
-            ss >> target;
-            if (identifier == "h") {
-                h(target);
-            } else if (identifier == "t") {
-                t(target);
-            } else if (identifier == "x_1_2") {
-                rx(target, qc::PI_2);
-            } else if (identifier == "y_1_2") {
-                ry(target, qc::PI_2);
-            } else {
-                throw QFRException("[grcs parser] unknown gate '" + identifier + "'");
-            }
-        }
+  std::string line;
+  std::string identifier;
+  Qubit control = 0;
+  Qubit target = 0;
+  std::size_t cycle = 0;
+  while (std::getline(is, line)) {
+    if (line.empty()) {
+      continue;
+    }
+    std::stringstream ss(line);
+    ss >> cycle;
+    ss >> identifier;
+    if (identifier == "cz") {
+      ss >> control;
+      ss >> target;
+      z(target, qc::Control{control});
+    } else if (identifier == "is") {
+      ss >> control;
+      ss >> target;
+      iswap(control, target);
+    } else {
+      ss >> target;
+      if (identifier == "h") {
+        h(target);
+      } else if (identifier == "t") {
+        t(target);
+      } else if (identifier == "x_1_2") {
+        rx(target, qc::PI_2);
+      } else if (identifier == "y_1_2") {
+        ry(target, qc::PI_2);
+      } else {
+        throw QFRException("[grcs parser] unknown gate '" + identifier + "'");
+      }
     }
+  }
 }
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/src/parsers/QASMParser.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/parsers/QASMParser.cpp`

 * *Files 22% similar despite different names*

```diff
@@ -1,143 +1,145 @@
-/*
- * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
- */
-
 #include "QuantumComputation.hpp"
 
 void qc::QuantumComputation::importOpenQASM(std::istream& is) {
-    using namespace qasm;
-    // initialize parser
-    Parser p(is, qregs, cregs);
+  using namespace qasm;
+  // initialize parser
+  Parser p(is, qregs, cregs);
 
+  p.scan();
+  while (p.sym == Token::Kind::Comment) {
     p.scan();
-    while (p.sym == Token::Kind::Comment) {
-        p.scan();
-        p.handleComment();
-    }
-    if (p.sym == Token::Kind::Openqasm) {
-        p.scan();
-        p.check(Token::Kind::Real);
-        p.check(Token::Kind::Semicolon);
-    }
+    p.handleComment();
+  }
+  if (p.sym == Token::Kind::Openqasm) {
+    p.scan();
+    p.check(Token::Kind::Real);
+    p.check(Token::Kind::Semicolon);
+  }
+
+  while (p.sym != Token::Kind::Eof) {
+    if (p.sym == Token::Kind::Qreg) {
+      // quantum register definition
+      p.scan();
+      p.check(Token::Kind::Identifier);
+      const std::string s = p.t.str;
+      p.check(Token::Kind::Lbrack);
+      p.check(Token::Kind::Nninteger);
+      const auto n = static_cast<std::size_t>(p.t.val);
+      p.check(Token::Kind::Rbrack);
+      p.check(Token::Kind::Semicolon);
+      addQubitRegister(n, s);
+      p.nqubits = nqubits;
+    } else if (p.sym == Token::Kind::Creg) {
+      // classical register definition
+      p.scan();
+      p.check(Token::Kind::Identifier);
+      const std::string s = p.t.str;
+      p.check(Token::Kind::Lbrack);
+      p.check(Token::Kind::Nninteger);
+      const auto n = static_cast<std::size_t>(p.t.val);
+      p.check(Token::Kind::Rbrack);
+      p.check(Token::Kind::Semicolon);
+      addClassicalRegister(n, s);
+      p.nclassics = nclassics;
+    } else if (p.sym == Token::Kind::Identifier ||
+               p.sym == Token::Kind::Measure || p.sym == Token::Kind::Reset ||
+               p.sym == Token::Kind::McxGray ||
+               p.sym == Token::Kind::McxRecursive ||
+               p.sym == Token::Kind::McxVchain ||
+               p.sym == Token::Kind::Mcphase) {
+      // gate application
+      ops.emplace_back(p.qop());
+    } else if (p.sym == Token::Kind::Gate) {
+      // gate definition
+      p.gateDecl();
+    } else if (p.sym == Token::Kind::Include) {
+      // include statement
+      p.scan();
+      p.check(Token::Kind::String);
+      p.scanner->addFileInput(p.t.str);
+      p.check(Token::Kind::Semicolon);
+    } else if (p.sym == Token::Kind::Barrier) {
+      // barrier statement
+      p.scan();
+      std::vector<qc::QuantumRegister> args;
+      p.argList(args);
+      p.check(Token::Kind::Semicolon);
+
+      std::vector<qc::Qubit> qubits{};
+      for (auto& arg : args) {
+        for (std::size_t q = 0; q < arg.second; ++q) {
+          qubits.emplace_back(arg.first + q);
+        }
+      }
 
-    do {
-        if (p.sym == Token::Kind::Qreg) {
-            // quantum register definition
-            p.scan();
-            p.check(Token::Kind::Identifier);
-            const std::string s = p.t.str;
-            p.check(Token::Kind::Lbrack);
-            p.check(Token::Kind::Nninteger);
-            const auto n = static_cast<std::size_t>(p.t.val);
-            p.check(Token::Kind::Rbrack);
-            p.check(Token::Kind::Semicolon);
-            addQubitRegister(n, s);
-            p.nqubits = nqubits;
-        } else if (p.sym == Token::Kind::Creg) {
-            // classical register definition
-            p.scan();
-            p.check(Token::Kind::Identifier);
-            const std::string s = p.t.str;
-            p.check(Token::Kind::Lbrack);
-            p.check(Token::Kind::Nninteger);
-            const auto n = static_cast<std::size_t>(p.t.val);
-            p.check(Token::Kind::Rbrack);
-            p.check(Token::Kind::Semicolon);
-            addClassicalRegister(n, s);
-            p.nclassics = nclassics;
-        } else if (p.sym == Token::Kind::Identifier || p.sym == Token::Kind::Measure || p.sym == Token::Kind::Reset || p.sym == Token::Kind::McxGray || p.sym == Token::Kind::McxRecursive || p.sym == Token::Kind::McxVchain || p.sym == Token::Kind::Mcphase) {
-            // gate application
-            ops.emplace_back(p.qop());
-        } else if (p.sym == Token::Kind::Gate) {
-            // gate definition
-            p.gateDecl();
-        } else if (p.sym == Token::Kind::Include) {
-            // include statement
-            p.scan();
-            p.check(Token::Kind::String);
-            p.scanner->addFileInput(p.t.str);
-            p.check(Token::Kind::Semicolon);
-        } else if (p.sym == Token::Kind::Barrier) {
-            // barrier statement
-            p.scan();
-            std::vector<qc::QuantumRegister> args;
-            p.argList(args);
-            p.check(Token::Kind::Semicolon);
-
-            std::vector<qc::Qubit> qubits{};
-            for (auto& arg: args) {
-                for (std::size_t q = 0; q < arg.second; ++q) {
-                    qubits.emplace_back(arg.first + q);
-                }
-            }
-
-            emplace_back<NonUnitaryOperation>(nqubits, qubits, Barrier);
-        } else if (p.sym == Token::Kind::Opaque) {
-            // opaque gate definition
-            p.opaqueGateDecl();
-        } else if (p.sym == Token::Kind::If) {
-            // classically-controlled operation
-            p.scan();
-            p.check(Token::Kind::Lpar);
-            p.check(Token::Kind::Identifier);
-            const std::string creg = p.t.str;
-            p.check(Token::Kind::Eq);
-            p.check(Token::Kind::Nninteger);
-            const auto n = static_cast<std::size_t>(p.t.val);
-            p.check(Token::Kind::Rpar);
-
-            auto it = p.cregs.find(creg);
-            if (it == p.cregs.end()) {
-                p.error("Error in if statement: " + creg + " is not a creg!");
-            } else {
-                emplace_back<ClassicControlledOperation>(p.qop(), it->second, n);
-            }
-        } else if (p.sym == Token::Kind::Snapshot) {
-            // snapshot statement
-            p.scan();
-            p.check(Token::Kind::Lpar);
-            p.check(Token::Kind::Nninteger);
-            auto n = static_cast<std::size_t>(p.t.val);
-            p.check(Token::Kind::Rpar);
-
-            std::vector<qc::QuantumRegister> arguments{};
-            p.argList(arguments);
-
-            p.check(Token::Kind::Semicolon);
-
-            for (auto& arg: arguments) {
-                if (arg.second != 1) {
-                    p.error("Error in snapshot: arguments must be qubits");
-                }
-            }
-
-            Targets qubits{};
-            qubits.reserve(arguments.size());
-            for (auto& arg: arguments) {
-                qubits.emplace_back(arg.first);
-            }
-
-            emplace_back<NonUnitaryOperation>(nqubits, qubits, n);
-        } else if (p.sym == Token::Kind::Probabilities) {
-            // show probabilities statement
-            emplace_back<NonUnitaryOperation>(nqubits);
-            p.scan();
-            p.check(Token::Kind::Semicolon);
-        } else if (p.sym == Token::Kind::Comment) {
-            // comment
-            p.scan();
-            p.handleComment();
-        } else {
-            p.error("Unexpected statement: started with " + KIND_NAMES.at(p.sym) + "!");
+      emplace_back<NonUnitaryOperation>(nqubits, qubits, Barrier);
+    } else if (p.sym == Token::Kind::Opaque) {
+      // opaque gate definition
+      p.opaqueGateDecl();
+    } else if (p.sym == Token::Kind::If) {
+      // classically-controlled operation
+      p.scan();
+      p.check(Token::Kind::Lpar);
+      p.check(Token::Kind::Identifier);
+      const std::string creg = p.t.str;
+      p.check(Token::Kind::Eq);
+      p.check(Token::Kind::Nninteger);
+      const auto n = static_cast<std::size_t>(p.t.val);
+      p.check(Token::Kind::Rpar);
+
+      auto it = p.cregs.find(creg);
+      if (it == p.cregs.end()) {
+        p.error("Error in if statement: " + creg + " is not a creg!");
+      } else {
+        emplace_back<ClassicControlledOperation>(p.qop(), it->second, n);
+      }
+    } else if (p.sym == Token::Kind::Snapshot) {
+      // snapshot statement
+      p.scan();
+      p.check(Token::Kind::Lpar);
+      p.check(Token::Kind::Nninteger);
+      auto n = static_cast<std::size_t>(p.t.val);
+      p.check(Token::Kind::Rpar);
+
+      std::vector<qc::QuantumRegister> arguments{};
+      p.argList(arguments);
+
+      p.check(Token::Kind::Semicolon);
+
+      for (auto& arg : arguments) {
+        if (arg.second != 1) {
+          p.error("Error in snapshot: arguments must be qubits");
         }
-    } while (p.sym != Token::Kind::Eof);
+      }
 
-    // if any I/O information was gathered during parsing, transfer it to the QuantumComputation
-    if (!p.initialLayout.empty()) {
-        initialLayout = std::move(p.initialLayout);
-    }
-    if (!p.outputPermutation.empty()) {
-        outputPermutation = std::move(p.outputPermutation);
+      Targets qubits{};
+      qubits.reserve(arguments.size());
+      for (auto& arg : arguments) {
+        qubits.emplace_back(arg.first);
+      }
+
+      emplace_back<NonUnitaryOperation>(nqubits, qubits, n);
+    } else if (p.sym == Token::Kind::Probabilities) {
+      // show probabilities statement
+      emplace_back<NonUnitaryOperation>(nqubits);
+      p.scan();
+      p.check(Token::Kind::Semicolon);
+    } else if (p.sym == Token::Kind::Comment) {
+      // comment
+      p.scan();
+      p.handleComment();
+    } else {
+      p.error("Unexpected statement: started with " + KIND_NAMES.at(p.sym) +
+              "!");
     }
+  }
+
+  // if any I/O information was gathered during parsing, transfer it to the
+  // QuantumComputation
+  if (!p.initialLayout.empty()) {
+    initialLayout = std::move(p.initialLayout);
+  }
+  if (!p.outputPermutation.empty()) {
+    outputPermutation = std::move(p.outputPermutation);
+  }
 }
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/src/parsers/QCParser.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/parsers/QCParser.cpp`

 * *Files 7% similar despite different names*

```diff
@@ -1,283 +1,308 @@
-/*
- * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
- */
-
 #include "QuantumComputation.hpp"
 
 void qc::QuantumComputation::importQC(std::istream& is) {
-    std::map<std::string, Qubit> varMap{};
-    auto                         line = readQCHeader(is, varMap);
-    readQCGateDescriptions(is, line, varMap);
+  std::map<std::string, Qubit> varMap{};
+  auto line = readQCHeader(is, varMap);
+  readQCGateDescriptions(is, line, varMap);
 }
 
-int qc::QuantumComputation::readQCHeader(std::istream& is, std::map<std::string, Qubit>& varMap) {
-    std::string cmd;
-    std::string variable;
-    std::string identifier;
-    int         line = 0;
-
-    const std::string delimiter = " ";
-    std::size_t       pos{};
-
-    std::vector<std::string> variables{};
-    std::vector<std::string> inputs{};
-    std::vector<std::string> outputs{};
-    std::vector<std::string> constants{};
-
-    while (true) {
-        if (!static_cast<bool>(is >> cmd)) {
-            throw QFRException("[qc parser] l:" + std::to_string(line) + " msg: Invalid file header");
-        }
-        ++line;
+int qc::QuantumComputation::readQCHeader(std::istream& is,
+                                         std::map<std::string, Qubit>& varMap) {
+  std::string cmd;
+  std::string variable;
+  std::string identifier;
+  int line = 0;
+
+  const std::string delimiter = " ";
+  std::size_t pos{};
+
+  std::vector<std::string> variables{};
+  std::vector<std::string> inputs{};
+  std::vector<std::string> outputs{};
+  std::vector<std::string> constants{};
+
+  while (true) {
+    if (!static_cast<bool>(is >> cmd)) {
+      throw QFRException("[qc parser] l:" + std::to_string(line) +
+                         " msg: Invalid file header");
+    }
+    ++line;
 
-        // skip comments
-        if (cmd.front() == '#') {
-            is.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
-            continue;
-        }
+    // skip comments
+    if (cmd.front() == '#') {
+      is.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
+      continue;
+    }
 
-        // valid header commands start with '.' or end the header with BEGIN
-        if (cmd.front() != '.' && cmd != "BEGIN" && cmd != "begin") {
-            throw QFRException("[qc parser] l:" + std::to_string(line) + " msg: Invalid file header");
-        }
+    // valid header commands start with '.' or end the header with BEGIN
+    if (cmd.front() != '.' && cmd != "BEGIN" && cmd != "begin") {
+      throw QFRException("[qc parser] l:" + std::to_string(line) +
+                         " msg: Invalid file header");
+    }
 
-        // header read complete
-        if (cmd == "BEGIN" || cmd == "begin") {
-            break;
-        }
+    // header read complete
+    if (cmd == "BEGIN" || cmd == "begin") {
+      break;
+    }
 
-        if (cmd == ".v") {
-            is >> std::ws;
-            std::getline(is, identifier);
-            while ((pos = identifier.find(delimiter)) != std::string::npos) {
-                variable = identifier.substr(0, pos);
-                variables.emplace_back(variable);
-                identifier.erase(0, pos + 1);
-            }
-            variables.emplace_back(identifier);
-        } else if (cmd == ".i") {
-            is >> std::ws;
-            std::getline(is, identifier);
-            while ((pos = identifier.find(delimiter)) != std::string::npos) {
-                variable = identifier.substr(0, pos);
-                if (std::find(variables.begin(), variables.end(), variable) != variables.end()) {
-                    inputs.emplace_back(variable);
-                } else {
-                    throw QFRException("[qc parser] l:" + std::to_string(line) + " msg: Unknown variable in input statement: " + cmd);
-                }
-                identifier.erase(0, pos + 1);
-            }
-            if (std::find(variables.begin(), variables.end(), identifier) != variables.end()) {
-                inputs.emplace_back(identifier);
-            } else {
-                throw QFRException("[qc parser] l:" + std::to_string(line) + " msg: Unknown variable in input statement: " + cmd);
-            }
-        } else if (cmd == ".o") {
-            is >> std::ws;
-            std::getline(is, identifier);
-            while ((pos = identifier.find(delimiter)) != std::string::npos) {
-                variable = identifier.substr(0, pos);
-                if (std::find(variables.begin(), variables.end(), variable) != variables.end()) {
-                    outputs.emplace_back(variable);
-                } else {
-                    throw QFRException("[qc parser] l:" + std::to_string(line) + " msg: Unknown variable in output statement: " + cmd);
-                }
-                identifier.erase(0, pos + 1);
-            }
-            if (std::find(variables.begin(), variables.end(), identifier) != variables.end()) {
-                outputs.emplace_back(identifier);
-            } else {
-                throw QFRException("[qc parser] l:" + std::to_string(line) + " msg: Unknown variable in output statement: " + cmd);
-            }
-        } else if (cmd == ".c") {
-            is >> std::ws;
-            std::getline(is, identifier);
-            while ((pos = identifier.find(delimiter)) != std::string::npos) {
-                variable = identifier.substr(0, pos);
-                constants.emplace_back(variable);
-                identifier.erase(0, pos + 1);
-            }
-            constants.emplace_back(identifier);
-        } else if (cmd == ".ol") { // ignore output labels
-            is.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
-            continue;
+    if (cmd == ".v") {
+      is >> std::ws;
+      std::getline(is, identifier);
+      while ((pos = identifier.find(delimiter)) != std::string::npos) {
+        variable = identifier.substr(0, pos);
+        variables.emplace_back(variable);
+        identifier.erase(0, pos + 1);
+      }
+      variables.emplace_back(identifier);
+    } else if (cmd == ".i") {
+      is >> std::ws;
+      std::getline(is, identifier);
+      while ((pos = identifier.find(delimiter)) != std::string::npos) {
+        variable = identifier.substr(0, pos);
+        if (std::find(variables.begin(), variables.end(), variable) !=
+            variables.end()) {
+          inputs.emplace_back(variable);
         } else {
-            throw QFRException("[qc parser] l:" + std::to_string(line) + " msg: Unknown command: " + cmd);
-        }
-    }
-    addQubitRegister(inputs.size());
-    auto nconstants = variables.size() - inputs.size();
-    if (nconstants > 0) {
-        addAncillaryRegister(nconstants);
+          throw QFRException(
+              "[qc parser] l:" + std::to_string(line) +
+              " msg: Unknown variable in input statement: " + cmd);
+        }
+        identifier.erase(0, pos + 1);
+      }
+      if (std::find(variables.begin(), variables.end(), identifier) !=
+          variables.end()) {
+        inputs.emplace_back(identifier);
+      } else {
+        throw QFRException("[qc parser] l:" + std::to_string(line) +
+                           " msg: Unknown variable in input statement: " + cmd);
+      }
+    } else if (cmd == ".o") {
+      is >> std::ws;
+      std::getline(is, identifier);
+      while ((pos = identifier.find(delimiter)) != std::string::npos) {
+        variable = identifier.substr(0, pos);
+        if (std::find(variables.begin(), variables.end(), variable) !=
+            variables.end()) {
+          outputs.emplace_back(variable);
+        } else {
+          throw QFRException(
+              "[qc parser] l:" + std::to_string(line) +
+              " msg: Unknown variable in output statement: " + cmd);
+        }
+        identifier.erase(0, pos + 1);
+      }
+      if (std::find(variables.begin(), variables.end(), identifier) !=
+          variables.end()) {
+        outputs.emplace_back(identifier);
+      } else {
+        throw QFRException(
+            "[qc parser] l:" + std::to_string(line) +
+            " msg: Unknown variable in output statement: " + cmd);
+      }
+    } else if (cmd == ".c") {
+      is >> std::ws;
+      std::getline(is, identifier);
+      while ((pos = identifier.find(delimiter)) != std::string::npos) {
+        variable = identifier.substr(0, pos);
+        constants.emplace_back(variable);
+        identifier.erase(0, pos + 1);
+      }
+      constants.emplace_back(identifier);
+    } else if (cmd == ".ol") { // ignore output labels
+      is.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
+      continue;
+    } else {
+      throw QFRException("[qc parser] l:" + std::to_string(line) +
+                         " msg: Unknown command: " + cmd);
     }
-
-    auto qidx     = 0;
-    auto constidx = inputs.size();
-    for (auto& var: variables) {
-        // check if variable is input
-        if (std::count(inputs.begin(), inputs.end(), var) != 0) {
-            varMap.insert({var, qidx++});
+  }
+  addQubitRegister(inputs.size());
+  auto nconstants = variables.size() - inputs.size();
+  if (nconstants > 0) {
+    addAncillaryRegister(nconstants);
+  }
+
+  auto qidx = 0;
+  auto constidx = inputs.size();
+  for (auto& var : variables) {
+    // check if variable is input
+    if (std::count(inputs.begin(), inputs.end(), var) != 0) {
+      varMap.insert({var, qidx++});
+    } else {
+      if (!constants.empty()) {
+        if (constants.at(constidx - inputs.size()) == "0" ||
+            constants.at(constidx - inputs.size()) == "1") {
+          // add X operation in case of initial value 1
+          if (constants.at(constidx - inputs.size()) == "1") {
+            emplace_back<StandardOperation>(nqubits + nancillae, constidx, X);
+          }
+          varMap.insert({var, constidx++});
         } else {
-            if (!constants.empty()) {
-                if (constants.at(constidx - inputs.size()) == "0" || constants.at(constidx - inputs.size()) == "1") {
-                    // add X operation in case of initial value 1
-                    if (constants.at(constidx - inputs.size()) == "1") {
-                        emplace_back<StandardOperation>(nqubits + nancillae, constidx, X);
-                    }
-                    varMap.insert({var, constidx++});
-                } else {
-                    throw QFRException("[qc parser] l:" + std::to_string(line) + " msg: Non-binary constant specified: " + cmd);
-                }
-            } else {
-                // variable does not occur in input statement --> assumed to be |0> ancillary
-                varMap.insert({var, constidx++});
-            }
+          throw QFRException("[qc parser] l:" + std::to_string(line) +
+                             " msg: Non-binary constant specified: " + cmd);
         }
+      } else {
+        // variable does not occur in input statement --> assumed to be |0>
+        // ancillary
+        varMap.insert({var, constidx++});
+      }
     }
+  }
 
-    for (std::size_t q = 0; q < variables.size(); ++q) {
-        variable                             = variables.at(q);
-        auto p                               = varMap.at(variable);
-        initialLayout[static_cast<Qubit>(q)] = p;
-        if (!outputs.empty()) {
-            if (std::count(outputs.begin(), outputs.end(), variable) != 0) {
-                outputPermutation[static_cast<Qubit>(q)] = p;
-            } else {
-                outputPermutation.erase(static_cast<Qubit>(q));
-                garbage.at(p) = true;
-            }
-        } else {
-            // no output statement given --> assume all outputs are relevant
-            outputPermutation[static_cast<Qubit>(q)] = p;
-        }
+  for (std::size_t q = 0; q < variables.size(); ++q) {
+    variable = variables.at(q);
+    auto p = varMap.at(variable);
+    initialLayout[static_cast<Qubit>(q)] = p;
+    if (!outputs.empty()) {
+      if (std::count(outputs.begin(), outputs.end(), variable) != 0) {
+        outputPermutation[static_cast<Qubit>(q)] = p;
+      } else {
+        outputPermutation.erase(static_cast<Qubit>(q));
+        garbage.at(p) = true;
+      }
+    } else {
+      // no output statement given --> assume all outputs are relevant
+      outputPermutation[static_cast<Qubit>(q)] = p;
     }
+  }
 
-    return line;
+  return line;
 }
 
-void qc::QuantumComputation::readQCGateDescriptions(std::istream& is, int line, std::map<std::string, Qubit>& varMap) {
-    const std::regex gateRegex = std::regex(R"((H|X|Y|Zd?|[SPT]\*?|tof|cnot|swap|R[xyz])(?:\((pi\/2\^(\d+)|(?:[-+]?[0-9]+[.]?[0-9]*(?:[eE][-+]?[0-9]+)?))\))?)");
-    std::smatch      m;
-    std::string      cmd;
-
-    while (!is.eof()) {
-        if (!static_cast<bool>(is >> cmd)) {
-            throw QFRException("[qc parser] l:" + std::to_string(line) + " msg: Failed to read command");
-        }
-        ++line;
-
-        if (cmd.front() == '#') {
-            is.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
-            continue;
-        }
+void qc::QuantumComputation::readQCGateDescriptions(
+    std::istream& is, int line, std::map<std::string, Qubit>& varMap) {
+  const std::regex gateRegex = std::regex(
+      R"((H|X|Y|Zd?|[SPT]\*?|tof|cnot|swap|R[xyz])(?:\((pi\/2\^(\d+)|(?:[-+]?[0-9]+[.]?[0-9]*(?:[eE][-+]?[0-9]+)?))\))?)");
+  std::smatch m;
+  std::string cmd;
+
+  while (!is.eof()) {
+    if (!static_cast<bool>(is >> cmd)) {
+      throw QFRException("[qc parser] l:" + std::to_string(line) +
+                         " msg: Failed to read command");
+    }
+    ++line;
 
-        if (cmd == "END" || cmd == "end") {
-            break;
-        }
+    if (cmd.front() == '#') {
+      is.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
+      continue;
+    }
 
-        // match gate declaration
-        if (!std::regex_match(cmd, m, gateRegex)) {
-            throw QFRException("[qc parser] l:" + std::to_string(line) + " msg: Unsupported gate detected: " + cmd);
-        }
+    if (cmd == "END" || cmd == "end") {
+      break;
+    }
 
-        // extract gate information (identifier, #controls, divisor)
-        auto              lambda   = static_cast<fp>(0L);
-        OpType            gate     = None;
-        const std::string gateType = m.str(1);
-        if (gateType == "H") {
-            gate = H;
-        } else if (gateType == "X" || gateType == "cnot" || gateType == "tof") {
-            gate = X;
-        } else if (gateType == "Y") {
-            gate = Y;
-        } else if (gateType == "Z" || gateType == "Zd") {
-            gate = Z;
-        } else if (gateType == "P" || gateType == "S") {
-            gate = S;
-        } else if (gateType == "P*" || gateType == "S*") {
-            gate = Sdag;
-        } else if (gateType == "T") {
-            gate = T;
-        } else if (gateType == "T*") {
-            gate = Tdag;
-        } else if (gateType == "swap") {
-            gate = SWAP;
-        } else if (gateType == "Rx") {
-            gate = RX;
-        } else if (gateType == "Ry") {
-            gate = RY;
-        } else if (gateType == "Rz") {
-            gate = RZ;
-        }
+    // match gate declaration
+    if (!std::regex_match(cmd, m, gateRegex)) {
+      throw QFRException("[qc parser] l:" + std::to_string(line) +
+                         " msg: Unsupported gate detected: " + cmd);
+    }
 
-        if (gate == RX || gate == RY || gate == RZ) {
-            if (m.str(3).empty()) {
-                // float definition
-                lambda = static_cast<fp>(std::stold(m.str(2)));
-            } else if (!m.str(2).empty()) {
-                // pi/2^x definition
-                auto power = std::stoul(m.str(3));
-                if (power == 0UL) {
-                    lambda = PI;
-                } else if (power == 1UL) {
-                    lambda = PI_2;
-                } else if (power == 2UL) {
-                    lambda = PI_4;
-                } else {
-                    lambda = PI_4 / (std::pow(static_cast<fp>(2), power - 2UL));
-                }
-            } else {
-                throw QFRException("Rotation gate without angle detected");
-            }
-        }
+    // extract gate information (identifier, #controls, divisor)
+    auto lambda = static_cast<fp>(0L);
+    OpType gate = None;
+    const std::string gateType = m.str(1);
+    if (gateType == "H") {
+      gate = H;
+    } else if (gateType == "X" || gateType == "cnot" || gateType == "tof") {
+      gate = X;
+    } else if (gateType == "Y") {
+      gate = Y;
+    } else if (gateType == "Z" || gateType == "Zd") {
+      gate = Z;
+    } else if (gateType == "P" || gateType == "S") {
+      gate = S;
+    } else if (gateType == "P*" || gateType == "S*") {
+      gate = Sdag;
+    } else if (gateType == "T") {
+      gate = T;
+    } else if (gateType == "T*") {
+      gate = Tdag;
+    } else if (gateType == "swap") {
+      gate = SWAP;
+    } else if (gateType == "Rx") {
+      gate = RX;
+    } else if (gateType == "Ry") {
+      gate = RY;
+    } else if (gateType == "Rz") {
+      gate = RZ;
+    }
 
-        std::string qubits;
-        std::string label;
-        is >> std::ws;
-        getline(is, qubits);
-
-        std::vector<Control> controls{};
-
-        auto        delimiter = ' ';
-        std::size_t pos{};
-
-        while ((pos = qubits.find(delimiter)) != std::string::npos) {
-            label = qubits.substr(0, pos);
-            if (label.back() == '\'') {
-                label.erase(label.size() - 1);
-                controls.emplace_back(Control{varMap.at(label), Control::Type::Neg});
-            } else {
-                controls.emplace_back(Control{varMap.at(label)});
-            }
-            qubits.erase(0, pos + 1);
+    if (gate == RX || gate == RY || gate == RZ) {
+      if (m.str(3).empty()) {
+        // float definition
+        lambda = static_cast<fp>(std::stold(m.str(2)));
+      } else if (!m.str(2).empty()) {
+        // pi/2^x definition
+        auto power = std::stoul(m.str(3));
+        if (power == 0UL) {
+          lambda = PI;
+        } else if (power == 1UL) {
+          lambda = PI_2;
+        } else if (power == 2UL) {
+          lambda = PI_4;
+        } else {
+          lambda = PI_4 / (std::pow(static_cast<fp>(2), power - 2UL));
         }
-        // delete whitespace at the end
-        qubits.erase(std::remove(qubits.begin(), qubits.end(), delimiter), qubits.end());
-        controls.emplace_back(Control{varMap.at(qubits)});
+      } else {
+        throw QFRException("Rotation gate without angle detected");
+      }
+    }
 
-        if (controls.size() > nqubits + nancillae) {
-            throw QFRException("[qc parser] l:" + std::to_string(line) + " msg: Gate acts on " + std::to_string(controls.size()) + " qubits, but only " + std::to_string(nqubits + nancillae) + " qubits are available.");
-        }
+    std::string qubits;
+    std::string label;
+    is >> std::ws;
+    getline(is, qubits);
+
+    std::vector<Control> controls{};
+
+    auto delimiter = ' ';
+    std::size_t pos{};
+
+    while ((pos = qubits.find(delimiter)) != std::string::npos) {
+      label = qubits.substr(0, pos);
+      if (label.back() == '\'') {
+        label.erase(label.size() - 1);
+        controls.emplace_back(Control{varMap.at(label), Control::Type::Neg});
+      } else {
+        controls.emplace_back(Control{varMap.at(label)});
+      }
+      qubits.erase(0, pos + 1);
+    }
+    // delete whitespace at the end
+    qubits.erase(std::remove(qubits.begin(), qubits.end(), delimiter),
+                 qubits.end());
+    controls.emplace_back(Control{varMap.at(qubits)});
+
+    if (controls.size() > nqubits + nancillae) {
+      throw QFRException(
+          "[qc parser] l:" + std::to_string(line) + " msg: Gate acts on " +
+          std::to_string(controls.size()) + " qubits, but only " +
+          std::to_string(nqubits + nancillae) + " qubits are available.");
+    }
 
-        if (gate == X) {
-            const Qubit target = controls.back().qubit;
-            controls.pop_back();
-            x(target, Controls{controls.cbegin(), controls.cend()});
-        } else if (gate == H || gate == Y || gate == Z || gate == S || gate == Sdag || gate == T || gate == Tdag) {
-            const Qubit target = controls.back().qubit;
-            controls.pop_back();
-            emplace_back<StandardOperation>(nqubits, Controls{controls.cbegin(), controls.cend()}, target, gate);
-        } else if (gate == SWAP) {
-            const Qubit target0 = controls.back().qubit;
-            controls.pop_back();
-            const Qubit target1 = controls.back().qubit;
-            controls.pop_back();
-            swap(target0, target1, Controls{controls.cbegin(), controls.cend()});
-        } else if (gate == RX || gate == RY || gate == RZ) {
-            const Qubit target = controls.back().qubit;
-            controls.pop_back();
-            emplace_back<StandardOperation>(nqubits, Controls{controls.cbegin(), controls.cend()}, target, gate, std::vector{lambda});
-        }
+    if (gate == X) {
+      const Qubit target = controls.back().qubit;
+      controls.pop_back();
+      x(target, Controls{controls.cbegin(), controls.cend()});
+    } else if (gate == H || gate == Y || gate == Z || gate == S ||
+               gate == Sdag || gate == T || gate == Tdag) {
+      const Qubit target = controls.back().qubit;
+      controls.pop_back();
+      emplace_back<StandardOperation>(
+          nqubits, Controls{controls.cbegin(), controls.cend()}, target, gate);
+    } else if (gate == SWAP) {
+      const Qubit target0 = controls.back().qubit;
+      controls.pop_back();
+      const Qubit target1 = controls.back().qubit;
+      controls.pop_back();
+      swap(target0, target1, Controls{controls.cbegin(), controls.cend()});
+    } else if (gate == RX || gate == RY || gate == RZ) {
+      const Qubit target = controls.back().qubit;
+      controls.pop_back();
+      emplace_back<StandardOperation>(
+          nqubits, Controls{controls.cbegin(), controls.cend()}, target, gate,
+          std::vector{lambda});
     }
+  }
 }
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/src/parsers/RealParser.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/parsers/RealParser.cpp`

 * *Files 8% similar despite different names*

```diff
@@ -1,245 +1,260 @@
-/*
- * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
- */
-
 #include "QuantumComputation.hpp"
 
 void qc::QuantumComputation::importReal(std::istream& is) {
-    auto line = readRealHeader(is);
-    readRealGateDescriptions(is, line);
+  auto line = readRealHeader(is);
+  readRealGateDescriptions(is, line);
 }
 
 int qc::QuantumComputation::readRealHeader(std::istream& is) {
-    std::string cmd;
-    std::string variable;
-    int         line = 0;
-
-    while (true) {
-        if (!static_cast<bool>(is >> cmd)) {
-            throw QFRException("[real parser] l:" + std::to_string(line) + " msg: Invalid file header");
-        }
-        std::transform(cmd.begin(), cmd.end(), cmd.begin(),
-                       [](unsigned char ch) { return toupper(ch); });
-        ++line;
-
-        // skip comments
-        if (cmd.front() == '#') {
-            is.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
-            continue;
-        }
+  std::string cmd;
+  std::string variable;
+  int line = 0;
+
+  while (true) {
+    if (!static_cast<bool>(is >> cmd)) {
+      throw QFRException("[real parser] l:" + std::to_string(line) +
+                         " msg: Invalid file header");
+    }
+    std::transform(cmd.begin(), cmd.end(), cmd.begin(),
+                   [](unsigned char ch) { return toupper(ch); });
+    ++line;
+
+    // skip comments
+    if (cmd.front() == '#') {
+      is.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
+      continue;
+    }
 
-        // valid header commands start with '.'
-        if (cmd.front() != '.') {
-            throw QFRException("[real parser] l:" + std::to_string(line) + " msg: Invalid file header");
-        }
+    // valid header commands start with '.'
+    if (cmd.front() != '.') {
+      throw QFRException("[real parser] l:" + std::to_string(line) +
+                         " msg: Invalid file header");
+    }
 
-        if (cmd == ".BEGIN") {
-            // header read complete
-            return line;
-        }
+    if (cmd == ".BEGIN") {
+      // header read complete
+      return line;
+    }
 
-        if (cmd == ".NUMVARS") {
-            std::size_t nq{};
-            if (!static_cast<bool>(is >> nq)) {
-                nqubits = 0;
-            } else {
-                nqubits = nq;
-            }
-            nclassics = nqubits;
-        } else if (cmd == ".VARIABLES") {
-            for (std::size_t i = 0; i < nqubits; ++i) {
-                if (!static_cast<bool>(is >> variable) || variable.at(0) == '.') {
-                    throw QFRException("[real parser] l:" + std::to_string(line) + " msg: Invalid or insufficient variables declared");
-                }
-
-                qregs.insert({variable, {i, 1}});
-                cregs.insert({"c_" + variable, {i, 1}});
-                initialLayout.insert({i, i});
-                outputPermutation.insert({i, i});
-                ancillary.resize(nqubits);
-                garbage.resize(nqubits);
-            }
-        } else if (cmd == ".CONSTANTS") {
-            is >> std::ws;
-            for (std::size_t i = 0; i < nqubits; ++i) {
-                const auto value = is.get();
-                if (!is.good()) {
-                    throw QFRException("[real parser] l:" + std::to_string(line) + " msg: Failed read in '.constants' line");
-                }
-                if (value == '1') {
-                    emplace_back<StandardOperation>(nqubits, i, X);
-                } else if (value != '-' && value != '0') {
-                    throw QFRException("[real parser] l:" + std::to_string(line) + " msg: Invalid value in '.constants' header: '" + std::to_string(value) + "'");
-                }
-            }
-            is.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
-        } else if (cmd == ".INPUTS" || cmd == ".OUTPUTS" || cmd == ".GARBAGE" || cmd == ".VERSION" || cmd == ".INPUTBUS" || cmd == ".OUTPUTBUS") {
-            // TODO .inputs: specifies initial layout (and ancillaries)
-            // TODO .outputs: specifies output permutation
-            // TODO .garbage: specifies garbage outputs
-            is.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
-            continue;
-        } else if (cmd == ".DEFINE") {
-            // TODO: Defines currently not supported
-            std::cerr << "[WARN] File contains 'define' statement, which is currently not supported and thus simply skipped." << std::endl;
-            while (cmd != ".ENDDEFINE") {
-                is.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
-                is >> cmd;
-                std::transform(cmd.begin(), cmd.end(), cmd.begin(), [](const unsigned char c) { return toupper(c); });
-            }
-        } else {
-            throw QFRException("[real parser] l:" + std::to_string(line) + " msg: Unknown command: " + cmd);
-        }
+    if (cmd == ".NUMVARS") {
+      std::size_t nq{};
+      if (!static_cast<bool>(is >> nq)) {
+        nqubits = 0;
+      } else {
+        nqubits = nq;
+      }
+      nclassics = nqubits;
+    } else if (cmd == ".VARIABLES") {
+      for (std::size_t i = 0; i < nqubits; ++i) {
+        if (!static_cast<bool>(is >> variable) || variable.at(0) == '.') {
+          throw QFRException(
+              "[real parser] l:" + std::to_string(line) +
+              " msg: Invalid or insufficient variables declared");
+        }
+
+        qregs.insert({variable, {i, 1}});
+        cregs.insert({"c_" + variable, {i, 1}});
+        initialLayout.insert({i, i});
+        outputPermutation.insert({i, i});
+        ancillary.resize(nqubits);
+        garbage.resize(nqubits);
+      }
+    } else if (cmd == ".CONSTANTS") {
+      is >> std::ws;
+      for (std::size_t i = 0; i < nqubits; ++i) {
+        const auto value = is.get();
+        if (!is.good()) {
+          throw QFRException("[real parser] l:" + std::to_string(line) +
+                             " msg: Failed read in '.constants' line");
+        }
+        if (value == '1') {
+          emplace_back<StandardOperation>(nqubits, i, X);
+        } else if (value != '-' && value != '0') {
+          throw QFRException("[real parser] l:" + std::to_string(line) +
+                             " msg: Invalid value in '.constants' header: '" +
+                             std::to_string(value) + "'");
+        }
+      }
+      is.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
+    } else if (cmd == ".INPUTS" || cmd == ".OUTPUTS" || cmd == ".GARBAGE" ||
+               cmd == ".VERSION" || cmd == ".INPUTBUS" || cmd == ".OUTPUTBUS") {
+      // TODO .inputs: specifies initial layout (and ancillaries)
+      // TODO .outputs: specifies output permutation
+      // TODO .garbage: specifies garbage outputs
+      is.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
+      continue;
+    } else if (cmd == ".DEFINE") {
+      // TODO: Defines currently not supported
+      std::cerr << "[WARN] File contains 'define' statement, which is "
+                   "currently not supported and thus simply skipped."
+                << std::endl;
+      while (cmd != ".ENDDEFINE") {
+        is.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
+        is >> cmd;
+        std::transform(cmd.begin(), cmd.end(), cmd.begin(),
+                       [](const unsigned char c) { return toupper(c); });
+      }
+    } else {
+      throw QFRException("[real parser] l:" + std::to_string(line) +
+                         " msg: Unknown command: " + cmd);
     }
+  }
 }
 
-void qc::QuantumComputation::readRealGateDescriptions(std::istream& is, int line) {
-    const std::regex gateRegex = std::regex("(r[xyz]|i[df]|q|[0a-z](?:[+ip])?)(\\d+)?(?::([-+]?[0-9]+[.]?[0-9]*(?:[eE][-+]?[0-9]+)?))?");
-    std::smatch      m;
-    std::string      cmd;
-
-    static const std::map<std::string, OpType> IDENTIFIER_MAP{
-            {"0", I},
-            {"id", I},
-            {"h", H},
-            {"n", X},
-            {"c", X},
-            {"x", X},
-            {"y", Y},
-            {"z", Z},
-            {"s", S},
-            {"si", Sdag},
-            {"sp", Sdag},
-            {"s+", Sdag},
-            {"v", V},
-            {"vi", Vdag},
-            {"vp", Vdag},
-            {"v+", Vdag},
-            {"rx", RX},
-            {"ry", RY},
-            {"rz", RZ},
-            {"f", SWAP},
-            {"if", SWAP},
-            {"p", Peres},
-            {"pi", Peresdag},
-            {"p+", Peresdag},
-            {"q", Phase}};
-
-    while (!is.eof()) {
-        if (!static_cast<bool>(is >> cmd)) {
-            throw QFRException("[real parser] l:" + std::to_string(line) + " msg: Failed to read command");
-        }
-        std::transform(cmd.begin(), cmd.end(), cmd.begin(), [](const unsigned char c) { return tolower(c); });
-        ++line;
-
-        if (cmd.front() == '#') {
-            is.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
-            continue;
-        }
-
-        if (cmd == ".end") {
-            break;
-        }
+void qc::QuantumComputation::readRealGateDescriptions(std::istream& is,
+                                                      int line) {
+  const std::regex gateRegex =
+      std::regex("(r[xyz]|i[df]|q|[0a-z](?:[+ip])?)(\\d+)?(?::([-+]?[0-9]+[.]?["
+                 "0-9]*(?:[eE][-+]?[0-9]+)?))?");
+  std::smatch m;
+  std::string cmd;
+
+  static const std::map<std::string, OpType> IDENTIFIER_MAP{
+      {"0", I},     {"id", I},    {"h", H},         {"n", X},
+      {"c", X},     {"x", X},     {"y", Y},         {"z", Z},
+      {"s", S},     {"si", Sdag}, {"sp", Sdag},     {"s+", Sdag},
+      {"v", V},     {"vi", Vdag}, {"vp", Vdag},     {"v+", Vdag},
+      {"rx", RX},   {"ry", RY},   {"rz", RZ},       {"f", SWAP},
+      {"if", SWAP}, {"p", Peres}, {"pi", Peresdag}, {"p+", Peresdag},
+      {"q", Phase}};
+
+  while (!is.eof()) {
+    if (!static_cast<bool>(is >> cmd)) {
+      throw QFRException("[real parser] l:" + std::to_string(line) +
+                         " msg: Failed to read command");
+    }
+    std::transform(cmd.begin(), cmd.end(), cmd.begin(),
+                   [](const unsigned char c) { return tolower(c); });
+    ++line;
+
+    if (cmd.front() == '#') {
+      is.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
+      continue;
+    }
 
-        // match gate declaration
-        if (!std::regex_match(cmd, m, gateRegex)) {
-            throw QFRException("[real parser] l:" + std::to_string(line) + " msg: Unsupported gate detected: " + cmd);
-        }
+    if (cmd == ".end") {
+      break;
+    }
 
-        // extract gate information (identifier, #controls, divisor)
-        OpType gate{};
-        if (m.str(1) == "t") { // special treatment of t(offoli) for real format
-            gate = X;
-        } else {
-            auto it = IDENTIFIER_MAP.find(m.str(1));
-            if (it == IDENTIFIER_MAP.end()) {
-                throw QFRException("[real parser] l:" + std::to_string(line) + " msg: Unknown gate identifier: " + m.str(1));
-            }
-            gate = (*it).second;
-        }
-        auto     ncontrols = m.str(2).empty() ? 0 : std::stoul(m.str(2), nullptr, 0) - 1;
-        const fp lambda    = m.str(3).empty() ? static_cast<fp>(0L) : static_cast<fp>(std::stold(m.str(3)));
+    // match gate declaration
+    if (!std::regex_match(cmd, m, gateRegex)) {
+      throw QFRException("[real parser] l:" + std::to_string(line) +
+                         " msg: Unsupported gate detected: " + cmd);
+    }
 
-        if (gate == V || gate == Vdag || m.str(1) == "c" || gate == SWAP) {
-            ncontrols = 1;
-        } else if (gate == Peres || gate == Peresdag) {
-            ncontrols = 2;
-        }
+    // extract gate information (identifier, #controls, divisor)
+    OpType gate{};
+    if (m.str(1) == "t") { // special treatment of t(offoli) for real format
+      gate = X;
+    } else {
+      auto it = IDENTIFIER_MAP.find(m.str(1));
+      if (it == IDENTIFIER_MAP.end()) {
+        throw QFRException("[real parser] l:" + std::to_string(line) +
+                           " msg: Unknown gate identifier: " + m.str(1));
+      }
+      gate = (*it).second;
+    }
+    auto ncontrols =
+        m.str(2).empty() ? 0 : std::stoul(m.str(2), nullptr, 0) - 1;
+    const fp lambda = m.str(3).empty() ? static_cast<fp>(0L)
+                                       : static_cast<fp>(std::stold(m.str(3)));
+
+    if (gate == V || gate == Vdag || m.str(1) == "c" || gate == SWAP) {
+      ncontrols = 1;
+    } else if (gate == Peres || gate == Peresdag) {
+      ncontrols = 2;
+    }
 
-        if (ncontrols >= nqubits) {
-            throw QFRException("[real parser] l:" + std::to_string(line) + " msg: Gate acts on " + std::to_string(ncontrols + 1) + " qubits, but only " + std::to_string(nqubits) + " qubits are available.");
-        }
+    if (ncontrols >= nqubits) {
+      throw QFRException("[real parser] l:" + std::to_string(line) +
+                         " msg: Gate acts on " + std::to_string(ncontrols + 1) +
+                         " qubits, but only " + std::to_string(nqubits) +
+                         " qubits are available.");
+    }
 
-        std::string qubits;
-        std::string label;
-        getline(is, qubits);
-
-        std::vector<Control> controls{};
-        std::istringstream   iss(qubits);
-
-        // get controls and target
-        for (std::size_t i = 0; i < ncontrols; ++i) {
-            if (!(iss >> label)) {
-                throw QFRException("[real parser] l:" + std::to_string(line) + " msg: Too few variables for gate " + m.str(1));
-            }
-
-            const bool negativeControl = (label.at(0) == '-');
-            if (negativeControl) {
-                label.erase(label.begin());
-            }
-
-            auto iter = qregs.find(label);
-            if (iter == qregs.end()) {
-                throw QFRException("[real parser] l:" + std::to_string(line) + " msg: Label " + label + " not found!");
-            }
-            controls.emplace_back(Control{iter->second.first, negativeControl ? Control::Type::Neg : Control::Type::Pos});
-        }
+    std::string qubits;
+    std::string label;
+    getline(is, qubits);
+
+    std::vector<Control> controls{};
+    std::istringstream iss(qubits);
+
+    // get controls and target
+    for (std::size_t i = 0; i < ncontrols; ++i) {
+      if (!(iss >> label)) {
+        throw QFRException("[real parser] l:" + std::to_string(line) +
+                           " msg: Too few variables for gate " + m.str(1));
+      }
+
+      const bool negativeControl = (label.at(0) == '-');
+      if (negativeControl) {
+        label.erase(label.begin());
+      }
+
+      auto iter = qregs.find(label);
+      if (iter == qregs.end()) {
+        throw QFRException("[real parser] l:" + std::to_string(line) +
+                           " msg: Label " + label + " not found!");
+      }
+      controls.emplace_back(
+          Control{iter->second.first,
+                  negativeControl ? Control::Type::Neg : Control::Type::Pos});
+    }
 
-        if (!(iss >> label)) {
-            throw QFRException("[real parser] l:" + std::to_string(line) + " msg: Too few variables (no target) for gate " + m.str(1));
-        }
-        auto iter = qregs.find(label);
-        if (iter == qregs.end()) {
-            throw QFRException("[real parser] l:" + std::to_string(line) + " msg: Label " + label + " not found!");
-        }
+    if (!(iss >> label)) {
+      throw QFRException("[real parser] l:" + std::to_string(line) +
+                         " msg: Too few variables (no target) for gate " +
+                         m.str(1));
+    }
+    auto iter = qregs.find(label);
+    if (iter == qregs.end()) {
+      throw QFRException("[real parser] l:" + std::to_string(line) +
+                         " msg: Label " + label + " not found!");
+    }
 
-        updateMaxControls(ncontrols);
-        const Qubit target = iter->second.first;
-        switch (gate) {
-            case I:
-            case H:
-            case Y:
-            case Z:
-            case S:
-            case Sdag:
-            case T:
-            case Tdag:
-            case V:
-            case Vdag:
-                emplace_back<StandardOperation>(nqubits, Controls{controls.cbegin(), controls.cend()}, target, gate);
-                break;
-            case X:
-                emplace_back<StandardOperation>(nqubits, Controls{controls.cbegin(), controls.cend()}, target);
-                break;
-            case RX:
-            case RY:
-            case RZ:
-            case Phase:
-                emplace_back<StandardOperation>(nqubits, Controls{controls.cbegin(), controls.cend()}, target, gate, std::vector{PI / (lambda)});
-                break;
-            case SWAP:
-            case Peres:
-            case Peresdag:
-            case iSWAP: {
-                const auto target1 = controls.back().qubit;
-                controls.pop_back();
-                emplace_back<StandardOperation>(nqubits, Controls{controls.cbegin(), controls.cend()}, target1, target, gate);
-                break;
-            }
-            default:
-                std::cerr << "Unsupported operation encountered:  " << gate << "!" << std::endl;
-                break;
-        }
+    updateMaxControls(ncontrols);
+    const Qubit target = iter->second.first;
+    switch (gate) {
+    case I:
+    case H:
+    case Y:
+    case Z:
+    case S:
+    case Sdag:
+    case T:
+    case Tdag:
+    case V:
+    case Vdag:
+      emplace_back<StandardOperation>(
+          nqubits, Controls{controls.cbegin(), controls.cend()}, target, gate);
+      break;
+    case X:
+      emplace_back<StandardOperation>(
+          nqubits, Controls{controls.cbegin(), controls.cend()}, target);
+      break;
+    case RX:
+    case RY:
+    case RZ:
+    case Phase:
+      emplace_back<StandardOperation>(
+          nqubits, Controls{controls.cbegin(), controls.cend()}, target, gate,
+          std::vector{PI / (lambda)});
+      break;
+    case SWAP:
+    case Peres:
+    case Peresdag:
+    case iSWAP: {
+      const auto target1 = controls.back().qubit;
+      controls.pop_back();
+      emplace_back<StandardOperation>(
+          nqubits, Controls{controls.cbegin(), controls.cend()}, target1,
+          target, gate);
+      break;
+    }
+    default:
+      std::cerr << "Unsupported operation encountered:  " << gate << "!"
+                << std::endl;
+      break;
     }
+  }
 }
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/src/parsers/TFCParser.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/parsers/TFCParser.cpp`

 * *Files 6% similar despite different names*

```diff
@@ -1,230 +1,250 @@
-/*
- * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
- */
-
 #include "QuantumComputation.hpp"
 
 void qc::QuantumComputation::importTFC(std::istream& is) {
-    std::map<std::string, Qubit> varMap{};
-    auto                         line = readTFCHeader(is, varMap);
-    readTFCGateDescriptions(is, line, varMap);
+  std::map<std::string, Qubit> varMap{};
+  auto line = readTFCHeader(is, varMap);
+  readTFCGateDescriptions(is, line, varMap);
 }
 
-int qc::QuantumComputation::readTFCHeader(std::istream& is, std::map<std::string, Qubit>& varMap) {
-    std::string cmd;
-    std::string variable;
-    std::string identifier;
-    int         line = 0;
-
-    const std::string delimiter = ",";
-    size_t            pos{};
-
-    std::vector<std::string> variables{};
-    std::vector<std::string> inputs{};
-    std::vector<std::string> outputs{};
-    std::vector<std::string> constants{};
-
-    while (true) {
-        if (!static_cast<bool>(is >> cmd)) {
-            throw QFRException("[tfc parser] l:" + std::to_string(line) + " msg: Invalid file header");
-        }
-        ++line;
+int qc::QuantumComputation::readTFCHeader(
+    std::istream& is, std::map<std::string, Qubit>& varMap) {
+  std::string cmd;
+  std::string variable;
+  std::string identifier;
+  int line = 0;
+
+  const std::string delimiter = ",";
+  size_t pos{};
+
+  std::vector<std::string> variables{};
+  std::vector<std::string> inputs{};
+  std::vector<std::string> outputs{};
+  std::vector<std::string> constants{};
+
+  while (true) {
+    if (!static_cast<bool>(is >> cmd)) {
+      throw QFRException("[tfc parser] l:" + std::to_string(line) +
+                         " msg: Invalid file header");
+    }
+    ++line;
 
-        // skip comments
-        if (cmd.front() == '#') {
-            is.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
-            continue;
-        }
+    // skip comments
+    if (cmd.front() == '#') {
+      is.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
+      continue;
+    }
 
-        // valid header commands start with '.' or end the header with BEGIN
-        if (cmd.front() != '.' && cmd != "BEGIN" && cmd != "begin") {
-            throw QFRException("[tfc parser] l:" + std::to_string(line) + " msg: Invalid file header");
-        }
+    // valid header commands start with '.' or end the header with BEGIN
+    if (cmd.front() != '.' && cmd != "BEGIN" && cmd != "begin") {
+      throw QFRException("[tfc parser] l:" + std::to_string(line) +
+                         " msg: Invalid file header");
+    }
 
-        // header read complete
-        if (cmd == "BEGIN" || cmd == "begin") {
-            break;
-        }
+    // header read complete
+    if (cmd == "BEGIN" || cmd == "begin") {
+      break;
+    }
 
-        if (cmd == ".v") {
-            is >> std::ws;
-            std::getline(is, identifier);
-            while ((pos = identifier.find(delimiter)) != std::string::npos) {
-                variable = identifier.substr(0, pos);
-                variables.emplace_back(variable);
-                identifier.erase(0, pos + 1);
-            }
-            variables.emplace_back(identifier);
-        } else if (cmd == ".i") {
-            is >> std::ws;
-            std::getline(is, identifier);
-            while ((pos = identifier.find(delimiter)) != std::string::npos) {
-                variable = identifier.substr(0, pos);
-                if (std::find(variables.begin(), variables.end(), variable) != variables.end()) {
-                    inputs.emplace_back(variable);
-                } else {
-                    throw QFRException("[tfc parser] l:" + std::to_string(line) + " msg: Unknown variable in input statement: " + cmd);
-                }
-                identifier.erase(0, pos + 1);
-            }
-            if (std::find(variables.begin(), variables.end(), identifier) != variables.end()) {
-                inputs.emplace_back(identifier);
-            } else {
-                throw QFRException("[tfc parser] l:" + std::to_string(line) + " msg: Unknown variable in input statement: " + cmd);
-            }
-        } else if (cmd == ".o") {
-            is >> std::ws;
-            std::getline(is, identifier);
-            while ((pos = identifier.find(delimiter)) != std::string::npos) {
-                variable = identifier.substr(0, pos);
-                if (std::find(variables.begin(), variables.end(), variable) != variables.end()) {
-                    outputs.emplace_back(variable);
-                } else {
-                    throw QFRException("[tfc parser] l:" + std::to_string(line) + " msg: Unknown variable in output statement: " + cmd);
-                }
-                identifier.erase(0, pos + 1);
-            }
-            if (std::find(variables.begin(), variables.end(), identifier) != variables.end()) {
-                outputs.emplace_back(identifier);
-            } else {
-                throw QFRException("[tfc parser] l:" + std::to_string(line) + " msg: Unknown variable in output statement: " + cmd);
-            }
-        } else if (cmd == ".c") {
-            is >> std::ws;
-            std::getline(is, identifier);
-            while ((pos = identifier.find(delimiter)) != std::string::npos) {
-                variable = identifier.substr(0, pos);
-                constants.emplace_back(variable);
-                identifier.erase(0, pos + 1);
-            }
-            constants.emplace_back(identifier);
-        } else if (cmd == ".ol") { // ignore output labels
-            is.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
-            continue;
+    if (cmd == ".v") {
+      is >> std::ws;
+      std::getline(is, identifier);
+      while ((pos = identifier.find(delimiter)) != std::string::npos) {
+        variable = identifier.substr(0, pos);
+        variables.emplace_back(variable);
+        identifier.erase(0, pos + 1);
+      }
+      variables.emplace_back(identifier);
+    } else if (cmd == ".i") {
+      is >> std::ws;
+      std::getline(is, identifier);
+      while ((pos = identifier.find(delimiter)) != std::string::npos) {
+        variable = identifier.substr(0, pos);
+        if (std::find(variables.begin(), variables.end(), variable) !=
+            variables.end()) {
+          inputs.emplace_back(variable);
         } else {
-            throw QFRException("[tfc parser] l:" + std::to_string(line) + " msg: Unknown command: " + cmd);
-        }
-    }
-    addQubitRegister(inputs.size());
-    auto nconstants = variables.size() - inputs.size();
-    if (nconstants > 0) {
-        addAncillaryRegister(nconstants);
+          throw QFRException(
+              "[tfc parser] l:" + std::to_string(line) +
+              " msg: Unknown variable in input statement: " + cmd);
+        }
+        identifier.erase(0, pos + 1);
+      }
+      if (std::find(variables.begin(), variables.end(), identifier) !=
+          variables.end()) {
+        inputs.emplace_back(identifier);
+      } else {
+        throw QFRException("[tfc parser] l:" + std::to_string(line) +
+                           " msg: Unknown variable in input statement: " + cmd);
+      }
+    } else if (cmd == ".o") {
+      is >> std::ws;
+      std::getline(is, identifier);
+      while ((pos = identifier.find(delimiter)) != std::string::npos) {
+        variable = identifier.substr(0, pos);
+        if (std::find(variables.begin(), variables.end(), variable) !=
+            variables.end()) {
+          outputs.emplace_back(variable);
+        } else {
+          throw QFRException(
+              "[tfc parser] l:" + std::to_string(line) +
+              " msg: Unknown variable in output statement: " + cmd);
+        }
+        identifier.erase(0, pos + 1);
+      }
+      if (std::find(variables.begin(), variables.end(), identifier) !=
+          variables.end()) {
+        outputs.emplace_back(identifier);
+      } else {
+        throw QFRException(
+            "[tfc parser] l:" + std::to_string(line) +
+            " msg: Unknown variable in output statement: " + cmd);
+      }
+    } else if (cmd == ".c") {
+      is >> std::ws;
+      std::getline(is, identifier);
+      while ((pos = identifier.find(delimiter)) != std::string::npos) {
+        variable = identifier.substr(0, pos);
+        constants.emplace_back(variable);
+        identifier.erase(0, pos + 1);
+      }
+      constants.emplace_back(identifier);
+    } else if (cmd == ".ol") { // ignore output labels
+      is.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
+      continue;
+    } else {
+      throw QFRException("[tfc parser] l:" + std::to_string(line) +
+                         " msg: Unknown command: " + cmd);
     }
-
-    auto qidx     = 0;
-    auto constidx = inputs.size();
-    for (auto& var: variables) {
-        // check if variable is input
-        if (std::count(inputs.begin(), inputs.end(), var) != 0) {
-            varMap.insert({var, qidx++});
+  }
+  addQubitRegister(inputs.size());
+  auto nconstants = variables.size() - inputs.size();
+  if (nconstants > 0) {
+    addAncillaryRegister(nconstants);
+  }
+
+  auto qidx = 0;
+  auto constidx = inputs.size();
+  for (auto& var : variables) {
+    // check if variable is input
+    if (std::count(inputs.begin(), inputs.end(), var) != 0) {
+      varMap.insert({var, qidx++});
+    } else {
+      if (!constants.empty()) {
+        if (constants.at(constidx - inputs.size()) == "0" ||
+            constants.at(constidx - inputs.size()) == "1") {
+          // add X operation in case of initial value 1
+          if (constants.at(constidx - inputs.size()) == "1") {
+            x(static_cast<Qubit>(constidx));
+          }
+          varMap.insert({var, constidx++});
         } else {
-            if (!constants.empty()) {
-                if (constants.at(constidx - inputs.size()) == "0" || constants.at(constidx - inputs.size()) == "1") {
-                    // add X operation in case of initial value 1
-                    if (constants.at(constidx - inputs.size()) == "1") {
-                        x(static_cast<Qubit>(constidx));
-                    }
-                    varMap.insert({var, constidx++});
-                } else {
-                    throw QFRException("[tfc parser] l:" + std::to_string(line) + " msg: Non-binary constant specified: " + cmd);
-                }
-            } else {
-                // variable does not occur in input statement --> assumed to be |0> ancillary
-                varMap.insert({var, constidx++});
-            }
+          throw QFRException("[tfc parser] l:" + std::to_string(line) +
+                             " msg: Non-binary constant specified: " + cmd);
         }
+      } else {
+        // variable does not occur in input statement --> assumed to be |0>
+        // ancillary
+        varMap.insert({var, constidx++});
+      }
     }
+  }
 
-    for (size_t q = 0; q < variables.size(); ++q) {
-        variable                             = variables.at(q);
-        auto p                               = varMap.at(variable);
-        initialLayout[static_cast<Qubit>(q)] = p;
-        if (!outputs.empty()) {
-            if (std::count(outputs.begin(), outputs.end(), variable) != 0) {
-                outputPermutation[static_cast<Qubit>(q)] = p;
-            } else {
-                outputPermutation.erase(static_cast<Qubit>(q));
-                garbage.at(p) = true;
-            }
-        } else {
-            // no output statement given --> assume all outputs are relevant
-            outputPermutation[static_cast<Qubit>(q)] = p;
-        }
+  for (size_t q = 0; q < variables.size(); ++q) {
+    variable = variables.at(q);
+    auto p = varMap.at(variable);
+    initialLayout[static_cast<Qubit>(q)] = p;
+    if (!outputs.empty()) {
+      if (std::count(outputs.begin(), outputs.end(), variable) != 0) {
+        outputPermutation[static_cast<Qubit>(q)] = p;
+      } else {
+        outputPermutation.erase(static_cast<Qubit>(q));
+        garbage.at(p) = true;
+      }
+    } else {
+      // no output statement given --> assume all outputs are relevant
+      outputPermutation[static_cast<Qubit>(q)] = p;
     }
+  }
 
-    return line;
+  return line;
 }
 
-void qc::QuantumComputation::readTFCGateDescriptions(std::istream& is, int line, std::map<std::string, Qubit>& varMap) {
-    const std::regex gateRegex = std::regex("([tTfF])(\\d+)");
-    std::smatch      m;
-    std::string      cmd;
-
-    while (!is.eof()) {
-        if (!static_cast<bool>(is >> cmd)) {
-            throw QFRException("[tfc parser] l:" + std::to_string(line) + " msg: Failed to read command");
-        }
-        ++line;
+void qc::QuantumComputation::readTFCGateDescriptions(
+    std::istream& is, int line, std::map<std::string, Qubit>& varMap) {
+  const std::regex gateRegex = std::regex("([tTfF])(\\d+)");
+  std::smatch m;
+  std::string cmd;
+
+  while (!is.eof()) {
+    if (!static_cast<bool>(is >> cmd)) {
+      throw QFRException("[tfc parser] l:" + std::to_string(line) +
+                         " msg: Failed to read command");
+    }
+    ++line;
 
-        if (cmd.front() == '#') {
-            is.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
-            continue;
-        }
+    if (cmd.front() == '#') {
+      is.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
+      continue;
+    }
 
-        if (cmd == "END" || cmd == "end") {
-            break;
-        }
+    if (cmd == "END" || cmd == "end") {
+      break;
+    }
 
-        // match gate declaration
-        if (!std::regex_match(cmd, m, gateRegex)) {
-            throw QFRException("[tfc parser] l:" + std::to_string(line) + " msg: Unsupported gate detected: " + cmd);
-        }
+    // match gate declaration
+    if (!std::regex_match(cmd, m, gateRegex)) {
+      throw QFRException("[tfc parser] l:" + std::to_string(line) +
+                         " msg: Unsupported gate detected: " + cmd);
+    }
 
-        // extract gate information (identifier, #controls, divisor)
-        OpType gate = SWAP;
-        // special treatment of t(offoli) for real format
-        if (m.str(1) == "t" || m.str(1) == "T") {
-            gate = X;
-        }
-        const std::size_t ncontrols = m.str(2).empty() ? 0 : std::stoul(m.str(2), nullptr, 0) - 1;
+    // extract gate information (identifier, #controls, divisor)
+    OpType gate = SWAP;
+    // special treatment of t(offoli) for real format
+    if (m.str(1) == "t" || m.str(1) == "T") {
+      gate = X;
+    }
+    const std::size_t ncontrols =
+        m.str(2).empty() ? 0 : std::stoul(m.str(2), nullptr, 0) - 1;
 
-        if (ncontrols >= nqubits + nancillae) {
-            throw QFRException("[tfc parser] l:" + std::to_string(line) + " msg: Gate acts on " + std::to_string(ncontrols + 1) + " qubits, but only " + std::to_string(nqubits + nancillae) + " qubits are available.");
-        }
+    if (ncontrols >= nqubits + nancillae) {
+      throw QFRException(
+          "[tfc parser] l:" + std::to_string(line) + " msg: Gate acts on " +
+          std::to_string(ncontrols + 1) + " qubits, but only " +
+          std::to_string(nqubits + nancillae) + " qubits are available.");
+    }
 
-        std::string qubits;
-        std::string label;
-        is >> std::ws;
-        getline(is, qubits);
-
-        std::vector<Control> controls{};
-
-        const std::string delimiter = ",";
-        size_t            pos{};
-
-        while ((pos = qubits.find(delimiter)) != std::string::npos) {
-            label = qubits.substr(0, pos);
-            if (label.back() == '\'') {
-                label.erase(label.size() - 1);
-                controls.emplace_back(Control{varMap.at(label), Control::Type::Neg});
-            } else {
-                controls.emplace_back(Control{varMap.at(label)});
-            }
-            qubits.erase(0, pos + 1);
-        }
-        controls.emplace_back(Control{varMap.at(qubits)});
+    std::string qubits;
+    std::string label;
+    is >> std::ws;
+    getline(is, qubits);
 
-        if (gate == X) {
-            const Qubit target = controls.back().qubit;
-            controls.pop_back();
-            x(target, Controls{controls.cbegin(), controls.cend()});
-        } else {
-            const Qubit target0 = controls.back().qubit;
-            controls.pop_back();
-            const Qubit target1 = controls.back().qubit;
-            controls.pop_back();
-            swap(target0, target1, Controls{controls.cbegin(), controls.cend()});
-        }
+    std::vector<Control> controls{};
+
+    const std::string delimiter = ",";
+    size_t pos{};
+
+    while ((pos = qubits.find(delimiter)) != std::string::npos) {
+      label = qubits.substr(0, pos);
+      if (label.back() == '\'') {
+        label.erase(label.size() - 1);
+        controls.emplace_back(Control{varMap.at(label), Control::Type::Neg});
+      } else {
+        controls.emplace_back(Control{varMap.at(label)});
+      }
+      qubits.erase(0, pos + 1);
+    }
+    controls.emplace_back(Control{varMap.at(qubits)});
+
+    if (gate == X) {
+      const Qubit target = controls.back().qubit;
+      controls.pop_back();
+      x(target, Controls{controls.cbegin(), controls.cend()});
+    } else {
+      const Qubit target0 = controls.back().qubit;
+      controls.pop_back();
+      const Qubit target1 = controls.back().qubit;
+      controls.pop_back();
+      swap(target0, target1, Controls{controls.cbegin(), controls.cend()});
     }
+  }
 }
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/src/parsers/qasm_parser/Parser.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/parsers/qasm_parser/Parser.cpp`

 * *Files 26% similar despite different names*

```diff
@@ -1,930 +1,973 @@
-/*
- * This file is part of MQT QFR library which is released under the MIT license.
- * See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
- */
-
 #include "parsers/qasm_parser/Parser.hpp"
 
 #include "Definitions.hpp"
 #include "operations/Control.hpp"
 
 #include <memory>
 #include <vector>
 
 namespace qasm {
 
-    /***
-     * Private Methods
-     ***/
-    std::shared_ptr<Parser::Expr> Parser::exponentiation() {
-        if (sym == Token::Kind::Minus) {
-            scan();
-            auto x = exponentiation();
-            if (x->kind == Expr::Kind::Number) {
-                x->num = -x->num;
-            } else {
-                x = std::make_shared<Expr>(Expr::Kind::Sign, 0., x);
-            }
-            return x;
-        }
-
-        if (sym == Token::Kind::Real) {
-            scan();
-            return std::make_shared<Expr>(Expr::Kind::Number, t.valReal);
-        }
-        if (sym == Token::Kind::Nninteger) {
-            scan();
-            return std::make_shared<Expr>(Expr::Kind::Number, t.val);
-        }
-        if (sym == Token::Kind::Pi) {
-            scan();
-            return std::make_shared<Expr>(Expr::Kind::Number, qc::PI);
-        }
-        if (sym == Token::Kind::Identifier) {
-            scan();
-            return std::make_shared<Expr>(Expr::Kind::Id, 0., nullptr, nullptr, t.str);
-        }
-        if (sym == Token::Kind::Lpar) {
-            scan();
-            auto x = expr();
-            check(Token::Kind::Rpar);
-            return x;
-        }
-        if (unaryops.find(sym) != unaryops.end()) {
-            const auto op = sym;
-            scan();
-            check(Token::Kind::Lpar);
-            auto x = expr();
-            check(Token::Kind::Rpar);
-            if (x->kind == Expr::Kind::Number) {
-                if (op == Token::Kind::Sin) {
-                    x->num = std::sin(x->num);
-                } else if (op == Token::Kind::Cos) {
-                    x->num = std::cos(x->num);
-                } else if (op == Token::Kind::Tan) {
-                    x->num = std::tan(x->num);
-                } else if (op == Token::Kind::Exp) {
-                    x->num = std::exp(x->num);
-                } else if (op == Token::Kind::Ln) {
-                    x->num = std::log(x->num);
-                } else if (op == Token::Kind::Sqrt) {
-                    x->num = std::sqrt(x->num);
-                }
-                return x;
-            }
-            if (op == Token::Kind::Sin) {
-                return std::make_shared<Expr>(Expr::Kind::Sin, 0., x);
-            }
-            if (op == Token::Kind::Cos) {
-                return std::make_shared<Expr>(Expr::Kind::Cos, 0., x);
-            }
-            if (op == Token::Kind::Tan) {
-                return std::make_shared<Expr>(Expr::Kind::Tan, 0., x);
-            }
-            if (op == Token::Kind::Exp) {
-                return std::make_shared<Expr>(Expr::Kind::Exp, 0., x);
-            }
-            if (op == Token::Kind::Ln) {
-                return std::make_shared<Expr>(Expr::Kind::Ln, 0., x);
-            }
-            if (op == Token::Kind::Sqrt) {
-                return std::make_shared<Expr>(Expr::Kind::Sqrt, 0., x);
-            }
-        } else {
-            error("Invalid Expression");
-        }
-
-        return nullptr;
-    }
-
-    std::shared_ptr<Parser::Expr> Parser::factor() {
-        auto x = exponentiation();
-        while (sym == Token::Kind::Power) {
-            scan();
-            auto y = exponentiation();
-            if (x->kind == Expr::Kind::Number && y->kind == Expr::Kind::Number) {
-                x->num = std::pow(x->num, y->num);
-            } else {
-                x = std::make_shared<Expr>(Expr::Kind::Power, 0., x, y);
-            }
-        }
-        return x;
-    }
-
-    std::shared_ptr<Parser::Expr> Parser::term() {
-        auto x = factor();
-        while (sym == Token::Kind::Times || sym == Token::Kind::Div) {
-            auto op = sym;
-            scan();
-            auto y = factor();
-            if (op == Token::Kind::Times) {
-                if (x->kind == Expr::Kind::Number && y->kind == Expr::Kind::Number) {
-                    x->num = x->num * y->num;
-                } else {
-                    x = std::make_shared<Expr>(Expr::Kind::Times, 0., x, y);
-                }
-            } else {
-                if (x->kind == Expr::Kind::Number && y->kind == Expr::Kind::Number) {
-                    x->num = x->num / y->num;
-                } else {
-                    x = std::make_shared<Expr>(Expr::Kind::Div, 0., x, y);
-                }
-            }
-        }
-        return x;
-    }
-
-    std::shared_ptr<Parser::Expr> Parser::expr() {
-        std::shared_ptr<Expr> x{};
-        if (sym == Token::Kind::Minus) {
-            scan();
-            x = term();
-            if (x->kind == Expr::Kind::Number) {
-                x->num = -x->num;
-            } else {
-                x = std::make_shared<Expr>(Expr::Kind::Sign, 0., x);
-            }
-        } else {
-            x = term();
-        }
-
-        while (sym == Token::Kind::Plus || sym == Token::Kind::Minus) {
-            auto op = sym;
-            scan();
-            auto y = term();
-            if (op == Token::Kind::Plus) {
-                if (x->kind == Expr::Kind::Number && y->kind == Expr::Kind::Number) {
-                    x->num += y->num;
-                } else {
-                    x = std::make_shared<Expr>(Expr::Kind::Plus, 0., x, y);
-                }
-            } else {
-                if (x->kind == Expr::Kind::Number && y->kind == Expr::Kind::Number) {
-                    x->num -= y->num;
-                } else {
-                    x = std::make_shared<Expr>(Expr::Kind::Minus, 0., x, y);
-                }
-            }
-        }
-        return x;
-    }
-
-    std::shared_ptr<Parser::Expr> Parser::rewriteExpr(const std::shared_ptr<Expr>& expr, std::map<std::string, std::shared_ptr<Expr>>& exprMap) {
-        if (expr == nullptr) {
-            return nullptr;
-        }
-        auto op1 = rewriteExpr(expr->op1, exprMap);
-        auto op2 = rewriteExpr(expr->op2, exprMap);
-
-        if (expr->kind == Expr::Kind::Number) {
-            return std::make_shared<Expr>(expr->kind, expr->num, op1, op2, expr->id);
-        }
-        if (expr->kind == Expr::Kind::Plus) {
-            if (op1->kind == Expr::Kind::Number && op2->kind == Expr::Kind::Number) {
-                op1->num = op1->num + op2->num;
-                return op1;
-            }
-        } else if (expr->kind == Expr::Kind::Minus) {
-            if (op1->kind == Expr::Kind::Number && op2->kind == Expr::Kind::Number) {
-                op1->num = op1->num - op2->num;
-                return op1;
-            }
-        } else if (expr->kind == Expr::Kind::Sign) {
-            if (op1->kind == Expr::Kind::Number) {
-                op1->num = -op1->num;
-                return op1;
-            }
-        } else if (expr->kind == Expr::Kind::Times) {
-            if (op1->kind == Expr::Kind::Number && op2->kind == Expr::Kind::Number) {
-                op1->num = op1->num * op2->num;
-                return op1;
-            }
-        } else if (expr->kind == Expr::Kind::Div) {
-            if (op1->kind == Expr::Kind::Number && op2->kind == Expr::Kind::Number) {
-                op1->num = op1->num / op2->num;
-                return op1;
-            }
-        } else if (expr->kind == Expr::Kind::Power) {
-            if (op1->kind == Expr::Kind::Number && op2->kind == Expr::Kind::Number) {
-                op1->num = std::pow(op1->num, op2->num);
-                return op1;
-            }
-        } else if (expr->kind == Expr::Kind::Sin) {
-            if (op1->kind == Expr::Kind::Number) {
-                op1->num = std::sin(op1->num);
-                return op1;
-            }
-        } else if (expr->kind == Expr::Kind::Cos) {
-            if (op1->kind == Expr::Kind::Number) {
-                op1->num = std::cos(op1->num);
-                return op1;
-            }
-        } else if (expr->kind == Expr::Kind::Tan) {
-            if (op1->kind == Expr::Kind::Number) {
-                op1->num = std::tan(op1->num);
-                return op1;
-            }
-        } else if (expr->kind == Expr::Kind::Exp) {
-            if (op1->kind == Expr::Kind::Number) {
-                op1->num = std::exp(op1->num);
-                return op1;
-            }
-        } else if (expr->kind == Expr::Kind::Ln) {
-            if (op1->kind == Expr::Kind::Number) {
-                op1->num = std::log(op1->num);
-                return op1;
-            }
-        } else if (expr->kind == Expr::Kind::Sqrt) {
-            if (op1->kind == Expr::Kind::Number) {
-                op1->num = std::sqrt(op1->num);
-                return op1;
-            }
-        } else if (expr->kind == Expr::Kind::Id) {
-            return exprMap[expr->id];
-        }
-
-        return std::make_shared<Expr>(expr->kind, expr->num, op1, op2, expr->id);
-    }
-
-    void Parser::handleComment() {
-        // check if this comment provides any I/O mapping information
-        if (const auto initial = checkForInitialLayout(t.str); !initial.empty()) {
-            if (!initialLayout.empty()) {
-                error("Multiple initial layout specifications found.");
-            } else {
-                initialLayout = initial;
-            }
-        }
-        if (const auto output = checkForOutputPermutation(t.str); !output.empty()) {
-            if (!outputPermutation.empty()) {
-                error("Multiple output permutation specifications found.");
-            } else {
-                outputPermutation = output;
-            }
-        }
-    }
-
-    qc::Permutation Parser::checkForInitialLayout(std::string comment) {
-        static const auto INITIAL_LAYOUT_REGEX = std::regex("i (\\d+ )*(\\d+)");
-        static const auto QUBIT_REGEX          = std::regex("\\d+");
-        qc::Permutation   initial{};
-        if (std::regex_search(comment, INITIAL_LAYOUT_REGEX)) {
-            qc::Qubit logicalQubit = 0;
-            for (std::smatch m; std::regex_search(comment, m, QUBIT_REGEX); comment = m.suffix()) {
-                auto physicalQubit = static_cast<qc::Qubit>(std::stoul(m.str()));
-                initial.insert({physicalQubit, logicalQubit});
-                ++logicalQubit;
-            }
-        }
-        return initial;
-    }
-
-    qc::Permutation Parser::checkForOutputPermutation(std::string comment) {
-        static const auto OUTPUT_PERMUTATION_REGEX = std::regex("o (\\d+ )*(\\d+)");
-        static const auto QUBIT_REGEX              = std::regex("\\d+");
-        qc::Permutation   output{};
-        if (std::regex_search(comment, OUTPUT_PERMUTATION_REGEX)) {
-            qc::Qubit logicalQubit = 0;
-            for (std::smatch m; std::regex_search(comment, m, QUBIT_REGEX); comment = m.suffix()) {
-                auto physicalQubit = static_cast<qc::Qubit>(std::stoul(m.str()));
-                output.insert({physicalQubit, logicalQubit});
-                ++logicalQubit;
-            }
-        }
-        return output;
-    }
-
-    /***
-     * Public Methods
-     ***/
-    void Parser::scan() {
-        t   = la;
-        la  = scanner->next();
-        sym = la.kind;
-    }
-
-    void Parser::check(const Token::Kind expected) {
-        while (sym == Token::Kind::Comment) {
-            scan();
-            handleComment();
-        }
-
-        if (sym == expected) {
-            scan();
-        } else {
-            error("Expected '" + qasm::KIND_NAMES.at(expected) + "' but found '" + qasm::KIND_NAMES.at(sym) + "' in line " + std::to_string(la.line) + ", column " + std::to_string(la.col));
-        }
-    }
-
-    qc::QuantumRegister Parser::argumentQreg() {
-        check(Token::Kind::Identifier);
-        const std::string s = t.str;
-        if (qregs.find(s) == qregs.end()) {
-            error("Argument is not a qreg: " + s);
-        }
-
-        if (sym == Token::Kind::Lbrack) {
-            scan();
-            check(Token::Kind::Nninteger);
-            const auto offset = static_cast<std::size_t>(t.val);
-            check(Token::Kind::Rbrack);
-            return std::make_pair(qregs[s].first + offset, 1);
-        }
-        return std::make_pair(qregs[s].first, qregs[s].second);
-    }
-
-    qc::ClassicalRegister Parser::argumentCreg() {
+/***
+ * Private Methods
+ ***/
+std::shared_ptr<Parser::Expr> Parser::exponentiation() {
+  if (sym == Token::Kind::Minus) {
+    scan();
+    auto x = exponentiation();
+    if (x->kind == Expr::Kind::Number) {
+      x->num = -x->num;
+    } else {
+      x = std::make_shared<Expr>(Expr::Kind::Sign, 0., x);
+    }
+    return x;
+  }
+
+  if (sym == Token::Kind::Real) {
+    scan();
+    return std::make_shared<Expr>(Expr::Kind::Number, t.valReal);
+  }
+  if (sym == Token::Kind::Nninteger) {
+    scan();
+    return std::make_shared<Expr>(Expr::Kind::Number, t.val);
+  }
+  if (sym == Token::Kind::Pi) {
+    scan();
+    return std::make_shared<Expr>(Expr::Kind::Number, qc::PI);
+  }
+  if (sym == Token::Kind::Identifier) {
+    scan();
+    return std::make_shared<Expr>(Expr::Kind::Id, 0., nullptr, nullptr, t.str);
+  }
+  if (sym == Token::Kind::Lpar) {
+    scan();
+    auto x = expr();
+    check(Token::Kind::Rpar);
+    return x;
+  }
+  if (unaryops.find(sym) != unaryops.end()) {
+    const auto op = sym;
+    scan();
+    check(Token::Kind::Lpar);
+    auto x = expr();
+    check(Token::Kind::Rpar);
+    if (x->kind == Expr::Kind::Number) {
+      if (op == Token::Kind::Sin) {
+        x->num = std::sin(x->num);
+      } else if (op == Token::Kind::Cos) {
+        x->num = std::cos(x->num);
+      } else if (op == Token::Kind::Tan) {
+        x->num = std::tan(x->num);
+      } else if (op == Token::Kind::Exp) {
+        x->num = std::exp(x->num);
+      } else if (op == Token::Kind::Ln) {
+        x->num = std::log(x->num);
+      } else if (op == Token::Kind::Sqrt) {
+        x->num = std::sqrt(x->num);
+      }
+      return x;
+    }
+    if (op == Token::Kind::Sin) {
+      return std::make_shared<Expr>(Expr::Kind::Sin, 0., x);
+    }
+    if (op == Token::Kind::Cos) {
+      return std::make_shared<Expr>(Expr::Kind::Cos, 0., x);
+    }
+    if (op == Token::Kind::Tan) {
+      return std::make_shared<Expr>(Expr::Kind::Tan, 0., x);
+    }
+    if (op == Token::Kind::Exp) {
+      return std::make_shared<Expr>(Expr::Kind::Exp, 0., x);
+    }
+    if (op == Token::Kind::Ln) {
+      return std::make_shared<Expr>(Expr::Kind::Ln, 0., x);
+    }
+    if (op == Token::Kind::Sqrt) {
+      return std::make_shared<Expr>(Expr::Kind::Sqrt, 0., x);
+    }
+  } else {
+    error("Invalid Expression");
+  }
+
+  return nullptr;
+}
+
+std::shared_ptr<Parser::Expr> Parser::factor() {
+  auto x = exponentiation();
+  while (sym == Token::Kind::Power) {
+    scan();
+    auto y = exponentiation();
+    if (x->kind == Expr::Kind::Number && y->kind == Expr::Kind::Number) {
+      x->num = std::pow(x->num, y->num);
+    } else {
+      x = std::make_shared<Expr>(Expr::Kind::Power, 0., x, y);
+    }
+  }
+  return x;
+}
+
+std::shared_ptr<Parser::Expr> Parser::term() {
+  auto x = factor();
+  while (sym == Token::Kind::Times || sym == Token::Kind::Div) {
+    auto op = sym;
+    scan();
+    auto y = factor();
+    if (op == Token::Kind::Times) {
+      if (x->kind == Expr::Kind::Number && y->kind == Expr::Kind::Number) {
+        x->num = x->num * y->num;
+      } else {
+        x = std::make_shared<Expr>(Expr::Kind::Times, 0., x, y);
+      }
+    } else {
+      if (x->kind == Expr::Kind::Number && y->kind == Expr::Kind::Number) {
+        x->num = x->num / y->num;
+      } else {
+        x = std::make_shared<Expr>(Expr::Kind::Div, 0., x, y);
+      }
+    }
+  }
+  return x;
+}
+
+std::shared_ptr<Parser::Expr> Parser::expr() {
+  std::shared_ptr<Expr> x{};
+  if (sym == Token::Kind::Minus) {
+    scan();
+    x = term();
+    if (x->kind == Expr::Kind::Number) {
+      x->num = -x->num;
+    } else {
+      x = std::make_shared<Expr>(Expr::Kind::Sign, 0., x);
+    }
+  } else {
+    x = term();
+  }
+
+  while (sym == Token::Kind::Plus || sym == Token::Kind::Minus) {
+    auto op = sym;
+    scan();
+    auto y = term();
+    if (op == Token::Kind::Plus) {
+      if (x->kind == Expr::Kind::Number && y->kind == Expr::Kind::Number) {
+        x->num += y->num;
+      } else {
+        x = std::make_shared<Expr>(Expr::Kind::Plus, 0., x, y);
+      }
+    } else {
+      if (x->kind == Expr::Kind::Number && y->kind == Expr::Kind::Number) {
+        x->num -= y->num;
+      } else {
+        x = std::make_shared<Expr>(Expr::Kind::Minus, 0., x, y);
+      }
+    }
+  }
+  return x;
+}
+
+std::shared_ptr<Parser::Expr>
+Parser::rewriteExpr(const std::shared_ptr<Expr>& expr,
+                    std::map<std::string, std::shared_ptr<Expr>>& exprMap) {
+  if (expr == nullptr) {
+    return nullptr;
+  }
+  auto op1 = rewriteExpr(expr->op1, exprMap);
+  auto op2 = rewriteExpr(expr->op2, exprMap);
+
+  if (expr->kind == Expr::Kind::Number) {
+    return std::make_shared<Expr>(expr->kind, expr->num, op1, op2, expr->id);
+  }
+  if (expr->kind == Expr::Kind::Plus) {
+    if (op1->kind == Expr::Kind::Number && op2->kind == Expr::Kind::Number) {
+      op1->num = op1->num + op2->num;
+      return op1;
+    }
+  } else if (expr->kind == Expr::Kind::Minus) {
+    if (op1->kind == Expr::Kind::Number && op2->kind == Expr::Kind::Number) {
+      op1->num = op1->num - op2->num;
+      return op1;
+    }
+  } else if (expr->kind == Expr::Kind::Sign) {
+    if (op1->kind == Expr::Kind::Number) {
+      op1->num = -op1->num;
+      return op1;
+    }
+  } else if (expr->kind == Expr::Kind::Times) {
+    if (op1->kind == Expr::Kind::Number && op2->kind == Expr::Kind::Number) {
+      op1->num = op1->num * op2->num;
+      return op1;
+    }
+  } else if (expr->kind == Expr::Kind::Div) {
+    if (op1->kind == Expr::Kind::Number && op2->kind == Expr::Kind::Number) {
+      op1->num = op1->num / op2->num;
+      return op1;
+    }
+  } else if (expr->kind == Expr::Kind::Power) {
+    if (op1->kind == Expr::Kind::Number && op2->kind == Expr::Kind::Number) {
+      op1->num = std::pow(op1->num, op2->num);
+      return op1;
+    }
+  } else if (expr->kind == Expr::Kind::Sin) {
+    if (op1->kind == Expr::Kind::Number) {
+      op1->num = std::sin(op1->num);
+      return op1;
+    }
+  } else if (expr->kind == Expr::Kind::Cos) {
+    if (op1->kind == Expr::Kind::Number) {
+      op1->num = std::cos(op1->num);
+      return op1;
+    }
+  } else if (expr->kind == Expr::Kind::Tan) {
+    if (op1->kind == Expr::Kind::Number) {
+      op1->num = std::tan(op1->num);
+      return op1;
+    }
+  } else if (expr->kind == Expr::Kind::Exp) {
+    if (op1->kind == Expr::Kind::Number) {
+      op1->num = std::exp(op1->num);
+      return op1;
+    }
+  } else if (expr->kind == Expr::Kind::Ln) {
+    if (op1->kind == Expr::Kind::Number) {
+      op1->num = std::log(op1->num);
+      return op1;
+    }
+  } else if (expr->kind == Expr::Kind::Sqrt) {
+    if (op1->kind == Expr::Kind::Number) {
+      op1->num = std::sqrt(op1->num);
+      return op1;
+    }
+  } else if (expr->kind == Expr::Kind::Id) {
+    return exprMap[expr->id];
+  }
+
+  return std::make_shared<Expr>(expr->kind, expr->num, op1, op2, expr->id);
+}
+
+void Parser::handleComment() {
+  // check if this comment provides any I/O mapping information
+  if (const auto initial = checkForInitialLayout(t.str); !initial.empty()) {
+    if (!initialLayout.empty()) {
+      error("Multiple initial layout specifications found.");
+    } else {
+      initialLayout = initial;
+    }
+  }
+  if (const auto output = checkForOutputPermutation(t.str); !output.empty()) {
+    if (!outputPermutation.empty()) {
+      error("Multiple output permutation specifications found.");
+    } else {
+      outputPermutation = output;
+    }
+  }
+}
+
+qc::Permutation Parser::checkForInitialLayout(std::string comment) {
+  static const auto INITIAL_LAYOUT_REGEX = std::regex("i (\\d+ )*(\\d+)");
+  static const auto QUBIT_REGEX = std::regex("\\d+");
+  qc::Permutation initial{};
+  if (std::regex_search(comment, INITIAL_LAYOUT_REGEX)) {
+    qc::Qubit logicalQubit = 0;
+    for (std::smatch m; std::regex_search(comment, m, QUBIT_REGEX);
+         comment = m.suffix()) {
+      auto physicalQubit = static_cast<qc::Qubit>(std::stoul(m.str()));
+      initial.insert({physicalQubit, logicalQubit});
+      ++logicalQubit;
+    }
+  }
+  return initial;
+}
+
+qc::Permutation Parser::checkForOutputPermutation(std::string comment) {
+  static const auto OUTPUT_PERMUTATION_REGEX = std::regex("o (\\d+ )*(\\d+)");
+  static const auto QUBIT_REGEX = std::regex("\\d+");
+  qc::Permutation output{};
+  if (std::regex_search(comment, OUTPUT_PERMUTATION_REGEX)) {
+    qc::Qubit logicalQubit = 0;
+    for (std::smatch m; std::regex_search(comment, m, QUBIT_REGEX);
+         comment = m.suffix()) {
+      auto physicalQubit = static_cast<qc::Qubit>(std::stoul(m.str()));
+      output.insert({physicalQubit, logicalQubit});
+      ++logicalQubit;
+    }
+  }
+  return output;
+}
+
+/***
+ * Public Methods
+ ***/
+void Parser::scan() {
+  t = la;
+  la = scanner->next();
+  sym = la.kind;
+}
+
+void Parser::check(const Token::Kind expected) {
+  while (sym == Token::Kind::Comment) {
+    scan();
+    handleComment();
+  }
+
+  if (sym == expected) {
+    scan();
+  } else {
+    error("Expected '" + qasm::KIND_NAMES.at(expected) + "' but found '" +
+          qasm::KIND_NAMES.at(sym) + "' in line " + std::to_string(la.line) +
+          ", column " + std::to_string(la.col));
+  }
+}
+
+qc::QuantumRegister Parser::argumentQreg() {
+  check(Token::Kind::Identifier);
+  const std::string s = t.str;
+  if (qregs.find(s) == qregs.end()) {
+    error("Argument is not a qreg: " + s);
+  }
+
+  if (sym == Token::Kind::Lbrack) {
+    scan();
+    check(Token::Kind::Nninteger);
+    const auto offset = static_cast<std::size_t>(t.val);
+    check(Token::Kind::Rbrack);
+    return std::make_pair(qregs[s].first + offset, 1);
+  }
+  return std::make_pair(qregs[s].first, qregs[s].second);
+}
+
+qc::ClassicalRegister Parser::argumentCreg() {
+  check(Token::Kind::Identifier);
+  const std::string s = t.str;
+  if (cregs.find(s) == cregs.end()) {
+    error("Argument is not a creg: " + s);
+  }
+
+  if (sym == Token::Kind::Lbrack) {
+    scan();
+    check(Token::Kind::Nninteger);
+    const auto offset = static_cast<std::size_t>(t.val);
+    check(Token::Kind::Rbrack);
+    return std::make_pair(cregs[s].first + offset, 1);
+  }
+
+  return std::make_pair(cregs[s].first, cregs[s].second);
+}
+
+void Parser::expList(std::vector<std::shared_ptr<Parser::Expr>>& expressions) {
+  expressions.emplace_back(expr());
+  while (sym == Token::Kind::Comma) {
+    scan();
+    expressions.emplace_back(expr());
+  }
+}
+
+void Parser::argList(std::vector<qc::QuantumRegister>& arguments) {
+  arguments.emplace_back(argumentQreg());
+  while (sym == Token::Kind::Comma) {
+    scan();
+    arguments.emplace_back(argumentQreg());
+  }
+}
+
+void Parser::idList(std::vector<std::string>& identifiers) {
+  check(Token::Kind::Identifier);
+  identifiers.emplace_back(t.str);
+  while (sym == Token::Kind::Comma) {
+    scan();
+    check(Token::Kind::Identifier);
+    identifiers.emplace_back(t.str);
+  }
+}
+
+std::unique_ptr<qc::Operation> Parser::gate() {
+  if (sym == Token::Kind::McxGray || sym == Token::Kind::McxRecursive ||
+      sym == Token::Kind::McxVchain) {
+    const auto type = sym;
+    scan();
+    std::vector<qc::QuantumRegister> registers{};
+    registers.emplace_back(argumentQreg());
+    while (sym != Token::Kind::Semicolon) {
+      check(Token::Kind::Comma);
+      registers.emplace_back(argumentQreg());
+    }
+    scan();
+
+    // drop ancillaries since our library can natively work with MCTs
+    if (type == Token::Kind::McxVchain) {
+      // n controls, 1 target, n-2 ancillaries = 2n-1 qubits
+      const auto ancillaries = (registers.size() + 1) / 2 - 2;
+      for (std::size_t i = 0; i < ancillaries; ++i) {
+        registers.pop_back();
+      }
+    } else if (type == Token::Kind::McxRecursive) {
+      // 1 ancillary if more than 4 controls
+      if (registers.size() > 5) {
+        registers.pop_back();
+      }
+    }
+    const auto target = registers.back();
+    registers.pop_back();
+
+    auto info = GATE_MAP.at("x");
+    info.nControls = registers.size();
+    return knownGate(info, {}, registers, {target});
+  }
+  if (sym == Token::Kind::Mcphase) {
+    scan();
+    check(Token::Kind::Lpar);
+    const auto lambda = expr();
+    check(Token::Kind::Rpar);
+
+    std::vector<qc::QuantumRegister> registers{};
+    registers.emplace_back(argumentQreg());
+    while (sym != Token::Kind::Semicolon) {
+      check(Token::Kind::Comma);
+      registers.emplace_back(argumentQreg());
+    }
+    scan();
+
+    const auto target = registers.back();
+    registers.pop_back();
+    auto info = GATE_MAP.at("p");
+    info.nControls = registers.size();
+    return knownGate(info, {lambda->num}, registers, {target});
+  }
+  if (sym == Token::Kind::Identifier) {
+    scan();
+    const auto gateName = t.str;
+
+    GateInfo info{};
+    const auto found = gateInfo(gateName, info);
+    if (found) {
+      return knownGate(info);
+    }
+
+    // at this point, the gate has to be user-defined
+    if (compoundGates.find(gateName) == compoundGates.end()) {
+      error("Unknown gate " + gateName);
+    }
+    auto& compoundGate = compoundGates.find(gateName)->second;
+
+    std::vector<std::shared_ptr<Parser::Expr>> parameters;
+    if (sym == Token::Kind::Lpar) {
+      scan();
+      if (sym != Token::Kind::Rpar) {
+        expList(parameters);
+      }
+      check(Token::Kind::Rpar);
+    }
+    std::vector<qc::QuantumRegister> arguments;
+    argList(arguments);
+    check(Token::Kind::Semicolon);
+
+    if (compoundGate.argumentNames.size() != arguments.size()) {
+      std::ostringstream oss{};
+      if (compoundGate.argumentNames.size() < arguments.size()) {
+        oss << "Too many arguments for ";
+      } else {
+        oss << "Too few arguments for ";
+      }
+      oss << gateName << " gate! Expected " << compoundGate.argumentNames.size()
+          << ", but got " << arguments.size();
+      error(oss.str());
+    }
+
+    qc::QuantumRegisterMap argMap;
+    std::size_t size = 1;
+    for (size_t i = 0; i < arguments.size(); ++i) {
+      argMap[compoundGate.argumentNames[i]] = arguments[i];
+      if (arguments[i].second > 1 && size != 1 && arguments[i].second != size) {
+        error("Register sizes do not match!");
+      }
+
+      if (arguments[i].second > 1) {
+        size = arguments[i].second;
+      }
+    }
+
+    std::map<std::string, std::shared_ptr<Parser::Expr>> paramMap;
+    for (size_t i = 0; i < parameters.size(); ++i) {
+      paramMap[compoundGate.parameterNames[i]] = parameters[i];
+    }
+
+    qc::CompoundOperation op(nqubits);
+    for (auto& g : compoundGate.gates) {
+      const auto* gate = dynamic_cast<StandardGate*>(g.get());
+      if (gate == nullptr) {
+        error("Unsupported gate type in compound gate definition");
+      }
+      std::vector<qc::fp> rewrittenParameters;
+      rewrittenParameters.reserve(gate->parameters.size());
+      for (const auto& p : gate->parameters) {
+        rewrittenParameters.emplace_back(rewriteExpr(p, paramMap)->num);
+      }
+      std::vector<qc::QuantumRegister> rewrittenControls;
+      rewrittenControls.reserve(gate->controls.size());
+      for (const auto& control : gate->controls) {
+        rewrittenControls.emplace_back(argMap.at(control));
+      }
+      std::vector<qc::QuantumRegister> rewrittenTargets;
+      rewrittenTargets.reserve(gate->targets.size());
+      for (const auto& target : gate->targets) {
+        rewrittenTargets.emplace_back(argMap.at(target));
+      }
+
+      if (compoundGate.gates.size() == 1) {
+        return knownGate(gate->info, rewrittenParameters, rewrittenControls,
+                         rewrittenTargets);
+      }
+
+      op.getOps().emplace_back(knownGate(gate->info, rewrittenParameters,
+                                         rewrittenControls, rewrittenTargets));
+    }
+    return std::make_unique<qc::CompoundOperation>(std::move(op));
+  }
+  error("Symbol " + qasm::KIND_NAMES.at(sym) +
+        " not expected in Gate() routine!");
+}
+
+void Parser::opaqueGateDecl() {
+  check(Token::Kind::Opaque);
+  check(Token::Kind::Identifier);
+
+  CompoundGate gate;
+  auto gateName = t.str;
+  if (sym == Token::Kind::Lpar) {
+    scan();
+    if (sym != Token::Kind::Rpar) {
+      idList(gate.argumentNames);
+    }
+    check(Token::Kind::Rpar);
+  }
+  idList(gate.argumentNames);
+  compoundGates[gateName] = gate;
+  check(Token::Kind::Semicolon);
+}
+
+void Parser::gateDecl() {
+  check(Token::Kind::Gate);
+
+  // skip declarations of known gates
+  if (sym == Token::Kind::McxGray || sym == Token::Kind::McxRecursive ||
+      sym == Token::Kind::McxVchain || sym == Token::Kind::Mcphase) {
+    while (sym != Token::Kind::Rbrace) {
+      scan();
+    }
+    check(Token::Kind::Rbrace);
+    return;
+  }
+  check(Token::Kind::Identifier);
+  const std::string gateName = t.str;
+  GateInfo info{};
+  const auto found = gateInfo(gateName, info);
+  if (found) {
+    // gate is already supported natively -> skip declaration
+    while (sym != Token::Kind::Rbrace) {
+      scan();
+    }
+    check(Token::Kind::Rbrace);
+    return;
+  }
+
+  // at this point, this is a new gate definition
+  CompoundGate gate;
+  if (sym == Token::Kind::Lpar) {
+    scan();
+    if (sym != Token::Kind::Rpar) {
+      idList(gate.parameterNames);
+    }
+    check(Token::Kind::Rpar);
+  }
+  idList(gate.argumentNames);
+  check(Token::Kind::Lbrace);
+  while (sym != Token::Kind::Rbrace) {
+    if (sym == Token::Kind::McxGray || sym == Token::Kind::McxRecursive ||
+        sym == Token::Kind::McxVchain) {
+      auto type = sym;
+      scan();
+      std::vector<std::string> arguments{};
+      check(Token::Kind::Identifier);
+      arguments.emplace_back(t.str);
+      while (sym != Token::Kind::Semicolon) {
+        check(Token::Kind::Comma);
         check(Token::Kind::Identifier);
-        const std::string s = t.str;
-        if (cregs.find(s) == cregs.end()) {
-            error("Argument is not a creg: " + s);
-        }
-
-        if (sym == Token::Kind::Lbrack) {
-            scan();
-            check(Token::Kind::Nninteger);
-            const auto offset = static_cast<std::size_t>(t.val);
-            check(Token::Kind::Rbrack);
-            return std::make_pair(cregs[s].first + offset, 1);
-        }
-
-        return std::make_pair(cregs[s].first, cregs[s].second);
-    }
-
-    void Parser::expList(std::vector<std::shared_ptr<Parser::Expr>>& expressions) {
-        expressions.emplace_back(expr());
-        while (sym == Token::Kind::Comma) {
-            scan();
-            expressions.emplace_back(expr());
-        }
-    }
-
-    void Parser::argList(std::vector<qc::QuantumRegister>& arguments) {
-        arguments.emplace_back(argumentQreg());
-        while (sym == Token::Kind::Comma) {
-            scan();
-            arguments.emplace_back(argumentQreg());
-        }
-    }
-
-    void Parser::idList(std::vector<std::string>& identifiers) {
-        check(Token::Kind::Identifier);
-        identifiers.emplace_back(t.str);
-        while (sym == Token::Kind::Comma) {
-            scan();
-            check(Token::Kind::Identifier);
-            identifiers.emplace_back(t.str);
-        }
-    }
-
-    std::unique_ptr<qc::Operation> Parser::gate() {
-        if (sym == Token::Kind::McxGray || sym == Token::Kind::McxRecursive || sym == Token::Kind::McxVchain) {
-            const auto type = sym;
-            scan();
-            std::vector<qc::QuantumRegister> registers{};
-            registers.emplace_back(argumentQreg());
-            while (sym != Token::Kind::Semicolon) {
-                check(Token::Kind::Comma);
-                registers.emplace_back(argumentQreg());
-            }
-            scan();
-
-            // drop ancillaries since our library can natively work with MCTs
-            if (type == Token::Kind::McxVchain) {
-                // n controls, 1 target, n-2 ancillaries = 2n-1 qubits
-                const auto ancillaries = (registers.size() + 1) / 2 - 2;
-                for (std::size_t i = 0; i < ancillaries; ++i) {
-                    registers.pop_back();
-                }
-            } else if (type == Token::Kind::McxRecursive) {
-                // 1 ancillary if more than 4 controls
-                if (registers.size() > 5) {
-                    registers.pop_back();
-                }
-            }
-            const auto target = registers.back();
-            registers.pop_back();
-
-            auto info      = GATE_MAP.at("x");
-            info.nControls = registers.size();
-            return knownGate(info, {}, registers, {target});
-        }
-        if (sym == Token::Kind::Mcphase) {
-            scan();
-            check(Token::Kind::Lpar);
-            const auto lambda = expr();
-            check(Token::Kind::Rpar);
-
-            std::vector<qc::QuantumRegister> registers{};
-            registers.emplace_back(argumentQreg());
-            while (sym != Token::Kind::Semicolon) {
-                check(Token::Kind::Comma);
-                registers.emplace_back(argumentQreg());
-            }
-            scan();
-
-            const auto target = registers.back();
-            registers.pop_back();
-            auto info      = GATE_MAP.at("p");
-            info.nControls = registers.size();
-            return knownGate(info, {lambda->num}, registers, {target});
-        }
-        if (sym == Token::Kind::Identifier) {
-            scan();
-            const auto gateName = t.str;
-
-            GateInfo   info{};
-            const auto found = gateInfo(gateName, info);
-            if (found) {
-                return knownGate(info);
-            }
-
-            // at this point, the gate has to be user-defined
-            if (compoundGates.find(gateName) == compoundGates.end()) {
-                error("Unknown gate " + gateName);
-            }
-            auto& compoundGate = compoundGates.find(gateName)->second;
-
-            std::vector<std::shared_ptr<Parser::Expr>> parameters;
-            if (sym == Token::Kind::Lpar) {
-                scan();
-                if (sym != Token::Kind::Rpar) {
-                    expList(parameters);
-                }
-                check(Token::Kind::Rpar);
-            }
-            std::vector<qc::QuantumRegister> arguments;
-            argList(arguments);
-            check(Token::Kind::Semicolon);
-
-            if (compoundGate.argumentNames.size() != arguments.size()) {
-                std::ostringstream oss{};
-                if (compoundGate.argumentNames.size() < arguments.size()) {
-                    oss << "Too many arguments for ";
-                } else {
-                    oss << "Too few arguments for ";
-                }
-                oss << gateName << " gate! Expected " << compoundGate.argumentNames.size() << ", but got " << arguments.size();
-                error(oss.str());
-            }
-
-            qc::QuantumRegisterMap argMap;
-            std::size_t            size = 1;
-            for (size_t i = 0; i < arguments.size(); ++i) {
-                argMap[compoundGate.argumentNames[i]] = arguments[i];
-                if (arguments[i].second > 1 && size != 1 && arguments[i].second != size) {
-                    error("Register sizes do not match!");
-                }
-
-                if (arguments[i].second > 1) {
-                    size = arguments[i].second;
-                }
-            }
-
-            std::map<std::string, std::shared_ptr<Parser::Expr>> paramMap;
-            for (size_t i = 0; i < parameters.size(); ++i) {
-                paramMap[compoundGate.parameterNames[i]] = parameters[i];
-            }
-
-            qc::CompoundOperation op(nqubits);
-            for (auto& g: compoundGate.gates) {
-                const auto* gate = dynamic_cast<StandardGate*>(g.get());
-                if (gate == nullptr) {
-                    error("Unsupported gate type in compound gate definition");
-                }
-                std::vector<qc::fp> rewrittenParameters;
-                for (const auto& p: gate->parameters) {
-                    rewrittenParameters.emplace_back(rewriteExpr(p, paramMap)->num);
-                }
-                std::vector<qc::QuantumRegister> rewrittenControls;
-                for (const auto& control: gate->controls) {
-                    rewrittenControls.emplace_back(argMap.at(control));
-                }
-                std::vector<qc::QuantumRegister> rewrittenTargets;
-                for (const auto& target: gate->targets) {
-                    rewrittenTargets.emplace_back(argMap.at(target));
-                }
-
-                if (compoundGate.gates.size() == 1) {
-                    return knownGate(gate->info, rewrittenParameters, rewrittenControls, rewrittenTargets);
-                }
-
-                op.getOps().emplace_back(knownGate(gate->info, rewrittenParameters, rewrittenControls, rewrittenTargets));
-            }
-            return std::make_unique<qc::CompoundOperation>(std::move(op));
-        }
-        error("Symbol " + qasm::KIND_NAMES.at(sym) + " not expected in Gate() routine!");
-    }
-
-    void Parser::opaqueGateDecl() {
-        check(Token::Kind::Opaque);
+        arguments.emplace_back(t.str);
+      }
+      scan();
+
+      // drop ancillaries since our library can natively work with MCTs
+      if (type == Token::Kind::McxVchain) {
+        const auto ancillaries = (arguments.size() + 1) / 2 - 2;
+        for (std::size_t i = 0; i < ancillaries; ++i) {
+          arguments.pop_back();
+        }
+      } else if (type == Token::Kind::McxRecursive) {
+        // 1 ancillary if more than 4 controls
+        if (arguments.size() > 5) {
+          arguments.pop_back();
+        }
+      }
+
+      const auto target = arguments.back();
+      arguments.pop_back();
+      auto mcx = StandardGate{};
+      mcx.info = GATE_MAP.at("x");
+      mcx.info.nControls = arguments.size();
+      mcx.controls = std::move(arguments);
+      mcx.targets.emplace_back(target);
+      gate.gates.push_back(std::make_shared<StandardGate>(std::move(mcx)));
+    } else if (sym == Token::Kind::Mcphase) {
+      scan();
+      check(Token::Kind::Lpar);
+      const auto lambda = expr();
+      check(Token::Kind::Rpar);
+      std::vector<std::string> arguments{};
+      check(Token::Kind::Identifier);
+      arguments.emplace_back(t.str);
+      while (sym != Token::Kind::Semicolon) {
+        check(Token::Kind::Comma);
         check(Token::Kind::Identifier);
-
-        CompoundGate gate;
-        auto         gateName = t.str;
-        if (sym == Token::Kind::Lpar) {
-            scan();
-            if (sym != Token::Kind::Rpar) {
-                idList(gate.argumentNames);
-            }
-            check(Token::Kind::Rpar);
-        }
-        idList(gate.argumentNames);
-        compoundGates[gateName] = gate;
-        check(Token::Kind::Semicolon);
-    }
-
-    void Parser::gateDecl() {
-        check(Token::Kind::Gate);
-
-        // skip declarations of known gates
-        if (sym == Token::Kind::McxGray || sym == Token::Kind::McxRecursive || sym == Token::Kind::McxVchain || sym == Token::Kind::Mcphase) {
-            while (sym != Token::Kind::Rbrace) {
-                scan();
-            }
-            check(Token::Kind::Rbrace);
-            return;
-        }
-        check(Token::Kind::Identifier);
-        const std::string gateName = t.str;
-        GateInfo          info{};
-        const auto        found = gateInfo(gateName, info);
-        if (found) {
-            // gate is already supported natively -> skip declaration
-            while (sym != Token::Kind::Rbrace) {
-                scan();
-            }
-            check(Token::Kind::Rbrace);
-            return;
-        }
-
-        // at this point, this is a new gate definition
-        CompoundGate gate;
-        if (sym == Token::Kind::Lpar) {
-            scan();
-            if (sym != Token::Kind::Rpar) {
-                idList(gate.parameterNames);
-            }
-            check(Token::Kind::Rpar);
-        }
-        idList(gate.argumentNames);
-        check(Token::Kind::Lbrace);
-        while (sym != Token::Kind::Rbrace) {
-            if (sym == Token::Kind::McxGray || sym == Token::Kind::McxRecursive || sym == Token::Kind::McxVchain) {
-                auto type = sym;
-                scan();
-                std::vector<std::string> arguments{};
-                check(Token::Kind::Identifier);
-                arguments.emplace_back(t.str);
-                while (sym != Token::Kind::Semicolon) {
-                    check(Token::Kind::Comma);
-                    check(Token::Kind::Identifier);
-                    arguments.emplace_back(t.str);
-                }
-                scan();
-
-                // drop ancillaries since our library can natively work with MCTs
-                if (type == Token::Kind::McxVchain) {
-                    const auto ancillaries = (arguments.size() + 1) / 2 - 2;
-                    for (std::size_t i = 0; i < ancillaries; ++i) {
-                        arguments.pop_back();
-                    }
-                } else if (type == Token::Kind::McxRecursive) {
-                    // 1 ancillary if more than 4 controls
-                    if (arguments.size() > 5) {
-                        arguments.pop_back();
-                    }
-                }
-
-                const auto target = arguments.back();
-                arguments.pop_back();
-                auto mcx           = StandardGate{};
-                mcx.info           = GATE_MAP.at("x");
-                mcx.info.nControls = arguments.size();
-                mcx.controls       = std::move(arguments);
-                mcx.targets.emplace_back(target);
-                gate.gates.push_back(std::make_shared<StandardGate>(std::move(mcx)));
-            } else if (sym == Token::Kind::Mcphase) {
-                scan();
-                check(Token::Kind::Lpar);
-                const auto lambda = expr();
-                check(Token::Kind::Rpar);
-                std::vector<std::string> arguments{};
-                check(Token::Kind::Identifier);
-                arguments.emplace_back(t.str);
-                while (sym != Token::Kind::Semicolon) {
-                    check(Token::Kind::Comma);
-                    check(Token::Kind::Identifier);
-                    arguments.emplace_back(t.str);
-                }
-                scan();
-                const auto target = arguments.back();
-                arguments.pop_back();
-                auto mcp           = StandardGate{};
-                mcp.info           = GATE_MAP.at("p");
-                mcp.info.nControls = arguments.size();
-                mcp.controls       = std::move(arguments);
-                mcp.targets.emplace_back(target);
-                mcp.parameters.emplace_back(lambda);
-                gate.gates.push_back(std::make_shared<StandardGate>(std::move(mcp)));
-            } else if (sym == Token::Kind::Identifier) {
-                scan();
-                const std::string name = t.str;
-
-                std::vector<std::shared_ptr<Parser::Expr>> parameters;
-                std::vector<std::string>                   arguments;
-                if (sym == Token::Kind::Lpar) {
-                    scan();
-                    if (sym != Token::Kind::Rpar) {
-                        expList(parameters);
-                    }
-                    check(Token::Kind::Rpar);
-                }
-                idList(arguments);
-                check(Token::Kind::Semicolon);
-
-                GateInfo   gateInf{};
-                const auto gateFound = gateInfo(name, gateInf);
-                if (gateFound) {
-                    // gate is already supported natively
-                    auto sGate = StandardGate{};
-                    sGate.info = gateInf;
-                    for (std::size_t i = 0; i < sGate.info.nControls; ++i) {
-                        sGate.controls.emplace_back(arguments.front());
-                        arguments.erase(arguments.begin());
-                    }
-                    sGate.targets    = std::move(arguments);
-                    sGate.parameters = std::move(parameters);
-                    gate.gates.emplace_back(std::make_shared<StandardGate>(std::move(sGate)));
-                    continue;
-                }
-
-                // gate is not supported natively -> check if a definition for it exists
-                if (compoundGates.find(name) == compoundGates.end()) {
-                    error("Unsupported gate: " + name + " (no definition found)");
-                }
-
-                const auto& compoundGate = compoundGates.at(name);
-                if (compoundGate.argumentNames.size() != arguments.size()) {
-                    std::ostringstream oss{};
-                    if (compoundGate.argumentNames.size() < arguments.size()) {
-                        oss << "Too many arguments for ";
-                    } else {
-                        oss << "Too few arguments for ";
-                    }
-                    oss << name << " gate! Expected " << compoundGate.argumentNames.size() << ", but got " << arguments.size() << "!";
-                    error(oss.str());
-                }
-
-                std::map<std::string, std::string> argMap;
-                for (size_t i = 0; i < arguments.size(); ++i) {
-                    argMap[compoundGate.argumentNames[i]] = arguments[i];
-                }
-
-                std::map<std::string, std::shared_ptr<Parser::Expr>> paramMap;
-                for (size_t i = 0; i < parameters.size(); ++i) {
-                    paramMap[compoundGate.parameterNames[i]] = parameters[i];
-                }
-
-                for (const auto& gatePtr: compoundGate.gates) {
-                    const auto* gateDef = dynamic_cast<StandardGate*>(gatePtr.get());
-                    if (gateDef == nullptr) {
-                        error("Unsupported gate type in compound gate definition");
-                    }
-                    std::vector<std::shared_ptr<Expr>> rewrittenParameters;
-                    for (const auto& p: gateDef->parameters) {
-                        rewrittenParameters.emplace_back(rewriteExpr(p, paramMap));
-                    }
-                    std::vector<std::string> rewrittenControls;
-                    for (const auto& control: gateDef->controls) {
-                        rewrittenControls.emplace_back(argMap.at(control));
-                    }
-                    std::vector<std::string> rewrittenTargets;
-                    for (const auto& target: gateDef->targets) {
-                        rewrittenTargets.emplace_back(argMap.at(target));
-                    }
-                    auto newGate        = std::make_shared<StandardGate>();
-                    newGate->info       = gateDef->info;
-                    newGate->controls   = std::move(rewrittenControls);
-                    newGate->targets    = std::move(rewrittenTargets);
-                    newGate->parameters = std::move(rewrittenParameters);
-                    gate.gates.emplace_back(newGate);
-                }
-            } else if (sym == Token::Kind::Barrier) {
-                scan();
-                std::vector<std::string> arguments;
-                idList(arguments);
-                check(Token::Kind::Semicolon);
-                //Nothing to do here for the simulator
-            } else if (sym == Token::Kind::Comment) {
-                scan();
-                handleComment();
-            } else {
-                error("Error in gate declaration!");
-            }
-        }
-        compoundGates[gateName] = gate;
-        check(Token::Kind::Rbrace);
-    }
-
-    std::unique_ptr<qc::Operation> Parser::qop() {
-        if (sym == Token::Kind::Identifier ||
-            sym == Token::Kind::McxGray || sym == Token::Kind::McxRecursive || sym == Token::Kind::McxVchain ||
-            sym == Token::Kind::Mcphase) {
-            return gate();
-        }
-        if (sym == Token::Kind::Measure) {
-            scan();
-            auto qreg = argumentQreg();
-            check(Token::Kind::Minus);
-            check(Token::Kind::Gt);
-            auto creg = argumentCreg();
-            check(Token::Kind::Semicolon);
-
-            if (qreg.second == creg.second) {
-                std::vector<qc::Qubit> qubits{};
-                std::vector<qc::Bit>   classics{};
-                for (std::size_t i = 0; i < qreg.second; ++i) {
-                    const auto qubit = qreg.first + i;
-                    const auto clbit = creg.first + i;
-                    if (qubit >= nqubits) {
-                        std::stringstream ss{};
-                        ss << "Qubit " << qubit << " cannot be measured since the circuit only contains " << nqubits << " qubits";
-                        error(ss.str());
-                    }
-                    if (clbit >= nclassics) {
-                        std::stringstream ss{};
-                        ss << "Bit " << clbit << " cannot be target of a measurement since the circuit only contains " << nclassics << " classical bits";
-                        error(ss.str());
-                    }
-                    qubits.emplace_back(qubit);
-                    classics.emplace_back(clbit);
-                }
-                return std::make_unique<qc::NonUnitaryOperation>(nqubits, qubits, classics);
-            }
-            error("Mismatch of qreg and creg size in measurement");
-        }
-        if (sym == Token::Kind::Reset) {
-            scan();
-            auto qreg = argumentQreg();
-            check(Token::Kind::Semicolon);
-
-            std::vector<qc::Qubit> qubits;
-            for (std::size_t i = 0; i < qreg.second; ++i) {
-                auto qubit = qreg.first + i;
-                if (qubit >= nqubits) {
-                    std::stringstream ss{};
-                    ss << "Qubit " << qubit << " cannot be reset since the circuit only contains " << nqubits << " qubits";
-                    error(ss.str());
-                }
-                qubits.emplace_back(qubit);
-            }
-            return std::make_unique<qc::NonUnitaryOperation>(nqubits, qubits);
-        }
-        error("No valid Qop: " + t.str);
-    }
-
-    void Parser::parseParameters(const GateInfo& info, std::vector<qc::fp>& parameters) {
-        // if the gate has parameters, then parse them first
-        if (info.nParameters > 0) {
-            check(Token::Kind::Lpar);
-            for (std::size_t i = 0; i < info.nParameters; ++i) {
-                parameters.emplace_back(expr()->num);
-                if (i < (info.nParameters - 1)) {
-                    check(Token::Kind::Comma);
-                }
-            }
-            check(Token::Kind::Rpar);
-        }
-    }
-
-    void Parser::parseArguments(const GateInfo& info, std::vector<qc::fp>& parameters, std::vector<qc::QuantumRegister>& controlRegisters, std::vector<qc::QuantumRegister>& targetRegisters) {
-        parseParameters(info, parameters);
-
-        // if the gate has controls, collect them next
-        if (info.nControls > 0) {
-            for (std::size_t i = 0; i < info.nControls; ++i) {
-                controlRegisters.emplace_back(argumentQreg());
-                if (i < (info.nControls - 1)) {
-                    check(Token::Kind::Comma);
-                }
-            }
-        }
-
-        // finally, if the gate has targets, collect them
-        if (info.nTargets > 0) {
-            if (info.nControls > 0U) {
-                check(Token::Kind::Comma);
-            }
-            for (std::size_t i = 0; i < info.nTargets; ++i) {
-                targetRegisters.emplace_back(argumentQreg());
-                if (i < (info.nTargets - 1)) {
-                    check(Token::Kind::Comma);
-                }
-            }
-        }
-        check(Token::Kind::Semicolon);
-    }
-
-    bool Parser::gateInfo(const std::string& name, GateInfo& info) {
-        if (const auto it = GATE_MAP.find(name); it != GATE_MAP.end()) {
-            info = it->second;
-            return true;
-        }
-        auto        cName     = name;
-        std::size_t nControls = 0;
-        while (cName.front() == 'c') {
-            cName = cName.substr(1);
-            ++nControls;
-        }
-        if (const auto it = GATE_MAP.find(cName); it != GATE_MAP.end()) {
-            info = it->second;
-            info.nControls += nControls;
-            return true;
-        }
-        return false;
-    }
-
-    std::unique_ptr<qc::Operation> Parser::knownGate(const GateInfo& info, const std::vector<qc::fp>& parameters, const std::vector<qc::QuantumRegister>& controlRegisters, const std::vector<qc::QuantumRegister>& targetRegisters) {
-        bool         broadcasting = false;
-        qc::Controls controls{};
-        for (const auto& [startQubit, length]: controlRegisters) {
-            if (length != 1) {
-                broadcasting = true;
-            }
-            for (std::size_t i = 0; i < length; ++i) {
-                const auto control = qc::Control{static_cast<qc::Qubit>(startQubit + i)};
-                if (std::find(controls.begin(), controls.end(), control) != controls.end()) {
-                    error("Duplicate control qubit in multi-qubit gate.");
-                }
-                controls.emplace(control);
-            }
-        }
-
-        qc::Targets targets{};
-        for (const auto& [startQubit, length]: targetRegisters) {
-            if (length != 1) {
-                broadcasting = true;
-            }
-            for (std::size_t i = 0; i < length; ++i) {
-                const auto target = static_cast<qc::Qubit>(startQubit + i);
-                if (std::find(targets.begin(), targets.end(), target) != targets.end()) {
-                    error("Duplicate target qubit in multi-qubit gate.");
-                }
-                if (std::find(controls.begin(), controls.end(), qc::Control{target}) != controls.end()) {
-                    error("Duplicate qubit argument in multi-qubit gate.");
-                }
-                targets.emplace_back(target);
-            }
-        }
-
-        if (!broadcasting) {
-            // standard case: no broadcasting, just a simple operation
-            return std::make_unique<qc::StandardOperation>(nqubits, controls, targets, info.type, parameters);
-        }
-
-        // handle case where there are no controls
-        if (info.nControls == 0) {
-            // handle single-qubit gates
-            if (info.nTargets == 1) {
-                const auto& [startQubit, length] = targetRegisters.front();
-                auto gate                        = qc::CompoundOperation(nqubits);
-                for (std::size_t i = 0; i < length; ++i) {
-                    gate.emplace_back<qc::StandardOperation>(nqubits, static_cast<qc::Qubit>(startQubit + i), info.type, parameters);
-                }
-                return std::make_unique<qc::CompoundOperation>(std::move(gate));
-            }
-            error("Broadcasting not supported for multi-target gates.");
-        }
-
-        // the single control, single target case is special as we support broadcasting
-        if (info.nControls == 1) {
-            const auto& [startControl, lengthControl] = controlRegisters.front();
-            if (info.nTargets == 1) {
-                const auto& [startTarget, lengthTarget] = targetRegisters.front();
-                auto gate                               = qc::CompoundOperation(nqubits);
-                if (lengthControl == 1 && lengthTarget > 1) {
-                    for (std::size_t i = 0; i < lengthTarget; ++i) {
-                        gate.emplace_back<qc::StandardOperation>(nqubits, qc::Control{startControl}, static_cast<qc::Qubit>(startTarget + i), info.type, parameters);
-                    }
-                    return std::make_unique<qc::CompoundOperation>(std::move(gate));
-                }
-                if (lengthControl > 1 && lengthTarget == 1) {
-                    for (std::size_t i = 0; i < lengthControl; ++i) {
-                        gate.emplace_back<qc::StandardOperation>(nqubits, qc::Control{static_cast<qc::Qubit>(startControl + i)}, startTarget, info.type, parameters);
-                    }
-                    return std::make_unique<qc::CompoundOperation>(std::move(gate));
-                }
-                if (lengthControl == lengthTarget) {
-                    for (std::size_t i = 0; i < lengthControl; ++i) {
-                        gate.emplace_back<qc::StandardOperation>(nqubits, qc::Control{static_cast<qc::Qubit>(startControl + i)}, static_cast<qc::Qubit>(startTarget + i), info.type, parameters);
-                    }
-                    return std::make_unique<qc::CompoundOperation>(std::move(gate));
-                }
-                error("Ill-formed broadcasting statement.");
-            }
+        arguments.emplace_back(t.str);
+      }
+      scan();
+      const auto target = arguments.back();
+      arguments.pop_back();
+      auto mcp = StandardGate{};
+      mcp.info = GATE_MAP.at("p");
+      mcp.info.nControls = arguments.size();
+      mcp.controls = std::move(arguments);
+      mcp.targets.emplace_back(target);
+      mcp.parameters.emplace_back(lambda);
+      gate.gates.push_back(std::make_shared<StandardGate>(std::move(mcp)));
+    } else if (sym == Token::Kind::Identifier) {
+      scan();
+      const std::string name = t.str;
+
+      std::vector<std::shared_ptr<Parser::Expr>> parameters;
+      std::vector<std::string> arguments;
+      if (sym == Token::Kind::Lpar) {
+        scan();
+        if (sym != Token::Kind::Rpar) {
+          expList(parameters);
+        }
+        check(Token::Kind::Rpar);
+      }
+      idList(arguments);
+      check(Token::Kind::Semicolon);
+
+      GateInfo gateInf{};
+      const auto gateFound = gateInfo(name, gateInf);
+      if (gateFound) {
+        // gate is already supported natively
+        auto sGate = StandardGate{};
+        sGate.info = gateInf;
+        for (std::size_t i = 0; i < sGate.info.nControls; ++i) {
+          sGate.controls.emplace_back(arguments.front());
+          arguments.erase(arguments.begin());
+        }
+        sGate.targets = std::move(arguments);
+        sGate.parameters = std::move(parameters);
+        gate.gates.emplace_back(
+            std::make_shared<StandardGate>(std::move(sGate)));
+        continue;
+      }
+
+      // gate is not supported natively -> check if a definition for it exists
+      if (compoundGates.find(name) == compoundGates.end()) {
+        error("Unsupported gate: " + name + " (no definition found)");
+      }
+
+      const auto& compoundGate = compoundGates.at(name);
+      if (compoundGate.argumentNames.size() != arguments.size()) {
+        std::ostringstream oss{};
+        if (compoundGate.argumentNames.size() < arguments.size()) {
+          oss << "Too many arguments for ";
+        } else {
+          oss << "Too few arguments for ";
         }
-        error("Broadcasting not supported for multi-control, multi-target gates.");
-    }
+        oss << name << " gate! Expected " << compoundGate.argumentNames.size()
+            << ", but got " << arguments.size() << "!";
+        error(oss.str());
+      }
+
+      std::map<std::string, std::string> argMap;
+      for (size_t i = 0; i < arguments.size(); ++i) {
+        argMap[compoundGate.argumentNames[i]] = arguments[i];
+      }
+
+      std::map<std::string, std::shared_ptr<Parser::Expr>> paramMap;
+      for (size_t i = 0; i < parameters.size(); ++i) {
+        paramMap[compoundGate.parameterNames[i]] = parameters[i];
+      }
+
+      for (const auto& gatePtr : compoundGate.gates) {
+        const auto* gateDef = dynamic_cast<StandardGate*>(gatePtr.get());
+        if (gateDef == nullptr) {
+          error("Unsupported gate type in compound gate definition");
+        }
+        std::vector<std::shared_ptr<Expr>> rewrittenParameters;
+        rewrittenParameters.reserve(gateDef->parameters.size());
+        for (const auto& p : gateDef->parameters) {
+          rewrittenParameters.emplace_back(rewriteExpr(p, paramMap));
+        }
+        std::vector<std::string> rewrittenControls;
+        rewrittenControls.reserve(gateDef->controls.size());
+        for (const auto& control : gateDef->controls) {
+          rewrittenControls.emplace_back(argMap.at(control));
+        }
+        std::vector<std::string> rewrittenTargets;
+        rewrittenTargets.reserve(gateDef->targets.size());
+        for (const auto& target : gateDef->targets) {
+          rewrittenTargets.emplace_back(argMap.at(target));
+        }
+        auto newGate = std::make_shared<StandardGate>();
+        newGate->info = gateDef->info;
+        newGate->controls = std::move(rewrittenControls);
+        newGate->targets = std::move(rewrittenTargets);
+        newGate->parameters = std::move(rewrittenParameters);
+        gate.gates.emplace_back(newGate);
+      }
+    } else if (sym == Token::Kind::Barrier) {
+      scan();
+      std::vector<std::string> arguments;
+      idList(arguments);
+      check(Token::Kind::Semicolon);
+      // Nothing to do here for the simulator
+    } else if (sym == Token::Kind::Comment) {
+      scan();
+      handleComment();
+    } else {
+      error("Error in gate declaration!");
+    }
+  }
+  compoundGates[gateName] = gate;
+  check(Token::Kind::Rbrace);
+}
+
+std::unique_ptr<qc::Operation> Parser::qop() {
+  if (sym == Token::Kind::Identifier || sym == Token::Kind::McxGray ||
+      sym == Token::Kind::McxRecursive || sym == Token::Kind::McxVchain ||
+      sym == Token::Kind::Mcphase) {
+    return gate();
+  }
+  if (sym == Token::Kind::Measure) {
+    scan();
+    auto qreg = argumentQreg();
+    check(Token::Kind::Minus);
+    check(Token::Kind::Gt);
+    auto creg = argumentCreg();
+    check(Token::Kind::Semicolon);
+
+    if (qreg.second == creg.second) {
+      std::vector<qc::Qubit> qubits{};
+      std::vector<qc::Bit> classics{};
+      for (std::size_t i = 0; i < qreg.second; ++i) {
+        const auto qubit = qreg.first + i;
+        const auto clbit = creg.first + i;
+        if (qubit >= nqubits) {
+          std::stringstream ss{};
+          ss << "Qubit " << qubit
+             << " cannot be measured since the circuit only contains "
+             << nqubits << " qubits";
+          error(ss.str());
+        }
+        if (clbit >= nclassics) {
+          std::stringstream ss{};
+          ss << "Bit " << clbit
+             << " cannot be target of a measurement since the circuit only "
+                "contains "
+             << nclassics << " classical bits";
+          error(ss.str());
+        }
+        qubits.emplace_back(qubit);
+        classics.emplace_back(clbit);
+      }
+      return std::make_unique<qc::NonUnitaryOperation>(nqubits, qubits,
+                                                       classics);
+    }
+    error("Mismatch of qreg and creg size in measurement");
+  }
+  if (sym == Token::Kind::Reset) {
+    scan();
+    auto qreg = argumentQreg();
+    check(Token::Kind::Semicolon);
+
+    std::vector<qc::Qubit> qubits;
+    for (std::size_t i = 0; i < qreg.second; ++i) {
+      auto qubit = qreg.first + i;
+      if (qubit >= nqubits) {
+        std::stringstream ss{};
+        ss << "Qubit " << qubit
+           << " cannot be reset since the circuit only contains " << nqubits
+           << " qubits";
+        error(ss.str());
+      }
+      qubits.emplace_back(qubit);
+    }
+    return std::make_unique<qc::NonUnitaryOperation>(nqubits, qubits);
+  }
+  error("No valid Qop: " + t.str);
+}
+
+void Parser::parseParameters(const GateInfo& info,
+                             std::vector<qc::fp>& parameters) {
+  // if the gate has parameters, then parse them first
+  if (info.nParameters > 0) {
+    check(Token::Kind::Lpar);
+    for (std::size_t i = 0; i < info.nParameters; ++i) {
+      parameters.emplace_back(expr()->num);
+      if (i < (info.nParameters - 1)) {
+        check(Token::Kind::Comma);
+      }
+    }
+    check(Token::Kind::Rpar);
+  }
+}
+
+void Parser::parseArguments(const GateInfo& info,
+                            std::vector<qc::fp>& parameters,
+                            std::vector<qc::QuantumRegister>& controlRegisters,
+                            std::vector<qc::QuantumRegister>& targetRegisters) {
+  parseParameters(info, parameters);
+
+  // if the gate has controls, collect them next
+  if (info.nControls > 0) {
+    for (std::size_t i = 0; i < info.nControls; ++i) {
+      controlRegisters.emplace_back(argumentQreg());
+      if (i < (info.nControls - 1)) {
+        check(Token::Kind::Comma);
+      }
+    }
+  }
+
+  // finally, if the gate has targets, collect them
+  if (info.nTargets > 0) {
+    if (info.nControls > 0U) {
+      check(Token::Kind::Comma);
+    }
+    for (std::size_t i = 0; i < info.nTargets; ++i) {
+      targetRegisters.emplace_back(argumentQreg());
+      if (i < (info.nTargets - 1)) {
+        check(Token::Kind::Comma);
+      }
+    }
+  }
+  check(Token::Kind::Semicolon);
+}
+
+bool Parser::gateInfo(const std::string& name, GateInfo& info) {
+  if (const auto it = GATE_MAP.find(name); it != GATE_MAP.end()) {
+    info = it->second;
+    return true;
+  }
+  auto cName = name;
+  std::size_t nControls = 0;
+  while (cName.front() == 'c') {
+    cName = cName.substr(1);
+    ++nControls;
+  }
+  if (const auto it = GATE_MAP.find(cName); it != GATE_MAP.end()) {
+    info = it->second;
+    info.nControls += nControls;
+    return true;
+  }
+  return false;
+}
+
+std::unique_ptr<qc::Operation>
+Parser::knownGate(const GateInfo& info, const std::vector<qc::fp>& parameters,
+                  const std::vector<qc::QuantumRegister>& controlRegisters,
+                  const std::vector<qc::QuantumRegister>& targetRegisters) {
+  bool broadcasting = false;
+  qc::Controls controls{};
+  for (const auto& [startQubit, length] : controlRegisters) {
+    if (length != 1) {
+      broadcasting = true;
+    }
+    for (std::size_t i = 0; i < length; ++i) {
+      const auto control = qc::Control{static_cast<qc::Qubit>(startQubit + i)};
+      if (std::find(controls.begin(), controls.end(), control) !=
+          controls.end()) {
+        error("Duplicate control qubit in multi-qubit gate.");
+      }
+      controls.emplace(control);
+    }
+  }
+
+  qc::Targets targets{};
+  for (const auto& [startQubit, length] : targetRegisters) {
+    if (length != 1) {
+      broadcasting = true;
+    }
+    for (std::size_t i = 0; i < length; ++i) {
+      const auto target = static_cast<qc::Qubit>(startQubit + i);
+      if (std::find(targets.begin(), targets.end(), target) != targets.end()) {
+        error("Duplicate target qubit in multi-qubit gate.");
+      }
+      if (std::find(controls.begin(), controls.end(), qc::Control{target}) !=
+          controls.end()) {
+        error("Duplicate qubit argument in multi-qubit gate.");
+      }
+      targets.emplace_back(target);
+    }
+  }
+
+  if (!broadcasting) {
+    // standard case: no broadcasting, just a simple operation
+    return std::make_unique<qc::StandardOperation>(nqubits, controls, targets,
+                                                   info.type, parameters);
+  }
+
+  // handle case where there are no controls
+  if (info.nControls == 0) {
+    // handle single-qubit gates
+    if (info.nTargets == 1) {
+      const auto& [startQubit, length] = targetRegisters.front();
+      auto gate = qc::CompoundOperation(nqubits);
+      for (std::size_t i = 0; i < length; ++i) {
+        gate.emplace_back<qc::StandardOperation>(
+            nqubits, static_cast<qc::Qubit>(startQubit + i), info.type,
+            parameters);
+      }
+      return std::make_unique<qc::CompoundOperation>(std::move(gate));
+    }
+    error("Broadcasting not supported for multi-target gates.");
+  }
+
+  // the single control, single target case is special as we support
+  // broadcasting
+  if (info.nControls == 1) {
+    const auto& [startControl, lengthControl] = controlRegisters.front();
+    if (info.nTargets == 1) {
+      const auto& [startTarget, lengthTarget] = targetRegisters.front();
+      auto gate = qc::CompoundOperation(nqubits);
+      if (lengthControl == 1 && lengthTarget > 1) {
+        for (std::size_t i = 0; i < lengthTarget; ++i) {
+          gate.emplace_back<qc::StandardOperation>(
+              nqubits, qc::Control{startControl},
+              static_cast<qc::Qubit>(startTarget + i), info.type, parameters);
+        }
+        return std::make_unique<qc::CompoundOperation>(std::move(gate));
+      }
+      if (lengthControl > 1 && lengthTarget == 1) {
+        for (std::size_t i = 0; i < lengthControl; ++i) {
+          gate.emplace_back<qc::StandardOperation>(
+              nqubits, qc::Control{static_cast<qc::Qubit>(startControl + i)},
+              startTarget, info.type, parameters);
+        }
+        return std::make_unique<qc::CompoundOperation>(std::move(gate));
+      }
+      if (lengthControl == lengthTarget) {
+        for (std::size_t i = 0; i < lengthControl; ++i) {
+          gate.emplace_back<qc::StandardOperation>(
+              nqubits, qc::Control{static_cast<qc::Qubit>(startControl + i)},
+              static_cast<qc::Qubit>(startTarget + i), info.type, parameters);
+        }
+        return std::make_unique<qc::CompoundOperation>(std::move(gate));
+      }
+      error("Ill-formed broadcasting statement.");
+    }
+  }
+  error("Broadcasting not supported for multi-control, multi-target gates.");
+}
 
 } // namespace qasm
```

### Comparing `mqt.ddsim-1.17.3/extern/qfr/src/zx/FunctionalityConstruction.cpp` & `mqt.ddsim-1.18.0/extern/mqt-core/src/zx/FunctionalityConstruction.cpp`

 * *Files 13% similar despite different names*

```diff
@@ -1,440 +1,444 @@
-/*
-* This file is part of MQT QFR library which is released under the MIT license.
-* See file README.md or go to https://www.cda.cit.tum.de/research/quantum/ for more information.
-*/
-
 #include "zx/FunctionalityConstruction.hpp"
 
-#include "Definitions.hpp"
-#include "Rational.hpp"
-#include "ZXDiagram.hpp"
+#include "zx/Definitions.hpp"
+#include "zx/Rational.hpp"
+#include "zx/ZXDiagram.hpp"
 
 #include <algorithm>
 #include <string>
 #include <variant>
 #include <vector>
 
 namespace zx {
 
-    bool FunctionalityConstruction::checkSwap(const op_it& it, const op_it& end, const Qubit ctrl,
-                                              const Qubit            target,
-                                              const qc::Permutation& p) {
-        if (it + 1 != end && it + 2 != end) {
-            const auto& op1 = *(it + 1);
-            const auto& op2 = *(it + 2);
-            if (op1->getType() == qc::OpType::X && op2->getType() == qc::OpType::X &&
-                op1->getNcontrols() == 1 && op2->getNcontrols() == 1) {
-                const auto tar1  = p.at(op1->getTargets().front());
-                const auto tar2  = p.at(op2->getTargets().front());
-                const auto ctrl1 = p.at((*op1->getControls().begin()).qubit);
-                const auto ctrl2 = p.at((*op2->getControls().begin()).qubit);
-                return ctrl == static_cast<Qubit>(tar1) && tar1 == ctrl2 && target == static_cast<Qubit>(ctrl1) && ctrl1 == tar2;
-            }
-        }
-        return false;
-    }
-
-    void FunctionalityConstruction::addZSpider(ZXDiagram& diag, const zx::Qubit qubit,
-                                               std::vector<Vertex>& qubits,
-                                               const PiExpression& phase, const EdgeType type) {
-        const auto q = static_cast<std::size_t>(qubit);
-
-        auto newVertex = diag.addVertex(qubit, diag.getVData(qubits[q]).value().col + 1, phase, VertexType::Z);
-
-        diag.addEdge(qubits[q], newVertex, type);
-        qubits[q] = newVertex;
-    }
-
-    void FunctionalityConstruction::addXSpider(ZXDiagram& diag, const Qubit qubit,
-                                               std::vector<Vertex>& qubits,
-                                               const PiExpression& phase, const EdgeType type) {
-        const auto q         = static_cast<std::size_t>(qubit);
-        const auto newVertex = diag.addVertex(
-                qubit, diag.getVData(qubits[q]).value().col + 1, phase,
-                VertexType::X);
-        diag.addEdge(qubits[q], newVertex, type);
-        qubits[q] = newVertex;
-    }
-
-    void FunctionalityConstruction::addCnot(ZXDiagram& diag, const Qubit ctrl, const Qubit target,
-                                            std::vector<Vertex>& qubits) {
-        addZSpider(diag, ctrl, qubits);
-        addXSpider(diag, target, qubits);
-        diag.addEdge(qubits[static_cast<std::size_t>(ctrl)], qubits[static_cast<std::size_t>(target)]);
-    }
-
-    void
-    FunctionalityConstruction::addCphase(ZXDiagram& diag, const PiExpression& phase,
-                                         const Qubit ctrl, const Qubit target,
-                                         std::vector<Vertex>& qubits) {
-        auto newConst = phase.getConst() / 2;
-        auto newPhase = phase / 2.0;
-        newPhase.setConst(newConst);
-        addZSpider(diag, ctrl, qubits, newPhase); //todo maybe should provide a method for int division
-        addCnot(diag, ctrl, target, qubits);
-        addZSpider(diag, target, qubits, -newPhase);
+bool FunctionalityConstruction::checkSwap(const op_it& it, const op_it& end,
+                                          const Qubit ctrl, const Qubit target,
+                                          const qc::Permutation& p) {
+  if (it + 1 != end && it + 2 != end) {
+    const auto& op1 = *(it + 1);
+    const auto& op2 = *(it + 2);
+    if (op1->getType() == qc::OpType::X && op2->getType() == qc::OpType::X &&
+        op1->getNcontrols() == 1 && op2->getNcontrols() == 1) {
+      const auto tar1 = p.at(op1->getTargets().front());
+      const auto tar2 = p.at(op2->getTargets().front());
+      const auto ctrl1 = p.at((*op1->getControls().begin()).qubit);
+      const auto ctrl2 = p.at((*op2->getControls().begin()).qubit);
+      return ctrl == static_cast<Qubit>(tar1) && tar1 == ctrl2 &&
+             target == static_cast<Qubit>(ctrl1) && ctrl1 == tar2;
+    }
+  }
+  return false;
+}
+
+void FunctionalityConstruction::addZSpider(ZXDiagram& diag,
+                                           const zx::Qubit qubit,
+                                           std::vector<Vertex>& qubits,
+                                           const PiExpression& phase,
+                                           const EdgeType type) {
+  const auto q = static_cast<std::size_t>(qubit);
+  const auto& vData = diag.getVData(qubits[q]);
+  if (!vData.has_value()) {
+    return;
+  }
+  const auto newVertex =
+      diag.addVertex(qubit, vData->col + 1, phase, VertexType::Z);
+  diag.addEdge(qubits[q], newVertex, type);
+  qubits[q] = newVertex;
+}
+
+void FunctionalityConstruction::addXSpider(ZXDiagram& diag, const Qubit qubit,
+                                           std::vector<Vertex>& qubits,
+                                           const PiExpression& phase,
+                                           const EdgeType type) {
+  const auto q = static_cast<std::size_t>(qubit);
+  const auto& vData = diag.getVData(qubits[q]);
+  if (!vData.has_value()) {
+    return;
+  }
+  const auto newVertex =
+      diag.addVertex(qubit, vData->col + 1, phase, VertexType::X);
+  diag.addEdge(qubits[q], newVertex, type);
+  qubits[q] = newVertex;
+}
+
+void FunctionalityConstruction::addCnot(ZXDiagram& diag, const Qubit ctrl,
+                                        const Qubit target,
+                                        std::vector<Vertex>& qubits) {
+  addZSpider(diag, ctrl, qubits);
+  addXSpider(diag, target, qubits);
+  diag.addEdge(qubits[static_cast<std::size_t>(ctrl)],
+               qubits[static_cast<std::size_t>(target)]);
+}
+
+void FunctionalityConstruction::addCphase(ZXDiagram& diag,
+                                          const PiExpression& phase,
+                                          const Qubit ctrl, const Qubit target,
+                                          std::vector<Vertex>& qubits) {
+  auto newConst = phase.getConst() / 2;
+  auto newPhase = phase / 2.0;
+  newPhase.setConst(newConst);
+  addZSpider(diag, ctrl, qubits,
+             newPhase); // todo maybe should provide a method for int division
+  addCnot(diag, ctrl, target, qubits);
+  addZSpider(diag, target, qubits, -newPhase);
+  addCnot(diag, ctrl, target, qubits);
+  addZSpider(diag, target, qubits, newPhase);
+}
+
+void FunctionalityConstruction::addSwap(ZXDiagram& diag, const Qubit target,
+                                        const Qubit target2,
+                                        std::vector<Vertex>& qubits) {
+  const auto c = static_cast<std::size_t>(target);
+  const auto t = static_cast<std::size_t>(target2);
+
+  const auto s0 = qubits[t];
+  const auto s1 = qubits[c];
+
+  const auto& vData = diag.getVData(qubits[t]);
+  if (!vData.has_value()) {
+    return;
+  }
+  const auto col = vData->col + 1;
+
+  const auto t0 = diag.addVertex(target2, col);
+  const auto t1 = diag.addVertex(target, col);
+  diag.addEdge(s0, t1);
+  diag.addEdge(s1, t0);
+  qubits[t] = t0;
+  qubits[c] = t1;
+}
+
+void FunctionalityConstruction::addCcx(ZXDiagram& diag, const Qubit ctrl0,
+                                       const Qubit ctrl1, const Qubit target,
+                                       std::vector<Vertex>& qubits) {
+  addZSpider(diag, target, qubits, PiExpression(), EdgeType::Hadamard);
+  addCnot(diag, ctrl1, target, qubits);
+  addZSpider(diag, target, qubits, PiExpression(PiRational(-1, 4)));
+  addCnot(diag, ctrl0, target, qubits);
+  addZSpider(diag, target, qubits, PiExpression(PiRational(1, 4)));
+  addCnot(diag, ctrl1, target, qubits);
+  addZSpider(diag, ctrl1, qubits, PiExpression(PiRational(1, 4)));
+  addZSpider(diag, target, qubits, PiExpression(PiRational(-1, 4)));
+  addCnot(diag, ctrl0, target, qubits);
+  addZSpider(diag, target, qubits, PiExpression(PiRational(1, 4)));
+  addCnot(diag, ctrl0, ctrl1, qubits);
+  addZSpider(diag, ctrl0, qubits, PiExpression(PiRational(1, 4)));
+  addZSpider(diag, ctrl1, qubits, PiExpression(PiRational(-1, 4)));
+  addZSpider(diag, target, qubits, PiExpression(PiRational(0, 1)),
+             EdgeType::Hadamard);
+  addCnot(diag, ctrl0, ctrl1, qubits);
+}
+
+FunctionalityConstruction::op_it
+FunctionalityConstruction::parseOp(ZXDiagram& diag, op_it it, op_it end,
+                                   std::vector<Vertex>& qubits,
+                                   const qc::Permutation& p) {
+  const auto& op = *it;
+  // barrier statements are ignored
+  if (op->getType() == qc::OpType::Barrier) {
+    return it + 1;
+  }
+
+  if (!op->isControlled()) {
+    // single qubit gates
+    const auto target = static_cast<zx::Qubit>(p.at(op->getTargets().front()));
+    switch (op->getType()) {
+    case qc::OpType::Z:
+      addZSpider(diag, target, qubits, PiExpression(PiRational(1, 1)));
+      break;
+    case qc::OpType::RZ: {
+      const auto& param = parseParam(op.get(), 0);
+      diag.addGlobalPhase(-param / 2.0);
+
+      addZSpider(diag, target, qubits, parseParam(op.get(), 0));
+      break;
+    }
+    case qc::OpType::Phase:
+      addZSpider(diag, target, qubits, parseParam(op.get(), 0));
+      break;
+    case qc::OpType::X:
+      addXSpider(diag, target, qubits, PiExpression(PiRational(1, 1)));
+      break;
+    case qc::OpType::RX:
+      addXSpider(diag, target, qubits, parseParam(op.get(), 0));
+      break;
+    case qc::OpType::Y:
+      diag.addGlobalPhase(PiExpression{-PiRational(1, 2)});
+
+      addZSpider(diag, target, qubits, PiExpression(PiRational(1, 1)));
+      addXSpider(diag, target, qubits, PiExpression(PiRational(1, 1)));
+      break;
+    case qc::OpType::RY:
+      diag.addGlobalPhase(
+          PiExpression(-PiRational(op->getParameter().front()) / 2 +
+                       PiRational(1, 2) + PiRational(3, 2)));
+
+      addXSpider(diag, target, qubits, PiExpression(PiRational(1, 2)));
+      addZSpider(diag, target, qubits,
+                 parseParam(op.get(), 0) + PiRational(1, 1));
+      addXSpider(diag, target, qubits, PiExpression(PiRational(1, 2)));
+      addZSpider(diag, target, qubits, PiExpression(PiRational(3, 1)));
+      break;
+    case qc::OpType::T:
+      addZSpider(diag, target, qubits, PiExpression(PiRational(1, 4)));
+      break;
+    case qc::OpType::Tdag:
+      addZSpider(diag, target, qubits, PiExpression(PiRational(-1, 4)));
+      break;
+    case qc::OpType::S:
+      addZSpider(diag, target, qubits, PiExpression(PiRational(1, 2)));
+      break;
+    case qc::OpType::Sdag:
+      addZSpider(diag, target, qubits, PiExpression(PiRational(-1, 2)));
+      break;
+    case qc::OpType::U2:
+      addZSpider(diag, target, qubits,
+                 parseParam(op.get(), 1) - PiRational(1, 2));
+      addXSpider(diag, target, qubits, PiExpression(PiRational(1, 2)));
+      addZSpider(diag, target, qubits,
+                 parseParam(op.get(), 0) + PiRational(1, 2));
+      break;
+    case qc::OpType::U3:
+      addZSpider(diag, target, qubits, parseParam(op.get(), 2));
+      addXSpider(diag, target, qubits, PiExpression(PiRational(1, 2)));
+      addZSpider(diag, target, qubits,
+                 parseParam(op.get(), 0) + PiRational(1, 1));
+      addXSpider(diag, target, qubits, PiExpression(PiRational(1, 2)));
+      addZSpider(diag, target, qubits,
+                 parseParam(op.get(), 1) + PiRational(3, 1));
+      break;
+    case qc::OpType::SWAP: {
+      const auto target2 = static_cast<zx::Qubit>(p.at(op->getTargets()[1]));
+      addSwap(diag, target, target2, qubits);
+      break;
+    }
+    case qc::OpType::iSWAP: {
+      const auto target2 = static_cast<zx::Qubit>(p.at(op->getTargets()[1]));
+      addZSpider(diag, target, qubits, PiExpression(PiRational(1, 2)));
+      addZSpider(diag, target2, qubits, PiExpression(PiRational(1, 2)));
+      addZSpider(diag, target, qubits, PiExpression(), EdgeType::Hadamard);
+      // NOLINTNEXTLINE(readability-suspicious-call-argument)
+      addCnot(diag, target, target2, qubits);
+      addCnot(diag, target2, target, qubits);
+      addZSpider(diag, target2, qubits, PiExpression(), EdgeType::Hadamard);
+      break;
+    }
+    case qc::OpType::H:
+      addZSpider(diag, target, qubits, PiExpression(), EdgeType::Hadamard);
+      break;
+    case qc::OpType::Measure:
+    case qc::OpType::I:
+      break;
+    case qc::OpType::SX:
+      addXSpider(diag, target, qubits, PiExpression(PiRational(1, 2)));
+      break;
+    case qc::OpType::SXdag:
+      addXSpider(diag, target, qubits, PiExpression(PiRational(-1, 2)));
+      break;
+    default:
+      throw ZXException("Unsupported Operation: " +
+                        qc::toString(op->getType()));
+    }
+  } else if (op->getNcontrols() == 1 && op->getNtargets() == 1) {
+    // two-qubit controlled gates
+    const auto target = static_cast<zx::Qubit>(p.at(op->getTargets().front()));
+    const auto ctrl =
+        static_cast<zx::Qubit>(p.at((*op->getControls().begin()).qubit));
+    switch (op->getType()) { // TODO: any gate can be controlled
+    case qc::OpType::X:
+      // check if swap
+      if (checkSwap(it, end, ctrl, target, p)) {
+        addSwap(diag, target, ctrl, qubits);
+        return it + 3;
+      } else {
         addCnot(diag, ctrl, target, qubits);
-        addZSpider(diag, target, qubits, newPhase);
-    }
+      }
 
-    void FunctionalityConstruction::addSwap(ZXDiagram& diag, const Qubit target, const Qubit target2,
-                                            std::vector<Vertex>& qubits) {
-        const auto c = static_cast<std::size_t>(target);
-        const auto t = static_cast<std::size_t>(target2);
-
-        const auto s0 = qubits[t];
-        const auto s1 = qubits[c];
-
-        const auto t0 = diag.addVertex(target2, diag.getVData(qubits[t]).value().col + 1);
-        const auto t1 = diag.addVertex(target, diag.getVData(qubits[t]).value().col + 1);
-        diag.addEdge(s0, t1);
-        diag.addEdge(s1, t0);
-        qubits[t] = t0;
-        qubits[c] = t1;
-    }
-
-    void FunctionalityConstruction::addCcx(ZXDiagram& diag, const Qubit ctrl0, const Qubit ctrl1, const Qubit target,
-                                           std::vector<Vertex>& qubits) {
-        addZSpider(diag, target, qubits, PiExpression(), EdgeType::Hadamard);
-        addCnot(diag, ctrl1, target, qubits);
-        addZSpider(diag, target, qubits, PiExpression(PiRational(-1, 4)));
-        addCnot(diag, ctrl0, target, qubits);
-        addZSpider(diag, target, qubits, PiExpression(PiRational(1, 4)));
-        addCnot(diag, ctrl1, target, qubits);
-        addZSpider(diag, ctrl1, qubits, PiExpression(PiRational(1, 4)));
-        addZSpider(diag, target, qubits, PiExpression(PiRational(-1, 4)));
-        addCnot(diag, ctrl0, target, qubits);
-        addZSpider(diag, target, qubits, PiExpression(PiRational(1, 4)));
-        addCnot(diag, ctrl0, ctrl1, qubits);
-        addZSpider(diag, ctrl0, qubits, PiExpression(PiRational(1, 4)));
-        addZSpider(diag, ctrl1, qubits, PiExpression(PiRational(-1, 4)));
-        addZSpider(diag, target, qubits, PiExpression(PiRational(0, 1)),
-                   EdgeType::Hadamard);
-        addCnot(diag, ctrl0, ctrl1, qubits);
-    }
-
-    FunctionalityConstruction::op_it FunctionalityConstruction::parseOp(ZXDiagram& diag, op_it it, op_it end,
-                                                                        std::vector<Vertex>& qubits, const qc::Permutation& p) {
-        const auto& op = *it;
-        // barrier statements are ignored
-        if (op->getType() == qc::OpType::Barrier) {
-            return it + 1;
-        }
-
-        if (!op->isControlled()) {
-            // single qubit gates
-            const auto target = static_cast<zx::Qubit>(p.at(op->getTargets().front()));
-            switch (op->getType()) {
-                case qc::OpType::Z:
-                    addZSpider(diag, target, qubits,
-                               PiExpression(PiRational(1, 1)));
-                    break;
-                case qc::OpType::RZ: {
-                    const auto& param = parseParam(op.get(), 0);
-                    diag.addGlobalPhase(-param / 2.0);
-
-                    addZSpider(
-                            diag, target, qubits,
-                            parseParam(op.get(), 0));
-                    break;
-                }
-                case qc::OpType::Phase:
-                    addZSpider(diag, target, qubits, parseParam(op.get(), 0));
-                    break;
-                case qc::OpType::X:
-                    addXSpider(diag, target, qubits,
-                               PiExpression(PiRational(1, 1)));
-                    break;
-                case qc::OpType::RX:
-                    addXSpider(diag, target, qubits, parseParam(op.get(), 0));
-                    break;
-                case qc::OpType::Y:
-                    diag.addGlobalPhase(PiExpression{-PiRational(1, 2)});
-
-                    addZSpider(diag, target, qubits,
-                               PiExpression(PiRational(1, 1)));
-                    addXSpider(diag, target, qubits,
-                               PiExpression(PiRational(1, 1)));
-                    break;
-                case qc::OpType::RY:
-                    diag.addGlobalPhase(PiExpression(-PiRational(op->getParameter().front()) / 2 +
-                                                     PiRational(1, 2) + PiRational(3, 2)));
-
-                    addXSpider(diag, target, qubits,
-                               PiExpression(PiRational(1, 2)));
-                    addZSpider(diag, target, qubits,
-                               parseParam(op.get(), 0) + PiRational(1, 1));
-                    addXSpider(diag, target, qubits,
-                               PiExpression(PiRational(1, 2)));
-                    addZSpider(diag, target, qubits,
-                               PiExpression(PiRational(3, 1)));
-                    break;
-                case qc::OpType::T:
-                    addZSpider(diag, target, qubits,
-                               PiExpression(PiRational(1, 4)));
-                    break;
-                case qc::OpType::Tdag:
-                    addZSpider(diag, target, qubits,
-                               PiExpression(PiRational(-1, 4)));
-                    break;
-                case qc::OpType::S:
-                    addZSpider(diag, target, qubits,
-                               PiExpression(PiRational(1, 2)));
-                    break;
-                case qc::OpType::Sdag:
-                    addZSpider(diag, target, qubits,
-                               PiExpression(PiRational(-1, 2)));
-                    break;
-                case qc::OpType::U2:
-                    addZSpider(diag, target, qubits,
-                               parseParam(op.get(), 1) - PiRational(1, 2));
-                    addXSpider(diag, target, qubits,
-                               PiExpression(PiRational(1, 2)));
-                    addZSpider(diag, target, qubits,
-                               parseParam(op.get(), 0) + PiRational(1, 2));
-                    break;
-                case qc::OpType::U3:
-                    addZSpider(diag, target, qubits, parseParam(op.get(), 2));
-                    addXSpider(diag, target, qubits,
-                               PiExpression(PiRational(1, 2)));
-                    addZSpider(diag, target, qubits,
-                               parseParam(op.get(), 0) + PiRational(1, 1));
-                    addXSpider(diag, target, qubits,
-                               PiExpression(PiRational(1, 2)));
-                    addZSpider(diag, target, qubits,
-                               parseParam(op.get(), 1) + PiRational(3, 1));
-                    break;
-                case qc::OpType::SWAP: {
-                    const auto target2 = static_cast<zx::Qubit>(p.at(op->getTargets()[1]));
-                    addSwap(diag, target, target2, qubits);
-                    break;
-                }
-                case qc::OpType::iSWAP: {
-                    const auto target2 = static_cast<zx::Qubit>(p.at(op->getTargets()[1]));
-                    addZSpider(diag, target, qubits, PiExpression(PiRational(1, 2)));
-                    addZSpider(diag, target2, qubits, PiExpression(PiRational(1, 2)));
-                    addZSpider(diag, target, qubits, PiExpression(),
-                               EdgeType::Hadamard);
-                    addCnot(diag, target, target2, qubits); // NOLINT (readability-suspicious-call-argument)
-                    addCnot(diag, target2, target, qubits);
-                    addZSpider(diag, target2, qubits, PiExpression(),
-                               EdgeType::Hadamard);
-                    break;
-                }
-                case qc::OpType::H:
-                    addZSpider(diag, target, qubits, PiExpression(),
-                               EdgeType::Hadamard);
-                    break;
-                case qc::OpType::Measure:
-                case qc::OpType::I:
-                    break;
-                case qc::OpType::SX:
-                    addXSpider(diag, target, qubits, PiExpression(PiRational(1, 2)));
-                    break;
-                case qc::OpType::SXdag:
-                    addXSpider(diag, target, qubits, PiExpression(PiRational(-1, 2)));
-                    break;
-                default:
-                    throw ZXException("Unsupported Operation: " +
-                                      qc::toString(op->getType()));
-            }
-        } else if (op->getNcontrols() == 1 && op->getNtargets() == 1) {
-            // two-qubit controlled gates
-            const auto target = static_cast<zx::Qubit>(p.at(op->getTargets().front()));
-            const auto ctrl   = static_cast<zx::Qubit>(p.at((*op->getControls().begin()).qubit));
-            switch (op->getType()) { // TODO: any gate can be controlled
-                case qc::OpType::X:
-                    // check if swap
-                    if (checkSwap(it, end, ctrl, target, p)) {
-                        addSwap(diag, target, ctrl, qubits);
-                        return it + 3;
-                    } else {
-                        addCnot(diag, ctrl, target, qubits);
-                    }
-
-                    break;
-                case qc::OpType::Z:
-                    addZSpider(diag, target, qubits, PiExpression(),
-                               EdgeType::Hadamard);
-                    addCnot(diag, ctrl, target, qubits);
-                    addZSpider(diag, target, qubits, PiExpression(),
-                               EdgeType::Hadamard);
-
-                    break;
-
-                case qc::OpType::I:
-                    break;
-
-                case qc::OpType::Phase:
-                    addCphase(diag, parseParam(op.get(), 0), ctrl, target,
-                              qubits);
-                    break;
-
-                case qc::OpType::T:
-                    addCphase(diag, zx::PiExpression{PiRational(1, 4)}, ctrl,
-                              target, qubits);
-                    break;
-
-                case qc::OpType::S:
-                    addCphase(diag, zx::PiExpression{PiRational(1, 2)}, ctrl,
-                              target, qubits);
-                    break;
-
-                case qc::OpType::Tdag:
-                    addCphase(diag, zx::PiExpression{PiRational(-1, 4)}, ctrl,
-                              target, qubits);
-                    break;
-
-                case qc::OpType::Sdag:
-                    addCphase(diag, zx::PiExpression{PiRational(-1, 2)}, ctrl,
-                              target, qubits);
-                    break;
-                default:
-                    throw ZXException("Unsupported Controlled Operation: " +
-                                      qc::toString(op->getType()));
-            }
-        } else if (op->getNcontrols() == 2) {
-            // three-qubit controlled gates (ccx or ccz)
-            Qubit      ctrl0  = 0;
-            Qubit      ctrl1  = 0;
-            const auto target = static_cast<Qubit>(p.at(op->getTargets().front()));
-            int        i      = 0;
-            for (const auto& ctrl: op->getControls()) {
-                if (i++ == 0) {
-                    ctrl0 = static_cast<Qubit>(p.at(ctrl.qubit));
-                } else {
-                    ctrl1 = static_cast<Qubit>(p.at(ctrl.qubit));
-                }
-            }
-            switch (op->getType()) {
-                case qc::OpType::X:
-                    addCcx(diag, ctrl0, ctrl1, target, qubits);
-                    break;
-
-                case qc::OpType::Z:
-                    addZSpider(diag, target, qubits, PiExpression(),
-                               EdgeType::Hadamard);
-                    addCcx(diag, ctrl0, ctrl1, target, qubits);
-                    addZSpider(diag, target, qubits, PiExpression(),
-                               EdgeType::Hadamard);
-                    break;
-                default:
-                    throw ZXException("Unsupported Multi-control operation: " +
-                                      qc::toString(op->getType()));
-            }
-        } else {
-            throw ZXException("Unsupported Multi-control operation (" + std::to_string(op->getNcontrols()) + " ctrls)" + qc::toString(op->getType()));
-        }
-        return it + 1;
-    }
-
-    ZXDiagram FunctionalityConstruction::buildFunctionality(const qc::QuantumComputation* qc) {
-        ZXDiagram           diag(qc->getNqubits());
-        std::vector<Vertex> qubits(qc->getNqubits());
-        for (std::size_t i = 0; i < qc->getNqubits(); ++i) {
-            diag.removeEdge(i, i + qc->getNqubits());
-            qubits[i] = i;
-        }
-
-        for (auto it = qc->cbegin(); it != qc->cend();) {
-            const auto& op = *it;
-
-            if (op->getType() == qc::OpType::Compound) {
-                const auto* compOp = dynamic_cast<qc::CompoundOperation*>(op.get());
-                for (auto subIt = compOp->cbegin(); subIt != compOp->cend();) {
-                    subIt = parseOp(diag, subIt, compOp->cend(), qubits, qc->initialLayout);
-                }
-                ++it;
-            } else {
-                it = parseOp(diag, it, qc->cend(), qubits, qc->initialLayout);
-            }
-        }
-
-        for (std::size_t i = 0; i < qubits.size(); ++i) {
-            diag.addEdge(qubits[i], diag.getOutput(i));
-        }
-        return diag;
-    }
-    bool FunctionalityConstruction::transformableToZX(const qc::QuantumComputation* qc) {
-        return std::all_of(qc->cbegin(), qc->cend(), [&](const auto& op) { return transformableToZX(op.get()); });
-    }
-
-    bool FunctionalityConstruction::transformableToZX(const qc::Operation* op) {
-        if (op->getType() == qc::OpType::Compound) {
-            const auto* compOp = dynamic_cast<const qc::CompoundOperation*>(op);
-
-            return std::all_of(compOp->cbegin(), compOp->cend(), [&](const auto& operation) { return transformableToZX(operation.get()); });
-        }
-
-        if (op->getType() == qc::OpType::Barrier) {
-            return true;
-        }
-
-        if (!op->isControlled()) {
-            switch (op->getType()) {
-                case qc::OpType::Z:
-                case qc::OpType::RZ:
-                case qc::OpType::Phase:
-                case qc::OpType::X:
-                case qc::OpType::RX:
-                case qc::OpType::Y:
-                case qc::OpType::RY:
-                case qc::OpType::T:
-                case qc::OpType::Tdag:
-                case qc::OpType::S:
-                case qc::OpType::Sdag:
-                case qc::OpType::U2:
-                case qc::OpType::U3:
-                case qc::OpType::SWAP:
-                case qc::OpType::iSWAP:
-                case qc::OpType::H:
-                case qc::OpType::Measure:
-                case qc::OpType::I:
-                case qc::OpType::SX:
-                case qc::OpType::SXdag:
-                    return true;
-                default:
-                    return false;
-            }
-        } else if (op->getNcontrols() == 1 && op->getNtargets() == 1) {
-            switch (op->getType()) { // TODO: any gate can be controlled
-                case qc::OpType::X:
-                case qc::OpType::Z:
-                case qc::OpType::I:
-                case qc::OpType::Phase:
-                case qc::OpType::T:
-                case qc::OpType::S:
-                case qc::OpType::Tdag:
-                case qc::OpType::Sdag:
-                    return true;
-
-                default:
-                    return false;
-            }
-        } else if (op->getNcontrols() == 2) {
-            switch (op->getType()) {
-                case qc::OpType::X:
-                case qc::OpType::Z:
-                    return true;
-                default:
-                    return false;
-            }
-        }
-        return false;
-    }
-
-    PiExpression FunctionalityConstruction::parseParam(const qc::Operation* op,
-                                                       const std::size_t    i) {
-        if (const auto* symbOp = dynamic_cast<const qc::SymbolicOperation*>(op)) {
-            return toPiExpr(symbOp->getParameter(i));
-        }
-        return PiExpression{zx::PiRational{op->getParameter().at(i)}};
-    }
-    PiExpression FunctionalityConstruction::toPiExpr(const qc::SymbolOrNumber& param) {
-        if (std::holds_alternative<double>(param)) {
-            return zx::PiExpression{
-                    zx::PiRational{std::get<double>(param)}};
-        }
-        return std::get<qc::Symbolic>(param).convert<zx::PiRational>();
-    }
+      break;
+    case qc::OpType::Z:
+      addZSpider(diag, target, qubits, PiExpression(), EdgeType::Hadamard);
+      addCnot(diag, ctrl, target, qubits);
+      addZSpider(diag, target, qubits, PiExpression(), EdgeType::Hadamard);
+
+      break;
+
+    case qc::OpType::I:
+      break;
+
+    case qc::OpType::Phase:
+      addCphase(diag, parseParam(op.get(), 0), ctrl, target, qubits);
+      break;
+
+    case qc::OpType::T:
+      addCphase(diag, zx::PiExpression{PiRational(1, 4)}, ctrl, target, qubits);
+      break;
+
+    case qc::OpType::S:
+      addCphase(diag, zx::PiExpression{PiRational(1, 2)}, ctrl, target, qubits);
+      break;
+
+    case qc::OpType::Tdag:
+      addCphase(diag, zx::PiExpression{PiRational(-1, 4)}, ctrl, target,
+                qubits);
+      break;
+
+    case qc::OpType::Sdag:
+      addCphase(diag, zx::PiExpression{PiRational(-1, 2)}, ctrl, target,
+                qubits);
+      break;
+    default:
+      throw ZXException("Unsupported Controlled Operation: " +
+                        qc::toString(op->getType()));
+    }
+  } else if (op->getNcontrols() == 2) {
+    // three-qubit controlled gates (ccx or ccz)
+    Qubit ctrl0 = 0;
+    Qubit ctrl1 = 0;
+    const auto target = static_cast<Qubit>(p.at(op->getTargets().front()));
+    int i = 0;
+    for (const auto& ctrl : op->getControls()) {
+      if (i++ == 0) {
+        ctrl0 = static_cast<Qubit>(p.at(ctrl.qubit));
+      } else {
+        ctrl1 = static_cast<Qubit>(p.at(ctrl.qubit));
+      }
+    }
+    switch (op->getType()) {
+    case qc::OpType::X:
+      addCcx(diag, ctrl0, ctrl1, target, qubits);
+      break;
+
+    case qc::OpType::Z:
+      addZSpider(diag, target, qubits, PiExpression(), EdgeType::Hadamard);
+      addCcx(diag, ctrl0, ctrl1, target, qubits);
+      addZSpider(diag, target, qubits, PiExpression(), EdgeType::Hadamard);
+      break;
+    default:
+      throw ZXException("Unsupported Multi-control operation: " +
+                        qc::toString(op->getType()));
+    }
+  } else {
+    throw ZXException("Unsupported Multi-control operation (" +
+                      std::to_string(op->getNcontrols()) + " ctrls)" +
+                      qc::toString(op->getType()));
+  }
+  return it + 1;
+}
+
+ZXDiagram FunctionalityConstruction::buildFunctionality(
+    const qc::QuantumComputation* qc) {
+  ZXDiagram diag(qc->getNqubits());
+  std::vector<Vertex> qubits(qc->getNqubits());
+  for (std::size_t i = 0; i < qc->getNqubits(); ++i) {
+    diag.removeEdge(i, i + qc->getNqubits());
+    qubits[i] = i;
+  }
+
+  for (auto it = qc->cbegin(); it != qc->cend();) {
+    const auto& op = *it;
+
+    if (op->getType() == qc::OpType::Compound) {
+      const auto* compOp = dynamic_cast<qc::CompoundOperation*>(op.get());
+      for (auto subIt = compOp->cbegin(); subIt != compOp->cend();) {
+        subIt = parseOp(diag, subIt, compOp->cend(), qubits, qc->initialLayout);
+      }
+      ++it;
+    } else {
+      it = parseOp(diag, it, qc->cend(), qubits, qc->initialLayout);
+    }
+  }
+
+  for (std::size_t i = 0; i < qubits.size(); ++i) {
+    diag.addEdge(qubits[i], diag.getOutput(i));
+  }
+  return diag;
+}
+bool FunctionalityConstruction::transformableToZX(
+    const qc::QuantumComputation* qc) {
+  return std::all_of(qc->cbegin(), qc->cend(), [&](const auto& op) {
+    return transformableToZX(op.get());
+  });
+}
+
+bool FunctionalityConstruction::transformableToZX(const qc::Operation* op) {
+  if (op->getType() == qc::OpType::Compound) {
+    const auto* compOp = dynamic_cast<const qc::CompoundOperation*>(op);
+
+    return std::all_of(compOp->cbegin(), compOp->cend(),
+                       [&](const auto& operation) {
+                         return transformableToZX(operation.get());
+                       });
+  }
+
+  if (op->getType() == qc::OpType::Barrier) {
+    return true;
+  }
+
+  if (!op->isControlled()) {
+    switch (op->getType()) {
+    case qc::OpType::Z:
+    case qc::OpType::RZ:
+    case qc::OpType::Phase:
+    case qc::OpType::X:
+    case qc::OpType::RX:
+    case qc::OpType::Y:
+    case qc::OpType::RY:
+    case qc::OpType::T:
+    case qc::OpType::Tdag:
+    case qc::OpType::S:
+    case qc::OpType::Sdag:
+    case qc::OpType::U2:
+    case qc::OpType::U3:
+    case qc::OpType::SWAP:
+    case qc::OpType::iSWAP:
+    case qc::OpType::H:
+    case qc::OpType::Measure:
+    case qc::OpType::I:
+    case qc::OpType::SX:
+    case qc::OpType::SXdag:
+      return true;
+    default:
+      return false;
+    }
+  } else if (op->getNcontrols() == 1 && op->getNtargets() == 1) {
+    switch (op->getType()) { // TODO: any gate can be controlled
+    case qc::OpType::X:
+    case qc::OpType::Z:
+    case qc::OpType::I:
+    case qc::OpType::Phase:
+    case qc::OpType::T:
+    case qc::OpType::S:
+    case qc::OpType::Tdag:
+    case qc::OpType::Sdag:
+      return true;
+
+    default:
+      return false;
+    }
+  } else if (op->getNcontrols() == 2) {
+    switch (op->getType()) {
+    case qc::OpType::X:
+    case qc::OpType::Z:
+      return true;
+    default:
+      return false;
+    }
+  }
+  return false;
+}
+
+PiExpression FunctionalityConstruction::parseParam(const qc::Operation* op,
+                                                   const std::size_t i) {
+  if (const auto* symbOp = dynamic_cast<const qc::SymbolicOperation*>(op)) {
+    return toPiExpr(symbOp->getParameter(i));
+  }
+  return PiExpression{zx::PiRational{op->getParameter().at(i)}};
+}
+PiExpression
+FunctionalityConstruction::toPiExpr(const qc::SymbolOrNumber& param) {
+  if (std::holds_alternative<double>(param)) {
+    return zx::PiExpression{zx::PiRational{std::get<double>(param)}};
+  }
+  return std::get<qc::Symbolic>(param).convert<zx::PiRational>();
+}
 } // namespace zx
```

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/.vscode/settings.json` & `mqt.ddsim-1.18.0/extern/taskflow/.vscode/settings.json`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/CMakeLists.txt` & `mqt.ddsim-1.18.0/extern/taskflow/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/README.md` & `mqt.ddsim-1.18.0/extern/taskflow/README.md`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/cmake/ComputeCpp/Modules/ComputeCppCompilerChecks.cmake` & `mqt.ddsim-1.18.0/extern/taskflow/cmake/ComputeCpp/Modules/ComputeCppCompilerChecks.cmake`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/cmake/ComputeCpp/Modules/FindComputeCpp.cmake` & `mqt.ddsim-1.18.0/extern/taskflow/cmake/ComputeCpp/Modules/FindComputeCpp.cmake`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/cmake/ComputeCpp/toolchains/arm-gcc-poky.cmake` & `mqt.ddsim-1.18.0/extern/taskflow/cmake/ComputeCpp/toolchains/arm-gcc-poky.cmake`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/cmake/ComputeCpp/toolchains/gcc-generic.cmake` & `mqt.ddsim-1.18.0/extern/taskflow/cmake/ComputeCpp/toolchains/gcc-generic.cmake`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/cmake/cuda/modules/FindcuBLAS.cmake` & `mqt.ddsim-1.18.0/extern/taskflow/cmake/cuda/modules/FindcuBLAS.cmake`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/algorithm/critical.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/algorithm/critical.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/algorithm/data_pipeline.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/algorithm/data_pipeline.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/algorithm/find.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/algorithm/find.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/algorithm/for_each.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/algorithm/for_each.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/algorithm/launch.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/algorithm/launch.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/algorithm/partitioner.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/algorithm/partitioner.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/algorithm/pipeline.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/algorithm/pipeline.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/algorithm/reduce.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/algorithm/reduce.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/algorithm/scan.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/algorithm/scan.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/algorithm/sort.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/algorithm/sort.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/algorithm/transform.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/algorithm/transform.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/async.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/async.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/async_task.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/async_task.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/declarations.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/declarations.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/error.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/error.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/executor-module-opt.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/executor-module-opt.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/executor.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/executor.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/flow_builder.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/flow_builder.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/graph.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/graph.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/notifier.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/notifier.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/observer.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/observer.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/semaphore.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/semaphore.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/task.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/task.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/taskflow.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/taskflow.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/topology.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/topology.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/tsq.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/tsq.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/core/worker.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/core/worker.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/algorithm/find.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/algorithm/find.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/algorithm/for_each.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/algorithm/for_each.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/algorithm/matmul.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/algorithm/matmul.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/algorithm/merge.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/algorithm/merge.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/algorithm/reduce.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/algorithm/reduce.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/algorithm/scan.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/algorithm/scan.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/algorithm/sort.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/algorithm/sort.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/algorithm/transform.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/algorithm/transform.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/algorithm/transpose.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/algorithm/transpose.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/cuda_capturer.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/cuda_capturer.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/cuda_device.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/cuda_device.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/cuda_error.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/cuda_error.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/cuda_execution_policy.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/cuda_execution_policy.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/cuda_graph.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/cuda_graph.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/cuda_memory.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/cuda_memory.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/cuda_meta.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/cuda_meta.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/cuda_object.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/cuda_object.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/cuda_optimizer.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/cuda_optimizer.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/cuda_stream.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/cuda_stream.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/cuda_task.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/cuda_task.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/cuda/cudaflow.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/cuda/cudaflow.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/dsl/connection.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/dsl/connection.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/dsl/meta_macro.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/dsl/meta_macro.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/dsl/task_analyzer.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/dsl/task_analyzer.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/dsl/task_dsl.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/dsl/task_dsl.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/dsl/task_trait.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/dsl/task_trait.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/dsl/tuple_utils.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/dsl/tuple_utils.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/dsl/type_list.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/dsl/type_list.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/sycl/algorithm/reduce.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/sycl/algorithm/reduce.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/sycl/algorithm/sycl_for_each.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/sycl/algorithm/sycl_for_each.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/sycl/algorithm/sycl_transform.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/sycl/algorithm/sycl_transform.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/sycl/sycl_execution_policy.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/sycl/sycl_execution_policy.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/sycl/sycl_graph.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/sycl/sycl_graph.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/sycl/sycl_meta.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/sycl/sycl_meta.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/sycl/sycl_task.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/sycl/sycl_task.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/sycl/syclflow.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/sycl/syclflow.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/taskflow.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/taskflow.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/utility/iterator.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/utility/iterator.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/utility/math.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/utility/math.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/utility/object_pool.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/utility/object_pool.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/utility/os.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/utility/os.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/utility/serializer.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/utility/serializer.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/utility/singleton.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/utility/singleton.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/utility/small_vector.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/utility/small_vector.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/utility/stream.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/utility/stream.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/utility/traits.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/utility/traits.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/extern/taskflow/taskflow/utility/uuid.hpp` & `mqt.ddsim-1.18.0/extern/taskflow/taskflow/utility/uuid.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/include/CircuitSimulator.hpp` & `mqt.ddsim-1.18.0/include/CircuitSimulator.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/include/DeterministicNoiseSimulator.hpp` & `mqt.ddsim-1.18.0/include/DeterministicNoiseSimulator.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/include/GroverSimulator.hpp` & `mqt.ddsim-1.18.0/include/GroverSimulator.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/include/HybridSchrodingerFeynmanSimulator.hpp` & `mqt.ddsim-1.18.0/include/HybridSchrodingerFeynmanSimulator.hpp`

 * *Files 0% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 #ifndef DDSIM_HYBRIDSCHRODINGERFEYNMANSIMULATOR_HPP
 #define DDSIM_HYBRIDSCHRODINGERFEYNMANSIMULATOR_HPP
 
 #include "CircuitOptimizer.hpp"
 #include "CircuitSimulator.hpp"
-#include "Operations.hpp"
 #include "QuantumComputation.hpp"
 #include "dd/Export.hpp"
+#include "dd/Operations.hpp"
 #include "dd/Package.hpp"
 
 #include <complex>
 #include <memory>
 
 template<class Config = dd::DDPackageConfig>
 class HybridSchrodingerFeynmanSimulator: public CircuitSimulator<Config> {
```

### Comparing `mqt.ddsim-1.17.3/include/PathSimulator.hpp` & `mqt.ddsim-1.18.0/include/PathSimulator.hpp`

 * *Files 0% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 #ifndef DDSIM_PATHSIMULATOR_HPP
 #define DDSIM_PATHSIMULATOR_HPP
 
 #include "CircuitOptimizer.hpp"
 #include "CircuitSimulator.hpp"
-#include "Operations.hpp"
+#include "dd/Operations.hpp"
 #include "nlohmann/json.hpp"
 
 #include <future>
 #include <limits>
 #include <taskflow/taskflow.hpp>
 #include <thread>
 #include <unordered_map>
```

### Comparing `mqt.ddsim-1.17.3/include/ShorFastSimulator.hpp` & `mqt.ddsim-1.18.0/include/ShorFastSimulator.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/include/ShorSimulator.hpp` & `mqt.ddsim-1.18.0/include/ShorSimulator.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/include/Simulator.hpp` & `mqt.ddsim-1.18.0/include/Simulator.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/include/StochasticNoiseSimulator.hpp` & `mqt.ddsim-1.18.0/include/StochasticNoiseSimulator.hpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/include/UnitarySimulator.hpp` & `mqt.ddsim-1.18.0/include/UnitarySimulator.hpp`

 * *Files 3% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 #ifndef DDSIM_UNITARYSIMULATOR_HPP
 #define DDSIM_UNITARYSIMULATOR_HPP
 
 #include "CircuitOptimizer.hpp"
 #include "CircuitSimulator.hpp"
-#include "Operations.hpp"
 #include "QuantumComputation.hpp"
+#include "dd/Operations.hpp"
 #include "dd/Package.hpp"
 
 #include <memory>
 
 template<class Config = dd::DDPackageConfig>
 class UnitarySimulator: public CircuitSimulator<Config> {
 public:
```

### Comparing `mqt.ddsim-1.17.3/mqt/ddsim/__init__.py` & `mqt.ddsim-1.18.0/mqt/ddsim/__init__.py`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/mqt/ddsim/bindings.cpp` & `mqt.ddsim-1.18.0/mqt/ddsim/bindings.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -3,16 +3,16 @@
  * See file README.md or go to https://iic.jku.at/eda/research/quantum/ for more information.
  */
 // clang-format off
 #include "CircuitSimulator.hpp"
 #include "HybridSchrodingerFeynmanSimulator.hpp"
 #include "PathSimulator.hpp"
 #include "UnitarySimulator.hpp"
-#include "qiskit/QasmQobjExperiment.hpp"
-#include "qiskit/QuantumCircuit.hpp"
+#include "python/qiskit/QasmQobjExperiment.hpp"
+#include "python/qiskit/QuantumCircuit.hpp"
 
 #include <pybind11/numpy.h>
 #include <pybind11/pybind11.h>
 #include <pybind11/stl.h>
 
 #include <memory>
 // clang-format on
```

### Comparing `mqt.ddsim-1.17.3/mqt/ddsim/hybridqasmsimulator.py` & `mqt.ddsim-1.18.0/mqt/ddsim/hybridqasmsimulator.py`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/mqt/ddsim/hybridstatevectorsimulator.py` & `mqt.ddsim-1.18.0/mqt/ddsim/hybridstatevectorsimulator.py`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/mqt/ddsim/job.py` & `mqt.ddsim-1.18.0/mqt/ddsim/job.py`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/mqt/ddsim/pathqasmsimulator.py` & `mqt.ddsim-1.18.0/mqt/ddsim/pathqasmsimulator.py`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/mqt/ddsim/pathstatevectorsimulator.py` & `mqt.ddsim-1.18.0/mqt/ddsim/pathstatevectorsimulator.py`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/mqt/ddsim/provider.py` & `mqt.ddsim-1.18.0/mqt/ddsim/provider.py`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/mqt/ddsim/qasmsimulator.py` & `mqt.ddsim-1.18.0/mqt/ddsim/qasmsimulator.py`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/mqt/ddsim/statevectorsimulator.py` & `mqt.ddsim-1.18.0/mqt/ddsim/statevectorsimulator.py`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/mqt/ddsim/unitarysimulator.py` & `mqt.ddsim-1.18.0/mqt/ddsim/unitarysimulator.py`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/mqt.ddsim.egg-info/PKG-INFO` & `mqt.ddsim-1.18.0/mqt.ddsim.egg-info/PKG-INFO`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: mqt.ddsim
-Version: 1.17.3
+Version: 1.18.0
 Summary: A quantum simulator based on decision diagrams written in C++
 Author-email: Stefan Hillmich <stefan.hillmich@jku.at>, Lukas Burgholzer <lukas.burgholzer@jku.at>
 License: MIT License
         
         Copyright (c) 2021 Stefan Hillmich, Lukas Burgholzer, Thomas Grurl, and Robert Wille
         
         Permission is hereby granted, free of charge, to any person obtaining a copy
@@ -69,15 +69,15 @@
   </picture>
 </p>
 
 # MQT DDSIM - A quantum circuit simulator based on decision diagrams written in C++
 
 A tool for classical quantum circuit simulation by the [Chair for Design Automation](https://www.cda.cit.tum.de/) at the [Technical University of Munich](https://www.tum.de/).
 QCEC is part of the Munich Quantum Toolkit (MQT; formerly known as JKQ and developed by the [Institute for Integrated Circuits](https://iic.jku.at/eda/) at the [Johannes Kepler University Linz](https://jku.at)).
-It builds upon [our quantum functionality representation (QFR)](https://github.com/cda-tum/qfr) and [our decision diagram (DD) package](https://github.com/cda-tum/dd_package.git).
+It builds upon [MQT Core](https://github.com/cda-tum/mqt-core).
 
 **Detailed documentation on all available formats, options, and algorithms is available at [ReadTheDocs](https://ddsim.readthedocs.io/en/latest/).**
 
 If you have any questions, feel free to contact us via [quantum.cda@xcit.tum.de](mailto:quantum.cda@xcit.tum.de) or by creating an [issue](https://github.com/cda-tum/ddsim/issues) on GitHub.
 
 ## Getting Started
```

### Comparing `mqt.ddsim-1.17.3/noxfile.py` & `mqt.ddsim-1.18.0/noxfile.py`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/pyproject.toml` & `mqt.ddsim-1.18.0/pyproject.toml`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/scripts/approximation.sh` & `mqt.ddsim-1.18.0/scripts/approximation.sh`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/scripts/hybrid_simulation.sh` & `mqt.ddsim-1.18.0/scripts/hybrid_simulation.sh`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/scripts/primebases_timing_shor.sh` & `mqt.ddsim-1.18.0/scripts/primebases_timing_shor.sh`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/setup.py` & `mqt.ddsim-1.18.0/setup.py`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/src/CMakeLists.txt` & `mqt.ddsim-1.18.0/src/CMakeLists.txt`

 * *Files 3% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-add_subdirectory("${PROJECT_SOURCE_DIR}/extern/qfr" "extern/qfr"
+add_subdirectory("${PROJECT_SOURCE_DIR}/extern/mqt-core" "extern/mqt-core"
                  EXCLUDE_FROM_ALL)
 
 add_library(
   ${PROJECT_NAME}
   ${PROJECT_SOURCE_DIR}/include/Simulator.hpp
   ${CMAKE_CURRENT_SOURCE_DIR}/Simulator.cpp
   ${PROJECT_SOURCE_DIR}/include/CircuitSimulator.hpp
@@ -27,15 +27,15 @@
   ${PROJECT_NAME}
   PUBLIC $<BUILD_INTERFACE:${${PROJECT_NAME}_SOURCE_DIR}/include>)
 
 # cmake-lint: disable=C0103
 set(JSON_MultipleHeaders
     OFF
     CACHE INTERNAL "")
-target_link_libraries(${PROJECT_NAME} PUBLIC MQT::qfr_dd)
+target_link_libraries(${PROJECT_NAME} PUBLIC MQT::CoreDD)
 
 set(TF_BUILD_TESTS
     OFF
     CACHE BOOL "")
 set(TF_BUILD_EXAMPLES
     OFF
     CACHE BOOL "")
```

### Comparing `mqt.ddsim-1.17.3/src/CircuitSimulator.cpp` & `mqt.ddsim-1.18.0/src/CircuitSimulator.cpp`

 * *Files 0% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 #include "CircuitSimulator.hpp"
 
 #include "CircuitOptimizer.hpp"
-#include "Operations.hpp"
 #include "dd/Export.hpp"
 #include "dd/FunctionalityConstruction.hpp"
+#include "dd/Operations.hpp"
 
 template<class Config>
 std::map<std::string, std::size_t> CircuitSimulator<Config>::simulate(std::size_t shots) {
     bool hasNonmeasurementNonUnitary = false;
     bool hasMeasurements             = false;
     bool measurementsLast            = true;
```

### Comparing `mqt.ddsim-1.17.3/src/DeterministicNoiseSimulator.cpp` & `mqt.ddsim-1.18.0/src/DeterministicNoiseSimulator.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/src/GroverSimulator.cpp` & `mqt.ddsim-1.18.0/src/GroverSimulator.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/src/HybridSchrodingerFeynmanSimulator.cpp` & `mqt.ddsim-1.18.0/src/HybridSchrodingerFeynmanSimulator.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/src/PathSimulator.cpp` & `mqt.ddsim-1.18.0/src/PathSimulator.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/src/ShorFastSimulator.cpp` & `mqt.ddsim-1.18.0/src/ShorFastSimulator.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/src/ShorSimulator.cpp` & `mqt.ddsim-1.18.0/src/ShorSimulator.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/src/Simulator.cpp` & `mqt.ddsim-1.18.0/src/Simulator.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/src/StochasticNoiseSimulator.cpp` & `mqt.ddsim-1.18.0/src/StochasticNoiseSimulator.cpp`

 * *Files identical despite different names*

### Comparing `mqt.ddsim-1.17.3/src/UnitarySimulator.cpp` & `mqt.ddsim-1.18.0/src/UnitarySimulator.cpp`

 * *Files identical despite different names*

