# Comparing `tmp/whitebox_workflows-1.0.9-cp37-abi3-win_amd64.whl.zip` & `tmp/whitebox_workflows-1.1.0-cp37-abi3-macosx_11_0_arm64.whl.zip`

## zipinfo {}

```diff
@@ -1,10 +1,10 @@
-Zip file size: 9260616 bytes, number of entries: 8
--rw-r--r--  4.6 unx     9132 b- defN 23-Mar-01 19:30 whitebox_workflows-1.0.9.dist-info/METADATA
--rw-r--r--  4.6 unx       96 b- defN 23-Mar-01 19:30 whitebox_workflows-1.0.9.dist-info/WHEEL
--rw-r--r--  4.6 unx      161 b- defN 23-Mar-01 19:30 whitebox_workflows-1.0.9.dist-info/license_files/LICENSE.txt
--rw-r--r--  4.6 unx      155 b- defN 23-Mar-01 19:30 whitebox_workflows/__init__.py
--rw-r--r--  4.6 unx    86536 b- defN 23-Mar-01 19:30 whitebox_workflows/__init__.pyi
--rw-r--r--  4.6 unx        0 b- defN 23-Mar-01 19:30 whitebox_workflows/py.typed
--rwxr-xr-x  4.6 unx 32744960 b- defN 23-Mar-01 19:30 whitebox_workflows/whitebox_workflows.pyd
--rw-r--r--  4.6 unx      713 b- defN 23-Mar-01 19:30 whitebox_workflows-1.0.9.dist-info/RECORD
-8 files, 32841753 bytes uncompressed, 9259360 bytes compressed:  71.8%
+Zip file size: 7613069 bytes, number of entries: 8
+-rw-r--r--  4.6 unx     9842 b- defN 23-Jun-17 18:04 whitebox_workflows-1.1.0.dist-info/METADATA
+-rw-r--r--  4.6 unx      103 b- defN 23-Jun-17 18:04 whitebox_workflows-1.1.0.dist-info/WHEEL
+-rw-r--r--  4.6 unx      161 b- defN 23-Jun-17 18:04 whitebox_workflows-1.1.0.dist-info/license_files/LICENSE.txt
+-rw-r--r--  4.6 unx      155 b- defN 23-Jun-17 18:04 whitebox_workflows/__init__.py
+-rw-r--r--  4.6 unx    87574 b- defN 23-Jun-17 18:04 whitebox_workflows/__init__.pyi
+-rw-r--r--  4.6 unx        0 b- defN 23-Jun-17 18:04 whitebox_workflows/py.typed
+-rwxr-xr-x  4.6 unx 21274999 b- defN 23-Jun-17 18:04 whitebox_workflows/whitebox_workflows.abi3.so
+-rw-r--r--  4.6 unx      718 b- defN 23-Jun-17 18:04 whitebox_workflows-1.1.0.dist-info/RECORD
+8 files, 21373552 bytes uncompressed, 7611805 bytes compressed:  64.4%
```

## zipnote {}

```diff
@@ -1,25 +1,25 @@
-Filename: whitebox_workflows-1.0.9.dist-info/METADATA
+Filename: whitebox_workflows-1.1.0.dist-info/METADATA
 Comment: 
 
-Filename: whitebox_workflows-1.0.9.dist-info/WHEEL
+Filename: whitebox_workflows-1.1.0.dist-info/WHEEL
 Comment: 
 
-Filename: whitebox_workflows-1.0.9.dist-info/license_files/LICENSE.txt
+Filename: whitebox_workflows-1.1.0.dist-info/license_files/LICENSE.txt
 Comment: 
 
 Filename: whitebox_workflows/__init__.py
 Comment: 
 
 Filename: whitebox_workflows/__init__.pyi
 Comment: 
 
 Filename: whitebox_workflows/py.typed
 Comment: 
 
-Filename: whitebox_workflows/whitebox_workflows.pyd
+Filename: whitebox_workflows/whitebox_workflows.abi3.so
 Comment: 
 
-Filename: whitebox_workflows-1.0.9.dist-info/RECORD
+Filename: whitebox_workflows-1.1.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## whitebox_workflows/__init__.pyi

```diff
@@ -824,14 +824,16 @@
 
 	def log10(self) -> Raster: ...
 
 	def max(self, other: Union[Raster, float]) -> Raster: ...
 
 	def min(self, other: Union[Raster, float]) -> Raster: ...
 
+	def normalize(self) -> Raster: ...
+
 	def signum(self) -> Raster: ...
 
 	def sin(self) -> Raster: ...
 
 	def sinh(self) -> Raster: ...
 
 	def sqrt(self) -> Raster: ...
@@ -1304,14 +1306,16 @@
 	
 	def depth_in_sink(self, dem: Raster, zero_background: bool = False) -> Raster: ...
 
 	def depth_to_water(self, dem: Raster, streams: Optional[Vector] = None, lakes: Optional[Vector] = None) -> Raster: ...
 
 	def deviation_from_mean_elevation(self, dem: Raster, filter_size_x: int = 11, filter_size_y: int = 11) -> Raster: ...
 
+	def deviation_from_regional_direction(self, input: Vector, elongation_threshold: float = 0.75) -> Vector: ...
+
 	def diff_of_gaussians_filter(self, raster: Raster, sigma1: float = 2.0, sigma2: float = 4.0) -> Raster: ...
 
 	def difference(self, input: Vector, overlay: Vector) -> Vector: ...
 
 	def difference_curvature(self, dem: Raster, log_transform: bool = False, z_factor: float = 1.0) -> Raster: ...
 
 	def difference_from_mean_elevation(self, dem: Raster, filter_size_x: int = 11, filter_size_y: int = 11) -> Raster: ...
@@ -1380,14 +1384,16 @@
 
 	def export_table_to_csv(self, input: Vector, output_csv_file: str, headers: bool = True) -> None: ...
 
 	def exposure_towards_wind_flux(self, dem: Raster, azimuth: float = 0.0, max_dist: float = float('inf'), z_factor: float = 1.0) -> Raster: ...
 
 	def extend_vector_lines(self, input: Vector, distance: float, extend_direction: str = "both") -> Vector: ...
 
+	def extract_by_attribute(self, input: Vector, statement: str) -> Vector: ...
+
 	def extract_nodes(self, input: Vector) -> Vector: ...
 
 	def extract_raster_values_at_points(self, rasters: List[Raster], points: Vector) -> Tuple[Vector, str]: ...
 
 	def extract_streams(self, flow_accumulation: Raster, threshold: float = 0.0, zero_background: bool = False) -> Raster: ...
 
 	def extract_valleys(self, dem: Raster, variant: str = "lq", line_thin: bool = False, filter_size: int = 5) -> Raster: ...
@@ -1456,25 +1462,25 @@
 
 	def gaussian_contrast_stretch(self, raster: Raster, num_tones: int = 256) -> Raster: ...
 
 	def gaussian_curvature(self, dem: Raster, log_transform: bool = False, z_factor: float = 1.0) -> Raster: ...
 
 	def gaussian_filter(self, raster: Raster, sigma: float = 0.75) -> Raster: ...
 
-	def geomorphons(self, dem: Raster, search_distance: int = 1, flatness_threshold: float = 1.0, flatness_distance: int = 0, skip_distance: int = 0, output_forms: bool = True, analyze_residuals: bool = False) -> Raster: ...
+	def geomorphons(self, dem: Raster, search_distance: int = 50, flatness_threshold: float = 0.0, flatness_distance: int = 0, skip_distance: int = 0, output_forms: bool = True, analyze_residuals: bool = False) -> Raster: ...
 
 	def generalize_classified_raster(self, raster: Raster, area_threshold: int = 5, method: str = "longest") -> Raster: ...
 
 	def generalize_with_similarity(self, raster: Raster, similarity_rasters: List[Raster], area_threshold: int = 5) -> Raster: ...
 
 	def generating_function(self, dem: Raster, log_transform: bool = False, z_factor: float = 1.0) -> Raster: ...
 
 	def hack_stream_order(self, d8_pntr: Raster, streams_raster: Raster, esri_pntr: bool = False, zero_background: bool = False) -> Raster: ...
 
-	def heat_map(self, points: Vector, field_name: str, bandwidth: float = 0.0, cell_size: float = 0.0, base_raster: Optional[Raster] = None, kernel_function: str = "quartic") -> Raster: ...
+	def heat_map(self, points: Vector, field_name: Optional[str] = None, bandwidth: float = 0.0, cell_size: float = 0.0, base_raster: Optional[Raster] = None, kernel_function: str = "quartic") -> Raster: ...
 
 	def height_above_ground(self, input: Lidar) -> Lidar: ...
 
 	def hexagonal_grid_from_raster_base(self, base: Raster, width: float, orientation: str = "h") -> Vector: ...
 
 	def hexagonal_grid_from_vector_base(self, base: Vector, width: float, orientation: str = "h") -> Vector: ...
 
@@ -1556,47 +1562,47 @@
 
 	def ks_normality_test(self, raster: Raster, output_html_file: str, num_samples: int) -> None: ...
 
 	def laplacian_filter(self, raster: Raster, variant: str = "3x3(1)", clip_amount: float = 0.0) -> Raster: ...
 
 	def laplacian_of_gaussians_filter(self, raster: Raster, sigma: float = 0.75) -> Raster: ...
 
-	def las_to_ascii(self, input_lidar: Lidar) -> None: ...
+	def las_to_ascii(self, input_lidar: Optional[Lidar]) -> None: ...
 
-	def las_to_shapefile(self, input_lidar: Lidar, output_multipoint: bool = False) -> Vector: ...
+	def las_to_shapefile(self, input_lidar: Optional[Lidar], output_multipoint: bool = False) -> Vector: ...
 
 	def layer_footprint_raster(self, input: Raster) -> Vector: ...
 
 	def layer_footprint_vector(self, input: Vector) -> Vector: ...
 
 	def lee_filter(self, raster: Raster, filter_size_x: int = 11, filter_size_y: int = 11, sigma: float = 10.0, m_value: float = 5.0) -> Raster: ...
 
 	def length_of_upstream_channels(self, d8_pointer: Raster, streams_raster: Raster, esri_pointer: bool = False, zero_background: bool = False) -> Raster: ...
 
 	def license_type(self, floating_license_id: str) -> LicenseType: ...
 
-	def lidar_block_maximum(self, input_lidar: Lidar, cell_size: float = 1.0) -> Raster: ...
+	def lidar_block_maximum(self, input_lidar: Optional[Lidar], cell_size: float = 1.0) -> Raster: ...
 
-	def lidar_block_minimum(self, input_lidar: Lidar, cell_size: float = 1.0) -> Raster: ...
+	def lidar_block_minimum(self, input_lidar: Optional[Lidar], cell_size: float = 1.0) -> Raster: ...
 
 	def lidar_classify_subset(self, base_lidar: Lidar, subset_lidar: Lidar, subset_class_value: int, nonsubset_class_value: int) -> Lidar: ...
 
 	def lidar_colourize(self, in_lidar: Lidar, in_image: Raster) -> Lidar: ...
 
-	def lidar_construct_vector_tin(self, input_lidar: Lidar, returns_included: str = "all", excluded_classes: Optional[List[int]] = None, min_elev: float = float('-inf'), max_elev: float = float('inf'), max_triangle_edge_length: float = float('inf')) -> Vector: ...
+	def lidar_construct_vector_tin(self, input_lidar: Optional[Lidar], returns_included: str = "all", excluded_classes: Optional[List[int]] = None, min_elev: float = float('-inf'), max_elev: float = float('inf'), max_triangle_edge_length: float = float('inf')) -> Vector: ...
 
 	def lidar_contour(self, input_lidar: Optional[Lidar], contour_interval: float = 10.0, base_contour: float = 0.0, smooth: int = 5, interpolation_parameter: str = "elevation", returns_included: str = "all",  excluded_classes: Optional[List[int]] = None, min_elev: float = float('-inf'), max_elev: float = float('inf'), tile_overlap: float = 0.0, max_triangle_edge_length: float = float('inf')) -> Optional[Vector]: ...
 
-	def lidar_digital_surface_model(self, input_lidar: Lidar, cell_size: float = 1.0, search_radius: float = 0.5, min_elev: float = float('-inf'), max_elev: float = float('inf'), max_triangle_edge_length: float = float('inf')) -> Raster: ...
+	def lidar_digital_surface_model(self, input_lidar: Optional[Lidar], cell_size: float = 1.0, search_radius: float = 0.5, min_elev: float = float('-inf'), max_elev: float = float('inf'), max_triangle_edge_length: float = float('inf')) -> Raster: ...
 
 	def lidar_eigenvalue_features(self, input_lidar: Optional[Lidar], num_neighbours: Optional[int], search_radius: Optional[float]) -> None: ...
 
 	def lidar_elevation_slice(self, input: Lidar, minz: float = float('-inf'), maxz: float = float('inf'), classify: bool = False, in_class_value: int = 2, out_class_value: int = 1) -> Lidar: ...
 
-	def lidar_ground_point_filter(self, input_lidar: Lidar, search_radius: float = 2.0, min_neighbours: int = 0, slope_threshold: float = 45.0, height_threshold: float = 1.0, classify: bool = False, slope_norm: bool = True, height_above_ground: bool = False) -> Lidar: ...
+	def lidar_ground_point_filter(self, input_lidar: Optional[Lidar], search_radius: float = 2.0, min_neighbours: int = 0, slope_threshold: float = 45.0, height_threshold: float = 1.0, classify: bool = False, slope_norm: bool = True, height_above_ground: bool = False) -> Lidar: ...
 
 	def lidar_hex_bin(self, input_lidar: Lidar, width: float, orientation: str = "h") -> Vector: ...
 
 	def lidar_hillshade(self, input: Lidar, search_radius: float = -1.0, azimuth: float = 315.0, altitude: float = 30.0) -> Lidar: ...
 
 	def lidar_histogram(self, input_lidar: Lidar, output_html_file: str, parameter: str = "elevation", clip_percent: float = 1.0) -> None: ...
 
@@ -1604,23 +1610,23 @@
 
 	def lidar_info(self, input_lidar: Lidar, output_html_file: Optional[str], show_point_density: bool = True, show_vlrs: bool = True, show_geokeys: bool = True) -> str: ...
 
 	def lidar_join(self, inputs: List[Lidar]) -> Lidar: ...
 
 	def lidar_kappa(self, input_lidar1: Lidar, input_lidar2: Lidar, output_html_file: str, cell_size: float = 1.0, output_class_accuracy: bool = False) -> Raster: ...
 
-	def lidar_nearest_neighbour_gridding(self, input_lidar: Lidar, interpolation_parameter: str = "elevation", returns_included: str = "all", cell_size: float = 1.0, search_radius: float = 2.5, excluded_classes: Optional[List[int]] = None, min_elev: float = float('-inf'), max_elev: float = float('inf')) -> Raster: ...
+	def lidar_nearest_neighbour_gridding(self, input_lidar: Optional[Lidar], interpolation_parameter: str = "elevation", returns_included: str = "all", cell_size: float = 1.0, search_radius: float = 2.5, excluded_classes: Optional[List[int]] = None, min_elev: float = float('-inf'), max_elev: float = float('inf')) -> Raster: ...
 
-	def lidar_point_density(self, input_lidar: Lidar, returns_included: str = "all", cell_size: float = 1.0, search_radius: float = 2.5, excluded_classes: Optional[List[int]] = None, min_elev: float = float('-inf'), max_elev: float = float('inf')) -> Raster: ...
+	def lidar_point_density(self, input_lidar: Optional[Lidar], returns_included: str = "all", cell_size: float = 1.0, search_radius: float = 2.5, excluded_classes: Optional[List[int]] = None, min_elev: float = float('-inf'), max_elev: float = float('inf')) -> Raster: ...
 
 	def lidar_point_return_analysis(self, input: Lidar, create_output: bool = False) -> Optional[Lidar]: ...
 
-	def lidar_point_stats(self, input_lidar: Lidar, cell_size: float = 1.0, num_points: bool = False, num_pulses: bool = False, avg_points_per_pulse: bool = False, z_range: bool = False, intensity_range: bool = False, predominant_class: bool = False) : ...
+	def lidar_point_stats(self, input_lidar: Optional[Lidar], cell_size: float = 1.0, num_points: bool = False, num_pulses: bool = False, avg_points_per_pulse: bool = False, z_range: bool = False, intensity_range: bool = False, predominant_class: bool = False) : ...
 
-	def lidar_radial_basis_function_interpolation(self, input_lidar: Lidar, interpolation_parameter: str = "elevation", returns_included: str = "all", cell_size: float = 1.0, num_points: int = 15, excluded_classes: Optional[List[int]] = None, min_elev: float = float('-inf'), max_elev: float = float('inf'), func_type: str = "thinplatespline", poly_order: str = "none", weight: float = 0.1) -> Raster: ...
+	def lidar_radial_basis_function_interpolation(self, input_lidar: Optional[Lidar], interpolation_parameter: str = "elevation", returns_included: str = "all", cell_size: float = 1.0, num_points: int = 15, excluded_classes: Optional[List[int]] = None, min_elev: float = float('-inf'), max_elev: float = float('inf'), func_type: str = "thinplatespline", poly_order: str = "none", weight: float = 0.1) -> Raster: ...
 
 	def lidar_ransac_planes(self, in_lidar: Lidar, search_radius: float = 2.0, num_iterations: int = 50, num_samples: int = 10, inlier_threshold: float = 0.15, acceptable_model_size: int = 30, max_planar_slope: float = 75.0, classify: bool = False, only_last_returns: bool = False) -> Lidar: ...
 
 	def lidar_remove_outliers(self, input: Lidar, search_radius: float = 2.0, elev_diff: float = 50.0, use_median: bool = False, classify: bool = False) -> Lidar: ...
 
 	def lidar_rooftop_analysis(self, lidar_inputs: List[Lidar], building_footprints: Vector, search_radius: float = 2.0, num_iterations: int = 50, num_samples: int = 10, inlier_threshold: float = 0.15, acceptable_model_size: int = 30, max_planar_slope: float = 75.0, norm_diff_threshold: float = 2.0, azimuth: float = 180.0, altitude: float = 30.0) -> Vector: ...
 
@@ -1634,17 +1640,17 @@
 
 	def lidar_thin(self, input: Lidar, resolution: float = 1.0, selection_method: str = "first", save_filtered: bool = False) -> Tuple[Lidar, Union[Lidar, None]]: ...
 
 	def lidar_thin_high_density(self, input: Lidar, density: float, resolution: float = 1.0, save_filtered: bool = False) -> Tuple[Lidar, Union[Lidar, None]]: ...
 
 	def lidar_tile(self, input_lidar: Lidar, tile_width: float = 1000.0, tile_height: float = 1000.0, origin_x: float = 0.0, origin_y: float = 0.0, min_points_in_tile: int = 2, output_laz_format: bool = True) -> None: ...
 
-	def lidar_tile_footprint(self, input_lidar: Lidar, output_hulls: bool = False) -> Vector: ...
+	def lidar_tile_footprint(self, input_lidar: Optional[Lidar], output_hulls: bool = False) -> Vector: ...
 
-	def lidar_tin_gridding(self, input_lidar: Lidar, interpolation_parameter: str = "elevation", returns_included: str = "all", cell_size: float = 1.0, excluded_classes: Optional[List[int]] = None, min_elev: float = float('-inf'), max_elev: float = float('inf'), max_triangle_edge_length: float = float('inf')) -> Raster: ...
+	def lidar_tin_gridding(self, input_lidar: Optional[Lidar], interpolation_parameter: str = "elevation", returns_included: str = "all", cell_size: float = 1.0, excluded_classes: Optional[List[int]] = None, min_elev: float = float('-inf'), max_elev: float = float('inf'), max_triangle_edge_length: float = float('inf')) -> Raster: ...
 
 	def lidar_tophat_transform(self, input: Lidar, search_radius: float) -> Lidar: ...
 
 	def line_detection_filter(self, raster: Raster, variant: str = "v", abs_values: bool = False, clip_tails: float = 0.0) -> Raster: ...
 
 	def line_intersections(self, input1: Vector, input2: Vector) -> Vector: ...
 
@@ -1792,14 +1798,16 @@
 
 	def olympic_filter(self, raster: Raster, filter_size_x: int = 11, filter_size_y: int = 11) -> Raster: ...
 
 	def opening(self, raster: Raster, filter_size_x: int = 11, filter_size_y: int = 11) -> Raster: ...
 
 	def openness(self, dem: Raster, dist: int = 20) -> Tuple[Raster, Raster]: ...
 
+	def otsu_thresholding(self, raster: Raster) -> Raster: ...
+
 	def paired_sample_t_test(self, raster1: Raster, raster2: Raster, output_html_file: str, num_samples: int) -> None: ...
 
 	def panchromatic_sharpening(self, pan: Raster, colour_composite: Raster, red: Raster, green: Raster, blue: Raster, fusion_method: str = "brovey") -> Raster: ...
 
 	def parallelepiped_classification(self, input_rasters: List[Raster], training_data: Vector, class_field_name: str) -> Raster: ...
 
 	def patch_orientation(self, input: Vector) -> Vector: ...
@@ -1846,14 +1854,16 @@
 
 	def print_geotiff_tags(self, file_name: str) : ...
 
 	def profile(self, lines_vector: Vector, surface: Raster, output_html_file: str) -> None: ...
 
 	def profile_curvature(self, dem: Raster, log_transform: bool = False, z_factor: float = 1.0) -> Raster: ...
 
+	def prune_vector_streams(self, streams: Vector, dem: Raster, threshold: float, snap_distance: float = 0.001) -> Vector: ...
+
 	def qin_flow_accumulation(self, dem: Raster, out_type: str = "sca", exponent: float = 10.0, max_slope: float = 45.0, convergence_threshold: float = float('inf'), log_transform: bool = False, clip: bool = False) -> Raster: ...
 
 	def quantiles(self, raster: Raster, num_quantiles: int = 5) -> Raster: ...
 
 	def quinn_flow_accumulation(self, dem: Raster, out_type: str = "sca", exponent: float = 1.1, convergence_threshold: float = float('inf'), log_transform: bool = False, clip: bool = False) -> Raster: ...
 
 	def radial_basis_function_interpolation(self, points: Vector, field_name: str = "FID", use_z: bool = False, radius: float = 0.0, min_points: int = 0, cell_size: float = 0.0, base_raster: Optional[Raster] = None, func_type: str = "thinplatespline", poly_order: str = "none", weight: float = 0.1) -> Raster: ...
@@ -1878,15 +1888,15 @@
 
 	def raster_cell_assignment(self, raster: Raster, what_to_assign: str = "column") -> Raster: ...
 
 	def raster_histogram(self, raster: Raster, output_html_file: str, num_bins: Optional[bool] = None) -> None: ...
 
 	def raster_perimeter(self, raster: Raster, units: str = "map units", zero_background: bool = False) -> Tuple[Raster, str]: ...
 
-	def raster_streams_to_vector(self, streams: Raster, d8_pointer: Raster, esri_pointer: bool = False) -> Vector: ...
+	def raster_streams_to_vector(self, streams: Raster, d8_pointer: Raster, esri_pointer: bool = False, all_vertices: bool = False) -> Vector: ...
 
 	def raster_summary_stats(self, input: Raster) -> str: ...
 
 	def raster_to_vector_lines(self, raster: Raster) -> Vector: ...
 
 	def raster_to_vector_points(self, raster: Raster) -> Vector: ...
 
@@ -2050,16 +2060,20 @@
 
 	def time_in_daylight(self, dem: Raster, az_fraction: float = 5.0, max_dist: float = float('inf'), latitude: float = 0.0, longitude: float = 0.0, utc_offset_str: str = "UTC+00:00", start_day: int = 1, end_day: int = 365, start_time: str = "sunrise", end_time: str = "sunset") -> Raster: ...
 
 	def tin_interpolation(self, points: Vector, field_name: str = "FID", use_z: bool = False, cell_size: float = 0.0, base_raster: Optional[Raster] = None, max_triangle_edge_length: float = float('inf')) -> Raster: ...
 
 	def tophat_transform(self, raster: Raster, filter_size_x: int = 11, filter_size_y: int = 11, variant: str = "white") -> Raster: ...
 
+	def topological_breach_burn(self, streams: Vector, dem: Raster, snap_distance: float = 0.001) -> Tuple[Raster, Raster, Raster, Raster]: ...
+
 	def topological_stream_order(self, d8_pntr: Raster, streams_raster: Raster, esri_pntr: bool = False, zero_background: bool = False) -> Raster: ...
 
+	def topographic_hachures(self, dem: Raster, contour_interval = 10.0, base_contour = 0.0, deflection_tolerance = 10.0, filter_size = 9, separation = 2.0, distmin = 0.5, distmax = 2.0, discretization = 0.5, turnmax = 45.0, slopemin = 0.5, depth = 16) -> Vector: ...
+	    
 	def topo_render(self, dem: Raster, palette: WbPalette = WbPalette.Soft, reverse_palette: bool = False,  azimuth: float = 315.0, altitude: float = 30.0, clipping_polygon: Optional[Vector] = None, background_hgt_offset: float = 10.0, background_clr: Tuple[int, int, int, int] = (255, 255, 255, 255), attenuation_parameter: float = 0.3,  ambient_light: float = 0.2, z_factor: float = 1.0) -> Raster: ...
 
 	def topographic_position_animation(self, dem: Raster, output_html_file: str = "topo_pos.html", palette: WbPalette = WbPalette.Soft,  min_scale: int = 1, num_steps: int = 1, step_nonlinearity: float = 1.0, image_height: int = 600, delay: int = 250, label: str = "", use_dev_max: bool = False) -> None: ...
 
 	def total_curvature(self, dem: Raster, log_transform: bool = False, z_factor: float = 1.0) -> Raster: ...
 
 	def total_filter(self, raster: Raster, filter_size_x: int = 11, filter_size_y: int = 11) -> Raster: ...
@@ -2128,15 +2142,15 @@
 
 	def yield_map(self, input: Vector, pass_field_name: str, swath_width: float = 6.096, max_change_in_heading: float = 25.0) -> Vector: ...
 
 	def yield_normalization(self, input: Vector, yield_field_name: str,  radius: float, standardize: bool = False, min_yield: float = 0.0, max_yield: float = float('inf')) -> Vector: ...
 
 	def z_scores(self, raster: Raster) -> Raster: ...
 
-	def zonal_statistics(self, data_raster: Raster, feature_definitions_raster: Raster, stat_type: str = "mean") -> Tuple[Raster, str]: ...
+	def zonal_statistics(self, data_raster: Raster, feature_definitions_raster: Raster, stat_type: str = "mean", zero_is_background: bool = False) -> Tuple[Raster, str]: ...
 
 
 class WbPalette(Enum):
 	Atlas: int
 	HighRelief: int
 	Arid: int
 	Earthtones: int
```

## Comparing `whitebox_workflows-1.0.9.dist-info/METADATA` & `whitebox_workflows-1.1.0.dist-info/METADATA`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: whitebox_workflows
-Version: 1.0.9
+Version: 1.1.0
 Classifier: Programming Language :: Rust
 Classifier: Programming Language :: Python :: Implementation :: CPython
 Classifier: Programming Language :: Python :: Implementation :: PyPy
 License-File: LICENSE.txt
 Summary: whitebox_workflows is a Python library for advanced spatial analysis.
 Keywords: spatial analysis,GIS,remote sensing
 Author: Whitebox Geospatial Inc.
@@ -149,7 +149,22 @@
 for a in range(lidar.header.number_of_points):
     (point_data, time, colour, waveform) = lidar.get_point_record(a)
     if point_data.is_first_return() or point_data.is_intermediate_return():
         lidar_out.add_point(point_data, time)
 
 wbe.write_lidar(lidar_out, "new_lidar.laz")
 ```
+
+## Release history
+
+### Version 1.1 (June 17, 2023)
+- Added ability to read COPC lidar files.
+- Added the extract_by_attribute tool to filter out vector features by attribute characteristics.
+- Added the deviation_from_regional_direction tool.
+- Added the otsu_thresholding tool, which uses Ostu's method for optimal binary thresholding,
+  transforming the input image into background and foreground pixels.
+- Added the topographic_hachures tool.
+- Fixed a bug with polygon holes in the raster_to_vector_polygons tool.
+- Fixed a bug with the individual_tree_detection tool that prevented use of the min_height parameter
+  when applied in batch mode.
+- Fixed a bug with the breakline_mapping tool in WbW-Pro.
+
```

## Comparing `whitebox_workflows-1.0.9.dist-info/RECORD` & `whitebox_workflows-1.1.0.dist-info/RECORD`

 * *Files 14% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-whitebox_workflows-1.0.9.dist-info/METADATA,sha256=3oWhIaeAy8XUGKCgovPYhzfOgek8eVta_6ihwLd9VPY,9132
-whitebox_workflows-1.0.9.dist-info/WHEEL,sha256=1sWpEWQ4W14PHZKGG7P3N-ltHsg4-oHetUDg-P5cwfw,96
-whitebox_workflows-1.0.9.dist-info/license_files/LICENSE.txt,sha256=81hwVZcj5cV3fKP2h66KoD70cR90XP74jD7cZlItQ5g,161
+whitebox_workflows-1.1.0.dist-info/METADATA,sha256=1hoaO570E-HPja31Ez6AO-ZbKwN3MKN2GUn0l-u2wVI,9842
+whitebox_workflows-1.1.0.dist-info/WHEEL,sha256=ExO3irOL43CSWqbMTtuTGIEzaUNSp56OtPGe2z24euw,103
+whitebox_workflows-1.1.0.dist-info/license_files/LICENSE.txt,sha256=81hwVZcj5cV3fKP2h66KoD70cR90XP74jD7cZlItQ5g,161
 whitebox_workflows/__init__.py,sha256=N7_U6-Pv0v-TYeVxmBCTaM9rBhnhGc6BhqtKoiIZeyQ,155
-whitebox_workflows/__init__.pyi,sha256=jf2_otWlpMzR3B74iXda_hVcNmUsh7eWyqgb5hWuPmY,86536
+whitebox_workflows/__init__.pyi,sha256=qYGD9LzNhadWv-jTKf5TursNUoOjE64HfZzs_pNpiUo,87574
 whitebox_workflows/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-whitebox_workflows/whitebox_workflows.pyd,sha256=0XErJXZt02okef2OCcEwypSpJ9FlHEJ_5YBhPan7ob4,32744960
-whitebox_workflows-1.0.9.dist-info/RECORD,,
+whitebox_workflows/whitebox_workflows.abi3.so,sha256=d3XiOUeSjk5Pu-2vY9xjlkcbIrTr7wDAx0NzhqPj0yA,21274999
+whitebox_workflows-1.1.0.dist-info/RECORD,,
```

